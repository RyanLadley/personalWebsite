/*! grapesjs - 0.12.25 */
!function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.grapesjs = e() : t.grapesjs = e() }(this, function () {
    return function (t) { function e(i) { if (n[i]) return n[i].exports; var r = n[i] = { i: i, l: !1, exports: {} }; return t[i].call(r.exports, r, r.exports, e), r.l = !0, r.exports } var n = {}; return e.m = t, e.c = n, e.d = function (t, n, i) { e.o(t, n) || Object.defineProperty(t, n, { configurable: !1, enumerable: !0, get: i }) }, e.n = function (t) { var n = t && t.__esModule ? function () { return t.default } : function () { return t }; return e.d(n, "a", n), n }, e.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e) }, e.p = "", e(e.s = 56) }([function (t, e, n) { (function (i) { var r, o; !function (s) { var a = "object" == typeof self && self.self === self && self || "object" == typeof i && i.global === i && i; r = [n(1), n(8), e], void 0 !== (o = function (t, e, n) { a.Backbone = s(a, n, t, e) }.apply(e, r)) && (t.exports = o) }(function (t, e, n, i) { var r = t.Backbone, o = Array.prototype.slice; e.VERSION = "1.3.3", e.$ = i, e.noConflict = function () { return t.Backbone = r, this }, e.emulateHTTP = !1, e.emulateJSON = !1; var s = function (t, e, i) { switch (t) { case 1: return function () { return n[e](this[i]) }; case 2: return function (t) { return n[e](this[i], t) }; case 3: return function (t, r) { return n[e](this[i], l(t, this), r) }; case 4: return function (t, r, o) { return n[e](this[i], l(t, this), r, o) }; default: return function () { var t = o.call(arguments); return t.unshift(this[i]), n[e].apply(n, t) } } }, a = function (t, e, i) { n.each(e, function (e, r) { n[r] && (t.prototype[r] = s(e, r, i)) }) }, l = function (t, e) { return n.isFunction(t) ? t : n.isObject(t) && !e._isModel(t) ? c(t) : n.isString(t) ? function (e) { return e.get(t) } : t }, c = function (t) { var e = n.matches(t); return function (t) { return e(t.attributes) } }, u = e.Events = {}, h = /\s+/, d = function (t, e, i, r, o) { var s, a = 0; if (i && "object" == typeof i) { void 0 !== r && "context" in o && void 0 === o.context && (o.context = r); for (s = n.keys(i); a < s.length; a++)e = d(t, e, s[a], i[s[a]], o) } else if (i && h.test(i)) for (s = i.split(h); a < s.length; a++)e = t(e, s[a], r, o); else e = t(e, i, r, o); return e }; u.on = function (t, e, n) { return f(this, t, e, n) }; var f = function (t, e, n, i, r) { if (t._events = d(p, t._events || {}, e, n, { context: i, ctx: t, listening: r }), r) { (t._listeners || (t._listeners = {}))[r.id] = r } return t }; u.listenTo = function (t, e, i) { if (!t) return this; var r = t._listenId || (t._listenId = n.uniqueId("l")), o = this._listeningTo || (this._listeningTo = {}), s = o[r]; if (!s) { var a = this._listenId || (this._listenId = n.uniqueId("l")); s = o[r] = { obj: t, objId: r, id: a, listeningTo: o, count: 0 } } return f(t, e, i, this, s), this }; var p = function (t, e, n, i) { if (n) { var r = t[e] || (t[e] = []), o = i.context, s = i.ctx, a = i.listening; a && a.count++ , r.push({ callback: n, context: o, ctx: o || s, listening: a }) } return t }; u.off = function (t, e, n) { return this._events ? (this._events = d(g, this._events, t, e, { context: n, listeners: this._listeners }), this) : this }, u.stopListening = function (t, e, i) { var r = this._listeningTo; if (!r) return this; for (var o = t ? [t._listenId] : n.keys(r), s = 0; s < o.length; s++) { var a = r[o[s]]; if (!a) break; a.obj.off(e, i, this) } return this }; var g = function (t, e, i, r) { if (t) { var o, s = 0, a = r.context, l = r.listeners; if (e || i || a) { for (var c = e ? [e] : n.keys(t); s < c.length; s++) { e = c[s]; var u = t[e]; if (!u) break; for (var h = [], d = 0; d < u.length; d++) { var f = u[d]; i && i !== f.callback && i !== f.callback._callback || a && a !== f.context ? h.push(f) : (o = f.listening) && 0 == --o.count && (delete l[o.id], delete o.listeningTo[o.objId]) } h.length ? t[e] = h : delete t[e] } return t } for (var p = n.keys(l); s < p.length; s++)o = l[p[s]], delete l[o.id], delete o.listeningTo[o.objId] } }; u.once = function (t, e, i) { var r = d(m, {}, t, e, n.bind(this.off, this)); return "string" == typeof t && null == i && (e = void 0), this.on(r, e, i) }, u.listenToOnce = function (t, e, i) { var r = d(m, {}, e, i, n.bind(this.stopListening, this, t)); return this.listenTo(t, r) }; var m = function (t, e, i, r) { if (i) { var o = t[e] = n.once(function () { r(e, o), i.apply(this, arguments) }); o._callback = i } return t }; u.trigger = function (t) { if (!this._events) return this; for (var e = Math.max(0, arguments.length - 1), n = Array(e), i = 0; i < e; i++)n[i] = arguments[i + 1]; return d(v, this._events, t, void 0, n), this }; var v = function (t, e, n, i) { if (t) { var r = t[e], o = t.all; r && o && (o = o.slice()), r && y(r, i), o && y(o, [e].concat(i)) } return t }, y = function (t, e) { var n, i = -1, r = t.length, o = e[0], s = e[1], a = e[2]; switch (e.length) { case 0: for (; ++i < r;)(n = t[i]).callback.call(n.ctx); return; case 1: for (; ++i < r;)(n = t[i]).callback.call(n.ctx, o); return; case 2: for (; ++i < r;)(n = t[i]).callback.call(n.ctx, o, s); return; case 3: for (; ++i < r;)(n = t[i]).callback.call(n.ctx, o, s, a); return; default: for (; ++i < r;)(n = t[i]).callback.apply(n.ctx, e); return } }; u.bind = u.on, u.unbind = u.off, n.extend(e, u); var b = e.Model = function (t, e) { var i = t || {}; e || (e = {}), this.cid = n.uniqueId(this.cidPrefix), this.attributes = {}, e.collection && (this.collection = e.collection), e.parse && (i = this.parse(i, e) || {}); var r = n.result(this, "defaults"); i = n.defaults(n.extend({}, r, i), r), this.set(i, e), this.changed = {}, this.initialize.apply(this, arguments) }; n.extend(b.prototype, u, { changed: null, validationError: null, idAttribute: "id", cidPrefix: "c", initialize: function () { }, toJSON: function (t) { return n.clone(this.attributes) }, sync: function () { return e.sync.apply(this, arguments) }, get: function (t) { return this.attributes[t] }, escape: function (t) { return n.escape(this.get(t)) }, has: function (t) { return null != this.get(t) }, matches: function (t) { return !!n.iteratee(t, this)(this.attributes) }, set: function (t, e, i) { if (null == t) return this; var r; if ("object" == typeof t ? (r = t, i = e) : (r = {})[t] = e, i || (i = {}), !this._validate(r, i)) return !1; var o = i.unset, s = i.silent, a = [], l = this._changing; this._changing = !0, l || (this._previousAttributes = n.clone(this.attributes), this.changed = {}); var c = this.attributes, u = this.changed, h = this._previousAttributes; for (var d in r) e = r[d], n.isEqual(c[d], e) || a.push(d), n.isEqual(h[d], e) ? delete u[d] : u[d] = e, o ? delete c[d] : c[d] = e; if (this.idAttribute in r && (this.id = this.get(this.idAttribute)), !s) { a.length && (this._pending = i); for (var f = 0; f < a.length; f++)this.trigger("change:" + a[f], this, c[a[f]], i) } if (l) return this; if (!s) for (; this._pending;)i = this._pending, this._pending = !1, this.trigger("change", this, i); return this._pending = !1, this._changing = !1, this }, unset: function (t, e) { return this.set(t, void 0, n.extend({}, e, { unset: !0 })) }, clear: function (t) { var e = {}; for (var i in this.attributes) e[i] = void 0; return this.set(e, n.extend({}, t, { unset: !0 })) }, hasChanged: function (t) { return null == t ? !n.isEmpty(this.changed) : n.has(this.changed, t) }, changedAttributes: function (t) { if (!t) return !!this.hasChanged() && n.clone(this.changed); var e = this._changing ? this._previousAttributes : this.attributes, i = {}; for (var r in t) { var o = t[r]; n.isEqual(e[r], o) || (i[r] = o) } return !!n.size(i) && i }, previous: function (t) { return null != t && this._previousAttributes ? this._previousAttributes[t] : null }, previousAttributes: function () { return n.clone(this._previousAttributes) }, fetch: function (t) { t = n.extend({ parse: !0 }, t); var e = this, i = t.success; return t.success = function (n) { var r = t.parse ? e.parse(n, t) : n; if (!e.set(r, t)) return !1; i && i.call(t.context, e, n, t), e.trigger("sync", e, n, t) }, H(this, t), this.sync("read", this, t) }, save: function (t, e, i) { var r; null == t || "object" == typeof t ? (r = t, i = e) : (r = {})[t] = e, i = n.extend({ validate: !0, parse: !0 }, i); var o = i.wait; if (r && !o) { if (!this.set(r, i)) return !1 } else if (!this._validate(r, i)) return !1; var s = this, a = i.success, l = this.attributes; i.success = function (t) { s.attributes = l; var e = i.parse ? s.parse(t, i) : t; if (o && (e = n.extend({}, r, e)), e && !s.set(e, i)) return !1; a && a.call(i.context, s, t, i), s.trigger("sync", s, t, i) }, H(this, i), r && o && (this.attributes = n.extend({}, l, r)); var c = this.isNew() ? "create" : i.patch ? "patch" : "update"; "patch" !== c || i.attrs || (i.attrs = r); var u = this.sync(c, this, i); return this.attributes = l, u }, destroy: function (t) { t = t ? n.clone(t) : {}; var e = this, i = t.success, r = t.wait, o = function () { e.stopListening(), e.trigger("destroy", e, e.collection, t) }; t.success = function (n) { r && o(), i && i.call(t.context, e, n, t), e.isNew() || e.trigger("sync", e, n, t) }; var s = !1; return this.isNew() ? n.defer(t.success) : (H(this, t), s = this.sync("delete", this, t)), r || o(), s }, url: function () { var t = n.result(this, "urlRoot") || n.result(this.collection, "url") || z(); if (this.isNew()) return t; var e = this.get(this.idAttribute); return t.replace(/[^\/]$/, "$&/") + encodeURIComponent(e) }, parse: function (t, e) { return t }, clone: function () { return new this.constructor(this.attributes) }, isNew: function () { return !this.has(this.idAttribute) }, isValid: function (t) { return this._validate({}, n.extend({}, t, { validate: !0 })) }, _validate: function (t, e) { if (!e.validate || !this.validate) return !0; t = n.extend({}, this.attributes, t); var i = this.validationError = this.validate(t, e) || null; return !i || (this.trigger("invalid", this, i, n.extend(e, { validationError: i })), !1) } }), a(b, { keys: 1, values: 1, pairs: 1, invert: 1, pick: 0, omit: 0, chain: 1, isEmpty: 1 }, "attributes"); var x = e.Collection = function (t, e) { e || (e = {}), e.model && (this.model = e.model), void 0 !== e.comparator && (this.comparator = e.comparator), this._reset(), this.initialize.apply(this, arguments), t && this.reset(t, n.extend({ silent: !0 }, e)) }, w = { add: !0, remove: !0, merge: !0 }, C = { add: !0, remove: !1 }, k = function (t, e, n) { n = Math.min(Math.max(n, 0), t.length); var i, r = Array(t.length - n), o = e.length; for (i = 0; i < r.length; i++)r[i] = t[i + n]; for (i = 0; i < o; i++)t[i + n] = e[i]; for (i = 0; i < r.length; i++)t[i + o + n] = r[i] }; n.extend(x.prototype, u, { model: b, initialize: function () { }, toJSON: function (t) { return this.map(function (e) { return e.toJSON(t) }) }, sync: function () { return e.sync.apply(this, arguments) }, add: function (t, e) { return this.set(t, n.extend({ merge: !1 }, e, C)) }, remove: function (t, e) { e = n.extend({}, e); var i = !n.isArray(t); t = i ? [t] : t.slice(); var r = this._removeModels(t, e); return !e.silent && r.length && (e.changes = { added: [], merged: [], removed: r }, this.trigger("update", this, e)), i ? r[0] : r }, set: function (t, e) { if (null != t) { e = n.extend({}, w, e), e.parse && !this._isModel(t) && (t = this.parse(t, e) || []); var i = !n.isArray(t); t = i ? [t] : t.slice(); var r = e.at; null != r && (r = +r), r > this.length && (r = this.length), r < 0 && (r += this.length + 1); var o, s, a = [], l = [], c = [], u = [], h = {}, d = e.add, f = e.merge, p = e.remove, g = !1, m = this.comparator && null == r && !1 !== e.sort, v = n.isString(this.comparator) ? this.comparator : null; for (s = 0; s < t.length; s++) { o = t[s]; var y = this.get(o); if (y) { if (f && o !== y) { var b = this._isModel(o) ? o.attributes : o; e.parse && (b = y.parse(b, e)), y.set(b, e), c.push(y), m && !g && (g = y.hasChanged(v)) } h[y.cid] || (h[y.cid] = !0, a.push(y)), t[s] = y } else d && (o = t[s] = this._prepareModel(o, e)) && (l.push(o), this._addReference(o, e), h[o.cid] = !0, a.push(o)) } if (p) { for (s = 0; s < this.length; s++)o = this.models[s], h[o.cid] || u.push(o); u.length && this._removeModels(u, e) } var x = !1, C = !m && d && p; if (a.length && C ? (x = this.length !== a.length || n.some(this.models, function (t, e) { return t !== a[e] }), this.models.length = 0, k(this.models, a, 0), this.length = this.models.length) : l.length && (m && (g = !0), k(this.models, l, null == r ? this.length : r), this.length = this.models.length), g && this.sort({ silent: !0 }), !e.silent) { for (s = 0; s < l.length; s++)null != r && (e.index = r + s), o = l[s], o.trigger("add", o, this, e); (g || x) && this.trigger("sort", this, e), (l.length || u.length || c.length) && (e.changes = { added: l, removed: u, merged: c }, this.trigger("update", this, e)) } return i ? t[0] : t } }, reset: function (t, e) { e = e ? n.clone(e) : {}; for (var i = 0; i < this.models.length; i++)this._removeReference(this.models[i], e); return e.previousModels = this.models, this._reset(), t = this.add(t, n.extend({ silent: !0 }, e)), e.silent || this.trigger("reset", this, e), t }, push: function (t, e) { return this.add(t, n.extend({ at: this.length }, e)) }, pop: function (t) { var e = this.at(this.length - 1); return this.remove(e, t) }, unshift: function (t, e) { return this.add(t, n.extend({ at: 0 }, e)) }, shift: function (t) { var e = this.at(0); return this.remove(e, t) }, slice: function () { return o.apply(this.models, arguments) }, get: function (t) { if (null != t) return this._byId[t] || this._byId[this.modelId(t.attributes || t)] || t.cid && this._byId[t.cid] }, has: function (t) { return null != this.get(t) }, at: function (t) { return t < 0 && (t += this.length), this.models[t] }, where: function (t, e) { return this[e ? "find" : "filter"](t) }, findWhere: function (t) { return this.where(t, !0) }, sort: function (t) { var e = this.comparator; if (!e) throw new Error("Cannot sort a set without a comparator"); t || (t = {}); var i = e.length; return n.isFunction(e) && (e = n.bind(e, this)), 1 === i || n.isString(e) ? this.models = this.sortBy(e) : this.models.sort(e), t.silent || this.trigger("sort", this, t), this }, pluck: function (t) { return this.map(t + "") }, fetch: function (t) { t = n.extend({ parse: !0 }, t); var e = t.success, i = this; return t.success = function (n) { var r = t.reset ? "reset" : "set"; i[r](n, t), e && e.call(t.context, i, n, t), i.trigger("sync", i, n, t) }, H(this, t), this.sync("read", this, t) }, create: function (t, e) { e = e ? n.clone(e) : {}; var i = e.wait; if (!(t = this._prepareModel(t, e))) return !1; i || this.add(t, e); var r = this, o = e.success; return e.success = function (t, e, n) { i && r.add(t, n), o && o.call(n.context, t, e, n) }, t.save(null, e), t }, parse: function (t, e) { return t }, clone: function () { return new this.constructor(this.models, { model: this.model, comparator: this.comparator }) }, modelId: function (t) { return t[this.model.prototype.idAttribute || "id"] }, _reset: function () { this.length = 0, this.models = [], this._byId = {} }, _prepareModel: function (t, e) { if (this._isModel(t)) return t.collection || (t.collection = this), t; e = e ? n.clone(e) : {}, e.collection = this; var i = new this.model(t, e); return i.validationError ? (this.trigger("invalid", this, i.validationError, e), !1) : i }, _removeModels: function (t, e) { for (var n = [], i = 0; i < t.length; i++) { var r = this.get(t[i]); if (r) { var o = this.indexOf(r); this.models.splice(o, 1), this.length-- , delete this._byId[r.cid]; var s = this.modelId(r.attributes); null != s && delete this._byId[s], e.silent || (e.index = o, r.trigger("remove", r, this, e)), n.push(r), this._removeReference(r, e) } } return n }, _isModel: function (t) { return t instanceof b }, _addReference: function (t, e) { this._byId[t.cid] = t; var n = this.modelId(t.attributes); null != n && (this._byId[n] = t), t.on("all", this._onModelEvent, this) }, _removeReference: function (t, e) { delete this._byId[t.cid]; var n = this.modelId(t.attributes); null != n && delete this._byId[n], this === t.collection && delete t.collection, t.off("all", this._onModelEvent, this) }, _onModelEvent: function (t, e, n, i) { if (e) { if (("add" === t || "remove" === t) && n !== this) return; if ("destroy" === t && this.remove(e, i), "change" === t) { var r = this.modelId(e.previousAttributes()), o = this.modelId(e.attributes); r !== o && (null != r && delete this._byId[r], null != o && (this._byId[o] = e)) } } this.trigger.apply(this, arguments) } }), a(x, { forEach: 3, each: 3, map: 3, collect: 3, reduce: 0, foldl: 0, inject: 0, reduceRight: 0, foldr: 0, find: 3, detect: 3, filter: 3, select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 3, includes: 3, contains: 3, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3, head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3, without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3, isEmpty: 1, chain: 1, sample: 3, partition: 3, groupBy: 3, countBy: 3, sortBy: 3, indexBy: 3, findIndex: 3, findLastIndex: 3 }, "models"); var S = e.View = function (t) { this.cid = n.uniqueId("view"), n.extend(this, n.pick(t, M)), this._ensureElement(), this.initialize.apply(this, arguments) }, T = /^(\S+)\s*(.*)$/, M = ["model", "collection", "el", "id", "attributes", "className", "tagName", "events"]; n.extend(S.prototype, u, { tagName: "div", $: function (t) { return this.$el.find(t) }, initialize: function () { }, render: function () { return this }, remove: function () { return this._removeElement(), this.stopListening(), this }, _removeElement: function () { this.$el.remove() }, setElement: function (t) { return this.undelegateEvents(), this._setElement(t), this.delegateEvents(), this }, _setElement: function (t) { this.$el = t instanceof e.$ ? t : e.$(t), this.el = this.$el[0] }, delegateEvents: function (t) { if (t || (t = n.result(this, "events")), !t) return this; this.undelegateEvents(); for (var e in t) { var i = t[e]; if (n.isFunction(i) || (i = this[i]), i) { var r = e.match(T); this.delegate(r[1], r[2], n.bind(i, this)) } } return this }, delegate: function (t, e, n) { return this.$el.on(t + ".delegateEvents" + this.cid, e, n), this }, undelegateEvents: function () { return this.$el && this.$el.off(".delegateEvents" + this.cid), this }, undelegate: function (t, e, n) { return this.$el.off(t + ".delegateEvents" + this.cid, e, n), this }, _createElement: function (t) { return document.createElement(t) }, _ensureElement: function () { if (this.el) this.setElement(n.result(this, "el")); else { var t = n.extend({}, n.result(this, "attributes")); this.id && (t.id = n.result(this, "id")), this.className && (t.class = n.result(this, "className")), this.setElement(this._createElement(n.result(this, "tagName"))), this._setAttributes(t) } }, _setAttributes: function (t) { this.$el.attr(t) } }), e.sync = function (t, i, r) { var o = E[t]; n.defaults(r || (r = {}), { emulateHTTP: e.emulateHTTP, emulateJSON: e.emulateJSON }); var s = { type: o, dataType: "json" }; if (r.url || (s.url = n.result(i, "url") || z()), null != r.data || !i || "create" !== t && "update" !== t && "patch" !== t || (s.contentType = "application/json", s.data = JSON.stringify(r.attrs || i.toJSON(r))), r.emulateJSON && (s.contentType = "application/x-www-form-urlencoded", s.data = s.data ? { model: s.data } : {}), r.emulateHTTP && ("PUT" === o || "DELETE" === o || "PATCH" === o)) { s.type = "POST", r.emulateJSON && (s.data._method = o); var a = r.beforeSend; r.beforeSend = function (t) { if (t.setRequestHeader("X-HTTP-Method-Override", o), a) return a.apply(this, arguments) } } "GET" === s.type || r.emulateJSON || (s.processData = !1); var l = r.error; r.error = function (t, e, n) { r.textStatus = e, r.errorThrown = n, l && l.call(r.context, t, e, n) }; var c = r.xhr = e.ajax(n.extend(s, r)); return i.trigger("request", i, c, r), c }; var E = { create: "POST", update: "PUT", patch: "PATCH", delete: "DELETE", read: "GET" }; e.ajax = function () { return e.$.ajax.apply(e.$, arguments) }; var P = e.Router = function (t) { t || (t = {}), t.routes && (this.routes = t.routes), this._bindRoutes(), this.initialize.apply(this, arguments) }, A = /\((.*?)\)/g, L = /(\(\?)?:\w+/g, O = /\*\w+/g, N = /[\-{}\[\]+?.,\\\^$|#\s]/g; n.extend(P.prototype, u, { initialize: function () { }, route: function (t, i, r) { n.isRegExp(t) || (t = this._routeToRegExp(t)), n.isFunction(i) && (r = i, i = ""), r || (r = this[i]); var o = this; return e.history.route(t, function (n) { var s = o._extractParameters(t, n); !1 !== o.execute(r, s, i) && (o.trigger.apply(o, ["route:" + i].concat(s)), o.trigger("route", i, s), e.history.trigger("route", o, i, s)) }), this }, execute: function (t, e, n) { t && t.apply(this, e) }, navigate: function (t, n) { return e.history.navigate(t, n), this }, _bindRoutes: function () { if (this.routes) { this.routes = n.result(this, "routes"); for (var t, e = n.keys(this.routes); null != (t = e.pop());)this.route(t, this.routes[t]) } }, _routeToRegExp: function (t) { return t = t.replace(N, "\\$&").replace(A, "(?:$1)?").replace(L, function (t, e) { return e ? t : "([^/?]+)" }).replace(O, "([^?]*?)"), new RegExp("^" + t + "(?:\\?([\\s\\S]*))?$") }, _extractParameters: function (t, e) { var i = t.exec(e).slice(1); return n.map(i, function (t, e) { return e === i.length - 1 ? t || null : t ? decodeURIComponent(t) : null }) } }); var D = e.History = function () { this.handlers = [], this.checkUrl = n.bind(this.checkUrl, this), "undefined" != typeof window && (this.location = window.location, this.history = window.history) }, I = /^[#\/]|\s+$/g, _ = /^\/+|\/+$/g, F = /#.*$/; D.started = !1, n.extend(D.prototype, u, { interval: 50, atRoot: function () { return this.location.pathname.replace(/[^\/]$/, "$&/") === this.root && !this.getSearch() }, matchRoot: function () { return this.decodeFragment(this.location.pathname).slice(0, this.root.length - 1) + "/" === this.root }, decodeFragment: function (t) { return decodeURI(t.replace(/%25/g, "%2525")) }, getSearch: function () { var t = this.location.href.replace(/#.*/, "").match(/\?.+/); return t ? t[0] : "" }, getHash: function (t) { var e = (t || this).location.href.match(/#(.*)$/); return e ? e[1] : "" }, getPath: function () { var t = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1); return "/" === t.charAt(0) ? t.slice(1) : t }, getFragment: function (t) { return null == t && (t = this._usePushState || !this._wantsHashChange ? this.getPath() : this.getHash()), t.replace(I, "") }, start: function (t) { if (D.started) throw new Error("Backbone.history has already been started"); if (D.started = !0, this.options = n.extend({ root: "/" }, this.options, t), this.root = this.options.root, this._wantsHashChange = !1 !== this.options.hashChange, this._hasHashChange = "onhashchange" in window && (void 0 === document.documentMode || document.documentMode > 7), this._useHashChange = this._wantsHashChange && this._hasHashChange, this._wantsPushState = !!this.options.pushState, this._hasPushState = !(!this.history || !this.history.pushState), this._usePushState = this._wantsPushState && this._hasPushState, this.fragment = this.getFragment(), this.root = ("/" + this.root + "/").replace(_, "/"), this._wantsHashChange && this._wantsPushState) { if (!this._hasPushState && !this.atRoot()) { var e = this.root.slice(0, -1) || "/"; return this.location.replace(e + "#" + this.getPath()), !0 } this._hasPushState && this.atRoot() && this.navigate(this.getHash(), { replace: !0 }) } if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) { this.iframe = document.createElement("iframe"), this.iframe.src = "javascript:0", this.iframe.style.display = "none", this.iframe.tabIndex = -1; var i = document.body, r = i.insertBefore(this.iframe, i.firstChild).contentWindow; r.document.open(), r.document.close(), r.location.hash = "#" + this.fragment } var o = window.addEventListener || function (t, e) { return attachEvent("on" + t, e) }; if (this._usePushState ? o("popstate", this.checkUrl, !1) : this._useHashChange && !this.iframe ? o("hashchange", this.checkUrl, !1) : this._wantsHashChange && (this._checkUrlInterval = setInterval(this.checkUrl, this.interval)), !this.options.silent) return this.loadUrl() }, stop: function () { var t = window.removeEventListener || function (t, e) { return detachEvent("on" + t, e) }; this._usePushState ? t("popstate", this.checkUrl, !1) : this._useHashChange && !this.iframe && t("hashchange", this.checkUrl, !1), this.iframe && (document.body.removeChild(this.iframe), this.iframe = null), this._checkUrlInterval && clearInterval(this._checkUrlInterval), D.started = !1 }, route: function (t, e) { this.handlers.unshift({ route: t, callback: e }) }, checkUrl: function (t) { var e = this.getFragment(); if (e === this.fragment && this.iframe && (e = this.getHash(this.iframe.contentWindow)), e === this.fragment) return !1; this.iframe && this.navigate(e), this.loadUrl() }, loadUrl: function (t) { return !!this.matchRoot() && (t = this.fragment = this.getFragment(t), n.some(this.handlers, function (e) { if (e.route.test(t)) return e.callback(t), !0 })) }, navigate: function (t, e) { if (!D.started) return !1; e && !0 !== e || (e = { trigger: !!e }), t = this.getFragment(t || ""); var n = this.root; "" !== t && "?" !== t.charAt(0) || (n = n.slice(0, -1) || "/"); var i = n + t; if (t = this.decodeFragment(t.replace(F, "")), this.fragment !== t) { if (this.fragment = t, this._usePushState) this.history[e.replace ? "replaceState" : "pushState"]({}, document.title, i); else { if (!this._wantsHashChange) return this.location.assign(i); if (this._updateHash(this.location, t, e.replace), this.iframe && t !== this.getHash(this.iframe.contentWindow)) { var r = this.iframe.contentWindow; e.replace || (r.document.open(), r.document.close()), this._updateHash(r.location, t, e.replace) } } return e.trigger ? this.loadUrl(t) : void 0 } }, _updateHash: function (t, e, n) { if (n) { var i = t.href.replace(/(javascript:|#).*$/, ""); t.replace(i + "#" + e) } else t.hash = "#" + e } }), e.history = new D; var $ = function (t, e) { var i, r = this; return i = t && n.has(t, "constructor") ? t.constructor : function () { return r.apply(this, arguments) }, n.extend(i, r, e), i.prototype = n.create(r.prototype, t), i.prototype.constructor = i, i.__super__ = r.prototype, i }; b.extend = x.extend = P.extend = S.extend = D.extend = $; var z = function () { throw new Error('A "url" property or function must be specified') }, H = function (t, e) { var n = e.error; e.error = function (i) { n && n.call(e.context, t, i, e), t.trigger("error", t, i, e) } }; return e }) }).call(e, n(15)) }, function (t, e, n) { var i, r; (function () { function n(t) { function e(e, n, i, r, o, s) { for (; o >= 0 && o < s; o += t) { var a = r ? r[o] : o; i = n(i, e[a], a, e) } return i } return function (n, i, r, o) { i = k(i, o, 4); var s = !L(n) && C.keys(n), a = (s || n).length, l = t > 0 ? 0 : a - 1; return arguments.length < 3 && (r = n[s ? s[l] : l], l += t), e(n, i, r, s, l, a) } } function o(t) { return function (e, n, i) { n = S(n, i); for (var r = A(e), o = t > 0 ? 0 : r - 1; o >= 0 && o < r; o += t)if (n(e[o], o, e)) return o; return -1 } } function s(t, e, n) { return function (i, r, o) { var s = 0, a = A(i); if ("number" == typeof o) t > 0 ? s = o >= 0 ? o : Math.max(o + a, s) : a = o >= 0 ? Math.min(o + 1, a) : o + a + 1; else if (n && o && a) return o = n(i, r), i[o] === r ? o : -1; if (r !== r) return o = e(p.call(i, s, a), C.isNaN), o >= 0 ? o + s : -1; for (o = t > 0 ? s : a - 1; o >= 0 && o < a; o += t)if (i[o] === r) return o; return -1 } } function a(t, e) { var n = _.length, i = t.constructor, r = C.isFunction(i) && i.prototype || h, o = "constructor"; for (C.has(t, o) && !C.contains(e, o) && e.push(o); n--;)(o = _[n]) in t && t[o] !== r[o] && !C.contains(e, o) && e.push(o) } var l = this, c = l._, u = Array.prototype, h = Object.prototype, d = Function.prototype, f = u.push, p = u.slice, g = h.toString, m = h.hasOwnProperty, v = Array.isArray, y = Object.keys, b = d.bind, x = Object.create, w = function () { }, C = function (t) { return t instanceof C ? t : this instanceof C ? void (this._wrapped = t) : new C(t) }; void 0 !== t && t.exports && (e = t.exports = C), e._ = C, C.VERSION = "1.8.3"; var k = function (t, e, n) { if (void 0 === e) return t; switch (null == n ? 3 : n) { case 1: return function (n) { return t.call(e, n) }; case 2: return function (n, i) { return t.call(e, n, i) }; case 3: return function (n, i, r) { return t.call(e, n, i, r) }; case 4: return function (n, i, r, o) { return t.call(e, n, i, r, o) } }return function () { return t.apply(e, arguments) } }, S = function (t, e, n) { return null == t ? C.identity : C.isFunction(t) ? k(t, e, n) : C.isObject(t) ? C.matcher(t) : C.property(t) }; C.iteratee = function (t, e) { return S(t, e, 1 / 0) }; var T = function (t, e) { return function (n) { var i = arguments.length; if (i < 2 || null == n) return n; for (var r = 1; r < i; r++)for (var o = arguments[r], s = t(o), a = s.length, l = 0; l < a; l++) { var c = s[l]; e && void 0 !== n[c] || (n[c] = o[c]) } return n } }, M = function (t) { if (!C.isObject(t)) return {}; if (x) return x(t); w.prototype = t; var e = new w; return w.prototype = null, e }, E = function (t) { return function (e) { return null == e ? void 0 : e[t] } }, P = Math.pow(2, 53) - 1, A = E("length"), L = function (t) { var e = A(t); return "number" == typeof e && e >= 0 && e <= P }; C.each = C.forEach = function (t, e, n) { e = k(e, n); var i, r; if (L(t)) for (i = 0, r = t.length; i < r; i++)e(t[i], i, t); else { var o = C.keys(t); for (i = 0, r = o.length; i < r; i++)e(t[o[i]], o[i], t) } return t }, C.map = C.collect = function (t, e, n) { e = S(e, n); for (var i = !L(t) && C.keys(t), r = (i || t).length, o = Array(r), s = 0; s < r; s++) { var a = i ? i[s] : s; o[s] = e(t[a], a, t) } return o }, C.reduce = C.foldl = C.inject = n(1), C.reduceRight = C.foldr = n(-1), C.find = C.detect = function (t, e, n) { var i; if (void 0 !== (i = L(t) ? C.findIndex(t, e, n) : C.findKey(t, e, n)) && -1 !== i) return t[i] }, C.filter = C.select = function (t, e, n) { var i = []; return e = S(e, n), C.each(t, function (t, n, r) { e(t, n, r) && i.push(t) }), i }, C.reject = function (t, e, n) { return C.filter(t, C.negate(S(e)), n) }, C.every = C.all = function (t, e, n) { e = S(e, n); for (var i = !L(t) && C.keys(t), r = (i || t).length, o = 0; o < r; o++) { var s = i ? i[o] : o; if (!e(t[s], s, t)) return !1 } return !0 }, C.some = C.any = function (t, e, n) { e = S(e, n); for (var i = !L(t) && C.keys(t), r = (i || t).length, o = 0; o < r; o++) { var s = i ? i[o] : o; if (e(t[s], s, t)) return !0 } return !1 }, C.contains = C.includes = C.include = function (t, e, n, i) { return L(t) || (t = C.values(t)), ("number" != typeof n || i) && (n = 0), C.indexOf(t, e, n) >= 0 }, C.invoke = function (t, e) { var n = p.call(arguments, 2), i = C.isFunction(e); return C.map(t, function (t) { var r = i ? e : t[e]; return null == r ? r : r.apply(t, n) }) }, C.pluck = function (t, e) { return C.map(t, C.property(e)) }, C.where = function (t, e) { return C.filter(t, C.matcher(e)) }, C.findWhere = function (t, e) { return C.find(t, C.matcher(e)) }, C.max = function (t, e, n) { var i, r, o = -1 / 0, s = -1 / 0; if (null == e && null != t) { t = L(t) ? t : C.values(t); for (var a = 0, l = t.length; a < l; a++)(i = t[a]) > o && (o = i) } else e = S(e, n), C.each(t, function (t, n, i) { ((r = e(t, n, i)) > s || r === -1 / 0 && o === -1 / 0) && (o = t, s = r) }); return o }, C.min = function (t, e, n) { var i, r, o = 1 / 0, s = 1 / 0; if (null == e && null != t) { t = L(t) ? t : C.values(t); for (var a = 0, l = t.length; a < l; a++)(i = t[a]) < o && (o = i) } else e = S(e, n), C.each(t, function (t, n, i) { ((r = e(t, n, i)) < s || r === 1 / 0 && o === 1 / 0) && (o = t, s = r) }); return o }, C.shuffle = function (t) { for (var e, n = L(t) ? t : C.values(t), i = n.length, r = Array(i), o = 0; o < i; o++)e = C.random(0, o), e !== o && (r[o] = r[e]), r[e] = n[o]; return r }, C.sample = function (t, e, n) { return null == e || n ? (L(t) || (t = C.values(t)), t[C.random(t.length - 1)]) : C.shuffle(t).slice(0, Math.max(0, e)) }, C.sortBy = function (t, e, n) { return e = S(e, n), C.pluck(C.map(t, function (t, n, i) { return { value: t, index: n, criteria: e(t, n, i) } }).sort(function (t, e) { var n = t.criteria, i = e.criteria; if (n !== i) { if (n > i || void 0 === n) return 1; if (n < i || void 0 === i) return -1 } return t.index - e.index }), "value") }; var O = function (t) { return function (e, n, i) { var r = {}; return n = S(n, i), C.each(e, function (i, o) { var s = n(i, o, e); t(r, i, s) }), r } }; C.groupBy = O(function (t, e, n) { C.has(t, n) ? t[n].push(e) : t[n] = [e] }), C.indexBy = O(function (t, e, n) { t[n] = e }), C.countBy = O(function (t, e, n) { C.has(t, n) ? t[n]++ : t[n] = 1 }), C.toArray = function (t) { return t ? C.isArray(t) ? p.call(t) : L(t) ? C.map(t, C.identity) : C.values(t) : [] }, C.size = function (t) { return null == t ? 0 : L(t) ? t.length : C.keys(t).length }, C.partition = function (t, e, n) { e = S(e, n); var i = [], r = []; return C.each(t, function (t, n, o) { (e(t, n, o) ? i : r).push(t) }), [i, r] }, C.first = C.head = C.take = function (t, e, n) { if (null != t) return null == e || n ? t[0] : C.initial(t, t.length - e) }, C.initial = function (t, e, n) { return p.call(t, 0, Math.max(0, t.length - (null == e || n ? 1 : e))) }, C.last = function (t, e, n) { if (null != t) return null == e || n ? t[t.length - 1] : C.rest(t, Math.max(0, t.length - e)) }, C.rest = C.tail = C.drop = function (t, e, n) { return p.call(t, null == e || n ? 1 : e) }, C.compact = function (t) { return C.filter(t, C.identity) }; var N = function (t, e, n, i) { for (var r = [], o = 0, s = i || 0, a = A(t); s < a; s++) { var l = t[s]; if (L(l) && (C.isArray(l) || C.isArguments(l))) { e || (l = N(l, e, n)); var c = 0, u = l.length; for (r.length += u; c < u;)r[o++] = l[c++] } else n || (r[o++] = l) } return r }; C.flatten = function (t, e) { return N(t, e, !1) }, C.without = function (t) { return C.difference(t, p.call(arguments, 1)) }, C.uniq = C.unique = function (t, e, n, i) { C.isBoolean(e) || (i = n, n = e, e = !1), null != n && (n = S(n, i)); for (var r = [], o = [], s = 0, a = A(t); s < a; s++) { var l = t[s], c = n ? n(l, s, t) : l; e ? (s && o === c || r.push(l), o = c) : n ? C.contains(o, c) || (o.push(c), r.push(l)) : C.contains(r, l) || r.push(l) } return r }, C.union = function () { return C.uniq(N(arguments, !0, !0)) }, C.intersection = function (t) { for (var e = [], n = arguments.length, i = 0, r = A(t); i < r; i++) { var o = t[i]; if (!C.contains(e, o)) { for (var s = 1; s < n && C.contains(arguments[s], o); s++); s === n && e.push(o) } } return e }, C.difference = function (t) { var e = N(arguments, !0, !0, 1); return C.filter(t, function (t) { return !C.contains(e, t) }) }, C.zip = function () { return C.unzip(arguments) }, C.unzip = function (t) { for (var e = t && C.max(t, A).length || 0, n = Array(e), i = 0; i < e; i++)n[i] = C.pluck(t, i); return n }, C.object = function (t, e) { for (var n = {}, i = 0, r = A(t); i < r; i++)e ? n[t[i]] = e[i] : n[t[i][0]] = t[i][1]; return n }, C.findIndex = o(1), C.findLastIndex = o(-1), C.sortedIndex = function (t, e, n, i) { n = S(n, i, 1); for (var r = n(e), o = 0, s = A(t); o < s;) { var a = Math.floor((o + s) / 2); n(t[a]) < r ? o = a + 1 : s = a } return o }, C.indexOf = s(1, C.findIndex, C.sortedIndex), C.lastIndexOf = s(-1, C.findLastIndex), C.range = function (t, e, n) { null == e && (e = t || 0, t = 0), n = n || 1; for (var i = Math.max(Math.ceil((e - t) / n), 0), r = Array(i), o = 0; o < i; o++ , t += n)r[o] = t; return r }; var D = function (t, e, n, i, r) { if (!(i instanceof e)) return t.apply(n, r); var o = M(t.prototype), s = t.apply(o, r); return C.isObject(s) ? s : o }; C.bind = function (t, e) { if (b && t.bind === b) return b.apply(t, p.call(arguments, 1)); if (!C.isFunction(t)) throw new TypeError("Bind must be called on a function"); var n = p.call(arguments, 2), i = function () { return D(t, i, e, this, n.concat(p.call(arguments))) }; return i }, C.partial = function (t) { var e = p.call(arguments, 1), n = function () { for (var i = 0, r = e.length, o = Array(r), s = 0; s < r; s++)o[s] = e[s] === C ? arguments[i++] : e[s]; for (; i < arguments.length;)o.push(arguments[i++]); return D(t, n, this, this, o) }; return n }, C.bindAll = function (t) { var e, n, i = arguments.length; if (i <= 1) throw new Error("bindAll must be passed function names"); for (e = 1; e < i; e++)n = arguments[e], t[n] = C.bind(t[n], t); return t }, C.memoize = function (t, e) { var n = function (i) { var r = n.cache, o = "" + (e ? e.apply(this, arguments) : i); return C.has(r, o) || (r[o] = t.apply(this, arguments)), r[o] }; return n.cache = {}, n }, C.delay = function (t, e) { var n = p.call(arguments, 2); return setTimeout(function () { return t.apply(null, n) }, e) }, C.defer = C.partial(C.delay, C, 1), C.throttle = function (t, e, n) { var i, r, o, s = null, a = 0; n || (n = {}); var l = function () { a = !1 === n.leading ? 0 : C.now(), s = null, o = t.apply(i, r), s || (i = r = null) }; return function () { var c = C.now(); a || !1 !== n.leading || (a = c); var u = e - (c - a); return i = this, r = arguments, u <= 0 || u > e ? (s && (clearTimeout(s), s = null), a = c, o = t.apply(i, r), s || (i = r = null)) : s || !1 === n.trailing || (s = setTimeout(l, u)), o } }, C.debounce = function (t, e, n) { var i, r, o, s, a, l = function () { var c = C.now() - s; c < e && c >= 0 ? i = setTimeout(l, e - c) : (i = null, n || (a = t.apply(o, r), i || (o = r = null))) }; return function () { o = this, r = arguments, s = C.now(); var c = n && !i; return i || (i = setTimeout(l, e)), c && (a = t.apply(o, r), o = r = null), a } }, C.wrap = function (t, e) { return C.partial(e, t) }, C.negate = function (t) { return function () { return !t.apply(this, arguments) } }, C.compose = function () { var t = arguments, e = t.length - 1; return function () { for (var n = e, i = t[e].apply(this, arguments); n--;)i = t[n].call(this, i); return i } }, C.after = function (t, e) { return function () { if (--t < 1) return e.apply(this, arguments) } }, C.before = function (t, e) { var n; return function () { return --t > 0 && (n = e.apply(this, arguments)), t <= 1 && (e = null), n } }, C.once = C.partial(C.before, 2); var I = !{ toString: null }.propertyIsEnumerable("toString"), _ = ["valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"]; C.keys = function (t) { if (!C.isObject(t)) return []; if (y) return y(t); var e = []; for (var n in t) C.has(t, n) && e.push(n); return I && a(t, e), e }, C.allKeys = function (t) { if (!C.isObject(t)) return []; var e = []; for (var n in t) e.push(n); return I && a(t, e), e }, C.values = function (t) { for (var e = C.keys(t), n = e.length, i = Array(n), r = 0; r < n; r++)i[r] = t[e[r]]; return i }, C.mapObject = function (t, e, n) { e = S(e, n); for (var i, r = C.keys(t), o = r.length, s = {}, a = 0; a < o; a++)i = r[a], s[i] = e(t[i], i, t); return s }, C.pairs = function (t) { for (var e = C.keys(t), n = e.length, i = Array(n), r = 0; r < n; r++)i[r] = [e[r], t[e[r]]]; return i }, C.invert = function (t) { for (var e = {}, n = C.keys(t), i = 0, r = n.length; i < r; i++)e[t[n[i]]] = n[i]; return e }, C.functions = C.methods = function (t) { var e = []; for (var n in t) C.isFunction(t[n]) && e.push(n); return e.sort() }, C.extend = T(C.allKeys), C.extendOwn = C.assign = T(C.keys), C.findKey = function (t, e, n) { e = S(e, n); for (var i, r = C.keys(t), o = 0, s = r.length; o < s; o++)if (i = r[o], e(t[i], i, t)) return i }, C.pick = function (t, e, n) { var i, r, o = {}, s = t; if (null == s) return o; C.isFunction(e) ? (r = C.allKeys(s), i = k(e, n)) : (r = N(arguments, !1, !1, 1), i = function (t, e, n) { return e in n }, s = Object(s)); for (var a = 0, l = r.length; a < l; a++) { var c = r[a], u = s[c]; i(u, c, s) && (o[c] = u) } return o }, C.omit = function (t, e, n) { if (C.isFunction(e)) e = C.negate(e); else { var i = C.map(N(arguments, !1, !1, 1), String); e = function (t, e) { return !C.contains(i, e) } } return C.pick(t, e, n) }, C.defaults = T(C.allKeys, !0), C.create = function (t, e) { var n = M(t); return e && C.extendOwn(n, e), n }, C.clone = function (t) { return C.isObject(t) ? C.isArray(t) ? t.slice() : C.extend({}, t) : t }, C.tap = function (t, e) { return e(t), t }, C.isMatch = function (t, e) { var n = C.keys(e), i = n.length; if (null == t) return !i; for (var r = Object(t), o = 0; o < i; o++) { var s = n[o]; if (e[s] !== r[s] || !(s in r)) return !1 } return !0 }; var F = function (t, e, n, i) { if (t === e) return 0 !== t || 1 / t == 1 / e; if (null == t || null == e) return t === e; t instanceof C && (t = t._wrapped), e instanceof C && (e = e._wrapped); var r = g.call(t); if (r !== g.call(e)) return !1; switch (r) { case "[object RegExp]": case "[object String]": return "" + t == "" + e; case "[object Number]": return +t != +t ? +e != +e : 0 == +t ? 1 / +t == 1 / e : +t == +e; case "[object Date]": case "[object Boolean]": return +t == +e }var o = "[object Array]" === r; if (!o) { if ("object" != typeof t || "object" != typeof e) return !1; var s = t.constructor, a = e.constructor; if (s !== a && !(C.isFunction(s) && s instanceof s && C.isFunction(a) && a instanceof a) && "constructor" in t && "constructor" in e) return !1 } n = n || [], i = i || []; for (var l = n.length; l--;)if (n[l] === t) return i[l] === e; if (n.push(t), i.push(e), o) { if ((l = t.length) !== e.length) return !1; for (; l--;)if (!F(t[l], e[l], n, i)) return !1 } else { var c, u = C.keys(t); if (l = u.length, C.keys(e).length !== l) return !1; for (; l--;)if (c = u[l], !C.has(e, c) || !F(t[c], e[c], n, i)) return !1 } return n.pop(), i.pop(), !0 }; C.isEqual = function (t, e) { return F(t, e) }, C.isEmpty = function (t) { return null == t || (L(t) && (C.isArray(t) || C.isString(t) || C.isArguments(t)) ? 0 === t.length : 0 === C.keys(t).length) }, C.isElement = function (t) { return !(!t || 1 !== t.nodeType) }, C.isArray = v || function (t) { return "[object Array]" === g.call(t) }, C.isObject = function (t) { var e = typeof t; return "function" === e || "object" === e && !!t }, C.each(["Arguments", "Function", "String", "Number", "Date", "RegExp", "Error"], function (t) { C["is" + t] = function (e) { return g.call(e) === "[object " + t + "]" } }), C.isArguments(arguments) || (C.isArguments = function (t) { return C.has(t, "callee") }), "function" != typeof /./ && "object" != typeof Int8Array && (C.isFunction = function (t) { return "function" == typeof t || !1 }), C.isFinite = function (t) { return isFinite(t) && !isNaN(parseFloat(t)) }, C.isNaN = function (t) { return C.isNumber(t) && t !== +t }, C.isBoolean = function (t) { return !0 === t || !1 === t || "[object Boolean]" === g.call(t) }, C.isNull = function (t) { return null === t }, C.isUndefined = function (t) { return void 0 === t }, C.has = function (t, e) { return null != t && m.call(t, e) }, C.noConflict = function () { return l._ = c, this }, C.identity = function (t) { return t }, C.constant = function (t) { return function () { return t } }, C.noop = function () { }, C.property = E, C.propertyOf = function (t) { return null == t ? function () { } : function (e) { return t[e] } }, C.matcher = C.matches = function (t) { return t = C.extendOwn({}, t), function (e) { return C.isMatch(e, t) } }, C.times = function (t, e, n) { var i = Array(Math.max(0, t)); e = k(e, n, 1); for (var r = 0; r < t; r++)i[r] = e(r); return i }, C.random = function (t, e) { return null == e && (e = t, t = 0), t + Math.floor(Math.random() * (e - t + 1)) }, C.now = Date.now || function () { return (new Date).getTime() }; var $ = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "`": "&#x60;" }, z = C.invert($), H = function (t) { var e = function (e) { return t[e] }, n = "(?:" + C.keys(t).join("|") + ")", i = RegExp(n), r = RegExp(n, "g"); return function (t) { return t = null == t ? "" : "" + t, i.test(t) ? t.replace(r, e) : t } }; C.escape = H($), C.unescape = H(z), C.result = function (t, e, n) { var i = null == t ? void 0 : t[e]; return void 0 === i && (i = n), C.isFunction(i) ? i.call(t) : i }; var R = 0; C.uniqueId = function (t) { var e = ++R + ""; return t ? t + e : e }, C.templateSettings = { evaluate: /<%([\s\S]+?)%>/g, interpolate: /<%=([\s\S]+?)%>/g, escape: /<%-([\s\S]+?)%>/g }; var V = /(.)^/, j = { "'": "'", "\\": "\\", "\r": "r", "\n": "n", "\u2028": "u2028", "\u2029": "u2029" }, B = /\\|'|\r|\n|\u2028|\u2029/g, W = function (t) { return "\\" + j[t] }; C.template = function (t, e, n) { !e && n && (e = n), e = C.defaults({}, e, C.templateSettings); var i = RegExp([(e.escape || V).source, (e.interpolate || V).source, (e.evaluate || V).source].join("|") + "|$", "g"), r = 0, o = "__p+='"; t.replace(i, function (e, n, i, s, a) { return o += t.slice(r, a).replace(B, W), r = a + e.length, n ? o += "'+\n((__t=(" + n + "))==null?'':_.escape(__t))+\n'" : i ? o += "'+\n((__t=(" + i + "))==null?'':__t)+\n'" : s && (o += "';\n" + s + "\n__p+='"), e }), o += "';\n", e.variable || (o = "with(obj||{}){\n" + o + "}\n"), o = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + o + "return __p;\n"; try { var s = new Function(e.variable || "obj", "_", o) } catch (t) { throw t.source = o, t } var a = function (t) { return s.call(this, t, C) }; return a.source = "function(" + (e.variable || "obj") + "){\n" + o + "}", a }, C.chain = function (t) { var e = C(t); return e._chain = !0, e }; var U = function (t, e) { return t._chain ? C(e).chain() : e }; C.mixin = function (t) { C.each(C.functions(t), function (e) { var n = C[e] = t[e]; C.prototype[e] = function () { var t = [this._wrapped]; return f.apply(t, arguments), U(this, n.apply(C, t)) } }) }, C.mixin(C), C.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (t) { var e = u[t]; C.prototype[t] = function () { var n = this._wrapped; return e.apply(n, arguments), "shift" !== t && "splice" !== t || 0 !== n.length || delete n[0], U(this, n) } }), C.each(["concat", "join", "slice"], function (t) { var e = u[t]; C.prototype[t] = function () { return U(this, e.apply(this._wrapped, arguments)) } }), C.prototype.value = function () { return this._wrapped }, C.prototype.valueOf = C.prototype.toJSON = C.prototype.value, C.prototype.toString = function () { return "" + this._wrapped }, i = [], void 0 !== (r = function () { return C }.apply(e, i)) && (t.exports = r) }).call(this) }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = function (t, e, n) { e = e.split(/\s+/), t = t instanceof Array ? t : [t]; for (var i = 0; i < e.length; ++i)!function (i) { t.forEach(function (t) { return t.addEventListener(e[i], n) }) }(i) }, r = function (t, e, n) { e = e.split(/\s+/), t = t instanceof Array ? t : [t]; for (var i = 0; i < e.length; ++i)!function (i) { t.forEach(function (t) { return t.removeEventListener(e[i], n) }) }(i) }, o = function (t) { return t.replace(parseFloat(t), "") }, s = function (t) { return t[0].toUpperCase() + t.toLowerCase().slice(1) }, a = function (t) { var e = t.split("-"); return e[0].toLowerCase() + e.slice(1).map(s) }; e.on = i, e.off = r, e.upFirst = s, e.camelCase = a, e.getUnitFromValue = o }, function (t, e, n) { "use strict"; (function (e) { var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, r = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, o = n(1), s = n(45), a = function (t) { return t && t.__esModule ? t : { default: t } }(s), l = n(0), c = n(145), u = n(23), h = n(146), d = function (t) { return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&") }; t.exports = l.Model.extend(a.default).extend({ defaults: { tagName: "div", type: "", removable: !0, draggable: !0, droppable: !0, badgable: !0, stylable: !0, highlightable: !0, copyable: !0, resizable: !1, editable: !1, layerable: !0, void: !1, state: "", status: "", content: "", icon: "", style: "", attributes: "", classes: "", script: "", traits: ["id", "title"], propagate: "", toolbar: null }, initialize: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e.sm || e.em || {}, i = this.parent(), s = i && i.attributes; if (s && s.propagate) { var a = {}, l = s.propagate; l.forEach(function (t) { return a[t] = i.get(t) }), a.propagate = l, a = r({}, a, t), this.set(a) } var c = this.get("propagate"); c && this.set("propagate", (0, o.isArray)(c) ? c : [c]), e && e.config && e.config.voidElements.indexOf(this.get("tagName")) >= 0 && this.set("void", !0), e.em = n, this.opt = e, this.sm = n, this.em = n, this.config = t, this.set("attributes", this.get("attributes") || {}), this.listenTo(this, "change:script", this.scriptUpdated), this.listenTo(this, "change:traits", this.traitsUpdated), this.loadTraits(), this.initClasses(), this.initComponents(), this.initToolbar(), ["stylable"].forEach(function (t) { var e = this.get(t); if ("string" == typeof e) { var n = e.split(",").map(function (t) { return t.trim() }); this.set(t, n) } }, this), this.set("status", ""), this.init() }, setAttributes: function (t) { t = r({}, t); var e = t.class; e && this.setClass(e), delete t.class; var n = t.style; n && this.setStyle(n), delete t.style, this.set("attributes", t) }, getAttributes: function () { return this.get("attributes") }, addClass: function (t) { var e = this.em.get("SelectorManager").addClass(t); return this.get("classes").add(e) }, setClass: function (t) { return this.get("classes").reset(), this.addClass(t) }, initClasses: function () { var t = this.normalizeClasses(this.get("classes") || this.config.classes || []); return this.set("classes", new u(t)), this }, initComponents: function () { var t = new c(null, this.opt); return t.parent = this, t.reset(this.get("components")), this.set("components", t), this }, init: function () { }, append: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = this.components().add(t, e); return (0, o.isArray)(n) ? n : [n] }, components: function (t) { var e = this.get("components"); if ((0, o.isUndefined)(t)) return e; e.reset(), t && this.append(t) }, parent: function () { var t = this.collection; return t && t.parent }, scriptUpdated: function () { this.set("scriptUpdated", 1) }, traitsUpdated: function () { var t = 0, e = Object.assign({}, this.get("attributes")), n = this.get("traits"); if (!(n instanceof h)) return void this.loadTraits(); n.each(function (n) { if (t = 1, !n.get("changeProp")) { var i = n.getInitValue(); i && (e[n.get("name")] = i) } }), t && this.set("attributes", e) }, initToolbar: function () { var t = this; if (!t.get("toolbar")) { var e = []; t.collection && e.push({ attributes: { class: "fa fa-arrow-up" }, command: "select-parent" }), t.get("draggable") && e.push({ attributes: { class: "fa fa-arrows" }, command: "tlb-move" }), t.get("copyable") && e.push({ attributes: { class: "fa fa-clone" }, command: "tlb-clone" }), t.get("removable") && e.push({ attributes: { class: "fa fa-trash-o" }, command: "tlb-delete" }), t.set("toolbar", e) } }, loadTraits: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = new h([], this.opt); return n.setTarget(this), t = t || this.get("traits"), t.length && n.add(t), this.set("traits", n, e), this }, normalizeClasses: function (t) { var e = []; if (this.sm.get) { var n = this.sm.get("SelectorManager"); if (n) return t.forEach(function (t) { var i = ""; i = "string" == typeof t ? t : t.name; var r = n.add(i); e.push(r) }), e } }, clone: function (t) { var n = e.clone(this.attributes), i = this.get("components"), r = this.get("traits"), o = this.get("classes"); return n.components = [], n.classes = [], n.traits = [], i.each(function (t, e) { n.components[e] = t.clone(1) }), r.each(function (t, e) { n.traits[e] = t.clone() }), o.each(function (t, e) { n.classes[e] = t.get("name") }), n.status = "", n.view = "", t && (this.opt.collection = null), new this.constructor(n, this.opt) }, getName: function () { var t = this.get("custom-name"), e = this.get("tagName"); e = "div" == e ? "box" : e; var n = this.get("type") || e; return n = n.charAt(0).toUpperCase() + n.slice(1), t || n }, getIcon: function () { var t = this.get("icon"); return t ? t + " " : "" }, toHTML: function (t) { var n = "", r = this, o = r.get("tagName"), s = 0, a = r.get("void"), l = "", c = "", u = this.getAttrToHTML(); for (var h in u) { "id" == h && (s = 1); var d = u[h]; c += void 0 !== (void 0 === d ? "undefined" : i(d)) && "" !== d ? " " + h + '="' + d + '"' : "" } var f = ""; return r.get("classes").each(function (t) { f += " " + t.get("name") }), f = "" !== f ? ' class="' + f.trim() + '"' : "", e.isEmpty(r.get("style")) || s || (l = ' id="' + r.getId() + '" '), n += "<" + o + f + l + c + (a ? "/" : "") + ">" + r.get("content"), r.get("components").each(function (t) { n += t.toHTML() }), a || (n += "</" + o + ">"), n }, getAttrToHTML: function () { var t = this.get("attributes") || {}; return delete t.style, t }, toJSON: function () { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; var i = l.Model.prototype.toJSON.apply(this, e), r = this.getScriptString(); return delete i.toolbar, r && (i.script = r), i }, getId: function () { return (this.get("attributes") || {}).id || this.cid }, getScriptString: function (t) { var e = this, n = t || this.get("script"); if (!n) return n; if ("function" == typeof n) { var i = n.toString().trim(); i = i.replace(/^function[\s\w]*\(\)\s?\{/, "").replace(/\}$/, ""), n = i.trim() } var r = this.sm.config || {}, o = d(r.tagVarStart || "{[ "), s = d(r.tagVarEnd || " ]}"), a = new RegExp(o + "(\\w+)" + s, "g"); return n = n.replace(a, function (t, n) { return e.scriptUpdated(), e.attributes[n] }) } }, { isComponent: function (t) { return { tagName: t.tagName ? t.tagName.toLowerCase() : "" } } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; (function (e) { var i = n(149); t.exports = e.View.extend({ className: function () { return this.getClasses() }, tagName: function () { return this.model.get("tagName") }, initialize: function (t) { var e = this.model; this.opts = t || {}, this.config = this.opts.config || {}, this.em = this.config.em || "", this.pfx = this.config.stylePrefix || "", this.ppfx = this.config.pStylePrefix || "", this.attr = e.get("attributes"), this.classe = this.attr.class || []; var n = this.$el, i = e.get("classes"); this.listenTo(e, "destroy remove", this.remove), this.listenTo(e, "change:style", this.updateStyle), this.listenTo(e, "change:attributes", this.updateAttributes), this.listenTo(e, "change:highlightable", this.updateHighlight), this.listenTo(e, "change:status", this.updateStatus), this.listenTo(e, "change:state", this.updateState), this.listenTo(e, "change:script", this.render), this.listenTo(e, "change", this.handleChange), this.listenTo(i, "add remove change", this.updateClasses), n.data("model", e), n.data("collection", e.get("components")), e.view = this, i.length && this.importClasses(), this.init() }, remove: function () { e.View.prototype.remove.apply(this); var t = this.childrenView; t && t.stopListening() }, init: function () { }, handleChange: function () { var t = this.em; if (t) { var e = this.model; t.trigger("component:update", e); for (var n in e.changed) t.trigger("component:update:" + n, e) } }, importClasses: function () { var t = this.config.em.get("SelectorManager"); t && this.model.get("classes").each(function (e) { t.add(e.get("name")) }) }, updateState: function (t) { var e = "hc-state"; this.model.get("state") ? this.$el.addClass(e) : this.$el.removeClass(e) }, updateStatus: function (t) { var e = this.el, n = this.model.get("status"), i = this.pfx, r = this.ppfx, o = i + "selected", s = o + "-parent", a = r + "freezed", l = e.getAttribute("class") || "", c = ""; switch (n) { case "selected": c = l + " " + o; break; case "selected-parent": c = l + " " + s; break; case "freezed": c = l + " " + a; break; default: this.$el.removeClass(o + " " + s + " " + a) }(c = c.trim()) && e.setAttribute("class", c) }, updateHighlight: function () { var t = this.model.get("highlightable"); this.setAttribute("data-highlightable", t ? 1 : "") }, updateStyle: function () { this.setAttribute("style", this.getStyleString()) }, updateClasses: function () { var t = this.model.get("classes").pluck("name").join(" "); this.setAttribute("class", t), this.updateStatus() }, setAttribute: function (t, e) { var n = this.$el; e ? n.attr(t, e) : n.removeAttr(t) }, getClasses: function () { var t = this.model.get("attributes"), e = t.class || []; return e.length ? e.join(" ") : null }, updateAttributes: function () { var t = this.model, e = {}, n = t.get("attributes"), i = t.get("src"); for (var r in n) e[r] = n[r]; i && (e.src = i), this.$el.attr(e), this.updateHighlight(), this.updateStyle() }, updateContent: function () { this.getChildrenContainer().innerHTML = this.model.get("content") }, getStyleString: function () { var t = ""; this.style = this.model.get("style"); for (var e in this.style) this.style.hasOwnProperty(e) && (t += e + ":" + this.style[e] + ";"); return t }, eventCall: function (t) { t.viewResponse = this }, prevDef: function (t) { t.preventDefault() }, updateScript: function () { if (this.model.get("script")) { var t = this.em; if (t) { t.get("Canvas").getCanvasView().updateScript(this) } } }, getChildrenContainer: function () { var t = this.el; return "function" == typeof this.getChildrenSelector ? t = this.el.querySelector(this.getChildrenSelector()) : this.getTemplate, t }, renderChildren: function () { var t = this.getChildrenContainer(), e = new i({ collection: this.model.get("components"), config: this.config, componentTypes: this.opts.componentTypes }); e.render(t), this.childrenView = e; for (var n = Array.prototype.slice.call(e.el.childNodes), r = 0, o = n.length; r < o; r++)t.appendChild(n.shift()); if (t !== this.el) { !function e(n) { Array.prototype.slice.call(n.children).forEach(function (n) { n.style["pointer-events"] = "none", t !== n && e(n) }) }(this.el) } }, renderAttributes: function () { this.updateAttributes(), this.updateClasses() }, render: function () { return this.renderAttributes(), this.updateContent(), this.renderChildren(), this.updateScript(), this } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; (function (e, i) { var r = n(1), o = n(2); t.exports = e.View.extend({ template: function (t) { return '\n      <div class="' + this.pfx + 'label">\n        ' + this.templateLabel(t) + '\n      </div>\n      <div class="' + this.ppfx + 'fields">\n        ' + this.templateInput(t) + "\n      </div>\n    " }, templateLabel: function (t) { var e = this.pfx; return '\n      <span class="' + e + "icon " + t.get("icon") + '" title="' + t.get("info") + '">\n        ' + t.get("name") + '\n      </span>\n      <b class="' + e + 'clear">&Cross;</b>\n    ' }, templateInput: function (t) { return '\n      <div class="' + this.ppfx + 'field">\n        <input placeholder="' + t.getDefaultValue() + '"/>\n      </div>\n    ' }, events: { change: "inputValueChanged" }, initialize: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; (0, r.bindAll)(this, "targetUpdated"), this.config = t.config || {}; var e = this.config.em; this.em = e, this.pfx = this.config.stylePrefix || "", this.ppfx = this.config.pStylePrefix || "", this.target = t.target || {}, this.propTarget = t.propTarget || {}, this.onChange = t.onChange, this.onInputRender = t.onInputRender || {}, this.customValue = t.customValue || {}; var n = this.model; this.property = n.get("property"), this.input = null; var i = this.pfx; this.inputHolderId = "#" + i + "input-holder", this.sector = n.collection && n.collection.sector, n.view = this, n.get("value") || n.set("value", n.getDefaultValue()), e && e.on("update:component:style:" + this.property, this.targetUpdated), this.listenTo(this.propTarget, "update", this.targetUpdated), this.listenTo(n, "destroy remove", this.remove), this.listenTo(n, "change:value", this.modelValueChanged), this.listenTo(n, "targetUpdated", this.targetUpdated), this.listenTo(n, "change:visible", this.updateVisibility), this.listenTo(n, "change:status", this.updateStatus), this.events["click ." + i + "clear"] = "clear", this.delegateEvents(); var o = this.init && this.init.bind(this); o && o() }, updateStatus: function () { var t = this.model.get("status"), e = this.pfx, n = this.ppfx, i = this.config, r = n + "color-hl", o = n + "color-warn", s = this.$el.children("." + e + "label"), a = this.getClearEl().style; switch (s.removeClass(r + " " + o), a.display = "none", t) { case "updated": s.addClass(r), i.clearProperties && (a.display = "inline"); break; case "computed": s.addClass(o) } }, clear: function () { this.getTargetModel().removeStyle(this.model.get("property")), this.targetUpdated() }, getClearEl: function () { return this.el.querySelector("." + this.pfx + "clear") }, getTarget: function () { return this.getTargetModel() }, getTargetModel: function () { return this.propTarget && this.propTarget.model }, getHelperModel: function () { return this.propTarget && this.propTarget.helper }, inputValueChanged: function (t) { t && t.stopPropagation(), this.model.setValue(this.getInputValue(), 1, { fromInput: 1 }), this.elementUpdated() }, elementUpdated: function () { this.model.set("status", "updated"); var t = this.model.parent, e = t && t.view; e && e.elementUpdated() }, setStatus: function (t) { this.model.set("status", t); var e = this.model.parent; e && e.set("status", t) }, targetUpdated: function () { if (this.checkVisibility()) { var t = this.config, e = t.em, n = this.model, i = "", r = "", o = this.getTargetValue({ ignoreDefault: 1 }), s = n.getDefaultValue(), a = this.getComputedValue(); o ? (i = o, t.highlightChanged && (r = "updated")) : a && t.showComputed && a != s ? (i = a, t.highlightComputed && (r = "computed")) : (i = s, r = ""), n.setValue(i, 0, { fromTarget: 1 }), this.setStatus(r), e && (e.trigger("styleManager:change", this), e.trigger("styleManager:change:" + n.get("property"), this)) } }, checkVisibility: function () { var t = 1; return this.config.hideNotStylable && (this.isTargetStylable() && this.isComponentStylable() ? this.show() : (this.hide(), t = 0), this.sector && this.sector.trigger("updateVisibility")), t }, getTargetValue: function () { var t, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n = this.model, i = this.getTargetModel(), r = this.customValue; if (!i) return t; if (t = i.getStyle()[n.get("property")], t || e.ignoreDefault || (t = n.getDefaultValue()), "function" == typeof r && !e.ignoreCustomValue) { var o = n.collection.indexOf(n), s = r(this, o); s && (t = s) } return t }, getComputedValue: function () { var t = this.propTarget, e = t.computed || {}, n = t.computedDefault || {}, i = this.config.avoidComputed || [], r = this.model.get("property"), s = i.indexOf(r) < 0, a = e[r], l = n[(0, o.camelCase)(r)]; return e && s && l !== a && a }, getInputValue: function () { var t = this.getInputEl(); return t ? t.value : "" }, modelValueChanged: function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = this.config.em, r = this.model, o = r.getFullValue(), s = this.getTarget(), a = this.onChange; n.fromInput || this.setValue(o), s && this.isTargetStylable() && this.isComponentStylable() && (n.fromTarget || (a && !n.fromParent ? a(s, this, n) : this.updateTargetStyle(o, null, n)), i && (i.trigger("component:update", r), i.trigger("component:styleUpdate", r), i.trigger("component:styleUpdate:" + r.get("property"), r))) }, updateTargetStyle: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = e || this.model.get("property"), r = this.getTarget(), o = r.getStyle(); t ? o[i] = t : delete o[i], r.setStyle(o, n); var s = this.getHelperModel(); s && s.setStyle(o, n) }, isTargetStylable: function () { var t = this.getTarget().get("stylable"); return t instanceof Array && (t = i.indexOf(t, this.property) >= 0), t }, isComponentStylable: function () { var t = this.em, e = t && t.get("selectedComponent"); if (!e) return !0; var n = e.get("stylable"); return n instanceof Array && (n = i.indexOf(n, this.property) >= 0), n }, setRawValue: function (t) { this.setValue(this.model.parseValue(t)) }, setValue: function (t) { var e = this.model, n = t || e.getDefaultValue(), i = this.getInputEl(); i && (i.value = n) }, getInputEl: function () { return this.input || (this.input = this.el.querySelector("input")), this.input }, updateVisibility: function () { this.el.style.display = this.model.get("visible") ? "block" : "none" }, show: function () { this.model.set("visible", 1) }, hide: function () { this.model.set("visible", 0) }, cleanValue: function () { this.setValue("") }, render: function () { var t = this.pfx, e = this.model, n = this.el; n.innerHTML = this.template(e), n.className = t + "property " + t + e.get("type"), this.updateStatus(); var i = this.onRender && this.onRender.bind(this); i && i(), this.setValue(e.get("value"), { targetUpdate: 1 }) } }) }).call(e, n(0), n(1)) }, function (t, e, n) { !function (e, n) { t.exports = n() }(0, function () { "use strict"; function t(t) { return new RegExp("(^|\\s)" + t + "(?:$|\\s)\\s*") } function e(t) { for (var e = t.childNodes.length; e > 0; --e)t.removeChild(t.firstChild); return t } function n(t, n) { return e(t).appendChild(n) } function i(t, e, n, i) { var r = document.createElement(t); if (n && (r.className = n), i && (r.style.cssText = i), "string" == typeof e) r.appendChild(document.createTextNode(e)); else if (e) for (var o = 0; o < e.length; ++o)r.appendChild(e[o]); return r } function r(t, e, n, r) { var o = i(t, e, n, r); return o.setAttribute("role", "presentation"), o } function o(t, e) { if (3 == e.nodeType && (e = e.parentNode), t.contains) return t.contains(e); do { if (11 == e.nodeType && (e = e.host), e == t) return !0 } while (e = e.parentNode) } function s() { var t; try { t = document.activeElement } catch (e) { t = document.body || null } for (; t && t.shadowRoot && t.shadowRoot.activeElement;)t = t.shadowRoot.activeElement; return t } function a(e, n) { var i = e.className; t(n).test(i) || (e.className += (i ? " " : "") + n) } function l(e, n) { for (var i = e.split(" "), r = 0; r < i.length; r++)i[r] && !t(i[r]).test(n) && (n += " " + i[r]); return n } function c(t) { var e = Array.prototype.slice.call(arguments, 1); return function () { return t.apply(null, e) } } function u(t, e, n) { e || (e = {}); for (var i in t) !t.hasOwnProperty(i) || !1 === n && e.hasOwnProperty(i) || (e[i] = t[i]); return e } function h(t, e, n, i, r) { null == e && -1 == (e = t.search(/[^\s\u00a0]/)) && (e = t.length); for (var o = i || 0, s = r || 0; ;) { var a = t.indexOf("\t", o); if (a < 0 || a >= e) return s + (e - o); s += a - o, s += n - s % n, o = a + 1 } } function d(t, e) { for (var n = 0; n < t.length; ++n)if (t[n] == e) return n; return -1 } function f(t, e, n) { for (var i = 0, r = 0; ;) { var o = t.indexOf("\t", i); -1 == o && (o = t.length); var s = o - i; if (o == t.length || r + s >= e) return i + Math.min(s, e - r); if (r += o - i, r += n - r % n, i = o + 1, r >= e) return i } } function p(t) { for (; qs.length <= t;)qs.push(g(qs) + " "); return qs[t] } function g(t) { return t[t.length - 1] } function m(t, e) { for (var n = [], i = 0; i < t.length; i++)n[i] = e(t[i], i); return n } function v(t, e, n) { for (var i = 0, r = n(e); i < t.length && n(t[i]) <= r;)i++; t.splice(i, 0, e) } function y() { } function b(t, e) { var n; return Object.create ? n = Object.create(t) : (y.prototype = t, n = new y), e && u(e, n), n } function x(t) { return /\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || Ks.test(t)) } function w(t, e) { return e ? !!(e.source.indexOf("\\w") > -1 && x(t)) || e.test(t) : x(t) } function C(t) { for (var e in t) if (t.hasOwnProperty(e) && t[e]) return !1; return !0 } function k(t) { return t.charCodeAt(0) >= 768 && Gs.test(t) } function S(t, e, n) { for (; (n < 0 ? e > 0 : e < t.length) && k(t.charAt(e));)e += n; return e } function T(t, e, n) { for (var i = e > n ? -1 : 1; ;) { if (e == n) return e; var r = (e + n) / 2, o = i < 0 ? Math.ceil(r) : Math.floor(r); if (o == e) return t(o) ? e : n; t(o) ? n = o : e = o + i } } function M(t, e, n) { var o = this; this.input = n, o.scrollbarFiller = i("div", null, "CodeMirror-scrollbar-filler"), o.scrollbarFiller.setAttribute("cm-not-content", "true"), o.gutterFiller = i("div", null, "CodeMirror-gutter-filler"), o.gutterFiller.setAttribute("cm-not-content", "true"), o.lineDiv = r("div", null, "CodeMirror-code"), o.selectionDiv = i("div", null, null, "position: relative; z-index: 1"), o.cursorDiv = i("div", null, "CodeMirror-cursors"), o.measure = i("div", null, "CodeMirror-measure"), o.lineMeasure = i("div", null, "CodeMirror-measure"), o.lineSpace = r("div", [o.measure, o.lineMeasure, o.selectionDiv, o.cursorDiv, o.lineDiv], null, "position: relative; outline: none"); var s = r("div", [o.lineSpace], "CodeMirror-lines"); o.mover = i("div", [s], null, "position: relative"), o.sizer = i("div", [o.mover], "CodeMirror-sizer"), o.sizerWidth = null, o.heightForcer = i("div", null, null, "position: absolute; height: " + Vs + "px; width: 1px;"), o.gutters = i("div", null, "CodeMirror-gutters"), o.lineGutter = null, o.scroller = i("div", [o.sizer, o.heightForcer, o.gutters], "CodeMirror-scroll"), o.scroller.setAttribute("tabIndex", "-1"), o.wrapper = i("div", [o.scrollbarFiller, o.gutterFiller, o.scroller], "CodeMirror"), vs && ys < 8 && (o.gutters.style.zIndex = -1, o.scroller.style.paddingRight = 0), bs || fs && Ps || (o.scroller.draggable = !0), t && (t.appendChild ? t.appendChild(o.wrapper) : t(o.wrapper)), o.viewFrom = o.viewTo = e.first, o.reportedViewFrom = o.reportedViewTo = e.first, o.view = [], o.renderedView = null, o.externalMeasured = null, o.viewOffset = 0, o.lastWrapHeight = o.lastWrapWidth = 0, o.updateLineNumbers = null, o.nativeBarWidth = o.barHeight = o.barWidth = 0, o.scrollbarsClipped = !1, o.lineNumWidth = o.lineNumInnerWidth = o.lineNumChars = null, o.alignWidgets = !1, o.cachedCharWidth = o.cachedTextHeight = o.cachedPaddingH = null, o.maxLine = null, o.maxLineLength = 0, o.maxLineChanged = !1, o.wheelDX = o.wheelDY = o.wheelStartX = o.wheelStartY = null, o.shift = !1, o.selForContextMenu = null, o.activeTouch = null, n.init(o) } function E(t, e) { if ((e -= t.first) < 0 || e >= t.size) throw new Error("There is no line " + (e + t.first) + " in the document."); for (var n = t; !n.lines;)for (var i = 0; ; ++i) { var r = n.children[i], o = r.chunkSize(); if (e < o) { n = r; break } e -= o } return n.lines[e] } function P(t, e, n) { var i = [], r = e.line; return t.iter(e.line, n.line + 1, function (t) { var o = t.text; r == n.line && (o = o.slice(0, n.ch)), r == e.line && (o = o.slice(e.ch)), i.push(o), ++r }), i } function A(t, e, n) { var i = []; return t.iter(e, n, function (t) { i.push(t.text) }), i } function L(t, e) { var n = e - t.height; if (n) for (var i = t; i; i = i.parent)i.height += n } function O(t) { if (null == t.parent) return null; for (var e = t.parent, n = d(e.lines, t), i = e.parent; i; e = i, i = i.parent)for (var r = 0; i.children[r] != e; ++r)n += i.children[r].chunkSize(); return n + e.first } function N(t, e) { var n = t.first; t: do { for (var i = 0; i < t.children.length; ++i) { var r = t.children[i], o = r.height; if (e < o) { t = r; continue t } e -= o, n += r.chunkSize() } return n } while (!t.lines); for (var s = 0; s < t.lines.length; ++s) { var a = t.lines[s], l = a.height; if (e < l) break; e -= l } return n + s } function D(t, e) { return e >= t.first && e < t.first + t.size } function I(t, e) { return String(t.lineNumberFormatter(e + t.firstLineNumber)) } function _(t, e, n) { if (void 0 === n && (n = null), !(this instanceof _)) return new _(t, e, n); this.line = t, this.ch = e, this.sticky = n } function F(t, e) { return t.line - e.line || t.ch - e.ch } function $(t, e) { return t.sticky == e.sticky && 0 == F(t, e) } function z(t) { return _(t.line, t.ch) } function H(t, e) { return F(t, e) < 0 ? e : t } function R(t, e) { return F(t, e) < 0 ? t : e } function V(t, e) { return Math.max(t.first, Math.min(e, t.first + t.size - 1)) } function j(t, e) { if (e.line < t.first) return _(t.first, 0); var n = t.first + t.size - 1; return e.line > n ? _(n, E(t, n).text.length) : B(e, E(t, e.line).text.length) } function B(t, e) { var n = t.ch; return null == n || n > e ? _(t.line, e) : n < 0 ? _(t.line, 0) : t } function W(t, e) { for (var n = [], i = 0; i < e.length; i++)n[i] = j(t, e[i]); return n } function U() { Ys = !0 } function q() { Xs = !0 } function K(t, e, n) { this.marker = t, this.from = e, this.to = n } function G(t, e) { if (t) for (var n = 0; n < t.length; ++n) { var i = t[n]; if (i.marker == e) return i } } function Y(t, e) { for (var n, i = 0; i < t.length; ++i)t[i] != e && (n || (n = [])).push(t[i]); return n } function X(t, e) { t.markedSpans = t.markedSpans ? t.markedSpans.concat([e]) : [e], e.marker.attachLine(t) } function J(t, e, n) { var i; if (t) for (var r = 0; r < t.length; ++r) { var o = t[r], s = o.marker, a = null == o.from || (s.inclusiveLeft ? o.from <= e : o.from < e); if (a || o.from == e && "bookmark" == s.type && (!n || !o.marker.insertLeft)) { var l = null == o.to || (s.inclusiveRight ? o.to >= e : o.to > e); (i || (i = [])).push(new K(s, o.from, l ? null : o.to)) } } return i } function Z(t, e, n) { var i; if (t) for (var r = 0; r < t.length; ++r) { var o = t[r], s = o.marker, a = null == o.to || (s.inclusiveRight ? o.to >= e : o.to > e); if (a || o.from == e && "bookmark" == s.type && (!n || o.marker.insertLeft)) { var l = null == o.from || (s.inclusiveLeft ? o.from <= e : o.from < e); (i || (i = [])).push(new K(s, l ? null : o.from - e, null == o.to ? null : o.to - e)) } } return i } function Q(t, e) { if (e.full) return null; var n = D(t, e.from.line) && E(t, e.from.line).markedSpans, i = D(t, e.to.line) && E(t, e.to.line).markedSpans; if (!n && !i) return null; var r = e.from.ch, o = e.to.ch, s = 0 == F(e.from, e.to), a = J(n, r, s), l = Z(i, o, s), c = 1 == e.text.length, u = g(e.text).length + (c ? r : 0); if (a) for (var h = 0; h < a.length; ++h) { var d = a[h]; if (null == d.to) { var f = G(l, d.marker); f ? c && (d.to = null == f.to ? null : f.to + u) : d.to = r } } if (l) for (var p = 0; p < l.length; ++p) { var m = l[p]; if (null != m.to && (m.to += u), null == m.from) { var v = G(a, m.marker); v || (m.from = u, c && (a || (a = [])).push(m)) } else m.from += u, c && (a || (a = [])).push(m) } a && (a = tt(a)), l && l != a && (l = tt(l)); var y = [a]; if (!c) { var b, x = e.text.length - 2; if (x > 0 && a) for (var w = 0; w < a.length; ++w)null == a[w].to && (b || (b = [])).push(new K(a[w].marker, null, null)); for (var C = 0; C < x; ++C)y.push(b); y.push(l) } return y } function tt(t) { for (var e = 0; e < t.length; ++e) { var n = t[e]; null != n.from && n.from == n.to && !1 !== n.marker.clearWhenEmpty && t.splice(e--, 1) } return t.length ? t : null } function et(t, e, n) { var i = null; if (t.iter(e.line, n.line + 1, function (t) { if (t.markedSpans) for (var e = 0; e < t.markedSpans.length; ++e) { var n = t.markedSpans[e].marker; !n.readOnly || i && -1 != d(i, n) || (i || (i = [])).push(n) } }), !i) return null; for (var r = [{ from: e, to: n }], o = 0; o < i.length; ++o)for (var s = i[o], a = s.find(0), l = 0; l < r.length; ++l) { var c = r[l]; if (!(F(c.to, a.from) < 0 || F(c.from, a.to) > 0)) { var u = [l, 1], h = F(c.from, a.from), f = F(c.to, a.to); (h < 0 || !s.inclusiveLeft && !h) && u.push({ from: c.from, to: a.from }), (f > 0 || !s.inclusiveRight && !f) && u.push({ from: a.to, to: c.to }), r.splice.apply(r, u), l += u.length - 3 } } return r } function nt(t) { var e = t.markedSpans; if (e) { for (var n = 0; n < e.length; ++n)e[n].marker.detachLine(t); t.markedSpans = null } } function it(t, e) { if (e) { for (var n = 0; n < e.length; ++n)e[n].marker.attachLine(t); t.markedSpans = e } } function rt(t) { return t.inclusiveLeft ? -1 : 0 } function ot(t) { return t.inclusiveRight ? 1 : 0 } function st(t, e) { var n = t.lines.length - e.lines.length; if (0 != n) return n; var i = t.find(), r = e.find(), o = F(i.from, r.from) || rt(t) - rt(e); if (o) return -o; var s = F(i.to, r.to) || ot(t) - ot(e); return s || e.id - t.id } function at(t, e) { var n, i = Xs && t.markedSpans; if (i) for (var r = void 0, o = 0; o < i.length; ++o)r = i[o], r.marker.collapsed && null == (e ? r.from : r.to) && (!n || st(n, r.marker) < 0) && (n = r.marker); return n } function lt(t) { return at(t, !0) } function ct(t) { return at(t, !1) } function ut(t, e, n, i, r) { var o = E(t, e), s = Xs && o.markedSpans; if (s) for (var a = 0; a < s.length; ++a) { var l = s[a]; if (l.marker.collapsed) { var c = l.marker.find(0), u = F(c.from, n) || rt(l.marker) - rt(r), h = F(c.to, i) || ot(l.marker) - ot(r); if (!(u >= 0 && h <= 0 || u <= 0 && h >= 0) && (u <= 0 && (l.marker.inclusiveRight && r.inclusiveLeft ? F(c.to, n) >= 0 : F(c.to, n) > 0) || u >= 0 && (l.marker.inclusiveRight && r.inclusiveLeft ? F(c.from, i) <= 0 : F(c.from, i) < 0))) return !0 } } } function ht(t) { for (var e; e = lt(t);)t = e.find(-1, !0).line; return t } function dt(t) { for (var e; e = ct(t);)t = e.find(1, !0).line; return t } function ft(t) { for (var e, n; e = ct(t);)t = e.find(1, !0).line, (n || (n = [])).push(t); return n } function pt(t, e) { var n = E(t, e), i = ht(n); return n == i ? e : O(i) } function gt(t, e) { if (e > t.lastLine()) return e; var n, i = E(t, e); if (!mt(t, i)) return e; for (; n = ct(i);)i = n.find(1, !0).line; return O(i) + 1 } function mt(t, e) { var n = Xs && e.markedSpans; if (n) for (var i = void 0, r = 0; r < n.length; ++r)if (i = n[r], i.marker.collapsed) { if (null == i.from) return !0; if (!i.marker.widgetNode && 0 == i.from && i.marker.inclusiveLeft && vt(t, e, i)) return !0 } } function vt(t, e, n) { if (null == n.to) { var i = n.marker.find(1, !0); return vt(t, i.line, G(i.line.markedSpans, n.marker)) } if (n.marker.inclusiveRight && n.to == e.text.length) return !0; for (var r = void 0, o = 0; o < e.markedSpans.length; ++o)if (r = e.markedSpans[o], r.marker.collapsed && !r.marker.widgetNode && r.from == n.to && (null == r.to || r.to != n.from) && (r.marker.inclusiveLeft || n.marker.inclusiveRight) && vt(t, e, r)) return !0 } function yt(t) { t = ht(t); for (var e = 0, n = t.parent, i = 0; i < n.lines.length; ++i) { var r = n.lines[i]; if (r == t) break; e += r.height } for (var o = n.parent; o; n = o, o = n.parent)for (var s = 0; s < o.children.length; ++s) { var a = o.children[s]; if (a == n) break; e += a.height } return e } function bt(t) { if (0 == t.height) return 0; for (var e, n = t.text.length, i = t; e = lt(i);) { var r = e.find(0, !0); i = r.from.line, n += r.from.ch - r.to.ch } for (i = t; e = ct(i);) { var o = e.find(0, !0); n -= i.text.length - o.from.ch, i = o.to.line, n += i.text.length - o.to.ch } return n } function xt(t) { var e = t.display, n = t.doc; e.maxLine = E(n, n.first), e.maxLineLength = bt(e.maxLine), e.maxLineChanged = !0, n.iter(function (t) { var n = bt(t); n > e.maxLineLength && (e.maxLineLength = n, e.maxLine = t) }) } function wt(t, e, n, i) { if (!t) return i(e, n, "ltr", 0); for (var r = !1, o = 0; o < t.length; ++o) { var s = t[o]; (s.from < n && s.to > e || e == n && s.to == e) && (i(Math.max(s.from, e), Math.min(s.to, n), 1 == s.level ? "rtl" : "ltr", o), r = !0) } r || i(e, n, "ltr") } function Ct(t, e, n) { var i; Js = null; for (var r = 0; r < t.length; ++r) { var o = t[r]; if (o.from < e && o.to > e) return r; o.to == e && (o.from != o.to && "before" == n ? i = r : Js = r), o.from == e && (o.from != o.to && "before" != n ? i = r : Js = r) } return null != i ? i : Js } function kt(t, e) { var n = t.order; return null == n && (n = t.order = Zs(t.text, e)), n } function St(t, e) { return t._handlers && t._handlers[e] || Qs } function Tt(t, e, n) { if (t.removeEventListener) t.removeEventListener(e, n, !1); else if (t.detachEvent) t.detachEvent("on" + e, n); else { var i = t._handlers, r = i && i[e]; if (r) { var o = d(r, n); o > -1 && (i[e] = r.slice(0, o).concat(r.slice(o + 1))) } } } function Mt(t, e) { var n = St(t, e); if (n.length) for (var i = Array.prototype.slice.call(arguments, 2), r = 0; r < n.length; ++r)n[r].apply(null, i) } function Et(t, e, n) { return "string" == typeof e && (e = { type: e, preventDefault: function () { this.defaultPrevented = !0 } }), Mt(t, n || e.type, t, e), Dt(e) || e.codemirrorIgnore } function Pt(t) { var e = t._handlers && t._handlers.cursorActivity; if (e) for (var n = t.curOp.cursorActivityHandlers || (t.curOp.cursorActivityHandlers = []), i = 0; i < e.length; ++i)-1 == d(n, e[i]) && n.push(e[i]) } function At(t, e) { return St(t, e).length > 0 } function Lt(t) { t.prototype.on = function (t, e) { ta(this, t, e) }, t.prototype.off = function (t, e) { Tt(this, t, e) } } function Ot(t) { t.preventDefault ? t.preventDefault() : t.returnValue = !1 } function Nt(t) { t.stopPropagation ? t.stopPropagation() : t.cancelBubble = !0 } function Dt(t) { return null != t.defaultPrevented ? t.defaultPrevented : 0 == t.returnValue } function It(t) { Ot(t), Nt(t) } function _t(t) { return t.target || t.srcElement } function Ft(t) { var e = t.which; return null == e && (1 & t.button ? e = 1 : 2 & t.button ? e = 3 : 4 & t.button && (e = 2)), As && t.ctrlKey && 1 == e && (e = 3), e } function $t(t) { if (null == Hs) { var e = i("span", ""); n(t, i("span", [e, document.createTextNode("x")])), 0 != t.firstChild.offsetHeight && (Hs = e.offsetWidth <= 1 && e.offsetHeight > 2 && !(vs && ys < 8)) } var r = Hs ? i("span", "") : i("span", " ", null, "display: inline-block; width: 1px; margin-right: -1px"); return r.setAttribute("cm-text", ""), r } function zt(t) { if (null != Rs) return Rs; var i = n(t, document.createTextNode("AA")), r = Ds(i, 0, 1).getBoundingClientRect(), o = Ds(i, 1, 2).getBoundingClientRect(); return e(t), !(!r || r.left == r.right) && (Rs = o.right - r.right < 3) } function Ht(t) { if (null != oa) return oa; var e = n(t, i("span", "x")), r = e.getBoundingClientRect(), o = Ds(e, 0, 1).getBoundingClientRect(); return oa = Math.abs(r.left - o.left) > 1 } function Rt(t, e) { arguments.length > 2 && (e.dependencies = Array.prototype.slice.call(arguments, 2)), sa[t] = e } function Vt(t, e) { aa[t] = e } function jt(t) { if ("string" == typeof t && aa.hasOwnProperty(t)) t = aa[t]; else if (t && "string" == typeof t.name && aa.hasOwnProperty(t.name)) { var e = aa[t.name]; "string" == typeof e && (e = { name: e }), t = b(e, t), t.name = e.name } else { if ("string" == typeof t && /^[\w\-]+\/[\w\-]+\+xml$/.test(t)) return jt("application/xml"); if ("string" == typeof t && /^[\w\-]+\/[\w\-]+\+json$/.test(t)) return jt("application/json") } return "string" == typeof t ? { name: t } : t || { name: "null" } } function Bt(t, e) { e = jt(e); var n = sa[e.name]; if (!n) return Bt(t, "text/plain"); var i = n(t, e); if (la.hasOwnProperty(e.name)) { var r = la[e.name]; for (var o in r) r.hasOwnProperty(o) && (i.hasOwnProperty(o) && (i["_" + o] = i[o]), i[o] = r[o]) } if (i.name = e.name, e.helperType && (i.helperType = e.helperType), e.modeProps) for (var s in e.modeProps) i[s] = e.modeProps[s]; return i } function Wt(t, e) { u(e, la.hasOwnProperty(t) ? la[t] : la[t] = {}) } function Ut(t, e) { if (!0 === e) return e; if (t.copyState) return t.copyState(e); var n = {}; for (var i in e) { var r = e[i]; r instanceof Array && (r = r.concat([])), n[i] = r } return n } function qt(t, e) { for (var n; t.innerMode && (n = t.innerMode(e)) && n.mode != t;)e = n.state, t = n.mode; return n || { mode: t, state: e } } function Kt(t, e, n) { return !t.startState || t.startState(e, n) } function Gt(t, e, n, i) { var r = [t.state.modeGen], o = {}; ne(t, e.text, t.doc.mode, n, function (t, e) { return r.push(t, e) }, o, i); for (var s = n.state, a = 0; a < t.state.overlays.length; ++a)!function (i) { n.baseTokens = r; var a = t.state.overlays[i], l = 1, c = 0; n.state = !0, ne(t, e.text, a.mode, n, function (t, e) { for (var n = l; c < t;) { var i = r[l]; i > t && r.splice(l, 1, t, r[l + 1], i), l += 2, c = Math.min(t, i) } if (e) if (a.opaque) r.splice(n, l - n, t, "overlay " + e), l = n + 2; else for (; n < l; n += 2) { var o = r[n + 1]; r[n + 1] = (o ? o + " " : "") + "overlay " + e } }, o), n.state = s, n.baseTokens = null, n.baseTokenPos = 1 }(a); return { styles: r, classes: o.bgClass || o.textClass ? o : null } } function Yt(t, e, n) { if (!e.styles || e.styles[0] != t.state.modeGen) { var i = Xt(t, O(e)), r = e.text.length > t.options.maxHighlightLength && Ut(t.doc.mode, i.state), o = Gt(t, e, i); r && (i.state = r), e.stateAfter = i.save(!r), e.styles = o.styles, o.classes ? e.styleClasses = o.classes : e.styleClasses && (e.styleClasses = null), n === t.doc.highlightFrontier && (t.doc.modeFrontier = Math.max(t.doc.modeFrontier, ++t.doc.highlightFrontier)) } return e.styles } function Xt(t, e, n) { var i = t.doc, r = t.display; if (!i.mode.startState) return new ha(i, !0, e); var o = ie(t, e, n), s = o > i.first && E(i, o - 1).stateAfter, a = s ? ha.fromSaved(i, s, o) : new ha(i, Kt(i.mode), o); return i.iter(o, e, function (n) { Jt(t, n.text, a); var i = a.line; n.stateAfter = i == e - 1 || i % 5 == 0 || i >= r.viewFrom && i < r.viewTo ? a.save() : null, a.nextLine() }), n && (i.modeFrontier = a.line), a } function Jt(t, e, n, i) { var r = t.doc.mode, o = new ca(e, t.options.tabSize, n); for (o.start = o.pos = i || 0, "" == e && Zt(r, n.state); !o.eol();)Qt(r, o, n.state), o.start = o.pos } function Zt(t, e) { if (t.blankLine) return t.blankLine(e); if (t.innerMode) { var n = qt(t, e); return n.mode.blankLine ? n.mode.blankLine(n.state) : void 0 } } function Qt(t, e, n, i) { for (var r = 0; r < 10; r++) { i && (i[0] = qt(t, n).mode); var o = t.token(e, n); if (e.pos > e.start) return o } throw new Error("Mode " + t.name + " failed to advance stream.") } function te(t, e, n, i) { var r, o = t.doc, s = o.mode; e = j(o, e); var a, l = E(o, e.line), c = Xt(t, e.line, n), u = new ca(l.text, t.options.tabSize, c); for (i && (a = []); (i || u.pos < e.ch) && !u.eol();)u.start = u.pos, r = Qt(s, u, c.state), i && a.push(new da(u, r, Ut(o.mode, c.state))); return i ? a : new da(u, r, c.state) } function ee(t, e) { if (t) for (; ;) { var n = t.match(/(?:^|\s+)line-(background-)?(\S+)/); if (!n) break; t = t.slice(0, n.index) + t.slice(n.index + n[0].length); var i = n[1] ? "bgClass" : "textClass"; null == e[i] ? e[i] = n[2] : new RegExp("(?:^|s)" + n[2] + "(?:$|s)").test(e[i]) || (e[i] += " " + n[2]) } return t } function ne(t, e, n, i, r, o, s) { var a = n.flattenSpans; null == a && (a = t.options.flattenSpans); var l, c = 0, u = null, h = new ca(e, t.options.tabSize, i), d = t.options.addModeClass && [null]; for ("" == e && ee(Zt(n, i.state), o); !h.eol();) { if (h.pos > t.options.maxHighlightLength ? (a = !1, s && Jt(t, e, i, h.pos), h.pos = e.length, l = null) : l = ee(Qt(n, h, i.state, d), o), d) { var f = d[0].name; f && (l = "m-" + (l ? f + " " + l : f)) } if (!a || u != l) { for (; c < h.start;)c = Math.min(h.start, c + 5e3), r(c, u); u = l } h.start = h.pos } for (; c < h.pos;) { var p = Math.min(h.pos, c + 5e3); r(p, u), c = p } } function ie(t, e, n) { for (var i, r, o = t.doc, s = n ? -1 : e - (t.doc.mode.innerMode ? 1e3 : 100), a = e; a > s; --a) { if (a <= o.first) return o.first; var l = E(o, a - 1), c = l.stateAfter; if (c && (!n || a + (c instanceof ua ? c.lookAhead : 0) <= o.modeFrontier)) return a; var u = h(l.text, null, t.options.tabSize); (null == r || i > u) && (r = a - 1, i = u) } return r } function re(t, e) { if (t.modeFrontier = Math.min(t.modeFrontier, e), !(t.highlightFrontier < e - 10)) { for (var n = t.first, i = e - 1; i > n; i--) { var r = E(t, i).stateAfter; if (r && (!(r instanceof ua) || i + r.lookAhead < e)) { n = i + 1; break } } t.highlightFrontier = Math.min(t.highlightFrontier, n) } } function oe(t, e, n, i) { t.text = e, t.stateAfter && (t.stateAfter = null), t.styles && (t.styles = null), null != t.order && (t.order = null), nt(t), it(t, n); var r = i ? i(t) : 1; r != t.height && L(t, r) } function se(t) { t.parent = null, nt(t) } function ae(t, e) { if (!t || /^\s*$/.test(t)) return null; var n = e.addModeClass ? ma : ga; return n[t] || (n[t] = t.replace(/\S+/g, "cm-$&")) } function le(t, e) { var n = r("span", null, null, bs ? "padding-right: .1px" : null), i = { pre: r("pre", [n], "CodeMirror-line"), content: n, col: 0, pos: 0, cm: t, trailingSpace: !1, splitSpaces: (vs || bs) && t.getOption("lineWrapping") }; e.measure = {}; for (var o = 0; o <= (e.rest ? e.rest.length : 0); o++) { var s = o ? e.rest[o - 1] : e.line, a = void 0; i.pos = 0, i.addToken = ue, zt(t.display.measure) && (a = kt(s, t.doc.direction)) && (i.addToken = de(i.addToken, a)), i.map = []; pe(s, i, Yt(t, s, e != t.display.externalMeasured && O(s))), s.styleClasses && (s.styleClasses.bgClass && (i.bgClass = l(s.styleClasses.bgClass, i.bgClass || "")), s.styleClasses.textClass && (i.textClass = l(s.styleClasses.textClass, i.textClass || ""))), 0 == i.map.length && i.map.push(0, 0, i.content.appendChild($t(t.display.measure))), 0 == o ? (e.measure.map = i.map, e.measure.cache = {}) : ((e.measure.maps || (e.measure.maps = [])).push(i.map), (e.measure.caches || (e.measure.caches = [])).push({})) } if (bs) { var c = i.content.lastChild; (/\bcm-tab\b/.test(c.className) || c.querySelector && c.querySelector(".cm-tab")) && (i.content.className = "cm-tab-wrap-hack") } return Mt(t, "renderLine", t, e.line, i.pre), i.pre.className && (i.textClass = l(i.pre.className, i.textClass || "")), i } function ce(t) { var e = i("span", "", "cm-invalidchar"); return e.title = "\\u" + t.charCodeAt(0).toString(16), e.setAttribute("aria-label", e.title), e } function ue(t, e, n, r, o, s, a) { if (e) { var l, c = t.splitSpaces ? he(e, t.trailingSpace) : e, u = t.cm.state.specialChars, h = !1; if (u.test(e)) { l = document.createDocumentFragment(); for (var d = 0; ;) { u.lastIndex = d; var f = u.exec(e), g = f ? f.index - d : e.length - d; if (g) { var m = document.createTextNode(c.slice(d, d + g)); vs && ys < 9 ? l.appendChild(i("span", [m])) : l.appendChild(m), t.map.push(t.pos, t.pos + g, m), t.col += g, t.pos += g } if (!f) break; d += g + 1; var v = void 0; if ("\t" == f[0]) { var y = t.cm.options.tabSize, b = y - t.col % y; v = l.appendChild(i("span", p(b), "cm-tab")), v.setAttribute("role", "presentation"), v.setAttribute("cm-text", "\t"), t.col += b } else "\r" == f[0] || "\n" == f[0] ? (v = l.appendChild(i("span", "\r" == f[0] ? "" : "", "cm-invalidchar")), v.setAttribute("cm-text", f[0]), t.col += 1) : (v = t.cm.options.specialCharPlaceholder(f[0]), v.setAttribute("cm-text", f[0]), vs && ys < 9 ? l.appendChild(i("span", [v])) : l.appendChild(v), t.col += 1); t.map.push(t.pos, t.pos + 1, v), t.pos++ } } else t.col += e.length, l = document.createTextNode(c), t.map.push(t.pos, t.pos + e.length, l), vs && ys < 9 && (h = !0), t.pos += e.length; if (t.trailingSpace = 32 == c.charCodeAt(e.length - 1), n || r || o || h || a) { var x = n || ""; r && (x += r), o && (x += o); var w = i("span", [l], x, a); return s && (w.title = s), t.content.appendChild(w) } t.content.appendChild(l) } } function he(t, e) { if (t.length > 1 && !/  /.test(t)) return t; for (var n = e, i = "", r = 0; r < t.length; r++) { var o = t.charAt(r); " " != o || !n || r != t.length - 1 && 32 != t.charCodeAt(r + 1) || (o = " "), i += o, n = " " == o } return i } function de(t, e) { return function (n, i, r, o, s, a, l) { r = r ? r + " cm-force-border" : "cm-force-border"; for (var c = n.pos, u = c + i.length; ;) { for (var h = void 0, d = 0; d < e.length && (h = e[d], !(h.to > c && h.from <= c)); d++); if (h.to >= u) return t(n, i, r, o, s, a, l); t(n, i.slice(0, h.to - c), r, o, null, a, l), o = null, i = i.slice(h.to - c), c = h.to } } } function fe(t, e, n, i) { var r = !i && n.widgetNode; r && t.map.push(t.pos, t.pos + e, r), !i && t.cm.display.input.needsContentAttribute && (r || (r = t.content.appendChild(document.createElement("span"))), r.setAttribute("cm-marker", n.id)), r && (t.cm.display.input.setUneditable(r), t.content.appendChild(r)), t.pos += e, t.trailingSpace = !1 } function pe(t, e, n) { var i = t.markedSpans, r = t.text, o = 0; if (i) for (var s, a, l, c, u, h, d, f = r.length, p = 0, g = 1, m = "", v = 0; ;) { if (v == p) { l = c = u = h = a = "", d = null, v = 1 / 0; for (var y = [], b = void 0, x = 0; x < i.length; ++x) { var w = i[x], C = w.marker; "bookmark" == C.type && w.from == p && C.widgetNode ? y.push(C) : w.from <= p && (null == w.to || w.to > p || C.collapsed && w.to == p && w.from == p) ? (null != w.to && w.to != p && v > w.to && (v = w.to, c = ""), C.className && (l += " " + C.className), C.css && (a = (a ? a + ";" : "") + C.css), C.startStyle && w.from == p && (u += " " + C.startStyle), C.endStyle && w.to == v && (b || (b = [])).push(C.endStyle, w.to), C.title && !h && (h = C.title), C.collapsed && (!d || st(d.marker, C) < 0) && (d = w)) : w.from > p && v > w.from && (v = w.from) } if (b) for (var k = 0; k < b.length; k += 2)b[k + 1] == v && (c += " " + b[k]); if (!d || d.from == p) for (var S = 0; S < y.length; ++S)fe(e, 0, y[S]); if (d && (d.from || 0) == p) { if (fe(e, (null == d.to ? f + 1 : d.to) - p, d.marker, null == d.from), null == d.to) return; d.to == p && (d = !1) } } if (p >= f) break; for (var T = Math.min(f, v); ;) { if (m) { var M = p + m.length; if (!d) { var E = M > T ? m.slice(0, T - p) : m; e.addToken(e, E, s ? s + l : l, u, p + E.length == v ? c : "", h, a) } if (M >= T) { m = m.slice(T - p), p = T; break } p = M, u = "" } m = r.slice(o, o = n[g++]), s = ae(n[g++], e.cm.options) } } else for (var P = 1; P < n.length; P += 2)e.addToken(e, r.slice(o, o = n[P]), ae(n[P + 1], e.cm.options)) } function ge(t, e, n) { this.line = e, this.rest = ft(e), this.size = this.rest ? O(g(this.rest)) - n + 1 : 1, this.node = this.text = null, this.hidden = mt(t, e) } function me(t, e, n) { for (var i, r = [], o = e; o < n; o = i) { var s = new ge(t.doc, E(t.doc, o), o); i = o + s.size, r.push(s) } return r } function ve(t) { va ? va.ops.push(t) : t.ownsGroup = va = { ops: [t], delayedCallbacks: [] } } function ye(t) { var e = t.delayedCallbacks, n = 0; do { for (; n < e.length; n++)e[n].call(null); for (var i = 0; i < t.ops.length; i++) { var r = t.ops[i]; if (r.cursorActivityHandlers) for (; r.cursorActivityCalled < r.cursorActivityHandlers.length;)r.cursorActivityHandlers[r.cursorActivityCalled++].call(null, r.cm) } } while (n < e.length) } function be(t, e) { var n = t.ownsGroup; if (n) try { ye(n) } finally { va = null, e(n) } } function xe(t, e) { var n = St(t, e); if (n.length) { var i, r = Array.prototype.slice.call(arguments, 2); va ? i = va.delayedCallbacks : ya ? i = ya : (i = ya = [], setTimeout(we, 0)); for (var o = 0; o < n.length; ++o)!function (t) { i.push(function () { return n[t].apply(null, r) }) }(o) } } function we() { var t = ya; ya = null; for (var e = 0; e < t.length; ++e)t[e]() } function Ce(t, e, n, i) { for (var r = 0; r < e.changes.length; r++) { var o = e.changes[r]; "text" == o ? Me(t, e) : "gutter" == o ? Pe(t, e, n, i) : "class" == o ? Ee(t, e) : "widget" == o && Ae(t, e, i) } e.changes = null } function ke(t) { return t.node == t.text && (t.node = i("div", null, null, "position: relative"), t.text.parentNode && t.text.parentNode.replaceChild(t.node, t.text), t.node.appendChild(t.text), vs && ys < 8 && (t.node.style.zIndex = 2)), t.node } function Se(t, e) { var n = e.bgClass ? e.bgClass + " " + (e.line.bgClass || "") : e.line.bgClass; if (n && (n += " CodeMirror-linebackground"), e.background) n ? e.background.className = n : (e.background.parentNode.removeChild(e.background), e.background = null); else if (n) { var r = ke(e); e.background = r.insertBefore(i("div", null, n), r.firstChild), t.display.input.setUneditable(e.background) } } function Te(t, e) { var n = t.display.externalMeasured; return n && n.line == e.line ? (t.display.externalMeasured = null, e.measure = n.measure, n.built) : le(t, e) } function Me(t, e) { var n = e.text.className, i = Te(t, e); e.text == e.node && (e.node = i.pre), e.text.parentNode.replaceChild(i.pre, e.text), e.text = i.pre, i.bgClass != e.bgClass || i.textClass != e.textClass ? (e.bgClass = i.bgClass, e.textClass = i.textClass, Ee(t, e)) : n && (e.text.className = n) } function Ee(t, e) { Se(t, e), e.line.wrapClass ? ke(e).className = e.line.wrapClass : e.node != e.text && (e.node.className = ""); var n = e.textClass ? e.textClass + " " + (e.line.textClass || "") : e.line.textClass; e.text.className = n || "" } function Pe(t, e, n, r) { if (e.gutter && (e.node.removeChild(e.gutter), e.gutter = null), e.gutterBackground && (e.node.removeChild(e.gutterBackground), e.gutterBackground = null), e.line.gutterClass) { var o = ke(e); e.gutterBackground = i("div", null, "CodeMirror-gutter-background " + e.line.gutterClass, "left: " + (t.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + "px; width: " + r.gutterTotalWidth + "px"), t.display.input.setUneditable(e.gutterBackground), o.insertBefore(e.gutterBackground, e.text) } var s = e.line.gutterMarkers; if (t.options.lineNumbers || s) { var a = ke(e), l = e.gutter = i("div", null, "CodeMirror-gutter-wrapper", "left: " + (t.options.fixedGutter ? r.fixedPos : -r.gutterTotalWidth) + "px"); if (t.display.input.setUneditable(l), a.insertBefore(l, e.text), e.line.gutterClass && (l.className += " " + e.line.gutterClass), !t.options.lineNumbers || s && s["CodeMirror-linenumbers"] || (e.lineNumber = l.appendChild(i("div", I(t.options, n), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + r.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + t.display.lineNumInnerWidth + "px"))), s) for (var c = 0; c < t.options.gutters.length; ++c) { var u = t.options.gutters[c], h = s.hasOwnProperty(u) && s[u]; h && l.appendChild(i("div", [h], "CodeMirror-gutter-elt", "left: " + r.gutterLeft[u] + "px; width: " + r.gutterWidth[u] + "px")) } } } function Ae(t, e, n) { e.alignable && (e.alignable = null); for (var i = e.node.firstChild, r = void 0; i; i = r)r = i.nextSibling, "CodeMirror-linewidget" == i.className && e.node.removeChild(i); Oe(t, e, n) } function Le(t, e, n, i) { var r = Te(t, e); return e.text = e.node = r.pre, r.bgClass && (e.bgClass = r.bgClass), r.textClass && (e.textClass = r.textClass), Ee(t, e), Pe(t, e, n, i), Oe(t, e, i), e.node } function Oe(t, e, n) { if (Ne(t, e.line, e, n, !0), e.rest) for (var i = 0; i < e.rest.length; i++)Ne(t, e.rest[i], e, n, !1) } function Ne(t, e, n, r, o) { if (e.widgets) for (var s = ke(n), a = 0, l = e.widgets; a < l.length; ++a) { var c = l[a], u = i("div", [c.node], "CodeMirror-linewidget"); c.handleMouseEvents || u.setAttribute("cm-ignore-events", "true"), De(c, u, n, r), t.display.input.setUneditable(u), o && c.above ? s.insertBefore(u, n.gutter || n.text) : s.appendChild(u), xe(c, "redraw") } } function De(t, e, n, i) { if (t.noHScroll) { (n.alignable || (n.alignable = [])).push(e); var r = i.wrapperWidth; e.style.left = i.fixedPos + "px", t.coverGutter || (r -= i.gutterTotalWidth, e.style.paddingLeft = i.gutterTotalWidth + "px"), e.style.width = r + "px" } t.coverGutter && (e.style.zIndex = 5, e.style.position = "relative", t.noHScroll || (e.style.marginLeft = -i.gutterTotalWidth + "px")) } function Ie(t) { if (null != t.height) return t.height; var e = t.doc.cm; if (!e) return 0; if (!o(document.body, t.node)) { var r = "position: relative;"; t.coverGutter && (r += "margin-left: -" + e.display.gutters.offsetWidth + "px;"), t.noHScroll && (r += "width: " + e.display.wrapper.clientWidth + "px;"), n(e.display.measure, i("div", [t.node], null, r)) } return t.height = t.node.parentNode.offsetHeight } function _e(t, e) { for (var n = _t(e); n != t.wrapper; n = n.parentNode)if (!n || 1 == n.nodeType && "true" == n.getAttribute("cm-ignore-events") || n.parentNode == t.sizer && n != t.mover) return !0 } function Fe(t) { return t.lineSpace.offsetTop } function $e(t) { return t.mover.offsetHeight - t.lineSpace.offsetHeight } function ze(t) { if (t.cachedPaddingH) return t.cachedPaddingH; var e = n(t.measure, i("pre", "x")), r = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle, o = { left: parseInt(r.paddingLeft), right: parseInt(r.paddingRight) }; return isNaN(o.left) || isNaN(o.right) || (t.cachedPaddingH = o), o } function He(t) { return Vs - t.display.nativeBarWidth } function Re(t) { return t.display.scroller.clientWidth - He(t) - t.display.barWidth } function Ve(t) { return t.display.scroller.clientHeight - He(t) - t.display.barHeight } function je(t, e, n) { var i = t.options.lineWrapping, r = i && Re(t); if (!e.measure.heights || i && e.measure.width != r) { var o = e.measure.heights = []; if (i) { e.measure.width = r; for (var s = e.text.firstChild.getClientRects(), a = 0; a < s.length - 1; a++) { var l = s[a], c = s[a + 1]; Math.abs(l.bottom - c.bottom) > 2 && o.push((l.bottom + c.top) / 2 - n.top) } } o.push(n.bottom - n.top) } } function Be(t, e, n) { if (t.line == e) return { map: t.measure.map, cache: t.measure.cache }; for (var i = 0; i < t.rest.length; i++)if (t.rest[i] == e) return { map: t.measure.maps[i], cache: t.measure.caches[i] }; for (var r = 0; r < t.rest.length; r++)if (O(t.rest[r]) > n) return { map: t.measure.maps[r], cache: t.measure.caches[r], before: !0 } } function We(t, e) { e = ht(e); var i = O(e), r = t.display.externalMeasured = new ge(t.doc, e, i); r.lineN = i; var o = r.built = le(t, r); return r.text = o.pre, n(t.display.lineMeasure, o.pre), r } function Ue(t, e, n, i) { return Ge(t, Ke(t, e), n, i) } function qe(t, e) { if (e >= t.display.viewFrom && e < t.display.viewTo) return t.display.view[Mn(t, e)]; var n = t.display.externalMeasured; return n && e >= n.lineN && e < n.lineN + n.size ? n : void 0 } function Ke(t, e) { var n = O(e), i = qe(t, n); i && !i.text ? i = null : i && i.changes && (Ce(t, i, n, wn(t)), t.curOp.forceUpdate = !0), i || (i = We(t, e)); var r = Be(i, e, n); return { line: e, view: i, rect: null, map: r.map, cache: r.cache, before: r.before, hasHeights: !1 } } function Ge(t, e, n, i, r) { e.before && (n = -1); var o, s = n + (i || ""); return e.cache.hasOwnProperty(s) ? o = e.cache[s] : (e.rect || (e.rect = e.view.text.getBoundingClientRect()), e.hasHeights || (je(t, e.view, e.rect), e.hasHeights = !0), o = Je(t, e, n, i), o.bogus || (e.cache[s] = o)), { left: o.left, right: o.right, top: r ? o.rtop : o.top, bottom: r ? o.rbottom : o.bottom } } function Ye(t, e, n) { for (var i, r, o, s, a, l, c = 0; c < t.length; c += 3)if (a = t[c], l = t[c + 1], e < a ? (r = 0, o = 1, s = "left") : e < l ? (r = e - a, o = r + 1) : (c == t.length - 3 || e == l && t[c + 3] > e) && (o = l - a, r = o - 1, e >= l && (s = "right")), null != r) { if (i = t[c + 2], a == l && n == (i.insertLeft ? "left" : "right") && (s = n), "left" == n && 0 == r) for (; c && t[c - 2] == t[c - 3] && t[c - 1].insertLeft;)i = t[2 + (c -= 3)], s = "left"; if ("right" == n && r == l - a) for (; c < t.length - 3 && t[c + 3] == t[c + 4] && !t[c + 5].insertLeft;)i = t[(c += 3) + 2], s = "right"; break } return { node: i, start: r, end: o, collapse: s, coverStart: a, coverEnd: l } } function Xe(t, e) { var n = ba; if ("left" == e) for (var i = 0; i < t.length && (n = t[i]).left == n.right; i++); else for (var r = t.length - 1; r >= 0 && (n = t[r]).left == n.right; r--); return n } function Je(t, e, n, i) { var r, o = Ye(e.map, n, i), s = o.node, a = o.start, l = o.end, c = o.collapse; if (3 == s.nodeType) { for (var u = 0; u < 4; u++) { for (; a && k(e.line.text.charAt(o.coverStart + a));)--a; for (; o.coverStart + l < o.coverEnd && k(e.line.text.charAt(o.coverStart + l));)++l; if (r = vs && ys < 9 && 0 == a && l == o.coverEnd - o.coverStart ? s.parentNode.getBoundingClientRect() : Xe(Ds(s, a, l).getClientRects(), i), r.left || r.right || 0 == a) break; l = a, a -= 1, c = "right" } vs && ys < 11 && (r = Ze(t.display.measure, r)) } else { a > 0 && (c = i = "right"); var h; r = t.options.lineWrapping && (h = s.getClientRects()).length > 1 ? h["right" == i ? h.length - 1 : 0] : s.getBoundingClientRect() } if (vs && ys < 9 && !a && (!r || !r.left && !r.right)) { var d = s.parentNode.getClientRects()[0]; r = d ? { left: d.left, right: d.left + xn(t.display), top: d.top, bottom: d.bottom } : ba } for (var f = r.top - e.rect.top, p = r.bottom - e.rect.top, g = (f + p) / 2, m = e.view.measure.heights, v = 0; v < m.length - 1 && !(g < m[v]); v++); var y = v ? m[v - 1] : 0, b = m[v], x = { left: ("right" == c ? r.right : r.left) - e.rect.left, right: ("left" == c ? r.left : r.right) - e.rect.left, top: y, bottom: b }; return r.left || r.right || (x.bogus = !0), t.options.singleCursorHeightPerLine || (x.rtop = f, x.rbottom = p), x } function Ze(t, e) { if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || !Ht(t)) return e; var n = screen.logicalXDPI / screen.deviceXDPI, i = screen.logicalYDPI / screen.deviceYDPI; return { left: e.left * n, right: e.right * n, top: e.top * i, bottom: e.bottom * i } } function Qe(t) { if (t.measure && (t.measure.cache = {}, t.measure.heights = null, t.rest)) for (var e = 0; e < t.rest.length; e++)t.measure.caches[e] = {} } function tn(t) { t.display.externalMeasure = null, e(t.display.lineMeasure); for (var n = 0; n < t.display.view.length; n++)Qe(t.display.view[n]) } function en(t) { tn(t), t.display.cachedCharWidth = t.display.cachedTextHeight = t.display.cachedPaddingH = null, t.options.lineWrapping || (t.display.maxLineChanged = !0), t.display.lineNumChars = null } function nn() { return ws && Es ? -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) : window.pageXOffset || (document.documentElement || document.body).scrollLeft } function rn() { return ws && Es ? -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) : window.pageYOffset || (document.documentElement || document.body).scrollTop } function on(t) { var e = 0; if (t.widgets) for (var n = 0; n < t.widgets.length; ++n)t.widgets[n].above && (e += Ie(t.widgets[n])); return e } function sn(t, e, n, i, r) { if (!r) { var o = on(e); n.top += o, n.bottom += o } if ("line" == i) return n; i || (i = "local"); var s = yt(e); if ("local" == i ? s += Fe(t.display) : s -= t.display.viewOffset, "page" == i || "window" == i) { var a = t.display.lineSpace.getBoundingClientRect(); s += a.top + ("window" == i ? 0 : rn()); var l = a.left + ("window" == i ? 0 : nn()); n.left += l, n.right += l } return n.top += s, n.bottom += s, n } function an(t, e, n) { if ("div" == n) return e; var i = e.left, r = e.top; if ("page" == n) i -= nn(), r -= rn(); else if ("local" == n || !n) { var o = t.display.sizer.getBoundingClientRect(); i += o.left, r += o.top } var s = t.display.lineSpace.getBoundingClientRect(); return { left: i - s.left, top: r - s.top } } function ln(t, e, n, i, r) { return i || (i = E(t.doc, e.line)), sn(t, i, Ue(t, i, e.ch, r), n) } function cn(t, e, n, i, r, o) { function s(e, s) { var a = Ge(t, r, e, s ? "right" : "left", o); return s ? a.left = a.right : a.right = a.left, sn(t, i, a, n) } function a(t, e, n) { var i = l[e], r = 1 == i.level; return s(n ? t - 1 : t, r != n) } i = i || E(t.doc, e.line), r || (r = Ke(t, i)); var l = kt(i, t.doc.direction), c = e.ch, u = e.sticky; if (c >= i.text.length ? (c = i.text.length, u = "before") : c <= 0 && (c = 0, u = "after"), !l) return s("before" == u ? c - 1 : c, "before" == u); var h = Ct(l, c, u), d = Js, f = a(c, h, "before" == u); return null != d && (f.other = a(c, d, "before" != u)), f } function un(t, e) { var n = 0; e = j(t.doc, e), t.options.lineWrapping || (n = xn(t.display) * e.ch); var i = E(t.doc, e.line), r = yt(i) + Fe(t.display); return { left: n, right: n, top: r, bottom: r + i.height } } function hn(t, e, n, i, r) { var o = _(t, e, n); return o.xRel = r, i && (o.outside = !0), o } function dn(t, e, n) { var i = t.doc; if ((n += t.display.viewOffset) < 0) return hn(i.first, 0, null, !0, -1); var r = N(i, n), o = i.first + i.size - 1; if (r > o) return hn(i.first + i.size - 1, E(i, o).text.length, null, !0, 1); e < 0 && (e = 0); for (var s = E(i, r); ;) { var a = mn(t, s, r, e, n), l = ct(s), c = l && l.find(0, !0); if (!l || !(a.ch > c.from.ch || a.ch == c.from.ch && a.xRel > 0)) return a; r = O(s = c.to.line) } } function fn(t, e, n, i) { i -= on(e); var r = e.text.length, o = T(function (e) { return Ge(t, n, e - 1).bottom <= i }, r, 0); return r = T(function (e) { return Ge(t, n, e).top > i }, o, r), { begin: o, end: r } } function pn(t, e, n, i) { return n || (n = Ke(t, e)), fn(t, e, n, sn(t, e, Ge(t, n, i), "line").top) } function gn(t, e, n, i) { return !(t.bottom <= n) && (t.top > n || (i ? t.left : t.right) > e) } function mn(t, e, n, i, r) { r -= yt(e); var o = Ke(t, e), s = on(e), a = 0, l = e.text.length, c = !0, u = kt(e, t.doc.direction); if (u) { var h = (t.options.lineWrapping ? yn : vn)(t, e, n, o, u, i, r); c = 1 != h.level, a = c ? h.from : h.to - 1, l = c ? h.to : h.from - 1 } var d, f, p = null, g = null, m = T(function (e) { var n = Ge(t, o, e); return n.top += s, n.bottom += s, !!gn(n, i, r, !1) && (n.top <= r && n.left <= i && (p = e, g = n), !0) }, a, l), v = !1; if (g) { var y = i - g.left < g.right - i, b = y == c; m = p + (b ? 0 : 1), f = b ? "after" : "before", d = y ? g.left : g.right } else { c || m != l && m != a || m++ , f = 0 == m ? "after" : m == e.text.length ? "before" : Ge(t, o, m - (c ? 1 : 0)).bottom + s <= r == c ? "after" : "before"; var x = cn(t, _(n, m, f), "line", e, o); d = x.left, v = r < x.top || r >= x.bottom } return m = S(e.text, m, 1), hn(n, m, f, v, i - d) } function vn(t, e, n, i, r, o, s) { var a = T(function (a) { var l = r[a], c = 1 != l.level; return gn(cn(t, _(n, c ? l.to : l.from, c ? "before" : "after"), "line", e, i), o, s, !0) }, 0, r.length - 1), l = r[a]; if (a > 0) { var c = 1 != l.level, u = cn(t, _(n, c ? l.from : l.to, c ? "after" : "before"), "line", e, i); gn(u, o, s, !0) && u.top > s && (l = r[a - 1]) } return l } function yn(t, e, n, i, r, o, s) { var a = fn(t, e, i, s), l = a.begin, c = a.end; /\s/.test(e.text.charAt(c - 1)) && c--; for (var u = null, h = null, d = 0; d < r.length; d++) { var f = r[d]; if (!(f.from >= c || f.to <= l)) { var p = 1 != f.level, g = Ge(t, i, p ? Math.min(c, f.to) - 1 : Math.max(l, f.from)).right, m = g < o ? o - g + 1e9 : g - o; (!u || h > m) && (u = f, h = m) } } return u || (u = r[r.length - 1]), u.from < l && (u = { from: l, to: u.to, level: u.level }), u.to > c && (u = { from: u.from, to: c, level: u.level }), u } function bn(t) { if (null != t.cachedTextHeight) return t.cachedTextHeight; if (null == pa) { pa = i("pre"); for (var r = 0; r < 49; ++r)pa.appendChild(document.createTextNode("x")), pa.appendChild(i("br")); pa.appendChild(document.createTextNode("x")) } n(t.measure, pa); var o = pa.offsetHeight / 50; return o > 3 && (t.cachedTextHeight = o), e(t.measure), o || 1 } function xn(t) { if (null != t.cachedCharWidth) return t.cachedCharWidth; var e = i("span", "xxxxxxxxxx"), r = i("pre", [e]); n(t.measure, r); var o = e.getBoundingClientRect(), s = (o.right - o.left) / 10; return s > 2 && (t.cachedCharWidth = s), s || 10 } function wn(t) { for (var e = t.display, n = {}, i = {}, r = e.gutters.clientLeft, o = e.gutters.firstChild, s = 0; o; o = o.nextSibling, ++s)n[t.options.gutters[s]] = o.offsetLeft + o.clientLeft + r, i[t.options.gutters[s]] = o.clientWidth; return { fixedPos: Cn(e), gutterTotalWidth: e.gutters.offsetWidth, gutterLeft: n, gutterWidth: i, wrapperWidth: e.wrapper.clientWidth } } function Cn(t) { return t.scroller.getBoundingClientRect().left - t.sizer.getBoundingClientRect().left } function kn(t) { var e = bn(t.display), n = t.options.lineWrapping, i = n && Math.max(5, t.display.scroller.clientWidth / xn(t.display) - 3); return function (r) { if (mt(t.doc, r)) return 0; var o = 0; if (r.widgets) for (var s = 0; s < r.widgets.length; s++)r.widgets[s].height && (o += r.widgets[s].height); return n ? o + (Math.ceil(r.text.length / i) || 1) * e : o + e } } function Sn(t) { var e = t.doc, n = kn(t); e.iter(function (t) { var e = n(t); e != t.height && L(t, e) }) } function Tn(t, e, n, i) { var r = t.display; if (!n && "true" == _t(e).getAttribute("cm-not-content")) return null; var o, s, a = r.lineSpace.getBoundingClientRect(); try { o = e.clientX - a.left, s = e.clientY - a.top } catch (e) { return null } var l, c = dn(t, o, s); if (i && 1 == c.xRel && (l = E(t.doc, c.line).text).length == c.ch) { var u = h(l, l.length, t.options.tabSize) - l.length; c = _(c.line, Math.max(0, Math.round((o - ze(t.display).left) / xn(t.display)) - u)) } return c } function Mn(t, e) { if (e >= t.display.viewTo) return null; if ((e -= t.display.viewFrom) < 0) return null; for (var n = t.display.view, i = 0; i < n.length; i++)if ((e -= n[i].size) < 0) return i } function En(t) { t.display.input.showSelection(t.display.input.prepareSelection()) } function Pn(t, e) { void 0 === e && (e = !0); for (var n = t.doc, i = {}, r = i.cursors = document.createDocumentFragment(), o = i.selection = document.createDocumentFragment(), s = 0; s < n.sel.ranges.length; s++)if (e || s != n.sel.primIndex) { var a = n.sel.ranges[s]; if (!(a.from().line >= t.display.viewTo || a.to().line < t.display.viewFrom)) { var l = a.empty(); (l || t.options.showCursorWhenSelecting) && An(t, a.head, r), l || On(t, a, o) } } return i } function An(t, e, n) { var r = cn(t, e, "div", null, null, !t.options.singleCursorHeightPerLine), o = n.appendChild(i("div", " ", "CodeMirror-cursor")); if (o.style.left = r.left + "px", o.style.top = r.top + "px", o.style.height = Math.max(0, r.bottom - r.top) * t.options.cursorHeight + "px", r.other) { var s = n.appendChild(i("div", " ", "CodeMirror-cursor CodeMirror-secondarycursor")); s.style.display = "", s.style.left = r.other.left + "px", s.style.top = r.other.top + "px", s.style.height = .85 * (r.other.bottom - r.other.top) + "px" } } function Ln(t, e) { return t.top - e.top || t.left - e.left } function On(t, e, n) { function r(t, e, n, r) { e < 0 && (e = 0), e = Math.round(e), r = Math.round(r), l.appendChild(i("div", null, "CodeMirror-selected", "position: absolute; left: " + t + "px;\n                             top: " + e + "px; width: " + (null == n ? h - t : n) + "px;\n                             height: " + (r - e) + "px")) } function o(e, n, i) { function o(n, i) { return ln(t, _(e, n), "div", f, i) } function s(e, n, i) { var r = pn(t, f, null, e), s = "ltr" == n == ("after" == i) ? "left" : "right"; return o("after" == i ? r.begin : r.end - (/\s/.test(f.text.charAt(r.end - 1)) ? 2 : 1), s)[s] } var l, c, f = E(a, e), p = f.text.length, g = kt(f, a.direction); return wt(g, n || 0, null == i ? p : i, function (t, e, a, f) { var m = "ltr" == a, v = o(t, m ? "left" : "right"), y = o(e - 1, m ? "right" : "left"), b = null == n && 0 == t, x = null == i && e == p, w = 0 == f, C = !g || f == g.length - 1; if (y.top - v.top <= 3) { var k = (d ? b : x) && w, S = (d ? x : b) && C, T = k ? u : (m ? v : y).left, M = S ? h : (m ? y : v).right; r(T, v.top, M - T, v.bottom) } else { var E, P, A, L; m ? (E = d && b && w ? u : v.left, P = d ? h : s(t, a, "before"), A = d ? u : s(e, a, "after"), L = d && x && C ? h : y.right) : (E = d ? s(t, a, "before") : u, P = !d && b && w ? h : v.right, A = !d && x && C ? u : y.left, L = d ? s(e, a, "after") : h), r(E, v.top, P - E, v.bottom), v.bottom < y.top && r(u, v.bottom, null, y.top), r(A, y.top, L - A, y.bottom) } (!l || Ln(v, l) < 0) && (l = v), Ln(y, l) < 0 && (l = y), (!c || Ln(v, c) < 0) && (c = v), Ln(y, c) < 0 && (c = y) }), { start: l, end: c } } var s = t.display, a = t.doc, l = document.createDocumentFragment(), c = ze(t.display), u = c.left, h = Math.max(s.sizerWidth, Re(t) - s.sizer.offsetLeft) - c.right, d = "ltr" == a.direction, f = e.from(), p = e.to(); if (f.line == p.line) o(f.line, f.ch, p.ch); else { var g = E(a, f.line), m = E(a, p.line), v = ht(g) == ht(m), y = o(f.line, f.ch, v ? g.text.length + 1 : null).end, b = o(p.line, v ? 0 : null, p.ch).start; v && (y.top < b.top - 2 ? (r(y.right, y.top, null, y.bottom), r(u, b.top, b.left, b.bottom)) : r(y.right, y.top, b.left - y.right, y.bottom)), y.bottom < b.top && r(u, y.bottom, null, b.top) } n.appendChild(l) } function Nn(t) { if (t.state.focused) { var e = t.display; clearInterval(e.blinker); var n = !0; e.cursorDiv.style.visibility = "", t.options.cursorBlinkRate > 0 ? e.blinker = setInterval(function () { return e.cursorDiv.style.visibility = (n = !n) ? "" : "hidden" }, t.options.cursorBlinkRate) : t.options.cursorBlinkRate < 0 && (e.cursorDiv.style.visibility = "hidden") } } function Dn(t) { t.state.focused || (t.display.input.focus(), _n(t)) } function In(t) { t.state.delayingBlurEvent = !0, setTimeout(function () { t.state.delayingBlurEvent && (t.state.delayingBlurEvent = !1, Fn(t)) }, 100) } function _n(t, e) { t.state.delayingBlurEvent && (t.state.delayingBlurEvent = !1), "nocursor" != t.options.readOnly && (t.state.focused || (Mt(t, "focus", t, e), t.state.focused = !0, a(t.display.wrapper, "CodeMirror-focused"), t.curOp || t.display.selForContextMenu == t.doc.sel || (t.display.input.reset(), bs && setTimeout(function () { return t.display.input.reset(!0) }, 20)), t.display.input.receivedFocus()), Nn(t)) } function Fn(t, e) { t.state.delayingBlurEvent || (t.state.focused && (Mt(t, "blur", t, e), t.state.focused = !1, Fs(t.display.wrapper, "CodeMirror-focused")), clearInterval(t.display.blinker), setTimeout(function () { t.state.focused || (t.display.shift = !1) }, 150)) } function $n(t) { for (var e = t.display, n = e.lineDiv.offsetTop, i = 0; i < e.view.length; i++) { var r = e.view[i], o = void 0; if (!r.hidden) { if (vs && ys < 8) { var s = r.node.offsetTop + r.node.offsetHeight; o = s - n, n = s } else { var a = r.node.getBoundingClientRect(); o = a.bottom - a.top } var l = r.line.height - o; if (o < 2 && (o = bn(e)), (l > .005 || l < -.005) && (L(r.line, o), zn(r.line), r.rest)) for (var c = 0; c < r.rest.length; c++)zn(r.rest[c]) } } } function zn(t) { if (t.widgets) for (var e = 0; e < t.widgets.length; ++e)t.widgets[e].height = t.widgets[e].node.parentNode.offsetHeight } function Hn(t, e, n) { var i = n && null != n.top ? Math.max(0, n.top) : t.scroller.scrollTop; i = Math.floor(i - Fe(t)); var r = n && null != n.bottom ? n.bottom : i + t.wrapper.clientHeight, o = N(e, i), s = N(e, r); if (n && n.ensure) { var a = n.ensure.from.line, l = n.ensure.to.line; a < o ? (o = a, s = N(e, yt(E(e, a)) + t.wrapper.clientHeight)) : Math.min(l, e.lastLine()) >= s && (o = N(e, yt(E(e, l)) - t.wrapper.clientHeight), s = l) } return { from: o, to: Math.max(s, o + 1) } } function Rn(t) { var e = t.display, n = e.view; if (e.alignWidgets || e.gutters.firstChild && t.options.fixedGutter) { for (var i = Cn(e) - e.scroller.scrollLeft + t.doc.scrollLeft, r = e.gutters.offsetWidth, o = i + "px", s = 0; s < n.length; s++)if (!n[s].hidden) { t.options.fixedGutter && (n[s].gutter && (n[s].gutter.style.left = o), n[s].gutterBackground && (n[s].gutterBackground.style.left = o)); var a = n[s].alignable; if (a) for (var l = 0; l < a.length; l++)a[l].style.left = o } t.options.fixedGutter && (e.gutters.style.left = i + r + "px") } } function Vn(t) { if (!t.options.lineNumbers) return !1; var e = t.doc, n = I(t.options, e.first + e.size - 1), r = t.display; if (n.length != r.lineNumChars) { var o = r.measure.appendChild(i("div", [i("div", n)], "CodeMirror-linenumber CodeMirror-gutter-elt")), s = o.firstChild.offsetWidth, a = o.offsetWidth - s; return r.lineGutter.style.width = "", r.lineNumInnerWidth = Math.max(s, r.lineGutter.offsetWidth - a) + 1, r.lineNumWidth = r.lineNumInnerWidth + a, r.lineNumChars = r.lineNumInnerWidth ? n.length : -1, r.lineGutter.style.width = r.lineNumWidth + "px", Ni(t), !0 } return !1 } function jn(t, e) { if (!Et(t, "scrollCursorIntoView")) { var n = t.display, r = n.sizer.getBoundingClientRect(), o = null; if (e.top + r.top < 0 ? o = !0 : e.bottom + r.top > (window.innerHeight || document.documentElement.clientHeight) && (o = !1), null != o && !Ts) { var s = i("div", "", null, "position: absolute;\n                         top: " + (e.top - n.viewOffset - Fe(t.display)) + "px;\n                         height: " + (e.bottom - e.top + He(t) + n.barHeight) + "px;\n                         left: " + e.left + "px; width: " + Math.max(2, e.right - e.left) + "px;"); t.display.lineSpace.appendChild(s), s.scrollIntoView(o), t.display.lineSpace.removeChild(s) } } } function Bn(t, e, n, i) { null == i && (i = 0); var r; t.options.lineWrapping || e != n || (e = e.ch ? _(e.line, "before" == e.sticky ? e.ch - 1 : e.ch, "after") : e, n = "before" == e.sticky ? _(e.line, e.ch + 1, "before") : e); for (var o = 0; o < 5; o++) { var s = !1, a = cn(t, e), l = n && n != e ? cn(t, n) : a; r = { left: Math.min(a.left, l.left), top: Math.min(a.top, l.top) - i, right: Math.max(a.left, l.left), bottom: Math.max(a.bottom, l.bottom) + i }; var c = Un(t, r), u = t.doc.scrollTop, h = t.doc.scrollLeft; if (null != c.scrollTop && (Zn(t, c.scrollTop), Math.abs(t.doc.scrollTop - u) > 1 && (s = !0)), null != c.scrollLeft && (ti(t, c.scrollLeft), Math.abs(t.doc.scrollLeft - h) > 1 && (s = !0)), !s) break } return r } function Wn(t, e) { var n = Un(t, e); null != n.scrollTop && Zn(t, n.scrollTop), null != n.scrollLeft && ti(t, n.scrollLeft) } function Un(t, e) { var n = t.display, i = bn(t.display); e.top < 0 && (e.top = 0); var r = t.curOp && null != t.curOp.scrollTop ? t.curOp.scrollTop : n.scroller.scrollTop, o = Ve(t), s = {}; e.bottom - e.top > o && (e.bottom = e.top + o); var a = t.doc.height + $e(n), l = e.top < i, c = e.bottom > a - i; if (e.top < r) s.scrollTop = l ? 0 : e.top; else if (e.bottom > r + o) { var u = Math.min(e.top, (c ? a : e.bottom) - o); u != r && (s.scrollTop = u) } var h = t.curOp && null != t.curOp.scrollLeft ? t.curOp.scrollLeft : n.scroller.scrollLeft, d = Re(t) - (t.options.fixedGutter ? n.gutters.offsetWidth : 0), f = e.right - e.left > d; return f && (e.right = e.left + d), e.left < 10 ? s.scrollLeft = 0 : e.left < h ? s.scrollLeft = Math.max(0, e.left - (f ? 0 : 10)) : e.right > d + h - 3 && (s.scrollLeft = e.right + (f ? 0 : 10) - d), s } function qn(t, e) { null != e && (Xn(t), t.curOp.scrollTop = (null == t.curOp.scrollTop ? t.doc.scrollTop : t.curOp.scrollTop) + e) } function Kn(t) { Xn(t); var e = t.getCursor(); t.curOp.scrollToPos = { from: e, to: e, margin: t.options.cursorScrollMargin } } function Gn(t, e, n) { null == e && null == n || Xn(t), null != e && (t.curOp.scrollLeft = e), null != n && (t.curOp.scrollTop = n) } function Yn(t, e) { Xn(t), t.curOp.scrollToPos = e } function Xn(t) { var e = t.curOp.scrollToPos; if (e) { t.curOp.scrollToPos = null; Jn(t, un(t, e.from), un(t, e.to), e.margin) } } function Jn(t, e, n, i) { var r = Un(t, { left: Math.min(e.left, n.left), top: Math.min(e.top, n.top) - i, right: Math.max(e.right, n.right), bottom: Math.max(e.bottom, n.bottom) + i }); Gn(t, r.scrollLeft, r.scrollTop) } function Zn(t, e) { Math.abs(t.doc.scrollTop - e) < 2 || (fs || Li(t, { top: e }), Qn(t, e, !0), fs && Li(t), ki(t, 100)) } function Qn(t, e, n) { e = Math.min(t.display.scroller.scrollHeight - t.display.scroller.clientHeight, e), (t.display.scroller.scrollTop != e || n) && (t.doc.scrollTop = e, t.display.scrollbars.setScrollTop(e), t.display.scroller.scrollTop != e && (t.display.scroller.scrollTop = e)) } function ti(t, e, n, i) { e = Math.min(e, t.display.scroller.scrollWidth - t.display.scroller.clientWidth), (n ? e == t.doc.scrollLeft : Math.abs(t.doc.scrollLeft - e) < 2) && !i || (t.doc.scrollLeft = e, Rn(t), t.display.scroller.scrollLeft != e && (t.display.scroller.scrollLeft = e), t.display.scrollbars.setScrollLeft(e)) } function ei(t) { var e = t.display, n = e.gutters.offsetWidth, i = Math.round(t.doc.height + $e(t.display)); return { clientHeight: e.scroller.clientHeight, viewHeight: e.wrapper.clientHeight, scrollWidth: e.scroller.scrollWidth, clientWidth: e.scroller.clientWidth, viewWidth: e.wrapper.clientWidth, barLeft: t.options.fixedGutter ? n : 0, docHeight: i, scrollHeight: i + He(t) + e.barHeight, nativeBarWidth: e.nativeBarWidth, gutterWidth: n } } function ni(t, e) { e || (e = ei(t)); var n = t.display.barWidth, i = t.display.barHeight; ii(t, e); for (var r = 0; r < 4 && n != t.display.barWidth || i != t.display.barHeight; r++)n != t.display.barWidth && t.options.lineWrapping && $n(t), ii(t, ei(t)), n = t.display.barWidth, i = t.display.barHeight } function ii(t, e) { var n = t.display, i = n.scrollbars.update(e); n.sizer.style.paddingRight = (n.barWidth = i.right) + "px", n.sizer.style.paddingBottom = (n.barHeight = i.bottom) + "px", n.heightForcer.style.borderBottom = i.bottom + "px solid transparent", i.right && i.bottom ? (n.scrollbarFiller.style.display = "block", n.scrollbarFiller.style.height = i.bottom + "px", n.scrollbarFiller.style.width = i.right + "px") : n.scrollbarFiller.style.display = "", i.bottom && t.options.coverGutterNextToScrollbar && t.options.fixedGutter ? (n.gutterFiller.style.display = "block", n.gutterFiller.style.height = i.bottom + "px", n.gutterFiller.style.width = e.gutterWidth + "px") : n.gutterFiller.style.display = "" } function ri(t) { t.display.scrollbars && (t.display.scrollbars.clear(), t.display.scrollbars.addClass && Fs(t.display.wrapper, t.display.scrollbars.addClass)), t.display.scrollbars = new Ca[t.options.scrollbarStyle](function (e) { t.display.wrapper.insertBefore(e, t.display.scrollbarFiller), ta(e, "mousedown", function () { t.state.focused && setTimeout(function () { return t.display.input.focus() }, 0) }), e.setAttribute("cm-not-content", "true") }, function (e, n) { "horizontal" == n ? ti(t, e) : Zn(t, e) }, t), t.display.scrollbars.addClass && a(t.display.wrapper, t.display.scrollbars.addClass) } function oi(t) { t.curOp = { cm: t, viewChanged: !1, startHeight: t.doc.height, forceUpdate: !1, updateInput: null, typing: !1, changeObjs: null, cursorActivityHandlers: null, cursorActivityCalled: 0, selectionChanged: !1, updateMaxLine: !1, scrollLeft: null, scrollTop: null, scrollToPos: null, focus: !1, id: ++ka }, ve(t.curOp) } function si(t) { be(t.curOp, function (t) { for (var e = 0; e < t.ops.length; e++)t.ops[e].cm.curOp = null; ai(t) }) } function ai(t) { for (var e = t.ops, n = 0; n < e.length; n++)li(e[n]); for (var i = 0; i < e.length; i++)ci(e[i]); for (var r = 0; r < e.length; r++)ui(e[r]); for (var o = 0; o < e.length; o++)hi(e[o]); for (var s = 0; s < e.length; s++)di(e[s]) } function li(t) { var e = t.cm, n = e.display; Ti(e), t.updateMaxLine && xt(e), t.mustUpdate = t.viewChanged || t.forceUpdate || null != t.scrollTop || t.scrollToPos && (t.scrollToPos.from.line < n.viewFrom || t.scrollToPos.to.line >= n.viewTo) || n.maxLineChanged && e.options.lineWrapping, t.update = t.mustUpdate && new Sa(e, t.mustUpdate && { top: t.scrollTop, ensure: t.scrollToPos }, t.forceUpdate) } function ci(t) { t.updatedDisplay = t.mustUpdate && Pi(t.cm, t.update) } function ui(t) { var e = t.cm, n = e.display; t.updatedDisplay && $n(e), t.barMeasure = ei(e), n.maxLineChanged && !e.options.lineWrapping && (t.adjustWidthTo = Ue(e, n.maxLine, n.maxLine.text.length).left + 3, e.display.sizerWidth = t.adjustWidthTo, t.barMeasure.scrollWidth = Math.max(n.scroller.clientWidth, n.sizer.offsetLeft + t.adjustWidthTo + He(e) + e.display.barWidth), t.maxScrollLeft = Math.max(0, n.sizer.offsetLeft + t.adjustWidthTo - Re(e))), (t.updatedDisplay || t.selectionChanged) && (t.preparedSelection = n.input.prepareSelection()) } function hi(t) { var e = t.cm; null != t.adjustWidthTo && (e.display.sizer.style.minWidth = t.adjustWidthTo + "px", t.maxScrollLeft < e.doc.scrollLeft && ti(e, Math.min(e.display.scroller.scrollLeft, t.maxScrollLeft), !0), e.display.maxLineChanged = !1); var n = t.focus && t.focus == s(); t.preparedSelection && e.display.input.showSelection(t.preparedSelection, n), (t.updatedDisplay || t.startHeight != e.doc.height) && ni(e, t.barMeasure), t.updatedDisplay && Di(e, t.barMeasure), t.selectionChanged && Nn(e), e.state.focused && t.updateInput && e.display.input.reset(t.typing), n && Dn(t.cm) } function di(t) { var e = t.cm, n = e.display, i = e.doc; if (t.updatedDisplay && Ai(e, t.update), null == n.wheelStartX || null == t.scrollTop && null == t.scrollLeft && !t.scrollToPos || (n.wheelStartX = n.wheelStartY = null), null != t.scrollTop && Qn(e, t.scrollTop, t.forceScroll), null != t.scrollLeft && ti(e, t.scrollLeft, !0, !0), t.scrollToPos) { jn(e, Bn(e, j(i, t.scrollToPos.from), j(i, t.scrollToPos.to), t.scrollToPos.margin)) } var r = t.maybeHiddenMarkers, o = t.maybeUnhiddenMarkers; if (r) for (var s = 0; s < r.length; ++s)r[s].lines.length || Mt(r[s], "hide"); if (o) for (var a = 0; a < o.length; ++a)o[a].lines.length && Mt(o[a], "unhide"); n.wrapper.offsetHeight && (i.scrollTop = e.display.scroller.scrollTop), t.changeObjs && Mt(e, "changes", e, t.changeObjs), t.update && t.update.finish() } function fi(t, e) { if (t.curOp) return e(); oi(t); try { return e() } finally { si(t) } } function pi(t, e) { return function () { if (t.curOp) return e.apply(t, arguments); oi(t); try { return e.apply(t, arguments) } finally { si(t) } } } function gi(t) { return function () { if (this.curOp) return t.apply(this, arguments); oi(this); try { return t.apply(this, arguments) } finally { si(this) } } } function mi(t) { return function () { var e = this.cm; if (!e || e.curOp) return t.apply(this, arguments); oi(e); try { return t.apply(this, arguments) } finally { si(e) } } } function vi(t, e, n, i) { null == e && (e = t.doc.first), null == n && (n = t.doc.first + t.doc.size), i || (i = 0); var r = t.display; if (i && n < r.viewTo && (null == r.updateLineNumbers || r.updateLineNumbers > e) && (r.updateLineNumbers = e), t.curOp.viewChanged = !0, e >= r.viewTo) Xs && pt(t.doc, e) < r.viewTo && bi(t); else if (n <= r.viewFrom) Xs && gt(t.doc, n + i) > r.viewFrom ? bi(t) : (r.viewFrom += i, r.viewTo += i); else if (e <= r.viewFrom && n >= r.viewTo) bi(t); else if (e <= r.viewFrom) { var o = xi(t, n, n + i, 1); o ? (r.view = r.view.slice(o.index), r.viewFrom = o.lineN, r.viewTo += i) : bi(t) } else if (n >= r.viewTo) { var s = xi(t, e, e, -1); s ? (r.view = r.view.slice(0, s.index), r.viewTo = s.lineN) : bi(t) } else { var a = xi(t, e, e, -1), l = xi(t, n, n + i, 1); a && l ? (r.view = r.view.slice(0, a.index).concat(me(t, a.lineN, l.lineN)).concat(r.view.slice(l.index)), r.viewTo += i) : bi(t) } var c = r.externalMeasured; c && (n < c.lineN ? c.lineN += i : e < c.lineN + c.size && (r.externalMeasured = null)) } function yi(t, e, n) { t.curOp.viewChanged = !0; var i = t.display, r = t.display.externalMeasured; if (r && e >= r.lineN && e < r.lineN + r.size && (i.externalMeasured = null), !(e < i.viewFrom || e >= i.viewTo)) { var o = i.view[Mn(t, e)]; if (null != o.node) { var s = o.changes || (o.changes = []); -1 == d(s, n) && s.push(n) } } } function bi(t) { t.display.viewFrom = t.display.viewTo = t.doc.first, t.display.view = [], t.display.viewOffset = 0 } function xi(t, e, n, i) { var r, o = Mn(t, e), s = t.display.view; if (!Xs || n == t.doc.first + t.doc.size) return { index: o, lineN: n }; for (var a = t.display.viewFrom, l = 0; l < o; l++)a += s[l].size; if (a != e) { if (i > 0) { if (o == s.length - 1) return null; r = a + s[o].size - e, o++ } else r = a - e; e += r, n += r } for (; pt(t.doc, n) != n;) { if (o == (i < 0 ? 0 : s.length - 1)) return null; n += i * s[o - (i < 0 ? 1 : 0)].size, o += i } return { index: o, lineN: n } } function wi(t, e, n) { var i = t.display; 0 == i.view.length || e >= i.viewTo || n <= i.viewFrom ? (i.view = me(t, e, n), i.viewFrom = e) : (i.viewFrom > e ? i.view = me(t, e, i.viewFrom).concat(i.view) : i.viewFrom < e && (i.view = i.view.slice(Mn(t, e))), i.viewFrom = e, i.viewTo < n ? i.view = i.view.concat(me(t, i.viewTo, n)) : i.viewTo > n && (i.view = i.view.slice(0, Mn(t, n)))), i.viewTo = n } function Ci(t) { for (var e = t.display.view, n = 0, i = 0; i < e.length; i++) { var r = e[i]; r.hidden || r.node && !r.changes || ++n } return n } function ki(t, e) { t.doc.highlightFrontier < t.display.viewTo && t.state.highlight.set(e, c(Si, t)) } function Si(t) { var e = t.doc; if (!(e.highlightFrontier >= t.display.viewTo)) { var n = +new Date + t.options.workTime, i = Xt(t, e.highlightFrontier), r = []; e.iter(i.line, Math.min(e.first + e.size, t.display.viewTo + 500), function (o) { if (i.line >= t.display.viewFrom) { var s = o.styles, a = o.text.length > t.options.maxHighlightLength ? Ut(e.mode, i.state) : null, l = Gt(t, o, i, !0); a && (i.state = a), o.styles = l.styles; var c = o.styleClasses, u = l.classes; u ? o.styleClasses = u : c && (o.styleClasses = null); for (var h = !s || s.length != o.styles.length || c != u && (!c || !u || c.bgClass != u.bgClass || c.textClass != u.textClass), d = 0; !h && d < s.length; ++d)h = s[d] != o.styles[d]; h && r.push(i.line), o.stateAfter = i.save(), i.nextLine() } else o.text.length <= t.options.maxHighlightLength && Jt(t, o.text, i), o.stateAfter = i.line % 5 == 0 ? i.save() : null, i.nextLine(); if (+new Date > n) return ki(t, t.options.workDelay), !0 }), e.highlightFrontier = i.line, e.modeFrontier = Math.max(e.modeFrontier, i.line), r.length && fi(t, function () { for (var e = 0; e < r.length; e++)yi(t, r[e], "text") }) } } function Ti(t) { var e = t.display; !e.scrollbarsClipped && e.scroller.offsetWidth && (e.nativeBarWidth = e.scroller.offsetWidth - e.scroller.clientWidth, e.heightForcer.style.height = He(t) + "px", e.sizer.style.marginBottom = -e.nativeBarWidth + "px", e.sizer.style.borderRightWidth = He(t) + "px", e.scrollbarsClipped = !0) } function Mi(t) { if (t.hasFocus()) return null; var e = s(); if (!e || !o(t.display.lineDiv, e)) return null; var n = { activeElt: e }; if (window.getSelection) { var i = window.getSelection(); i.anchorNode && i.extend && o(t.display.lineDiv, i.anchorNode) && (n.anchorNode = i.anchorNode, n.anchorOffset = i.anchorOffset, n.focusNode = i.focusNode, n.focusOffset = i.focusOffset) } return n } function Ei(t) { if (t && t.activeElt && t.activeElt != s() && (t.activeElt.focus(), t.anchorNode && o(document.body, t.anchorNode) && o(document.body, t.focusNode))) { var e = window.getSelection(), n = document.createRange(); n.setEnd(t.anchorNode, t.anchorOffset), n.collapse(!1), e.removeAllRanges(), e.addRange(n), e.extend(t.focusNode, t.focusOffset) } } function Pi(t, n) { var i = t.display, r = t.doc; if (n.editorIsHidden) return bi(t), !1; if (!n.force && n.visible.from >= i.viewFrom && n.visible.to <= i.viewTo && (null == i.updateLineNumbers || i.updateLineNumbers >= i.viewTo) && i.renderedView == i.view && 0 == Ci(t)) return !1; Vn(t) && (bi(t), n.dims = wn(t)); var o = r.first + r.size, s = Math.max(n.visible.from - t.options.viewportMargin, r.first), a = Math.min(o, n.visible.to + t.options.viewportMargin); i.viewFrom < s && s - i.viewFrom < 20 && (s = Math.max(r.first, i.viewFrom)), i.viewTo > a && i.viewTo - a < 20 && (a = Math.min(o, i.viewTo)), Xs && (s = pt(t.doc, s), a = gt(t.doc, a)); var l = s != i.viewFrom || a != i.viewTo || i.lastWrapHeight != n.wrapperHeight || i.lastWrapWidth != n.wrapperWidth; wi(t, s, a), i.viewOffset = yt(E(t.doc, i.viewFrom)), t.display.mover.style.top = i.viewOffset + "px"; var c = Ci(t); if (!l && 0 == c && !n.force && i.renderedView == i.view && (null == i.updateLineNumbers || i.updateLineNumbers >= i.viewTo)) return !1; var u = Mi(t); return c > 4 && (i.lineDiv.style.display = "none"), Oi(t, i.updateLineNumbers, n.dims), c > 4 && (i.lineDiv.style.display = ""), i.renderedView = i.view, Ei(u), e(i.cursorDiv), e(i.selectionDiv), i.gutters.style.height = i.sizer.style.minHeight = 0, l && (i.lastWrapHeight = n.wrapperHeight, i.lastWrapWidth = n.wrapperWidth, ki(t, 400)), i.updateLineNumbers = null, !0 } function Ai(t, e) { for (var n = e.viewport, i = !0; (i && t.options.lineWrapping && e.oldDisplayWidth != Re(t) || (n && null != n.top && (n = { top: Math.min(t.doc.height + $e(t.display) - Ve(t), n.top) }), e.visible = Hn(t.display, t.doc, n), !(e.visible.from >= t.display.viewFrom && e.visible.to <= t.display.viewTo))) && Pi(t, e); i = !1) { $n(t); var r = ei(t); En(t), ni(t, r), Di(t, r), e.force = !1 } e.signal(t, "update", t), t.display.viewFrom == t.display.reportedViewFrom && t.display.viewTo == t.display.reportedViewTo || (e.signal(t, "viewportChange", t, t.display.viewFrom, t.display.viewTo), t.display.reportedViewFrom = t.display.viewFrom, t.display.reportedViewTo = t.display.viewTo) } function Li(t, e) { var n = new Sa(t, e); if (Pi(t, n)) { $n(t), Ai(t, n); var i = ei(t); En(t), ni(t, i), Di(t, i), n.finish() } } function Oi(t, n, i) { function r(e) { var n = e.nextSibling; return bs && As && t.display.currentWheelTarget == e ? e.style.display = "none" : e.parentNode.removeChild(e), n } for (var o = t.display, s = t.options.lineNumbers, a = o.lineDiv, l = a.firstChild, c = o.view, u = o.viewFrom, h = 0; h < c.length; h++) { var f = c[h]; if (f.hidden); else if (f.node && f.node.parentNode == a) { for (; l != f.node;)l = r(l); var p = s && null != n && n <= u && f.lineNumber; f.changes && (d(f.changes, "gutter") > -1 && (p = !1), Ce(t, f, u, i)), p && (e(f.lineNumber), f.lineNumber.appendChild(document.createTextNode(I(t.options, u)))), l = f.node.nextSibling } else { var g = Le(t, f, u, i); a.insertBefore(g, l) } u += f.size } for (; l;)l = r(l) } function Ni(t) { var e = t.display.gutters.offsetWidth; t.display.sizer.style.marginLeft = e + "px" } function Di(t, e) { t.display.sizer.style.minHeight = e.docHeight + "px", t.display.heightForcer.style.top = e.docHeight + "px", t.display.gutters.style.height = e.docHeight + t.display.barHeight + He(t) + "px" } function Ii(t) { var n = t.display.gutters, r = t.options.gutters; e(n); for (var o = 0; o < r.length; ++o) { var s = r[o], a = n.appendChild(i("div", null, "CodeMirror-gutter " + s)); "CodeMirror-linenumbers" == s && (t.display.lineGutter = a, a.style.width = (t.display.lineNumWidth || 1) + "px") } n.style.display = o ? "" : "none", Ni(t) } function _i(t) { var e = d(t.gutters, "CodeMirror-linenumbers"); -1 == e && t.lineNumbers ? t.gutters = t.gutters.concat(["CodeMirror-linenumbers"]) : e > -1 && !t.lineNumbers && (t.gutters = t.gutters.slice(0), t.gutters.splice(e, 1)) } function Fi(t) { var e = t.wheelDeltaX, n = t.wheelDeltaY; return null == e && t.detail && t.axis == t.HORIZONTAL_AXIS && (e = t.detail), null == n && t.detail && t.axis == t.VERTICAL_AXIS ? n = t.detail : null == n && (n = t.wheelDelta), { x: e, y: n } } function $i(t) { var e = Fi(t); return e.x *= Ma, e.y *= Ma, e } function zi(t, e) { var n = Fi(e), i = n.x, r = n.y, o = t.display, s = o.scroller, a = s.scrollWidth > s.clientWidth, l = s.scrollHeight > s.clientHeight; if (i && a || r && l) { if (r && As && bs) t: for (var c = e.target, u = o.view; c != s; c = c.parentNode)for (var h = 0; h < u.length; h++)if (u[h].node == c) { t.display.currentWheelTarget = c; break t } if (i && !fs && !Cs && null != Ma) return r && l && Zn(t, Math.max(0, s.scrollTop + r * Ma)), ti(t, Math.max(0, s.scrollLeft + i * Ma)), (!r || r && l) && Ot(e), void (o.wheelStartX = null); if (r && null != Ma) { var d = r * Ma, f = t.doc.scrollTop, p = f + o.wrapper.clientHeight; d < 0 ? f = Math.max(0, f + d - 50) : p = Math.min(t.doc.height, p + d + 50), Li(t, { top: f, bottom: p }) } Ta < 20 && (null == o.wheelStartX ? (o.wheelStartX = s.scrollLeft, o.wheelStartY = s.scrollTop, o.wheelDX = i, o.wheelDY = r, setTimeout(function () { if (null != o.wheelStartX) { var t = s.scrollLeft - o.wheelStartX, e = s.scrollTop - o.wheelStartY, n = e && o.wheelDY && e / o.wheelDY || t && o.wheelDX && t / o.wheelDX; o.wheelStartX = o.wheelStartY = null, n && (Ma = (Ma * Ta + n) / (Ta + 1), ++Ta) } }, 200)) : (o.wheelDX += i, o.wheelDY += r)) } } function Hi(t, e) { var n = t[e]; t.sort(function (t, e) { return F(t.from(), e.from()) }), e = d(t, n); for (var i = 1; i < t.length; i++) { var r = t[i], o = t[i - 1]; if (F(o.to(), r.from()) >= 0) { var s = R(o.from(), r.from()), a = H(o.to(), r.to()), l = o.empty() ? r.from() == r.head : o.from() == o.head; i <= e && --e, t.splice(--i, 2, new Pa(l ? a : s, l ? s : a)) } } return new Ea(t, e) } function Ri(t, e) { return new Ea([new Pa(t, e || t)], 0) } function Vi(t) { return t.text ? _(t.from.line + t.text.length - 1, g(t.text).length + (1 == t.text.length ? t.from.ch : 0)) : t.to } function ji(t, e) { if (F(t, e.from) < 0) return t; if (F(t, e.to) <= 0) return Vi(e); var n = t.line + e.text.length - (e.to.line - e.from.line) - 1, i = t.ch; return t.line == e.to.line && (i += Vi(e).ch - e.to.ch), _(n, i) } function Bi(t, e) { for (var n = [], i = 0; i < t.sel.ranges.length; i++) { var r = t.sel.ranges[i]; n.push(new Pa(ji(r.anchor, e), ji(r.head, e))) } return Hi(n, t.sel.primIndex) } function Wi(t, e, n) { return t.line == e.line ? _(n.line, t.ch - e.ch + n.ch) : _(n.line + (t.line - e.line), t.ch) } function Ui(t, e, n) { for (var i = [], r = _(t.first, 0), o = r, s = 0; s < e.length; s++) { var a = e[s], l = Wi(a.from, r, o), c = Wi(Vi(a), r, o); if (r = a.to, o = c, "around" == n) { var u = t.sel.ranges[s], h = F(u.head, u.anchor) < 0; i[s] = new Pa(h ? c : l, h ? l : c) } else i[s] = new Pa(l, l) } return new Ea(i, t.sel.primIndex) } function qi(t) { t.doc.mode = Bt(t.options, t.doc.modeOption), Ki(t) } function Ki(t) { t.doc.iter(function (t) { t.stateAfter && (t.stateAfter = null), t.styles && (t.styles = null) }), t.doc.modeFrontier = t.doc.highlightFrontier = t.doc.first, ki(t, 100), t.state.modeGen++ , t.curOp && vi(t) } function Gi(t, e) { return 0 == e.from.ch && 0 == e.to.ch && "" == g(e.text) && (!t.cm || t.cm.options.wholeLineUpdateBefore) } function Yi(t, e, n, i) { function r(t) { return n ? n[t] : null } function o(t, n, r) { oe(t, n, r, i), xe(t, "change", t, e) } function s(t, e) { for (var n = [], o = t; o < e; ++o)n.push(new fa(c[o], r(o), i)); return n } var a = e.from, l = e.to, c = e.text, u = E(t, a.line), h = E(t, l.line), d = g(c), f = r(c.length - 1), p = l.line - a.line; if (e.full) t.insert(0, s(0, c.length)), t.remove(c.length, t.size - c.length); else if (Gi(t, e)) { var m = s(0, c.length - 1); o(h, h.text, f), p && t.remove(a.line, p), m.length && t.insert(a.line, m) } else if (u == h) if (1 == c.length) o(u, u.text.slice(0, a.ch) + d + u.text.slice(l.ch), f); else { var v = s(1, c.length - 1); v.push(new fa(d + u.text.slice(l.ch), f, i)), o(u, u.text.slice(0, a.ch) + c[0], r(0)), t.insert(a.line + 1, v) } else if (1 == c.length) o(u, u.text.slice(0, a.ch) + c[0] + h.text.slice(l.ch), r(0)), t.remove(a.line + 1, p); else { o(u, u.text.slice(0, a.ch) + c[0], r(0)), o(h, d + h.text.slice(l.ch), f); var y = s(1, c.length - 1); p > 1 && t.remove(a.line + 1, p - 1), t.insert(a.line + 1, y) } xe(t, "change", t, e) } function Xi(t, e, n) { function i(t, r, o) { if (t.linked) for (var s = 0; s < t.linked.length; ++s) { var a = t.linked[s]; if (a.doc != r) { var l = o && a.sharedHist; n && !l || (e(a.doc, l), i(a.doc, t, l)) } } } i(t, null, !0) } function Ji(t, e) { if (e.cm) throw new Error("This document is already in use."); t.doc = e, e.cm = t, Sn(t), qi(t), Zi(t), t.options.lineWrapping || xt(t), t.options.mode = e.modeOption, vi(t) } function Zi(t) { ("rtl" == t.doc.direction ? a : Fs)(t.display.lineDiv, "CodeMirror-rtl") } function Qi(t) { fi(t, function () { Zi(t), vi(t) }) } function tr(t) { this.done = [], this.undone = [], this.undoDepth = 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = t || 1 } function er(t, e) { var n = { from: z(e.from), to: Vi(e), text: P(t, e.from, e.to) }; return lr(t, n, e.from.line, e.to.line + 1), Xi(t, function (t) { return lr(t, n, e.from.line, e.to.line + 1) }, !0), n } function nr(t) { for (; t.length;) { if (!g(t).ranges) break; t.pop() } } function ir(t, e) { return e ? (nr(t.done), g(t.done)) : t.done.length && !g(t.done).ranges ? g(t.done) : t.done.length > 1 && !t.done[t.done.length - 2].ranges ? (t.done.pop(), g(t.done)) : void 0 } function rr(t, e, n, i) { var r = t.history; r.undone.length = 0; var o, s, a = +new Date; if ((r.lastOp == i || r.lastOrigin == e.origin && e.origin && ("+" == e.origin.charAt(0) && t.cm && r.lastModTime > a - t.cm.options.historyEventDelay || "*" == e.origin.charAt(0))) && (o = ir(r, r.lastOp == i))) s = g(o.changes), 0 == F(e.from, e.to) && 0 == F(e.from, s.to) ? s.to = Vi(e) : o.changes.push(er(t, e)); else { var l = g(r.done); for (l && l.ranges || ar(t.sel, r.done), o = { changes: [er(t, e)], generation: r.generation }, r.done.push(o); r.done.length > r.undoDepth;)r.done.shift(), r.done[0].ranges || r.done.shift() } r.done.push(n), r.generation = ++r.maxGeneration, r.lastModTime = r.lastSelTime = a, r.lastOp = r.lastSelOp = i, r.lastOrigin = r.lastSelOrigin = e.origin, s || Mt(t, "historyAdded") } function or(t, e, n, i) { var r = e.charAt(0); return "*" == r || "+" == r && n.ranges.length == i.ranges.length && n.somethingSelected() == i.somethingSelected() && new Date - t.history.lastSelTime <= (t.cm ? t.cm.options.historyEventDelay : 500) } function sr(t, e, n, i) { var r = t.history, o = i && i.origin; n == r.lastSelOp || o && r.lastSelOrigin == o && (r.lastModTime == r.lastSelTime && r.lastOrigin == o || or(t, o, g(r.done), e)) ? r.done[r.done.length - 1] = e : ar(e, r.done), r.lastSelTime = +new Date, r.lastSelOrigin = o, r.lastSelOp = n, i && !1 !== i.clearRedo && nr(r.undone) } function ar(t, e) { var n = g(e); n && n.ranges && n.equals(t) || e.push(t) } function lr(t, e, n, i) { var r = e["spans_" + t.id], o = 0; t.iter(Math.max(t.first, n), Math.min(t.first + t.size, i), function (n) { n.markedSpans && ((r || (r = e["spans_" + t.id] = {}))[o] = n.markedSpans), ++o }) } function cr(t) { if (!t) return null; for (var e, n = 0; n < t.length; ++n)t[n].marker.explicitlyCleared ? e || (e = t.slice(0, n)) : e && e.push(t[n]); return e ? e.length ? e : null : t } function ur(t, e) { var n = e["spans_" + t.id]; if (!n) return null; for (var i = [], r = 0; r < e.text.length; ++r)i.push(cr(n[r])); return i } function hr(t, e) { var n = ur(t, e), i = Q(t, e); if (!n) return i; if (!i) return n; for (var r = 0; r < n.length; ++r) { var o = n[r], s = i[r]; if (o && s) t: for (var a = 0; a < s.length; ++a) { for (var l = s[a], c = 0; c < o.length; ++c)if (o[c].marker == l.marker) continue t; o.push(l) } else s && (n[r] = s) } return n } function dr(t, e, n) { for (var i = [], r = 0; r < t.length; ++r) { var o = t[r]; if (o.ranges) i.push(n ? Ea.prototype.deepCopy.call(o) : o); else { var s = o.changes, a = []; i.push({ changes: a }); for (var l = 0; l < s.length; ++l) { var c = s[l], u = void 0; if (a.push({ from: c.from, to: c.to, text: c.text }), e) for (var h in c) (u = h.match(/^spans_(\d+)$/)) && d(e, Number(u[1])) > -1 && (g(a)[h] = c[h], delete c[h]) } } } return i } function fr(t, e, n, i) { if (i) { var r = t.anchor; if (n) { var o = F(e, r) < 0; o != F(n, r) < 0 ? (r = e, e = n) : o != F(e, n) < 0 && (e = n) } return new Pa(r, e) } return new Pa(n || e, e) } function pr(t, e, n, i, r) { null == r && (r = t.cm && (t.cm.display.shift || t.extend)), xr(t, new Ea([fr(t.sel.primary(), e, n, r)], 0), i) } function gr(t, e, n) { for (var i = [], r = t.cm && (t.cm.display.shift || t.extend), o = 0; o < t.sel.ranges.length; o++)i[o] = fr(t.sel.ranges[o], e[o], null, r); xr(t, Hi(i, t.sel.primIndex), n) } function mr(t, e, n, i) { var r = t.sel.ranges.slice(0); r[e] = n, xr(t, Hi(r, t.sel.primIndex), i) } function vr(t, e, n, i) { xr(t, Ri(e, n), i) } function yr(t, e, n) { var i = { ranges: e.ranges, update: function (e) { var n = this; this.ranges = []; for (var i = 0; i < e.length; i++)n.ranges[i] = new Pa(j(t, e[i].anchor), j(t, e[i].head)) }, origin: n && n.origin }; return Mt(t, "beforeSelectionChange", t, i), t.cm && Mt(t.cm, "beforeSelectionChange", t.cm, i), i.ranges != e.ranges ? Hi(i.ranges, i.ranges.length - 1) : e } function br(t, e, n) { var i = t.history.done, r = g(i); r && r.ranges ? (i[i.length - 1] = e, wr(t, e, n)) : xr(t, e, n) } function xr(t, e, n) { wr(t, e, n), sr(t, t.sel, t.cm ? t.cm.curOp.id : NaN, n) } function wr(t, e, n) { (At(t, "beforeSelectionChange") || t.cm && At(t.cm, "beforeSelectionChange")) && (e = yr(t, e, n)), Cr(t, Sr(t, e, n && n.bias || (F(e.primary().head, t.sel.primary().head) < 0 ? -1 : 1), !0)), n && !1 === n.scroll || !t.cm || Kn(t.cm) } function Cr(t, e) { e.equals(t.sel) || (t.sel = e, t.cm && (t.cm.curOp.updateInput = t.cm.curOp.selectionChanged = !0, Pt(t.cm)), xe(t, "cursorActivity", t)) } function kr(t) { Cr(t, Sr(t, t.sel, null, !1)) } function Sr(t, e, n, i) { for (var r, o = 0; o < e.ranges.length; o++) { var s = e.ranges[o], a = e.ranges.length == t.sel.ranges.length && t.sel.ranges[o], l = Mr(t, s.anchor, a && a.anchor, n, i), c = Mr(t, s.head, a && a.head, n, i); (r || l != s.anchor || c != s.head) && (r || (r = e.ranges.slice(0, o)), r[o] = new Pa(l, c)) } return r ? Hi(r, e.primIndex) : e } function Tr(t, e, n, i, r) { var o = E(t, e.line); if (o.markedSpans) for (var s = 0; s < o.markedSpans.length; ++s) { var a = o.markedSpans[s], l = a.marker; if ((null == a.from || (l.inclusiveLeft ? a.from <= e.ch : a.from < e.ch)) && (null == a.to || (l.inclusiveRight ? a.to >= e.ch : a.to > e.ch))) { if (r && (Mt(l, "beforeCursorEnter"), l.explicitlyCleared)) { if (o.markedSpans) { --s; continue } break } if (!l.atomic) continue; if (n) { var c = l.find(i < 0 ? 1 : -1), u = void 0; if ((i < 0 ? l.inclusiveRight : l.inclusiveLeft) && (c = Er(t, c, -i, c && c.line == e.line ? o : null)), c && c.line == e.line && (u = F(c, n)) && (i < 0 ? u < 0 : u > 0)) return Tr(t, c, e, i, r) } var h = l.find(i < 0 ? -1 : 1); return (i < 0 ? l.inclusiveLeft : l.inclusiveRight) && (h = Er(t, h, i, h.line == e.line ? o : null)), h ? Tr(t, h, e, i, r) : null } } return e } function Mr(t, e, n, i, r) { var o = i || 1, s = Tr(t, e, n, o, r) || !r && Tr(t, e, n, o, !0) || Tr(t, e, n, -o, r) || !r && Tr(t, e, n, -o, !0); return s || (t.cantEdit = !0, _(t.first, 0)) } function Er(t, e, n, i) { return n < 0 && 0 == e.ch ? e.line > t.first ? j(t, _(e.line - 1)) : null : n > 0 && e.ch == (i || E(t, e.line)).text.length ? e.line < t.first + t.size - 1 ? _(e.line + 1, 0) : null : new _(e.line, e.ch + n) } function Pr(t) { t.setSelection(_(t.firstLine(), 0), _(t.lastLine()), Bs) } function Ar(t, e, n) { var i = { canceled: !1, from: e.from, to: e.to, text: e.text, origin: e.origin, cancel: function () { return i.canceled = !0 } }; return n && (i.update = function (e, n, r, o) { e && (i.from = j(t, e)), n && (i.to = j(t, n)), r && (i.text = r), void 0 !== o && (i.origin = o) }), Mt(t, "beforeChange", t, i), t.cm && Mt(t.cm, "beforeChange", t.cm, i), i.canceled ? null : { from: i.from, to: i.to, text: i.text, origin: i.origin } } function Lr(t, e, n) { if (t.cm) { if (!t.cm.curOp) return pi(t.cm, Lr)(t, e, n); if (t.cm.state.suppressEdits) return } if (!(At(t, "beforeChange") || t.cm && At(t.cm, "beforeChange")) || (e = Ar(t, e, !0))) { var i = Ys && !n && et(t, e.from, e.to); if (i) for (var r = i.length - 1; r >= 0; --r)Or(t, { from: i[r].from, to: i[r].to, text: r ? [""] : e.text, origin: e.origin }); else Or(t, e) } } function Or(t, e) { if (1 != e.text.length || "" != e.text[0] || 0 != F(e.from, e.to)) { var n = Bi(t, e); rr(t, e, n, t.cm ? t.cm.curOp.id : NaN), Ir(t, e, n, Q(t, e)); var i = []; Xi(t, function (t, n) { n || -1 != d(i, t.history) || (Hr(t.history, e), i.push(t.history)), Ir(t, e, null, Q(t, e)) }) } } function Nr(t, e, n) { if (!t.cm || !t.cm.state.suppressEdits || n) { for (var i, r = t.history, o = t.sel, s = "undo" == e ? r.done : r.undone, a = "undo" == e ? r.undone : r.done, l = 0; l < s.length && (i = s[l], n ? !i.ranges || i.equals(t.sel) : i.ranges); l++); if (l != s.length) { for (r.lastOrigin = r.lastSelOrigin = null; i = s.pop(), i.ranges;) { if (ar(i, a), n && !i.equals(t.sel)) return void xr(t, i, { clearRedo: !1 }); o = i } var c = []; ar(o, a), a.push({ changes: c, generation: r.generation }), r.generation = i.generation || ++r.maxGeneration; for (var u = At(t, "beforeChange") || t.cm && At(t.cm, "beforeChange"), h = i.changes.length - 1; h >= 0; --h) { var f = function (n) { var r = i.changes[n]; if (r.origin = e, u && !Ar(t, r, !1)) return s.length = 0, {}; c.push(er(t, r)); var o = n ? Bi(t, r) : g(s); Ir(t, r, o, hr(t, r)), !n && t.cm && t.cm.scrollIntoView({ from: r.from, to: Vi(r) }); var a = []; Xi(t, function (t, e) { e || -1 != d(a, t.history) || (Hr(t.history, r), a.push(t.history)), Ir(t, r, null, hr(t, r)) }) }(h); if (f) return f.v } } } } function Dr(t, e) { if (0 != e && (t.first += e, t.sel = new Ea(m(t.sel.ranges, function (t) { return new Pa(_(t.anchor.line + e, t.anchor.ch), _(t.head.line + e, t.head.ch)) }), t.sel.primIndex), t.cm)) { vi(t.cm, t.first, t.first - e, e); for (var n = t.cm.display, i = n.viewFrom; i < n.viewTo; i++)yi(t.cm, i, "gutter") } } function Ir(t, e, n, i) { if (t.cm && !t.cm.curOp) return pi(t.cm, Ir)(t, e, n, i); if (e.to.line < t.first) return void Dr(t, e.text.length - 1 - (e.to.line - e.from.line)); if (!(e.from.line > t.lastLine())) { if (e.from.line < t.first) { var r = e.text.length - 1 - (t.first - e.from.line); Dr(t, r), e = { from: _(t.first, 0), to: _(e.to.line + r, e.to.ch), text: [g(e.text)], origin: e.origin } } var o = t.lastLine(); e.to.line > o && (e = { from: e.from, to: _(o, E(t, o).text.length), text: [e.text[0]], origin: e.origin }), e.removed = P(t, e.from, e.to), n || (n = Bi(t, e)), t.cm ? _r(t.cm, e, i) : Yi(t, e, i), wr(t, n, Bs) } } function _r(t, e, n) { var i = t.doc, r = t.display, o = e.from, s = e.to, a = !1, l = o.line; t.options.lineWrapping || (l = O(ht(E(i, o.line))), i.iter(l, s.line + 1, function (t) { if (t == r.maxLine) return a = !0, !0 })), i.sel.contains(e.from, e.to) > -1 && Pt(t), Yi(i, e, n, kn(t)), t.options.lineWrapping || (i.iter(l, o.line + e.text.length, function (t) { var e = bt(t); e > r.maxLineLength && (r.maxLine = t, r.maxLineLength = e, r.maxLineChanged = !0, a = !1) }), a && (t.curOp.updateMaxLine = !0)), re(i, o.line), ki(t, 400); var c = e.text.length - (s.line - o.line) - 1; e.full ? vi(t) : o.line != s.line || 1 != e.text.length || Gi(t.doc, e) ? vi(t, o.line, s.line + 1, c) : yi(t, o.line, "text"); var u = At(t, "changes"), h = At(t, "change"); if (h || u) { var d = { from: o, to: s, text: e.text, removed: e.removed, origin: e.origin }; h && xe(t, "change", t, d), u && (t.curOp.changeObjs || (t.curOp.changeObjs = [])).push(d) } t.display.selForContextMenu = null } function Fr(t, e, n, i, r) { if (i || (i = n), F(i, n) < 0) { var o; o = [i, n], n = o[0], i = o[1] } "string" == typeof e && (e = t.splitLines(e)), Lr(t, { from: n, to: i, text: e, origin: r }) } function $r(t, e, n, i) { n < t.line ? t.line += i : e < t.line && (t.line = e, t.ch = 0) } function zr(t, e, n, i) { for (var r = 0; r < t.length; ++r) { var o = t[r], s = !0; if (o.ranges) { o.copied || (o = t[r] = o.deepCopy(), o.copied = !0); for (var a = 0; a < o.ranges.length; a++)$r(o.ranges[a].anchor, e, n, i), $r(o.ranges[a].head, e, n, i) } else { for (var l = 0; l < o.changes.length; ++l) { var c = o.changes[l]; if (n < c.from.line) c.from = _(c.from.line + i, c.from.ch), c.to = _(c.to.line + i, c.to.ch); else if (e <= c.to.line) { s = !1; break } } s || (t.splice(0, r + 1), r = 0) } } } function Hr(t, e) { var n = e.from.line, i = e.to.line, r = e.text.length - (i - n) - 1; zr(t.done, n, i, r), zr(t.undone, n, i, r) } function Rr(t, e, n, i) { var r = e, o = e; return "number" == typeof e ? o = E(t, V(t, e)) : r = O(e), null == r ? null : (i(o, r) && t.cm && yi(t.cm, r, n), o) } function Vr(t) { var e = this; this.lines = t, this.parent = null; for (var n = 0, i = 0; i < t.length; ++i)t[i].parent = e, n += t[i].height; this.height = n } function jr(t) { var e = this; this.children = t; for (var n = 0, i = 0, r = 0; r < t.length; ++r) { var o = t[r]; n += o.chunkSize(), i += o.height, o.parent = e } this.size = n, this.height = i, this.parent = null } function Br(t, e, n) { yt(e) < (t.curOp && t.curOp.scrollTop || t.doc.scrollTop) && qn(t, n) } function Wr(t, e, n, i) { var r = new Aa(t, n, i), o = t.cm; return o && r.noHScroll && (o.display.alignWidgets = !0), Rr(t, e, "widget", function (e) { var n = e.widgets || (e.widgets = []); if (null == r.insertAt ? n.push(r) : n.splice(Math.min(n.length - 1, Math.max(0, r.insertAt)), 0, r), r.line = e, o && !mt(t, e)) { var i = yt(e) < t.scrollTop; L(e, e.height + Ie(r)), i && qn(o, r.height), o.curOp.forceUpdate = !0 } return !0 }), xe(o, "lineWidgetAdded", o, r, "number" == typeof e ? e : O(e)), r } function Ur(t, e, n, i, o) { if (i && i.shared) return qr(t, e, n, i, o); if (t.cm && !t.cm.curOp) return pi(t.cm, Ur)(t, e, n, i, o); var s = new Oa(t, o), a = F(e, n); if (i && u(i, s, !1), a > 0 || 0 == a && !1 !== s.clearWhenEmpty) return s; if (s.replacedWith && (s.collapsed = !0, s.widgetNode = r("span", [s.replacedWith], "CodeMirror-widget"), i.handleMouseEvents || s.widgetNode.setAttribute("cm-ignore-events", "true"), i.insertLeft && (s.widgetNode.insertLeft = !0)), s.collapsed) { if (ut(t, e.line, e, n, s) || e.line != n.line && ut(t, n.line, e, n, s)) throw new Error("Inserting collapsed marker partially overlapping an existing one"); q() } s.addToHistory && rr(t, { from: e, to: n, origin: "markText" }, t.sel, NaN); var l, c = e.line, h = t.cm; if (t.iter(c, n.line + 1, function (t) { h && s.collapsed && !h.options.lineWrapping && ht(t) == h.display.maxLine && (l = !0), s.collapsed && c != e.line && L(t, 0), X(t, new K(s, c == e.line ? e.ch : null, c == n.line ? n.ch : null)), ++c }), s.collapsed && t.iter(e.line, n.line + 1, function (e) { mt(t, e) && L(e, 0) }), s.clearOnEnter && ta(s, "beforeCursorEnter", function () { return s.clear() }), s.readOnly && (U(), (t.history.done.length || t.history.undone.length) && t.clearHistory()), s.collapsed && (s.id = ++La, s.atomic = !0), h) { if (l && (h.curOp.updateMaxLine = !0), s.collapsed) vi(h, e.line, n.line + 1); else if (s.className || s.title || s.startStyle || s.endStyle || s.css) for (var d = e.line; d <= n.line; d++)yi(h, d, "text"); s.atomic && kr(h.doc), xe(h, "markerAdded", h, s) } return s } function qr(t, e, n, i, r) { i = u(i), i.shared = !1; var o = [Ur(t, e, n, i, r)], s = o[0], a = i.widgetNode; return Xi(t, function (t) { a && (i.widgetNode = a.cloneNode(!0)), o.push(Ur(t, j(t, e), j(t, n), i, r)); for (var l = 0; l < t.linked.length; ++l)if (t.linked[l].isParent) return; s = g(o) }), new Na(o, s) } function Kr(t) { return t.findMarks(_(t.first, 0), t.clipPos(_(t.lastLine())), function (t) { return t.parent }) } function Gr(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n], r = i.find(), o = t.clipPos(r.from), s = t.clipPos(r.to); if (F(o, s)) { var a = Ur(t, o, s, i.primary, i.primary.type); i.markers.push(a), a.parent = i } } } function Yr(t) { for (var e = 0; e < t.length; e++)!function (e) { var n = t[e], i = [n.primary.doc]; Xi(n.primary.doc, function (t) { return i.push(t) }); for (var r = 0; r < n.markers.length; r++) { var o = n.markers[r]; -1 == d(i, o.doc) && (o.parent = null, n.markers.splice(r--, 1)) } }(e) } function Xr(t) { var e = this; if (Qr(e), !Et(e, t) && !_e(e.display, t)) { Ot(t), vs && (_a = +new Date); var n = Tn(e, t, !0), i = t.dataTransfer.files; if (n && !e.isReadOnly()) if (i && i.length && window.FileReader && window.File) for (var r = i.length, o = Array(r), s = 0, a = 0; a < r; ++a)!function (t, i) { if (!e.options.allowDropFileTypes || -1 != d(e.options.allowDropFileTypes, t.type)) { var a = new FileReader; a.onload = pi(e, function () { var t = a.result; if (/[\x00-\x08\x0e-\x1f]{2}/.test(t) && (t = ""), o[i] = t, ++s == r) { n = j(e.doc, n); var l = { from: n, to: n, text: e.doc.splitLines(o.join(e.doc.lineSeparator())), origin: "paste" }; Lr(e.doc, l), br(e.doc, Ri(n, Vi(l))) } }), a.readAsText(t) } }(i[a], a); else { if (e.state.draggingText && e.doc.sel.contains(n) > -1) return e.state.draggingText(t), void setTimeout(function () { return e.display.input.focus() }, 20); try { var l = t.dataTransfer.getData("Text"); if (l) { var c; if (e.state.draggingText && !e.state.draggingText.copy && (c = e.listSelections()), wr(e.doc, Ri(n, n)), c) for (var u = 0; u < c.length; ++u)Fr(e.doc, "", c[u].anchor, c[u].head, "drag"); e.replaceSelection(l, "around", "paste"), e.display.input.focus() } } catch (t) { } } } } function Jr(t, e) { if (vs && (!t.state.draggingText || +new Date - _a < 100)) return void It(e); if (!Et(t, e) && !_e(t.display, e) && (e.dataTransfer.setData("Text", t.getSelection()), e.dataTransfer.effectAllowed = "copyMove", e.dataTransfer.setDragImage && !ks)) { var n = i("img", null, null, "position: fixed; left: 0; top: 0;"); n.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", Cs && (n.width = n.height = 1, t.display.wrapper.appendChild(n), n._top = n.offsetTop), e.dataTransfer.setDragImage(n, 0, 0), Cs && n.parentNode.removeChild(n) } } function Zr(t, e) { var r = Tn(t, e); if (r) { var o = document.createDocumentFragment(); An(t, r, o), t.display.dragCursor || (t.display.dragCursor = i("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), t.display.lineSpace.insertBefore(t.display.dragCursor, t.display.cursorDiv)), n(t.display.dragCursor, o) } } function Qr(t) { t.display.dragCursor && (t.display.lineSpace.removeChild(t.display.dragCursor), t.display.dragCursor = null) } function to(t) { if (document.getElementsByClassName) for (var e = document.getElementsByClassName("CodeMirror"), n = 0; n < e.length; n++) { var i = e[n].CodeMirror; i && t(i) } } function eo() { Fa || (no(), Fa = !0) } function no() { var t; ta(window, "resize", function () { null == t && (t = setTimeout(function () { t = null, to(io) }, 100)) }), ta(window, "blur", function () { return to(Fn) }) } function io(t) { var e = t.display; e.lastWrapHeight == e.wrapper.clientHeight && e.lastWrapWidth == e.wrapper.clientWidth || (e.cachedCharWidth = e.cachedTextHeight = e.cachedPaddingH = null, e.scrollbarsClipped = !1, t.setSize()) } function ro(t) { var e = t.split(/-(?!$)/); t = e[e.length - 1]; for (var n, i, r, o, s = 0; s < e.length - 1; s++) { var a = e[s]; if (/^(cmd|meta|m)$/i.test(a)) o = !0; else if (/^a(lt)?$/i.test(a)) n = !0; else if (/^(c|ctrl|control)$/i.test(a)) i = !0; else { if (!/^s(hift)?$/i.test(a)) throw new Error("Unrecognized modifier name: " + a); r = !0 } } return n && (t = "Alt-" + t), i && (t = "Ctrl-" + t), o && (t = "Cmd-" + t), r && (t = "Shift-" + t), t } function oo(t) { var e = {}; for (var n in t) if (t.hasOwnProperty(n)) { var i = t[n]; if (/^(name|fallthrough|(de|at)tach)$/.test(n)) continue; if ("..." == i) { delete t[n]; continue } for (var r = m(n.split(" "), ro), o = 0; o < r.length; o++) { var s = void 0, a = void 0; o == r.length - 1 ? (a = r.join(" "), s = i) : (a = r.slice(0, o + 1).join(" "), s = "..."); var l = e[a]; if (l) { if (l != s) throw new Error("Inconsistent bindings for " + a) } else e[a] = s } delete t[n] } for (var c in e) t[c] = e[c]; return t } function so(t, e, n, i) { e = uo(e); var r = e.call ? e.call(t, i) : e[t]; if (!1 === r) return "nothing"; if ("..." === r) return "multi"; if (null != r && n(r)) return "handled"; if (e.fallthrough) { if ("[object Array]" != Object.prototype.toString.call(e.fallthrough)) return so(t, e.fallthrough, n, i); for (var o = 0; o < e.fallthrough.length; o++) { var s = so(t, e.fallthrough[o], n, i); if (s) return s } } } function ao(t) { var e = "string" == typeof t ? t : $a[t.keyCode]; return "Ctrl" == e || "Alt" == e || "Shift" == e || "Mod" == e } function lo(t, e, n) { var i = t; return e.altKey && "Alt" != i && (t = "Alt-" + t), (Is ? e.metaKey : e.ctrlKey) && "Ctrl" != i && (t = "Ctrl-" + t), (Is ? e.ctrlKey : e.metaKey) && "Cmd" != i && (t = "Cmd-" + t), !n && e.shiftKey && "Shift" != i && (t = "Shift-" + t), t } function co(t, e) { if (Cs && 34 == t.keyCode && t.char) return !1; var n = $a[t.keyCode]; return null != n && !t.altGraphKey && lo(n, t, e) } function uo(t) { return "string" == typeof t ? Va[t] : t } function ho(t, e) { for (var n = t.doc.sel.ranges, i = [], r = 0; r < n.length; r++) { for (var o = e(n[r]); i.length && F(o.from, g(i).to) <= 0;) { var s = i.pop(); if (F(s.from, o.from) < 0) { o.from = s.from; break } } i.push(o) } fi(t, function () { for (var e = i.length - 1; e >= 0; e--)Fr(t.doc, "", i[e].from, i[e].to, "+delete"); Kn(t) }) } function fo(t, e, n) { var i = S(t.text, e + n, n); return i < 0 || i > t.text.length ? null : i } function po(t, e, n) { var i = fo(t, e.ch, n); return null == i ? null : new _(e.line, i, n < 0 ? "after" : "before") } function go(t, e, n, i, r) { if (t) { var o = kt(n, e.doc.direction); if (o) { var s, a = r < 0 ? g(o) : o[0], l = r < 0 == (1 == a.level), c = l ? "after" : "before"; if (a.level > 0 || "rtl" == e.doc.direction) { var u = Ke(e, n); s = r < 0 ? n.text.length - 1 : 0; var h = Ge(e, u, s).top; s = T(function (t) { return Ge(e, u, t).top == h }, r < 0 == (1 == a.level) ? a.from : a.to - 1, s), "before" == c && (s = fo(n, s, 1)) } else s = r < 0 ? a.to : a.from; return new _(i, s, c) } } return new _(i, r < 0 ? n.text.length : 0, r < 0 ? "before" : "after") } function mo(t, e, n, i) { var r = kt(e, t.doc.direction); if (!r) return po(e, n, i); n.ch >= e.text.length ? (n.ch = e.text.length, n.sticky = "before") : n.ch <= 0 && (n.ch = 0, n.sticky = "after"); var o = Ct(r, n.ch, n.sticky), s = r[o]; if ("ltr" == t.doc.direction && s.level % 2 == 0 && (i > 0 ? s.to > n.ch : s.from < n.ch)) return po(e, n, i); var a, l = function (t, n) { return fo(e, t instanceof _ ? t.ch : t, n) }, c = function (n) { return t.options.lineWrapping ? (a = a || Ke(t, e), pn(t, e, a, n)) : { begin: 0, end: e.text.length } }, u = c("before" == n.sticky ? l(n, -1) : n.ch); if ("rtl" == t.doc.direction || 1 == s.level) { var h = 1 == s.level == i < 0, d = l(n, h ? 1 : -1); if (null != d && (h ? d <= s.to && d <= u.end : d >= s.from && d >= u.begin)) { var f = h ? "before" : "after"; return new _(n.line, d, f) } } var p = function (t, e, i) { for (var o = function (t, e) { return e ? new _(n.line, l(t, 1), "before") : new _(n.line, t, "after") }; t >= 0 && t < r.length; t += e) { var s = r[t], a = e > 0 == (1 != s.level), c = a ? i.begin : l(i.end, -1); if (s.from <= c && c < s.to) return o(c, a); if (c = a ? s.from : l(s.to, -1), i.begin <= c && c < i.end) return o(c, a) } }, g = p(o + i, i, u); if (g) return g; var m = i > 0 ? u.end : l(u.begin, -1); return null == m || i > 0 && m == e.text.length || !(g = p(i > 0 ? 0 : r.length - 1, i, c(m))) ? null : g } function vo(t, e) { var n = E(t.doc, e), i = ht(n); return i != n && (e = O(i)), go(!0, t, i, e, 1) } function yo(t, e) { var n = E(t.doc, e), i = dt(n); return i != n && (e = O(i)), go(!0, t, n, e, -1) } function bo(t, e) { var n = vo(t, e.line), i = E(t.doc, n.line), r = kt(i, t.doc.direction); if (!r || 0 == r[0].level) { var o = Math.max(0, i.text.search(/\S/)), s = e.line == n.line && e.ch <= o && e.ch; return _(n.line, s ? 0 : o, n.sticky) } return n } function xo(t, e, n) { if ("string" == typeof e && !(e = ja[e])) return !1; t.display.input.ensurePolled(); var i = t.display.shift, r = !1; try { t.isReadOnly() && (t.state.suppressEdits = !0), n && (t.display.shift = !1), r = e(t) != js } finally { t.display.shift = i, t.state.suppressEdits = !1 } return r } function wo(t, e, n) { for (var i = 0; i < t.state.keyMaps.length; i++) { var r = so(e, t.state.keyMaps[i], n, t); if (r) return r } return t.options.extraKeys && so(e, t.options.extraKeys, n, t) || so(e, t.options.keyMap, n, t) } function Co(t, e, n, i) { var r = t.state.keySeq; if (r) { if (ao(e)) return "handled"; Ba.set(50, function () { t.state.keySeq == r && (t.state.keySeq = null, t.display.input.reset()) }), e = r + " " + e } var o = wo(t, e, i); return "multi" == o && (t.state.keySeq = e), "handled" == o && xe(t, "keyHandled", t, e, n), "handled" != o && "multi" != o || (Ot(n), Nn(t)), r && !o && /\'$/.test(e) ? (Ot(n), !0) : !!o } function ko(t, e) { var n = co(e, !0); return !!n && (e.shiftKey && !t.state.keySeq ? Co(t, "Shift-" + n, e, function (e) { return xo(t, e, !0) }) || Co(t, n, e, function (e) { if ("string" == typeof e ? /^go[A-Z]/.test(e) : e.motion) return xo(t, e) }) : Co(t, n, e, function (e) { return xo(t, e) })) } function So(t, e, n) { return Co(t, "'" + n + "'", e, function (e) { return xo(t, e, !0) }) } function To(t) { var e = this; if (e.curOp.focus = s(), !Et(e, t)) { vs && ys < 11 && 27 == t.keyCode && (t.returnValue = !1); var n = t.keyCode; e.display.shift = 16 == n || t.shiftKey; var i = ko(e, t); Cs && (Wa = i ? n : null, !i && 88 == n && !ra && (As ? t.metaKey : t.ctrlKey) && e.replaceSelection("", null, "cut")), 18 != n || /\bCodeMirror-crosshair\b/.test(e.display.lineDiv.className) || Mo(e) } } function Mo(t) { function e(t) { 18 != t.keyCode && t.altKey || (Fs(n, "CodeMirror-crosshair"), Tt(document, "keyup", e), Tt(document, "mouseover", e)) } var n = t.display.lineDiv; a(n, "CodeMirror-crosshair"), ta(document, "keyup", e), ta(document, "mouseover", e) } function Eo(t) { 16 == t.keyCode && (this.doc.sel.shift = !1), Et(this, t) } function Po(t) { var e = this; if (!(_e(e.display, t) || Et(e, t) || t.ctrlKey && !t.altKey || As && t.metaKey)) { var n = t.keyCode, i = t.charCode; if (Cs && n == Wa) return Wa = null, void Ot(t); if (!Cs || t.which && !(t.which < 10) || !ko(e, t)) { var r = String.fromCharCode(null == i ? n : i); "\b" != r && (So(e, t, r) || e.display.input.onKeyPress(t)) } } } function Ao(t, e) { var n = +new Date; return Ka && Ka.compare(n, t, e) ? (qa = Ka = null, "triple") : qa && qa.compare(n, t, e) ? (Ka = new Ua(n, t, e), qa = null, "double") : (qa = new Ua(n, t, e), Ka = null, "single") } function Lo(t) { var e = this, n = e.display; if (!(Et(e, t) || n.activeTouch && n.input.supportsTouch())) { if (n.input.ensurePolled(), n.shift = t.shiftKey, _e(n, t)) return void (bs || (n.scroller.draggable = !1, setTimeout(function () { return n.scroller.draggable = !0 }, 100))); if (!Ho(e, t)) { var i = Tn(e, t), r = Ft(t), o = i ? Ao(i, r) : "single"; window.focus(), 1 == r && e.state.selectingText && e.state.selectingText(t), i && Oo(e, r, i, o, t) || (1 == r ? i ? Do(e, i, o, t) : _t(t) == n.scroller && Ot(t) : 2 == r ? (i && pr(e.doc, i), setTimeout(function () { return n.input.focus() }, 20)) : 3 == r && (_s ? Ro(e, t) : In(e))) } } } function Oo(t, e, n, i, r) { var o = "Click"; return "double" == i ? o = "Double" + o : "triple" == i && (o = "Triple" + o), o = (1 == e ? "Left" : 2 == e ? "Middle" : "Right") + o, Co(t, lo(o, r), r, function (e) { if ("string" == typeof e && (e = ja[e]), !e) return !1; var i = !1; try { t.isReadOnly() && (t.state.suppressEdits = !0), i = e(t, n) != js } finally { t.state.suppressEdits = !1 } return i }) } function No(t, e, n) { var i = t.getOption("configureMouse"), r = i ? i(t, e, n) : {}; if (null == r.unit) { var o = Ls ? n.shiftKey && n.metaKey : n.altKey; r.unit = o ? "rectangle" : "single" == e ? "char" : "double" == e ? "word" : "line" } return (null == r.extend || t.doc.extend) && (r.extend = t.doc.extend || n.shiftKey), null == r.addNew && (r.addNew = As ? n.metaKey : n.ctrlKey), null == r.moveOnDrag && (r.moveOnDrag = !(As ? n.altKey : n.ctrlKey)), r } function Do(t, e, n, i) { vs ? setTimeout(c(Dn, t), 0) : t.curOp.focus = s(); var r, o = No(t, n, i), a = t.doc.sel; t.options.dragDrop && ea && !t.isReadOnly() && "single" == n && (r = a.contains(e)) > -1 && (F((r = a.ranges[r]).from(), e) < 0 || e.xRel > 0) && (F(r.to(), e) > 0 || e.xRel < 0) ? Io(t, i, e, o) : Fo(t, i, e, o) } function Io(t, e, n, i) { var r = t.display, o = !1, s = pi(t, function (e) { bs && (r.scroller.draggable = !1), t.state.draggingText = !1, Tt(document, "mouseup", s), Tt(document, "mousemove", a), Tt(r.scroller, "dragstart", l), Tt(r.scroller, "drop", s), o || (Ot(e), i.addNew || pr(t.doc, n, null, null, i.extend), bs || vs && 9 == ys ? setTimeout(function () { document.body.focus(), r.input.focus() }, 20) : r.input.focus()) }), a = function (t) { o = o || Math.abs(e.clientX - t.clientX) + Math.abs(e.clientY - t.clientY) >= 10 }, l = function () { return o = !0 }; bs && (r.scroller.draggable = !0), t.state.draggingText = s, s.copy = !i.moveOnDrag, r.scroller.dragDrop && r.scroller.dragDrop(), ta(document, "mouseup", s), ta(document, "mousemove", a), ta(r.scroller, "dragstart", l), ta(r.scroller, "drop", s), In(t), setTimeout(function () { return r.input.focus() }, 20) } function _o(t, e, n) { if ("char" == n) return new Pa(e, e); if ("word" == n) return t.findWordAt(e); if ("line" == n) return new Pa(_(e.line, 0), j(t.doc, _(e.line + 1, 0))); var i = n(t, e); return new Pa(i.from, i.to) } function Fo(t, e, n, i) { function r(e) { if (0 != F(v, e)) if (v = e, "rectangle" == i.unit) { for (var r = [], o = t.options.tabSize, s = h(E(c, n.line).text, n.ch, o), a = h(E(c, e.line).text, e.ch, o), l = Math.min(s, a), g = Math.max(s, a), m = Math.min(n.line, e.line), y = Math.min(t.lastLine(), Math.max(n.line, e.line)); m <= y; m++) { var b = E(c, m).text, x = f(b, l, o); l == g ? r.push(new Pa(_(m, x), _(m, x))) : b.length > x && r.push(new Pa(_(m, x), _(m, f(b, g, o)))) } r.length || r.push(new Pa(n, n)), xr(c, Hi(p.ranges.slice(0, d).concat(r), d), { origin: "*mouse", scroll: !1 }), t.scrollIntoView(e) } else { var w, C = u, k = _o(t, e, i.unit), S = C.anchor; F(k.anchor, S) > 0 ? (w = k.head, S = R(C.from(), k.anchor)) : (w = k.anchor, S = H(C.to(), k.head)); var T = p.ranges.slice(0); T[d] = $o(t, new Pa(j(c, S), w)), xr(c, Hi(T, d), Ws) } } function o(e) { var n = ++b, a = Tn(t, e, !0, "rectangle" == i.unit); if (a) if (0 != F(a, v)) { t.curOp.focus = s(), r(a); var u = Hn(l, c); (a.line >= u.to || a.line < u.from) && setTimeout(pi(t, function () { b == n && o(e) }), 150) } else { var h = e.clientY < y.top ? -20 : e.clientY > y.bottom ? 20 : 0; h && setTimeout(pi(t, function () { b == n && (l.scroller.scrollTop += h, o(e)) }), 50) } } function a(e) { t.state.selectingText = !1, b = 1 / 0, Ot(e), l.input.focus(), Tt(document, "mousemove", x), Tt(document, "mouseup", w), c.history.lastSelOrigin = null } var l = t.display, c = t.doc; Ot(e); var u, d, p = c.sel, g = p.ranges; if (i.addNew && !i.extend ? (d = c.sel.contains(n), u = d > -1 ? g[d] : new Pa(n, n)) : (u = c.sel.primary(), d = c.sel.primIndex), "rectangle" == i.unit) i.addNew || (u = new Pa(n, n)), n = Tn(t, e, !0, !0), d = -1; else { var m = _o(t, n, i.unit); u = i.extend ? fr(u, m.anchor, m.head, i.extend) : m } i.addNew ? -1 == d ? (d = g.length, xr(c, Hi(g.concat([u]), d), { scroll: !1, origin: "*mouse" })) : g.length > 1 && g[d].empty() && "char" == i.unit && !i.extend ? (xr(c, Hi(g.slice(0, d).concat(g.slice(d + 1)), 0), { scroll: !1, origin: "*mouse" }), p = c.sel) : mr(c, d, u, Ws) : (d = 0, xr(c, new Ea([u], 0), Ws), p = c.sel); var v = n, y = l.wrapper.getBoundingClientRect(), b = 0, x = pi(t, function (t) { Ft(t) ? o(t) : a(t) }), w = pi(t, a); t.state.selectingText = w, ta(document, "mousemove", x), ta(document, "mouseup", w) } function $o(t, e) { var n = e.anchor, i = e.head, r = E(t.doc, n.line); if (0 == F(n, i) && n.sticky == i.sticky) return e; var o = kt(r); if (!o) return e; var s = Ct(o, n.ch, n.sticky), a = o[s]; if (a.from != n.ch && a.to != n.ch) return e; var l = s + (a.from == n.ch == (1 != a.level) ? 0 : 1); if (0 == l || l == o.length) return e; var c; if (i.line != n.line) c = (i.line - n.line) * ("ltr" == t.doc.direction ? 1 : -1) > 0; else { var u = Ct(o, i.ch, i.sticky), h = u - s || (i.ch - n.ch) * (1 == a.level ? -1 : 1); c = u == l - 1 || u == l ? h < 0 : h > 0 } var d = o[l + (c ? -1 : 0)], f = c == (1 == d.level), p = f ? d.from : d.to, g = f ? "after" : "before"; return n.ch == p && n.sticky == g ? e : new Pa(new _(n.line, p, g), i) } function zo(t, e, n, i) { var r, o; if (e.touches) r = e.touches[0].clientX, o = e.touches[0].clientY; else try { r = e.clientX, o = e.clientY } catch (e) { return !1 } if (r >= Math.floor(t.display.gutters.getBoundingClientRect().right)) return !1; i && Ot(e); var s = t.display, a = s.lineDiv.getBoundingClientRect(); if (o > a.bottom || !At(t, n)) return Dt(e); o -= a.top - s.viewOffset; for (var l = 0; l < t.options.gutters.length; ++l) { var c = s.gutters.childNodes[l]; if (c && c.getBoundingClientRect().right >= r) { return Mt(t, n, t, N(t.doc, o), t.options.gutters[l], e), Dt(e) } } } function Ho(t, e) { return zo(t, e, "gutterClick", !0) } function Ro(t, e) { _e(t.display, e) || Vo(t, e) || Et(t, e, "contextmenu") || t.display.input.onContextMenu(e) } function Vo(t, e) { return !!At(t, "gutterContextMenu") && zo(t, e, "gutterContextMenu", !1) } function jo(t) { t.display.wrapper.className = t.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + t.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), en(t) } function Bo(t) { Ii(t), vi(t), Rn(t) } function Wo(t, e, n) { if (!e != !(n && n != Ga)) { var i = t.display.dragFunctions, r = e ? ta : Tt; r(t.display.scroller, "dragstart", i.start), r(t.display.scroller, "dragenter", i.enter), r(t.display.scroller, "dragover", i.over), r(t.display.scroller, "dragleave", i.leave), r(t.display.scroller, "drop", i.drop) } } function Uo(t) { t.options.lineWrapping ? (a(t.display.wrapper, "CodeMirror-wrap"), t.display.sizer.style.minWidth = "", t.display.sizerWidth = null) : (Fs(t.display.wrapper, "CodeMirror-wrap"), xt(t)), Sn(t), vi(t), en(t), setTimeout(function () { return ni(t) }, 100) } function qo(t, e) { var n = this; if (!(this instanceof qo)) return new qo(t, e); this.options = e = e ? u(e) : {}, u(Ya, e, !1), _i(e); var i = e.value; "string" == typeof i && (i = new Ia(i, e.mode, null, e.lineSeparator, e.direction)), this.doc = i; var r = new qo.inputStyles[e.inputStyle](this), o = this.display = new M(t, i, r); o.wrapper.CodeMirror = this, Ii(this), jo(this), e.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), ri(this), this.state = { keyMaps: [], overlays: [], modeGen: 0, overwrite: !1, delayingBlurEvent: !1, focused: !1, suppressEdits: !1, pasteIncoming: !1, cutIncoming: !1, selectingText: !1, draggingText: !1, highlight: new zs, keySeq: null, specialChars: null }, e.autofocus && !Ps && o.input.focus(), vs && ys < 11 && setTimeout(function () { return n.display.input.reset(!0) }, 20), Ko(this), eo(), oi(this), this.curOp.forceUpdate = !0, Ji(this, i), e.autofocus && !Ps || this.hasFocus() ? setTimeout(c(_n, this), 20) : Fn(this); for (var s in Xa) Xa.hasOwnProperty(s) && Xa[s](n, e[s], Ga); Vn(this), e.finishInit && e.finishInit(this); for (var a = 0; a < Ja.length; ++a)Ja[a](n); si(this), bs && e.lineWrapping && "optimizelegibility" == getComputedStyle(o.lineDiv).textRendering && (o.lineDiv.style.textRendering = "auto") } function Ko(t) { function e() { r.activeTouch && (o = setTimeout(function () { return r.activeTouch = null }, 1e3), s = r.activeTouch, s.end = +new Date) } function n(t) { if (1 != t.touches.length) return !1; var e = t.touches[0]; return e.radiusX <= 1 && e.radiusY <= 1 } function i(t, e) { if (null == e.left) return !0; var n = e.left - t.left, i = e.top - t.top; return n * n + i * i > 400 } var r = t.display; ta(r.scroller, "mousedown", pi(t, Lo)), vs && ys < 11 ? ta(r.scroller, "dblclick", pi(t, function (e) { if (!Et(t, e)) { var n = Tn(t, e); if (n && !Ho(t, e) && !_e(t.display, e)) { Ot(e); var i = t.findWordAt(n); pr(t.doc, i.anchor, i.head) } } })) : ta(r.scroller, "dblclick", function (e) { return Et(t, e) || Ot(e) }), _s || ta(r.scroller, "contextmenu", function (e) { return Ro(t, e) }); var o, s = { end: 0 }; ta(r.scroller, "touchstart", function (e) { if (!Et(t, e) && !n(e) && !Ho(t, e)) { r.input.ensurePolled(), clearTimeout(o); var i = +new Date; r.activeTouch = { start: i, moved: !1, prev: i - s.end <= 300 ? s : null }, 1 == e.touches.length && (r.activeTouch.left = e.touches[0].pageX, r.activeTouch.top = e.touches[0].pageY) } }), ta(r.scroller, "touchmove", function () { r.activeTouch && (r.activeTouch.moved = !0) }), ta(r.scroller, "touchend", function (n) { var o = r.activeTouch; if (o && !_e(r, n) && null != o.left && !o.moved && new Date - o.start < 300) { var s, a = t.coordsChar(r.activeTouch, "page"); s = !o.prev || i(o, o.prev) ? new Pa(a, a) : !o.prev.prev || i(o, o.prev.prev) ? t.findWordAt(a) : new Pa(_(a.line, 0), j(t.doc, _(a.line + 1, 0))), t.setSelection(s.anchor, s.head), t.focus(), Ot(n) } e() }), ta(r.scroller, "touchcancel", e), ta(r.scroller, "scroll", function () { r.scroller.clientHeight && (Zn(t, r.scroller.scrollTop), ti(t, r.scroller.scrollLeft, !0), Mt(t, "scroll", t)) }), ta(r.scroller, "mousewheel", function (e) { return zi(t, e) }), ta(r.scroller, "DOMMouseScroll", function (e) { return zi(t, e) }), ta(r.wrapper, "scroll", function () { return r.wrapper.scrollTop = r.wrapper.scrollLeft = 0 }), r.dragFunctions = { enter: function (e) { Et(t, e) || It(e) }, over: function (e) { Et(t, e) || (Zr(t, e), It(e)) }, start: function (e) { return Jr(t, e) }, drop: pi(t, Xr), leave: function (e) { Et(t, e) || Qr(t) } }; var a = r.input.getField(); ta(a, "keyup", function (e) { return Eo.call(t, e) }), ta(a, "keydown", pi(t, To)), ta(a, "keypress", pi(t, Po)), ta(a, "focus", function (e) { return _n(t, e) }), ta(a, "blur", function (e) { return Fn(t, e) }) } function Go(t, e, n, i) { var r, o = t.doc; null == n && (n = "add"), "smart" == n && (o.mode.indent ? r = Xt(t, e).state : n = "prev"); var s = t.options.tabSize, a = E(o, e), l = h(a.text, null, s); a.stateAfter && (a.stateAfter = null); var c, u = a.text.match(/^\s*/)[0]; if (i || /\S/.test(a.text)) { if ("smart" == n && ((c = o.mode.indent(r, a.text.slice(u.length), a.text)) == js || c > 150)) { if (!i) return; n = "prev" } } else c = 0, n = "not"; "prev" == n ? c = e > o.first ? h(E(o, e - 1).text, null, s) : 0 : "add" == n ? c = l + t.options.indentUnit : "subtract" == n ? c = l - t.options.indentUnit : "number" == typeof n && (c = l + n), c = Math.max(0, c); var d = "", f = 0; if (t.options.indentWithTabs) for (var g = Math.floor(c / s); g; --g)f += s, d += "\t"; if (f < c && (d += p(c - f)), d != u) return Fr(o, d, _(e, 0), _(e, u.length), "+input"), a.stateAfter = null, !0; for (var m = 0; m < o.sel.ranges.length; m++) { var v = o.sel.ranges[m]; if (v.head.line == e && v.head.ch < u.length) { var y = _(e, u.length); mr(o, m, new Pa(y, y)); break } } } function Yo(t) { Za = t } function Xo(t, e, n, i, r) { var o = t.doc; t.display.shift = !1, i || (i = o.sel); var s = t.state.pasteIncoming || "paste" == r, a = na(e), l = null; if (s && i.ranges.length > 1) if (Za && Za.text.join("\n") == e) { if (i.ranges.length % Za.text.length == 0) { l = []; for (var c = 0; c < Za.text.length; c++)l.push(o.splitLines(Za.text[c])) } } else a.length == i.ranges.length && t.options.pasteLinesPerSelection && (l = m(a, function (t) { return [t] })); for (var u, h = i.ranges.length - 1; h >= 0; h--) { var d = i.ranges[h], f = d.from(), p = d.to(); d.empty() && (n && n > 0 ? f = _(f.line, f.ch - n) : t.state.overwrite && !s ? p = _(p.line, Math.min(E(o, p.line).text.length, p.ch + g(a).length)) : Za && Za.lineWise && Za.text.join("\n") == e && (f = p = _(f.line, 0))), u = t.curOp.updateInput; var v = { from: f, to: p, text: l ? l[h % l.length] : a, origin: r || (s ? "paste" : t.state.cutIncoming ? "cut" : "+input") }; Lr(t.doc, v), xe(t, "inputRead", t, v) } e && !s && Zo(t, e), Kn(t), t.curOp.updateInput = u, t.curOp.typing = !0, t.state.pasteIncoming = t.state.cutIncoming = !1 } function Jo(t, e) { var n = t.clipboardData && t.clipboardData.getData("Text"); if (n) return t.preventDefault(), e.isReadOnly() || e.options.disableInput || fi(e, function () { return Xo(e, n, 0, null, "paste") }), !0 } function Zo(t, e) { if (t.options.electricChars && t.options.smartIndent) for (var n = t.doc.sel, i = n.ranges.length - 1; i >= 0; i--) { var r = n.ranges[i]; if (!(r.head.ch > 100 || i && n.ranges[i - 1].head.line == r.head.line)) { var o = t.getModeAt(r.head), s = !1; if (o.electricChars) { for (var a = 0; a < o.electricChars.length; a++)if (e.indexOf(o.electricChars.charAt(a)) > -1) { s = Go(t, r.head.line, "smart"); break } } else o.electricInput && o.electricInput.test(E(t.doc, r.head.line).text.slice(0, r.head.ch)) && (s = Go(t, r.head.line, "smart")); s && xe(t, "electricInput", t, r.head.line) } } } function Qo(t) { for (var e = [], n = [], i = 0; i < t.doc.sel.ranges.length; i++) { var r = t.doc.sel.ranges[i].head.line, o = { anchor: _(r, 0), head: _(r + 1, 0) }; n.push(o), e.push(t.getRange(o.anchor, o.head)) } return { text: e, ranges: n } } function ts(t, e) { t.setAttribute("autocorrect", "off"), t.setAttribute("autocapitalize", "off"), t.setAttribute("spellcheck", !!e) } function es() { var t = i("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"), e = i("div", [t], null, "overflow: hidden; position: relative; width: 3px; height: 0px;"); return bs ? t.style.width = "1000px" : t.setAttribute("wrap", "off"), Ms && (t.style.border = "1px solid black"), ts(t), e } function ns(t, e, n, i, r) { function o() { var i = e.line + n; return !(i < t.first || i >= t.first + t.size) && (e = new _(i, e.ch, e.sticky), c = E(t, i)) } function s(i) { var s; if (null == (s = r ? mo(t.cm, c, e, n) : po(c, e, n))) { if (i || !o()) return !1; e = go(r, t.cm, c, e.line, n) } else e = s; return !0 } var a = e, l = n, c = E(t, e.line); if ("char" == i) s(); else if ("column" == i) s(!0); else if ("word" == i || "group" == i) for (var u = null, h = "group" == i, d = t.cm && t.cm.getHelper(e, "wordChars"), f = !0; !(n < 0) || s(!f); f = !1) { var p = c.text.charAt(e.ch) || "\n", g = w(p, d) ? "w" : h && "\n" == p ? "n" : !h || /\s/.test(p) ? null : "p"; if (!h || f || g || (g = "s"), u && u != g) { n < 0 && (n = 1, s(), e.sticky = "after"); break } if (g && (u = g), n > 0 && !s(!f)) break } var m = Mr(t, e, a, l, !0); return $(a, m) && (m.hitSide = !0), m } function is(t, e, n, i) { var r, o = t.doc, s = e.left; if ("page" == i) { var a = Math.min(t.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight), l = Math.max(a - .5 * bn(t.display), 3); r = (n > 0 ? e.bottom : e.top) + n * l } else "line" == i && (r = n > 0 ? e.bottom + 3 : e.top - 3); for (var c; c = dn(t, s, r), c.outside;) { if (n < 0 ? r <= 0 : r >= o.height) { c.hitSide = !0; break } r += 5 * n } return c } function rs(t, e) { var n = qe(t, e.line); if (!n || n.hidden) return null; var i = E(t.doc, e.line), r = Be(n, i, e.line), o = kt(i, t.doc.direction), s = "left"; if (o) { s = Ct(o, e.ch) % 2 ? "right" : "left" } var a = Ye(r.map, e.ch, s); return a.offset = "right" == a.collapse ? a.end : a.start, a } function os(t) { for (var e = t; e; e = e.parentNode)if (/CodeMirror-gutter-wrapper/.test(e.className)) return !0; return !1 } function ss(t, e) { return e && (t.bad = !0), t } function as(t, e, n, i, r) { function o(t) { return function (e) { return e.id == t } } function s() { u && (c += h, u = !1) } function a(t) { t && (s(), c += t) } function l(e) { if (1 == e.nodeType) { var n = e.getAttribute("cm-text"); if (null != n) return void a(n || e.textContent.replace(/\u200b/g, "")); var c, d = e.getAttribute("cm-marker"); if (d) { var f = t.findMarks(_(i, 0), _(r + 1, 0), o(+d)); return void (f.length && (c = f[0].find(0)) && a(P(t.doc, c.from, c.to).join(h))) } if ("false" == e.getAttribute("contenteditable")) return; var p = /^(pre|div|p)$/i.test(e.nodeName); p && s(); for (var g = 0; g < e.childNodes.length; g++)l(e.childNodes[g]); p && (u = !0) } else 3 == e.nodeType && a(e.nodeValue) } for (var c = "", u = !1, h = t.doc.lineSeparator(); l(e), e != n;)e = e.nextSibling; return c } function ls(t, e, n) { var i; if (e == t.display.lineDiv) { if (!(i = t.display.lineDiv.childNodes[n])) return ss(t.clipPos(_(t.display.viewTo - 1)), !0); e = null, n = 0 } else for (i = e; ; i = i.parentNode) { if (!i || i == t.display.lineDiv) return null; if (i.parentNode && i.parentNode == t.display.lineDiv) break } for (var r = 0; r < t.display.view.length; r++) { var o = t.display.view[r]; if (o.node == i) return cs(o, e, n) } } function cs(t, e, n) { function i(e, n, i) { for (var r = -1; r < (h ? h.length : 0); r++)for (var o = r < 0 ? u.map : h[r], s = 0; s < o.length; s += 3) { var a = o[s + 2]; if (a == e || a == n) { var l = O(r < 0 ? t.line : t.rest[r]), c = o[s] + i; return (i < 0 || a != e) && (c = o[s + (i ? 1 : 0)]), _(l, c) } } } var r = t.text.firstChild, s = !1; if (!e || !o(r, e)) return ss(_(O(t.line), 0), !0); if (e == r && (s = !0, e = r.childNodes[n], n = 0, !e)) { var a = t.rest ? g(t.rest) : t.line; return ss(_(O(a), a.text.length), s) } var l = 3 == e.nodeType ? e : null, c = e; for (l || 1 != e.childNodes.length || 3 != e.firstChild.nodeType || (l = e.firstChild, n && (n = l.nodeValue.length)); c.parentNode != r;)c = c.parentNode; var u = t.measure, h = u.maps, d = i(l, c, n); if (d) return ss(d, s); for (var f = c.nextSibling, p = l ? l.nodeValue.length - n : 0; f; f = f.nextSibling) { if (d = i(f, f.firstChild, 0)) return ss(_(d.line, d.ch - p), s); p += f.textContent.length } for (var m = c.previousSibling, v = n; m; m = m.previousSibling) { if (d = i(m, m.firstChild, -1)) return ss(_(d.line, d.ch + v), s); v += m.textContent.length } } function us(t, e) { function n() { t.value = l.getValue() } if (e = e ? u(e) : {}, e.value = t.value, !e.tabindex && t.tabIndex && (e.tabindex = t.tabIndex), !e.placeholder && t.placeholder && (e.placeholder = t.placeholder), null == e.autofocus) { var i = s(); e.autofocus = i == t || null != t.getAttribute("autofocus") && i == document.body } var r; if (t.form && (ta(t.form, "submit", n), !e.leaveSubmitMethodAlone)) { var o = t.form; r = o.submit; try { var a = o.submit = function () { n(), o.submit = r, o.submit(), o.submit = a } } catch (t) { } } e.finishInit = function (e) { e.save = n, e.getTextArea = function () { return t }, e.toTextArea = function () { e.toTextArea = isNaN, n(), t.parentNode.removeChild(e.getWrapperElement()), t.style.display = "", t.form && (Tt(t.form, "submit", n), "function" == typeof t.form.submit && (t.form.submit = r)) } }, t.style.display = "none"; var l = qo(function (e) { return t.parentNode.insertBefore(e, t.nextSibling) }, e); return l } var hs = navigator.userAgent, ds = navigator.platform, fs = /gecko\/\d/i.test(hs), ps = /MSIE \d/.test(hs), gs = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(hs), ms = /Edge\/(\d+)/.exec(hs), vs = ps || gs || ms, ys = vs && (ps ? document.documentMode || 6 : +(ms || gs)[1]), bs = !ms && /WebKit\//.test(hs), xs = bs && /Qt\/\d+\.\d+/.test(hs), ws = !ms && /Chrome\//.test(hs), Cs = /Opera\//.test(hs), ks = /Apple Computer/.test(navigator.vendor), Ss = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(hs), Ts = /PhantomJS/.test(hs), Ms = !ms && /AppleWebKit/.test(hs) && /Mobile\/\w+/.test(hs), Es = /Android/.test(hs), Ps = Ms || Es || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(hs), As = Ms || /Mac/.test(ds), Ls = /\bCrOS\b/.test(hs), Os = /win/i.test(ds), Ns = Cs && hs.match(/Version\/(\d*\.\d*)/); Ns && (Ns = Number(Ns[1])), Ns && Ns >= 15 && (Cs = !1, bs = !0); var Ds, Is = As && (xs || Cs && (null == Ns || Ns < 12.11)), _s = fs || vs && ys >= 9, Fs = function (e, n) { var i = e.className, r = t(n).exec(i); if (r) { var o = i.slice(r.index + r[0].length); e.className = i.slice(0, r.index) + (o ? r[1] + o : "") } }; Ds = document.createRange ? function (t, e, n, i) { var r = document.createRange(); return r.setEnd(i || t, n), r.setStart(t, e), r } : function (t, e, n) { var i = document.body.createTextRange(); try { i.moveToElementText(t.parentNode) } catch (t) { return i } return i.collapse(!0), i.moveEnd("character", n), i.moveStart("character", e), i }; var $s = function (t) { t.select() }; Ms ? $s = function (t) { t.selectionStart = 0, t.selectionEnd = t.value.length } : vs && ($s = function (t) { try { t.select() } catch (t) { } }); var zs = function () { this.id = null }; zs.prototype.set = function (t, e) { clearTimeout(this.id), this.id = setTimeout(e, t) }; var Hs, Rs, Vs = 30, js = { toString: function () { return "CodeMirror.Pass" } }, Bs = { scroll: !1 }, Ws = { origin: "*mouse" }, Us = { origin: "+move" }, qs = [""], Ks = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/, Gs = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/, Ys = !1, Xs = !1, Js = null, Zs = function () { function t(t) { return t <= 247 ? n.charAt(t) : 1424 <= t && t <= 1524 ? "R" : 1536 <= t && t <= 1785 ? i.charAt(t - 1536) : 1774 <= t && t <= 2220 ? "r" : 8192 <= t && t <= 8203 ? "w" : 8204 == t ? "b" : "L" } function e(t, e, n) { this.level = t, this.from = e, this.to = n } var n = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", i = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111", r = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, o = /[stwN]/, s = /[LRr]/, a = /[Lb1n]/, l = /[1n]/; return function (n, i) { var c = "ltr" == i ? "L" : "R"; if (0 == n.length || "ltr" == i && !r.test(n)) return !1; for (var u = n.length, h = [], d = 0; d < u; ++d)h.push(t(n.charCodeAt(d))); for (var f = 0, p = c; f < u; ++f) { var m = h[f]; "m" == m ? h[f] = p : p = m } for (var v = 0, y = c; v < u; ++v) { var b = h[v]; "1" == b && "r" == y ? h[v] = "n" : s.test(b) && (y = b, "r" == b && (h[v] = "R")) } for (var x = 1, w = h[0]; x < u - 1; ++x) { var C = h[x]; "+" == C && "1" == w && "1" == h[x + 1] ? h[x] = "1" : "," != C || w != h[x + 1] || "1" != w && "n" != w || (h[x] = w), w = C } for (var k = 0; k < u; ++k) { var S = h[k]; if ("," == S) h[k] = "N"; else if ("%" == S) { var T = void 0; for (T = k + 1; T < u && "%" == h[T]; ++T); for (var M = k && "!" == h[k - 1] || T < u && "1" == h[T] ? "1" : "N", E = k; E < T; ++E)h[E] = M; k = T - 1 } } for (var P = 0, A = c; P < u; ++P) { var L = h[P]; "L" == A && "1" == L ? h[P] = "L" : s.test(L) && (A = L) } for (var O = 0; O < u; ++O)if (o.test(h[O])) { var N = void 0; for (N = O + 1; N < u && o.test(h[N]); ++N); for (var D = "L" == (O ? h[O - 1] : c), I = "L" == (N < u ? h[N] : c), _ = D == I ? D ? "L" : "R" : c, F = O; F < N; ++F)h[F] = _; O = N - 1 } for (var $, z = [], H = 0; H < u;)if (a.test(h[H])) { var R = H; for (++H; H < u && a.test(h[H]); ++H); z.push(new e(0, R, H)) } else { var V = H, j = z.length; for (++H; H < u && "L" != h[H]; ++H); for (var B = V; B < H;)if (l.test(h[B])) { V < B && z.splice(j, 0, new e(1, V, B)); var W = B; for (++B; B < H && l.test(h[B]); ++B); z.splice(j, 0, new e(2, W, B)), V = B } else ++B; V < H && z.splice(j, 0, new e(1, V, H)) } return "ltr" == i && (1 == z[0].level && ($ = n.match(/^\s+/)) && (z[0].from = $[0].length, z.unshift(new e(0, 0, $[0].length))), 1 == g(z).level && ($ = n.match(/\s+$/)) && (g(z).to -= $[0].length, z.push(new e(0, u - $[0].length, u)))), "rtl" == i ? z.reverse() : z } }(), Qs = [], ta = function (t, e, n) { if (t.addEventListener) t.addEventListener(e, n, !1); else if (t.attachEvent) t.attachEvent("on" + e, n); else { var i = t._handlers || (t._handlers = {}); i[e] = (i[e] || Qs).concat(n) } }, ea = function () { if (vs && ys < 9) return !1; var t = i("div"); return "draggable" in t || "dragDrop" in t }(), na = 3 != "\n\nb".split(/\n/).length ? function (t) { for (var e = 0, n = [], i = t.length; e <= i;) { var r = t.indexOf("\n", e); -1 == r && (r = t.length); var o = t.slice(e, "\r" == t.charAt(r - 1) ? r - 1 : r), s = o.indexOf("\r"); -1 != s ? (n.push(o.slice(0, s)), e += s + 1) : (n.push(o), e = r + 1) } return n } : function (t) { return t.split(/\r\n?|\n/) }, ia = window.getSelection ? function (t) { try { return t.selectionStart != t.selectionEnd } catch (t) { return !1 } } : function (t) { var e; try { e = t.ownerDocument.selection.createRange() } catch (t) { } return !(!e || e.parentElement() != t) && 0 != e.compareEndPoints("StartToEnd", e) }, ra = function () { var t = i("div"); return "oncopy" in t || (t.setAttribute("oncopy", "return;"), "function" == typeof t.oncopy) }(), oa = null, sa = {}, aa = {}, la = {}, ca = function (t, e, n) { this.pos = this.start = 0, this.string = t, this.tabSize = e || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = n }; ca.prototype.eol = function () { return this.pos >= this.string.length }, ca.prototype.sol = function () { return this.pos == this.lineStart }, ca.prototype.peek = function () { return this.string.charAt(this.pos) || void 0 }, ca.prototype.next = function () { if (this.pos < this.string.length) return this.string.charAt(this.pos++) }, ca.prototype.eat = function (t) { var e = this.string.charAt(this.pos); if ("string" == typeof t ? e == t : e && (t.test ? t.test(e) : t(e))) return ++this.pos, e }, ca.prototype.eatWhile = function (t) { for (var e = this.pos; this.eat(t);); return this.pos > e }, ca.prototype.eatSpace = function () { for (var t = this, e = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos));)++t.pos; return this.pos > e }, ca.prototype.skipToEnd = function () { this.pos = this.string.length }, ca.prototype.skipTo = function (t) { var e = this.string.indexOf(t, this.pos); if (e > -1) return this.pos = e, !0 }, ca.prototype.backUp = function (t) { this.pos -= t }, ca.prototype.column = function () { return this.lastColumnPos < this.start && (this.lastColumnValue = h(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? h(this.string, this.lineStart, this.tabSize) : 0) }, ca.prototype.indentation = function () { return h(this.string, null, this.tabSize) - (this.lineStart ? h(this.string, this.lineStart, this.tabSize) : 0) }, ca.prototype.match = function (t, e, n) { if ("string" != typeof t) { var i = this.string.slice(this.pos).match(t); return i && i.index > 0 ? null : (i && !1 !== e && (this.pos += i[0].length), i) } var r = function (t) { return n ? t.toLowerCase() : t }; if (r(this.string.substr(this.pos, t.length)) == r(t)) return !1 !== e && (this.pos += t.length), !0 }, ca.prototype.current = function () { return this.string.slice(this.start, this.pos) }, ca.prototype.hideFirstChars = function (t, e) { this.lineStart += t; try { return e() } finally { this.lineStart -= t } }, ca.prototype.lookAhead = function (t) { var e = this.lineOracle; return e && e.lookAhead(t) }, ca.prototype.baseToken = function () { var t = this.lineOracle; return t && t.baseToken(this.pos) }; var ua = function (t, e) { this.state = t, this.lookAhead = e }, ha = function (t, e, n, i) { this.state = e, this.doc = t, this.line = n, this.maxLookAhead = i || 0, this.baseTokens = null, this.baseTokenPos = 1 }; ha.prototype.lookAhead = function (t) { var e = this.doc.getLine(this.line + t); return null != e && t > this.maxLookAhead && (this.maxLookAhead = t), e }, ha.prototype.baseToken = function (t) { var e = this; if (!this.baseTokens) return null; for (; this.baseTokens[this.baseTokenPos] <= t;)e.baseTokenPos += 2; var n = this.baseTokens[this.baseTokenPos + 1]; return { type: n && n.replace(/( |^)overlay .*/, ""), size: this.baseTokens[this.baseTokenPos] - t } }, ha.prototype.nextLine = function () { this.line++ , this.maxLookAhead > 0 && this.maxLookAhead-- }, ha.fromSaved = function (t, e, n) { return e instanceof ua ? new ha(t, Ut(t.mode, e.state), n, e.lookAhead) : new ha(t, Ut(t.mode, e), n) }, ha.prototype.save = function (t) { var e = !1 !== t ? Ut(this.doc.mode, this.state) : this.state; return this.maxLookAhead > 0 ? new ua(e, this.maxLookAhead) : e }; var da = function (t, e, n) { this.start = t.start, this.end = t.pos, this.string = t.current(), this.type = e || null, this.state = n }, fa = function (t, e, n) { this.text = t, it(this, e), this.height = n ? n(this) : 1 }; fa.prototype.lineNo = function () { return O(this) }, Lt(fa); var pa, ga = {}, ma = {}, va = null, ya = null, ba = { left: 0, right: 0, top: 0, bottom: 0 }, xa = function (t, e, n) { this.cm = n; var r = this.vert = i("div", [i("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"), o = this.horiz = i("div", [i("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar"); t(r), t(o), ta(r, "scroll", function () { r.clientHeight && e(r.scrollTop, "vertical") }), ta(o, "scroll", function () { o.clientWidth && e(o.scrollLeft, "horizontal") }), this.checkedZeroWidth = !1, vs && ys < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px") }; xa.prototype.update = function (t) { var e = t.scrollWidth > t.clientWidth + 1, n = t.scrollHeight > t.clientHeight + 1, i = t.nativeBarWidth; if (n) { this.vert.style.display = "block", this.vert.style.bottom = e ? i + "px" : "0"; var r = t.viewHeight - (e ? i : 0); this.vert.firstChild.style.height = Math.max(0, t.scrollHeight - t.clientHeight + r) + "px" } else this.vert.style.display = "", this.vert.firstChild.style.height = "0"; if (e) { this.horiz.style.display = "block", this.horiz.style.right = n ? i + "px" : "0", this.horiz.style.left = t.barLeft + "px"; var o = t.viewWidth - t.barLeft - (n ? i : 0); this.horiz.firstChild.style.width = Math.max(0, t.scrollWidth - t.clientWidth + o) + "px" } else this.horiz.style.display = "", this.horiz.firstChild.style.width = "0"; return !this.checkedZeroWidth && t.clientHeight > 0 && (0 == i && this.zeroWidthHack(), this.checkedZeroWidth = !0), { right: n ? i : 0, bottom: e ? i : 0 } }, xa.prototype.setScrollLeft = function (t) { this.horiz.scrollLeft != t && (this.horiz.scrollLeft = t), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz") }, xa.prototype.setScrollTop = function (t) { this.vert.scrollTop != t && (this.vert.scrollTop = t), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert") }, xa.prototype.zeroWidthHack = function () { var t = As && !Ss ? "12px" : "18px"; this.horiz.style.height = this.vert.style.width = t, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none", this.disableHoriz = new zs, this.disableVert = new zs }, xa.prototype.enableZeroWidthBar = function (t, e, n) { function i() { var r = t.getBoundingClientRect(); ("vert" == n ? document.elementFromPoint(r.right - 1, (r.top + r.bottom) / 2) : document.elementFromPoint((r.right + r.left) / 2, r.bottom - 1)) != t ? t.style.pointerEvents = "none" : e.set(1e3, i) } t.style.pointerEvents = "auto", e.set(1e3, i) }, xa.prototype.clear = function () { var t = this.horiz.parentNode; t.removeChild(this.horiz), t.removeChild(this.vert) }; var wa = function () { }; wa.prototype.update = function () { return { bottom: 0, right: 0 } }, wa.prototype.setScrollLeft = function () { }, wa.prototype.setScrollTop = function () { }, wa.prototype.clear = function () { }; var Ca = { native: xa, null: wa }, ka = 0, Sa = function (t, e, n) { var i = t.display; this.viewport = e, this.visible = Hn(i, t.doc, e), this.editorIsHidden = !i.wrapper.offsetWidth, this.wrapperHeight = i.wrapper.clientHeight, this.wrapperWidth = i.wrapper.clientWidth, this.oldDisplayWidth = Re(t), this.force = n, this.dims = wn(t), this.events = [] }; Sa.prototype.signal = function (t, e) { At(t, e) && this.events.push(arguments) }, Sa.prototype.finish = function () { for (var t = this, e = 0; e < this.events.length; e++)Mt.apply(null, t.events[e]) }; var Ta = 0, Ma = null; vs ? Ma = -.53 : fs ? Ma = 15 : ws ? Ma = -.7 : ks && (Ma = -1 / 3); var Ea = function (t, e) { this.ranges = t, this.primIndex = e }; Ea.prototype.primary = function () { return this.ranges[this.primIndex] }, Ea.prototype.equals = function (t) { var e = this; if (t == this) return !0; if (t.primIndex != this.primIndex || t.ranges.length != this.ranges.length) return !1; for (var n = 0; n < this.ranges.length; n++) { var i = e.ranges[n], r = t.ranges[n]; if (!$(i.anchor, r.anchor) || !$(i.head, r.head)) return !1 } return !0 }, Ea.prototype.deepCopy = function () { for (var t = this, e = [], n = 0; n < this.ranges.length; n++)e[n] = new Pa(z(t.ranges[n].anchor), z(t.ranges[n].head)); return new Ea(e, this.primIndex) }, Ea.prototype.somethingSelected = function () { for (var t = this, e = 0; e < this.ranges.length; e++)if (!t.ranges[e].empty()) return !0; return !1 }, Ea.prototype.contains = function (t, e) { var n = this; e || (e = t); for (var i = 0; i < this.ranges.length; i++) { var r = n.ranges[i]; if (F(e, r.from()) >= 0 && F(t, r.to()) <= 0) return i } return -1 }; var Pa = function (t, e) { this.anchor = t, this.head = e }; Pa.prototype.from = function () { return R(this.anchor, this.head) }, Pa.prototype.to = function () { return H(this.anchor, this.head) }, Pa.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch }, Vr.prototype = { chunkSize: function () { return this.lines.length }, removeInner: function (t, e) { for (var n = this, i = t, r = t + e; i < r; ++i) { var o = n.lines[i]; n.height -= o.height, se(o), xe(o, "delete") } this.lines.splice(t, e) }, collapse: function (t) { t.push.apply(t, this.lines) }, insertInner: function (t, e, n) { var i = this; this.height += n, this.lines = this.lines.slice(0, t).concat(e).concat(this.lines.slice(t)); for (var r = 0; r < e.length; ++r)e[r].parent = i }, iterN: function (t, e, n) { for (var i = this, r = t + e; t < r; ++t)if (n(i.lines[t])) return !0 } }, jr.prototype = { chunkSize: function () { return this.size }, removeInner: function (t, e) { var n = this; this.size -= e; for (var i = 0; i < this.children.length; ++i) { var r = n.children[i], o = r.chunkSize(); if (t < o) { var s = Math.min(e, o - t), a = r.height; if (r.removeInner(t, s), n.height -= a - r.height, o == s && (n.children.splice(i--, 1), r.parent = null), 0 == (e -= s)) break; t = 0 } else t -= o } if (this.size - e < 25 && (this.children.length > 1 || !(this.children[0] instanceof Vr))) { var l = []; this.collapse(l), this.children = [new Vr(l)], this.children[0].parent = this } }, collapse: function (t) { for (var e = this, n = 0; n < this.children.length; ++n)e.children[n].collapse(t) }, insertInner: function (t, e, n) { var i = this; this.size += e.length, this.height += n; for (var r = 0; r < this.children.length; ++r) { var o = i.children[r], s = o.chunkSize(); if (t <= s) { if (o.insertInner(t, e, n), o.lines && o.lines.length > 50) { for (var a = o.lines.length % 25 + 25, l = a; l < o.lines.length;) { var c = new Vr(o.lines.slice(l, l += 25)); o.height -= c.height, i.children.splice(++r, 0, c), c.parent = i } o.lines = o.lines.slice(0, a), i.maybeSpill() } break } t -= s } }, maybeSpill: function () { if (!(this.children.length <= 10)) { var t = this; do { var e = t.children.splice(t.children.length - 5, 5), n = new jr(e); if (t.parent) { t.size -= n.size, t.height -= n.height; var i = d(t.parent.children, t); t.parent.children.splice(i + 1, 0, n) } else { var r = new jr(t.children); r.parent = t, t.children = [r, n], t = r } n.parent = t.parent } while (t.children.length > 10); t.parent.maybeSpill() } }, iterN: function (t, e, n) { for (var i = this, r = 0; r < this.children.length; ++r) { var o = i.children[r], s = o.chunkSize(); if (t < s) { var a = Math.min(e, s - t); if (o.iterN(t, a, n)) return !0; if (0 == (e -= a)) break; t = 0 } else t -= s } } }; var Aa = function (t, e, n) { var i = this; if (n) for (var r in n) n.hasOwnProperty(r) && (i[r] = n[r]); this.doc = t, this.node = e }; Aa.prototype.clear = function () { var t = this, e = this.doc.cm, n = this.line.widgets, i = this.line, r = O(i); if (null != r && n) { for (var o = 0; o < n.length; ++o)n[o] == t && n.splice(o--, 1); n.length || (i.widgets = null); var s = Ie(this); L(i, Math.max(0, i.height - s)), e && (fi(e, function () { Br(e, i, -s), yi(e, r, "widget") }), xe(e, "lineWidgetCleared", e, this, r)) } }, Aa.prototype.changed = function () { var t = this, e = this.height, n = this.doc.cm, i = this.line; this.height = null; var r = Ie(this) - e; r && (L(i, i.height + r), n && fi(n, function () { n.curOp.forceUpdate = !0, Br(n, i, r), xe(n, "lineWidgetChanged", n, t, O(i)) })) }, Lt(Aa); var La = 0, Oa = function (t, e) { this.lines = [], this.type = e, this.doc = t, this.id = ++La }; Oa.prototype.clear = function () { var t = this; if (!this.explicitlyCleared) { var e = this.doc.cm, n = e && !e.curOp; if (n && oi(e), At(this, "clear")) { var i = this.find(); i && xe(this, "clear", i.from, i.to) } for (var r = null, o = null, s = 0; s < this.lines.length; ++s) { var a = t.lines[s], l = G(a.markedSpans, t); e && !t.collapsed ? yi(e, O(a), "text") : e && (null != l.to && (o = O(a)), null != l.from && (r = O(a))), a.markedSpans = Y(a.markedSpans, l), null == l.from && t.collapsed && !mt(t.doc, a) && e && L(a, bn(e.display)) } if (e && this.collapsed && !e.options.lineWrapping) for (var c = 0; c < this.lines.length; ++c) { var u = ht(t.lines[c]), h = bt(u); h > e.display.maxLineLength && (e.display.maxLine = u, e.display.maxLineLength = h, e.display.maxLineChanged = !0) } null != r && e && this.collapsed && vi(e, r, o + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, e && kr(e.doc)), e && xe(e, "markerCleared", e, this, r, o), n && si(e), this.parent && this.parent.clear() } }, Oa.prototype.find = function (t, e) { var n = this; null == t && "bookmark" == this.type && (t = 1); for (var i, r, o = 0; o < this.lines.length; ++o) { var s = n.lines[o], a = G(s.markedSpans, n); if (null != a.from && (i = _(e ? s : O(s), a.from), -1 == t)) return i; if (null != a.to && (r = _(e ? s : O(s), a.to), 1 == t)) return r } return i && { from: i, to: r } }, Oa.prototype.changed = function () { var t = this, e = this.find(-1, !0), n = this, i = this.doc.cm; e && i && fi(i, function () { var r = e.line, o = O(e.line), s = qe(i, o); if (s && (Qe(s), i.curOp.selectionChanged = i.curOp.forceUpdate = !0), i.curOp.updateMaxLine = !0, !mt(n.doc, r) && null != n.height) { var a = n.height; n.height = null; var l = Ie(n) - a; l && L(r, r.height + l) } xe(i, "markerChanged", i, t) }) }, Oa.prototype.attachLine = function (t) { if (!this.lines.length && this.doc.cm) { var e = this.doc.cm.curOp; e.maybeHiddenMarkers && -1 != d(e.maybeHiddenMarkers, this) || (e.maybeUnhiddenMarkers || (e.maybeUnhiddenMarkers = [])).push(this) } this.lines.push(t) }, Oa.prototype.detachLine = function (t) { if (this.lines.splice(d(this.lines, t), 1), !this.lines.length && this.doc.cm) { var e = this.doc.cm.curOp; (e.maybeHiddenMarkers || (e.maybeHiddenMarkers = [])).push(this) } }, Lt(Oa); var Na = function (t, e) { var n = this; this.markers = t, this.primary = e; for (var i = 0; i < t.length; ++i)t[i].parent = n }; Na.prototype.clear = function () { var t = this; if (!this.explicitlyCleared) { this.explicitlyCleared = !0; for (var e = 0; e < this.markers.length; ++e)t.markers[e].clear(); xe(this, "clear") } }, Na.prototype.find = function (t, e) { return this.primary.find(t, e) }, Lt(Na); var Da = 0, Ia = function (t, e, n, i, r) { if (!(this instanceof Ia)) return new Ia(t, e, n, i, r); null == n && (n = 0), jr.call(this, [new Vr([new fa("", null)])]), this.first = n, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = n; var o = _(n, 0); this.sel = Ri(o), this.history = new tr(null), this.id = ++Da, this.modeOption = e, this.lineSep = i, this.direction = "rtl" == r ? "rtl" : "ltr", this.extend = !1, "string" == typeof t && (t = this.splitLines(t)), Yi(this, { from: o, to: o, text: t }), xr(this, Ri(o), Bs) }; Ia.prototype = b(jr.prototype, { constructor: Ia, iter: function (t, e, n) { n ? this.iterN(t - this.first, e - t, n) : this.iterN(this.first, this.first + this.size, t) }, insert: function (t, e) { for (var n = 0, i = 0; i < e.length; ++i)n += e[i].height; this.insertInner(t - this.first, e, n) }, remove: function (t, e) { this.removeInner(t - this.first, e) }, getValue: function (t) { var e = A(this, this.first, this.first + this.size); return !1 === t ? e : e.join(t || this.lineSeparator()) }, setValue: mi(function (t) { var e = _(this.first, 0), n = this.first + this.size - 1; Lr(this, { from: e, to: _(n, E(this, n).text.length), text: this.splitLines(t), origin: "setValue", full: !0 }, !0), this.cm && Gn(this.cm, 0, 0), xr(this, Ri(e), Bs) }), replaceRange: function (t, e, n, i) { e = j(this, e), n = n ? j(this, n) : e, Fr(this, t, e, n, i) }, getRange: function (t, e, n) { var i = P(this, j(this, t), j(this, e)); return !1 === n ? i : i.join(n || this.lineSeparator()) }, getLine: function (t) { var e = this.getLineHandle(t); return e && e.text }, getLineHandle: function (t) { if (D(this, t)) return E(this, t) }, getLineNumber: function (t) { return O(t) }, getLineHandleVisualStart: function (t) { return "number" == typeof t && (t = E(this, t)), ht(t) }, lineCount: function () { return this.size }, firstLine: function () { return this.first }, lastLine: function () { return this.first + this.size - 1 }, clipPos: function (t) { return j(this, t) }, getCursor: function (t) { var e = this.sel.primary(); return null == t || "head" == t ? e.head : "anchor" == t ? e.anchor : "end" == t || "to" == t || !1 === t ? e.to() : e.from() }, listSelections: function () { return this.sel.ranges }, somethingSelected: function () { return this.sel.somethingSelected() }, setCursor: mi(function (t, e, n) { vr(this, j(this, "number" == typeof t ? _(t, e || 0) : t), null, n) }), setSelection: mi(function (t, e, n) { vr(this, j(this, t), j(this, e || t), n) }), extendSelection: mi(function (t, e, n) { pr(this, j(this, t), e && j(this, e), n) }), extendSelections: mi(function (t, e) { gr(this, W(this, t), e) }), extendSelectionsBy: mi(function (t, e) { gr(this, W(this, m(this.sel.ranges, t)), e) }), setSelections: mi(function (t, e, n) { var i = this; if (t.length) { for (var r = [], o = 0; o < t.length; o++)r[o] = new Pa(j(i, t[o].anchor), j(i, t[o].head)); null == e && (e = Math.min(t.length - 1, this.sel.primIndex)), xr(this, Hi(r, e), n) } }), addSelection: mi(function (t, e, n) { var i = this.sel.ranges.slice(0); i.push(new Pa(j(this, t), j(this, e || t))), xr(this, Hi(i, i.length - 1), n) }), getSelection: function (t) { for (var e, n = this, i = this.sel.ranges, r = 0; r < i.length; r++) { var o = P(n, i[r].from(), i[r].to()); e = e ? e.concat(o) : o } return !1 === t ? e : e.join(t || this.lineSeparator()) }, getSelections: function (t) { for (var e = this, n = [], i = this.sel.ranges, r = 0; r < i.length; r++) { var o = P(e, i[r].from(), i[r].to()); !1 !== t && (o = o.join(t || e.lineSeparator())), n[r] = o } return n }, replaceSelection: function (t, e, n) { for (var i = [], r = 0; r < this.sel.ranges.length; r++)i[r] = t; this.replaceSelections(i, e, n || "+input") }, replaceSelections: mi(function (t, e, n) { for (var i = this, r = [], o = this.sel, s = 0; s < o.ranges.length; s++) { var a = o.ranges[s]; r[s] = { from: a.from(), to: a.to(), text: i.splitLines(t[s]), origin: n } } for (var l = e && "end" != e && Ui(this, r, e), c = r.length - 1; c >= 0; c--)Lr(i, r[c]); l ? br(this, l) : this.cm && Kn(this.cm) }), undo: mi(function () { Nr(this, "undo") }), redo: mi(function () { Nr(this, "redo") }), undoSelection: mi(function () { Nr(this, "undo", !0) }), redoSelection: mi(function () { Nr(this, "redo", !0) }), setExtending: function (t) { this.extend = t }, getExtending: function () { return this.extend }, historySize: function () { for (var t = this.history, e = 0, n = 0, i = 0; i < t.done.length; i++)t.done[i].ranges || ++e; for (var r = 0; r < t.undone.length; r++)t.undone[r].ranges || ++n; return { undo: e, redo: n } }, clearHistory: function () { this.history = new tr(this.history.maxGeneration) }, markClean: function () { this.cleanGeneration = this.changeGeneration(!0) }, changeGeneration: function (t) { return t && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation }, isClean: function (t) { return this.history.generation == (t || this.cleanGeneration) }, getHistory: function () { return { done: dr(this.history.done), undone: dr(this.history.undone) } }, setHistory: function (t) { var e = this.history = new tr(this.history.maxGeneration); e.done = dr(t.done.slice(0), null, !0), e.undone = dr(t.undone.slice(0), null, !0) }, setGutterMarker: mi(function (t, e, n) { return Rr(this, t, "gutter", function (t) { var i = t.gutterMarkers || (t.gutterMarkers = {}); return i[e] = n, !n && C(i) && (t.gutterMarkers = null), !0 }) }), clearGutter: mi(function (t) { var e = this; this.iter(function (n) { n.gutterMarkers && n.gutterMarkers[t] && Rr(e, n, "gutter", function () { return n.gutterMarkers[t] = null, C(n.gutterMarkers) && (n.gutterMarkers = null), !0 }) }) }), lineInfo: function (t) { var e; if ("number" == typeof t) { if (!D(this, t)) return null; if (e = t, !(t = E(this, t))) return null } else if (null == (e = O(t))) return null; return { line: e, handle: t, text: t.text, gutterMarkers: t.gutterMarkers, textClass: t.textClass, bgClass: t.bgClass, wrapClass: t.wrapClass, widgets: t.widgets } }, addLineClass: mi(function (e, n, i) { return Rr(this, e, "gutter" == n ? "gutter" : "class", function (e) { var r = "text" == n ? "textClass" : "background" == n ? "bgClass" : "gutter" == n ? "gutterClass" : "wrapClass"; if (e[r]) { if (t(i).test(e[r])) return !1; e[r] += " " + i } else e[r] = i; return !0 }) }), removeLineClass: mi(function (e, n, i) { return Rr(this, e, "gutter" == n ? "gutter" : "class", function (e) { var r = "text" == n ? "textClass" : "background" == n ? "bgClass" : "gutter" == n ? "gutterClass" : "wrapClass", o = e[r]; if (!o) return !1; if (null == i) e[r] = null; else { var s = o.match(t(i)); if (!s) return !1; var a = s.index + s[0].length; e[r] = o.slice(0, s.index) + (s.index && a != o.length ? " " : "") + o.slice(a) || null } return !0 }) }), addLineWidget: mi(function (t, e, n) { return Wr(this, t, e, n) }), removeLineWidget: function (t) { t.clear() }, markText: function (t, e, n) { return Ur(this, j(this, t), j(this, e), n, n && n.type || "range") }, setBookmark: function (t, e) { var n = { replacedWith: e && (null == e.nodeType ? e.widget : e), insertLeft: e && e.insertLeft, clearWhenEmpty: !1, shared: e && e.shared, handleMouseEvents: e && e.handleMouseEvents }; return t = j(this, t), Ur(this, t, t, n, "bookmark") }, findMarksAt: function (t) { t = j(this, t); var e = [], n = E(this, t.line).markedSpans; if (n) for (var i = 0; i < n.length; ++i) { var r = n[i]; (null == r.from || r.from <= t.ch) && (null == r.to || r.to >= t.ch) && e.push(r.marker.parent || r.marker) } return e }, findMarks: function (t, e, n) { t = j(this, t), e = j(this, e); var i = [], r = t.line; return this.iter(t.line, e.line + 1, function (o) { var s = o.markedSpans; if (s) for (var a = 0; a < s.length; a++) { var l = s[a]; null != l.to && r == t.line && t.ch >= l.to || null == l.from && r != t.line || null != l.from && r == e.line && l.from >= e.ch || n && !n(l.marker) || i.push(l.marker.parent || l.marker) } ++r }), i }, getAllMarks: function () { var t = []; return this.iter(function (e) { var n = e.markedSpans; if (n) for (var i = 0; i < n.length; ++i)null != n[i].from && t.push(n[i].marker) }), t }, posFromIndex: function (t) { var e, n = this.first, i = this.lineSeparator().length; return this.iter(function (r) { var o = r.text.length + i; if (o > t) return e = t, !0; t -= o, ++n }), j(this, _(n, e)) }, indexFromPos: function (t) { t = j(this, t); var e = t.ch; if (t.line < this.first || t.ch < 0) return 0; var n = this.lineSeparator().length; return this.iter(this.first, t.line, function (t) { e += t.text.length + n }), e }, copy: function (t) { var e = new Ia(A(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction); return e.scrollTop = this.scrollTop, e.scrollLeft = this.scrollLeft, e.sel = this.sel, e.extend = !1, t && (e.history.undoDepth = this.history.undoDepth, e.setHistory(this.getHistory())), e }, linkedDoc: function (t) { t || (t = {}); var e = this.first, n = this.first + this.size; null != t.from && t.from > e && (e = t.from), null != t.to && t.to < n && (n = t.to); var i = new Ia(A(this, e, n), t.mode || this.modeOption, e, this.lineSep, this.direction); return t.sharedHist && (i.history = this.history), (this.linked || (this.linked = [])).push({ doc: i, sharedHist: t.sharedHist }), i.linked = [{ doc: this, isParent: !0, sharedHist: t.sharedHist }], Gr(i, Kr(this)), i }, unlinkDoc: function (t) { var e = this; if (t instanceof qo && (t = t.doc), this.linked) for (var n = 0; n < this.linked.length; ++n) { var i = e.linked[n]; if (i.doc == t) { e.linked.splice(n, 1), t.unlinkDoc(e), Yr(Kr(e)); break } } if (t.history == this.history) { var r = [t.id]; Xi(t, function (t) { return r.push(t.id) }, !0), t.history = new tr(null), t.history.done = dr(this.history.done, r), t.history.undone = dr(this.history.undone, r) } }, iterLinkedDocs: function (t) { Xi(this, t) }, getMode: function () { return this.mode }, getEditor: function () { return this.cm }, splitLines: function (t) { return this.lineSep ? t.split(this.lineSep) : na(t) }, lineSeparator: function () { return this.lineSep || "\n" }, setDirection: mi(function (t) { "rtl" != t && (t = "ltr"), t != this.direction && (this.direction = t, this.iter(function (t) { return t.order = null }), this.cm && Qi(this.cm)) }) }), Ia.prototype.eachLine = Ia.prototype.iter; for (var _a = 0, Fa = !1, $a = { 3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete", 63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert" }, za = 0; za < 10; za++)$a[za + 48] = $a[za + 96] = String(za); for (var Ha = 65; Ha <= 90; Ha++)$a[Ha] = String.fromCharCode(Ha); for (var Ra = 1; Ra <= 12; Ra++)$a[Ra + 111] = $a[Ra + 63235] = "F" + Ra; var Va = {}; Va.basic = { Left: "goCharLeft", Right: "goCharRight", Up: "goLineUp", Down: "goLineDown", End: "goLineEnd", Home: "goLineStartSmart", PageUp: "goPageUp", PageDown: "goPageDown", Delete: "delCharAfter", Backspace: "delCharBefore", "Shift-Backspace": "delCharBefore", Tab: "defaultTab", "Shift-Tab": "indentAuto", Enter: "newlineAndIndent", Insert: "toggleOverwrite", Esc: "singleSelection" }, Va.pcDefault = { "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo", "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown", "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd", "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find", "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll", "Ctrl-[": "indentLess", "Ctrl-]": "indentMore", "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection", fallthrough: "basic" }, Va.emacsy = { "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown", "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd", "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore", "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars", "Ctrl-O": "openLine" }, Va.macDefault = { "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo", "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft", "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore", "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find", "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll", "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight", "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd", fallthrough: ["basic", "emacsy"] }, Va.default = As ? Va.macDefault : Va.pcDefault; var ja = { selectAll: Pr, singleSelection: function (t) { return t.setSelection(t.getCursor("anchor"), t.getCursor("head"), Bs) }, killLine: function (t) { return ho(t, function (e) { if (e.empty()) { var n = E(t.doc, e.head.line).text.length; return e.head.ch == n && e.head.line < t.lastLine() ? { from: e.head, to: _(e.head.line + 1, 0) } : { from: e.head, to: _(e.head.line, n) } } return { from: e.from(), to: e.to() } }) }, deleteLine: function (t) { return ho(t, function (e) { return { from: _(e.from().line, 0), to: j(t.doc, _(e.to().line + 1, 0)) } }) }, delLineLeft: function (t) { return ho(t, function (t) { return { from: _(t.from().line, 0), to: t.from() } }) }, delWrappedLineLeft: function (t) { return ho(t, function (e) { var n = t.charCoords(e.head, "div").top + 5; return { from: t.coordsChar({ left: 0, top: n }, "div"), to: e.from() } }) }, delWrappedLineRight: function (t) { return ho(t, function (e) { var n = t.charCoords(e.head, "div").top + 5, i = t.coordsChar({ left: t.display.lineDiv.offsetWidth + 100, top: n }, "div"); return { from: e.from(), to: i } }) }, undo: function (t) { return t.undo() }, redo: function (t) { return t.redo() }, undoSelection: function (t) { return t.undoSelection() }, redoSelection: function (t) { return t.redoSelection() }, goDocStart: function (t) { return t.extendSelection(_(t.firstLine(), 0)) }, goDocEnd: function (t) { return t.extendSelection(_(t.lastLine())) }, goLineStart: function (t) { return t.extendSelectionsBy(function (e) { return vo(t, e.head.line) }, { origin: "+move", bias: 1 }) }, goLineStartSmart: function (t) { return t.extendSelectionsBy(function (e) { return bo(t, e.head) }, { origin: "+move", bias: 1 }) }, goLineEnd: function (t) { return t.extendSelectionsBy(function (e) { return yo(t, e.head.line) }, { origin: "+move", bias: -1 }) }, goLineRight: function (t) { return t.extendSelectionsBy(function (e) { var n = t.cursorCoords(e.head, "div").top + 5; return t.coordsChar({ left: t.display.lineDiv.offsetWidth + 100, top: n }, "div") }, Us) }, goLineLeft: function (t) { return t.extendSelectionsBy(function (e) { var n = t.cursorCoords(e.head, "div").top + 5; return t.coordsChar({ left: 0, top: n }, "div") }, Us) }, goLineLeftSmart: function (t) { return t.extendSelectionsBy(function (e) { var n = t.cursorCoords(e.head, "div").top + 5, i = t.coordsChar({ left: 0, top: n }, "div"); return i.ch < t.getLine(i.line).search(/\S/) ? bo(t, e.head) : i }, Us) }, goLineUp: function (t) { return t.moveV(-1, "line") }, goLineDown: function (t) { return t.moveV(1, "line") }, goPageUp: function (t) { return t.moveV(-1, "page") }, goPageDown: function (t) { return t.moveV(1, "page") }, goCharLeft: function (t) { return t.moveH(-1, "char") }, goCharRight: function (t) { return t.moveH(1, "char") }, goColumnLeft: function (t) { return t.moveH(-1, "column") }, goColumnRight: function (t) { return t.moveH(1, "column") }, goWordLeft: function (t) { return t.moveH(-1, "word") }, goGroupRight: function (t) { return t.moveH(1, "group") }, goGroupLeft: function (t) { return t.moveH(-1, "group") }, goWordRight: function (t) { return t.moveH(1, "word") }, delCharBefore: function (t) { return t.deleteH(-1, "char") }, delCharAfter: function (t) { return t.deleteH(1, "char") }, delWordBefore: function (t) { return t.deleteH(-1, "word") }, delWordAfter: function (t) { return t.deleteH(1, "word") }, delGroupBefore: function (t) { return t.deleteH(-1, "group") }, delGroupAfter: function (t) { return t.deleteH(1, "group") }, indentAuto: function (t) { return t.indentSelection("smart") }, indentMore: function (t) { return t.indentSelection("add") }, indentLess: function (t) { return t.indentSelection("subtract") }, insertTab: function (t) { return t.replaceSelection("\t") }, insertSoftTab: function (t) { for (var e = [], n = t.listSelections(), i = t.options.tabSize, r = 0; r < n.length; r++) { var o = n[r].from(), s = h(t.getLine(o.line), o.ch, i); e.push(p(i - s % i)) } t.replaceSelections(e) }, defaultTab: function (t) { t.somethingSelected() ? t.indentSelection("add") : t.execCommand("insertTab") }, transposeChars: function (t) { return fi(t, function () { for (var e = t.listSelections(), n = [], i = 0; i < e.length; i++)if (e[i].empty()) { var r = e[i].head, o = E(t.doc, r.line).text; if (o) if (r.ch == o.length && (r = new _(r.line, r.ch - 1)), r.ch > 0) r = new _(r.line, r.ch + 1), t.replaceRange(o.charAt(r.ch - 1) + o.charAt(r.ch - 2), _(r.line, r.ch - 2), r, "+transpose"); else if (r.line > t.doc.first) { var s = E(t.doc, r.line - 1).text; s && (r = new _(r.line, 1), t.replaceRange(o.charAt(0) + t.doc.lineSeparator() + s.charAt(s.length - 1), _(r.line - 1, s.length - 1), r, "+transpose")) } n.push(new Pa(r, r)) } t.setSelections(n) }) }, newlineAndIndent: function (t) { return fi(t, function () { for (var e = t.listSelections(), n = e.length - 1; n >= 0; n--)t.replaceRange(t.doc.lineSeparator(), e[n].anchor, e[n].head, "+input"); e = t.listSelections(); for (var i = 0; i < e.length; i++)t.indentLine(e[i].from().line, null, !0); Kn(t) }) }, openLine: function (t) { return t.replaceSelection("\n", "start") }, toggleOverwrite: function (t) { return t.toggleOverwrite() } }, Ba = new zs, Wa = null, Ua = function (t, e, n) { this.time = t, this.pos = e, this.button = n }; Ua.prototype.compare = function (t, e, n) { return this.time + 400 > t && 0 == F(e, this.pos) && n == this.button }; var qa, Ka, Ga = { toString: function () { return "CodeMirror.Init" } }, Ya = {}, Xa = {}; qo.defaults = Ya, qo.optionHandlers = Xa; var Ja = []; qo.defineInitHook = function (t) { return Ja.push(t) }; var Za = null, Qa = function (t) { this.cm = t, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new zs, this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null }; Qa.prototype.init = function (t) { function e(t) { if (!Et(r, t)) { if (r.somethingSelected()) Yo({ lineWise: !1, text: r.getSelections() }), "cut" == t.type && r.replaceSelection("", null, "cut"); else { if (!r.options.lineWiseCopyCut) return; var e = Qo(r); Yo({ lineWise: !0, text: e.text }), "cut" == t.type && r.operation(function () { r.setSelections(e.ranges, 0, Bs), r.replaceSelection("", null, "cut") }) } if (t.clipboardData) { t.clipboardData.clearData(); var n = Za.text.join("\n"); if (t.clipboardData.setData("Text", n), t.clipboardData.getData("Text") == n) return void t.preventDefault() } var s = es(), a = s.firstChild; r.display.lineSpace.insertBefore(s, r.display.lineSpace.firstChild), a.value = Za.text.join("\n"); var l = document.activeElement; $s(a), setTimeout(function () { r.display.lineSpace.removeChild(s), l.focus(), l == o && i.showPrimarySelection() }, 50) } } var n = this, i = this, r = i.cm, o = i.div = t.lineDiv; ts(o, r.options.spellcheck), ta(o, "paste", function (t) { Et(r, t) || Jo(t, r) || ys <= 11 && setTimeout(pi(r, function () { return n.updateFromDOM() }), 20) }), ta(o, "compositionstart", function (t) { n.composing = { data: t.data, done: !1 } }), ta(o, "compositionupdate", function (t) { n.composing || (n.composing = { data: t.data, done: !1 }) }), ta(o, "compositionend", function (t) { n.composing && (t.data != n.composing.data && n.readFromDOMSoon(), n.composing.done = !0) }), ta(o, "touchstart", function () { return i.forceCompositionEnd() }), ta(o, "input", function () { n.composing || n.readFromDOMSoon() }), ta(o, "copy", e), ta(o, "cut", e) }, Qa.prototype.prepareSelection = function () { var t = Pn(this.cm, !1); return t.focus = this.cm.state.focused, t }, Qa.prototype.showSelection = function (t, e) { t && this.cm.display.view.length && ((t.focus || e) && this.showPrimarySelection(), this.showMultipleSelections(t)) }, Qa.prototype.showPrimarySelection = function () { var t = window.getSelection(), e = this.cm, n = e.doc.sel.primary(), i = n.from(), r = n.to(); if (e.display.viewTo == e.display.viewFrom || i.line >= e.display.viewTo || r.line < e.display.viewFrom) return void t.removeAllRanges(); var o = ls(e, t.anchorNode, t.anchorOffset), s = ls(e, t.focusNode, t.focusOffset); if (!o || o.bad || !s || s.bad || 0 != F(R(o, s), i) || 0 != F(H(o, s), r)) { var a = e.display.view, l = i.line >= e.display.viewFrom && rs(e, i) || { node: a[0].measure.map[2], offset: 0 }, c = r.line < e.display.viewTo && rs(e, r); if (!c) { var u = a[a.length - 1].measure, h = u.maps ? u.maps[u.maps.length - 1] : u.map; c = { node: h[h.length - 1], offset: h[h.length - 2] - h[h.length - 3] } } if (!l || !c) return void t.removeAllRanges(); var d, f = t.rangeCount && t.getRangeAt(0); try { d = Ds(l.node, l.offset, c.offset, c.node) } catch (t) { } d && (!fs && e.state.focused ? (t.collapse(l.node, l.offset), d.collapsed || (t.removeAllRanges(), t.addRange(d))) : (t.removeAllRanges(), t.addRange(d)), f && null == t.anchorNode ? t.addRange(f) : fs && this.startGracePeriod()), this.rememberSelection() } }, Qa.prototype.startGracePeriod = function () { var t = this; clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function () { t.gracePeriod = !1, t.selectionChanged() && t.cm.operation(function () { return t.cm.curOp.selectionChanged = !0 }) }, 20) }, Qa.prototype.showMultipleSelections = function (t) { n(this.cm.display.cursorDiv, t.cursors), n(this.cm.display.selectionDiv, t.selection) }, Qa.prototype.rememberSelection = function () { var t = window.getSelection(); this.lastAnchorNode = t.anchorNode, this.lastAnchorOffset = t.anchorOffset, this.lastFocusNode = t.focusNode, this.lastFocusOffset = t.focusOffset }, Qa.prototype.selectionInEditor = function () { var t = window.getSelection(); if (!t.rangeCount) return !1; var e = t.getRangeAt(0).commonAncestorContainer; return o(this.div, e) }, Qa.prototype.focus = function () { "nocursor" != this.cm.options.readOnly && (this.selectionInEditor() || this.showSelection(this.prepareSelection(), !0), this.div.focus()) }, Qa.prototype.blur = function () { this.div.blur() }, Qa.prototype.getField = function () { return this.div }, Qa.prototype.supportsTouch = function () { return !0 }, Qa.prototype.receivedFocus = function () { function t() { e.cm.state.focused && (e.pollSelection(), e.polling.set(e.cm.options.pollInterval, t)) } var e = this; this.selectionInEditor() ? this.pollSelection() : fi(this.cm, function () { return e.cm.curOp.selectionChanged = !0 }), this.polling.set(this.cm.options.pollInterval, t) }, Qa.prototype.selectionChanged = function () { var t = window.getSelection(); return t.anchorNode != this.lastAnchorNode || t.anchorOffset != this.lastAnchorOffset || t.focusNode != this.lastFocusNode || t.focusOffset != this.lastFocusOffset }, Qa.prototype.pollSelection = function () { if (null == this.readDOMTimeout && !this.gracePeriod && this.selectionChanged()) { var t = window.getSelection(), e = this.cm; if (Es && ws && this.cm.options.gutters.length && os(t.anchorNode)) return this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs }), this.blur(), void this.focus(); if (!this.composing) { this.rememberSelection(); var n = ls(e, t.anchorNode, t.anchorOffset), i = ls(e, t.focusNode, t.focusOffset); n && i && fi(e, function () { xr(e.doc, Ri(n, i), Bs), (n.bad || i.bad) && (e.curOp.selectionChanged = !0) }) } } }, Qa.prototype.pollContent = function () { null != this.readDOMTimeout && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null); var t = this.cm, e = t.display, n = t.doc.sel.primary(), i = n.from(), r = n.to(); if (0 == i.ch && i.line > t.firstLine() && (i = _(i.line - 1, E(t.doc, i.line - 1).length)), r.ch == E(t.doc, r.line).text.length && r.line < t.lastLine() && (r = _(r.line + 1, 0)), i.line < e.viewFrom || r.line > e.viewTo - 1) return !1; var o, s, a; i.line == e.viewFrom || 0 == (o = Mn(t, i.line)) ? (s = O(e.view[0].line), a = e.view[0].node) : (s = O(e.view[o].line), a = e.view[o - 1].node.nextSibling); var l, c, u = Mn(t, r.line); if (u == e.view.length - 1 ? (l = e.viewTo - 1, c = e.lineDiv.lastChild) : (l = O(e.view[u + 1].line) - 1, c = e.view[u + 1].node.previousSibling), !a) return !1; for (var h = t.doc.splitLines(as(t, a, c, s, l)), d = P(t.doc, _(s, 0), _(l, E(t.doc, l).text.length)); h.length > 1 && d.length > 1;)if (g(h) == g(d)) h.pop(), d.pop(), l--; else { if (h[0] != d[0]) break; h.shift(), d.shift(), s++ } for (var f = 0, p = 0, m = h[0], v = d[0], y = Math.min(m.length, v.length); f < y && m.charCodeAt(f) == v.charCodeAt(f);)++f; for (var b = g(h), x = g(d), w = Math.min(b.length - (1 == h.length ? f : 0), x.length - (1 == d.length ? f : 0)); p < w && b.charCodeAt(b.length - p - 1) == x.charCodeAt(x.length - p - 1);)++p; if (1 == h.length && 1 == d.length && s == i.line) for (; f && f > i.ch && b.charCodeAt(b.length - p - 1) == x.charCodeAt(x.length - p - 1);)f-- , p++; h[h.length - 1] = b.slice(0, b.length - p).replace(/^\u200b+/, ""), h[0] = h[0].slice(f).replace(/\u200b+$/, ""); var C = _(s, f), k = _(l, d.length ? g(d).length - p : 0); return h.length > 1 || h[0] || F(C, k) ? (Fr(t.doc, h, C, k, "+input"), !0) : void 0 }, Qa.prototype.ensurePolled = function () { this.forceCompositionEnd() }, Qa.prototype.reset = function () { this.forceCompositionEnd() }, Qa.prototype.forceCompositionEnd = function () { this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus()) }, Qa.prototype.readFromDOMSoon = function () { var t = this; null == this.readDOMTimeout && (this.readDOMTimeout = setTimeout(function () { if (t.readDOMTimeout = null, t.composing) { if (!t.composing.done) return; t.composing = null } t.updateFromDOM() }, 80)) }, Qa.prototype.updateFromDOM = function () { var t = this; !this.cm.isReadOnly() && this.pollContent() || fi(this.cm, function () { return vi(t.cm) }) }, Qa.prototype.setUneditable = function (t) { t.contentEditable = "false" }, Qa.prototype.onKeyPress = function (t) { 0 != t.charCode && (t.preventDefault(), this.cm.isReadOnly() || pi(this.cm, Xo)(this.cm, String.fromCharCode(null == t.charCode ? t.keyCode : t.charCode), 0)) }, Qa.prototype.readOnlyChanged = function (t) { this.div.contentEditable = String("nocursor" != t) }, Qa.prototype.onContextMenu = function () { }, Qa.prototype.resetPosition = function () { }, Qa.prototype.needsContentAttribute = !0; var tl = function (t) { this.cm = t, this.prevInput = "", this.pollingFast = !1, this.polling = new zs, this.hasSelection = !1, this.composing = null }; tl.prototype.init = function (t) { function e(t) { if (!Et(r, t)) { if (r.somethingSelected()) Yo({ lineWise: !1, text: r.getSelections() }); else { if (!r.options.lineWiseCopyCut) return; var e = Qo(r); Yo({ lineWise: !0, text: e.text }), "cut" == t.type ? r.setSelections(e.ranges, null, Bs) : (i.prevInput = "", s.value = e.text.join("\n"), $s(s)) } "cut" == t.type && (r.state.cutIncoming = !0) } } var n = this, i = this, r = this.cm, o = this.wrapper = es(), s = this.textarea = o.firstChild; t.wrapper.insertBefore(o, t.wrapper.firstChild), Ms && (s.style.width = "0px"), ta(s, "input", function () { vs && ys >= 9 && n.hasSelection && (n.hasSelection = null), i.poll() }), ta(s, "paste", function (t) { Et(r, t) || Jo(t, r) || (r.state.pasteIncoming = !0, i.fastPoll()) }), ta(s, "cut", e), ta(s, "copy", e), ta(t.scroller, "paste", function (e) { _e(t, e) || Et(r, e) || (r.state.pasteIncoming = !0, i.focus()) }), ta(t.lineSpace, "selectstart", function (e) { _e(t, e) || Ot(e) }), ta(s, "compositionstart", function () { var t = r.getCursor("from"); i.composing && i.composing.range.clear(), i.composing = { start: t, range: r.markText(t, r.getCursor("to"), { className: "CodeMirror-composing" }) } }), ta(s, "compositionend", function () { i.composing && (i.poll(), i.composing.range.clear(), i.composing = null) }) }, tl.prototype.prepareSelection = function () { var t = this.cm, e = t.display, n = t.doc, i = Pn(t); if (t.options.moveInputWithCursor) { var r = cn(t, n.sel.primary().head, "div"), o = e.wrapper.getBoundingClientRect(), s = e.lineDiv.getBoundingClientRect(); i.teTop = Math.max(0, Math.min(e.wrapper.clientHeight - 10, r.top + s.top - o.top)), i.teLeft = Math.max(0, Math.min(e.wrapper.clientWidth - 10, r.left + s.left - o.left)) } return i }, tl.prototype.showSelection = function (t) { var e = this.cm, i = e.display; n(i.cursorDiv, t.cursors), n(i.selectionDiv, t.selection), null != t.teTop && (this.wrapper.style.top = t.teTop + "px", this.wrapper.style.left = t.teLeft + "px") }, tl.prototype.reset = function (t) { if (!this.contextMenuPending && !this.composing) { var e = this.cm; if (e.somethingSelected()) { this.prevInput = ""; var n = e.getSelection(); this.textarea.value = n, e.state.focused && $s(this.textarea), vs && ys >= 9 && (this.hasSelection = n) } else t || (this.prevInput = this.textarea.value = "", vs && ys >= 9 && (this.hasSelection = null)) } }, tl.prototype.getField = function () { return this.textarea }, tl.prototype.supportsTouch = function () { return !1 }, tl.prototype.focus = function () { if ("nocursor" != this.cm.options.readOnly && (!Ps || s() != this.textarea)) try { this.textarea.focus() } catch (t) { } }, tl.prototype.blur = function () { this.textarea.blur() }, tl.prototype.resetPosition = function () { this.wrapper.style.top = this.wrapper.style.left = 0 }, tl.prototype.receivedFocus = function () { this.slowPoll() }, tl.prototype.slowPoll = function () { var t = this; this.pollingFast || this.polling.set(this.cm.options.pollInterval, function () { t.poll(), t.cm.state.focused && t.slowPoll() }) }, tl.prototype.fastPoll = function () { function t() { n.poll() || e ? (n.pollingFast = !1, n.slowPoll()) : (e = !0, n.polling.set(60, t)) } var e = !1, n = this; n.pollingFast = !0, n.polling.set(20, t) }, tl.prototype.poll = function () { var t = this, e = this.cm, n = this.textarea, i = this.prevInput; if (this.contextMenuPending || !e.state.focused || ia(n) && !i && !this.composing || e.isReadOnly() || e.options.disableInput || e.state.keySeq) return !1; var r = n.value; if (r == i && !e.somethingSelected()) return !1; if (vs && ys >= 9 && this.hasSelection === r || As && /[\uf700-\uf7ff]/.test(r)) return e.display.input.reset(), !1; if (e.doc.sel == e.display.selForContextMenu) { var o = r.charCodeAt(0); if (8203 != o || i || (i = ""), 8666 == o) return this.reset(), this.cm.execCommand("undo") } for (var s = 0, a = Math.min(i.length, r.length); s < a && i.charCodeAt(s) == r.charCodeAt(s);)++s; return fi(e, function () { Xo(e, r.slice(s), i.length - s, null, t.composing ? "*compose" : null), r.length > 1e3 || r.indexOf("\n") > -1 ? n.value = t.prevInput = "" : t.prevInput = r, t.composing && (t.composing.range.clear(), t.composing.range = e.markText(t.composing.start, e.getCursor("to"), { className: "CodeMirror-composing" })) }), !0 }, tl.prototype.ensurePolled = function () { this.pollingFast && this.poll() && (this.pollingFast = !1) }, tl.prototype.onKeyPress = function () { vs && ys >= 9 && (this.hasSelection = null), this.fastPoll() }, tl.prototype.onContextMenu = function (t) { function e() { if (null != s.selectionStart) { var t = r.somethingSelected(), e = "" + (t ? s.value : ""); s.value = "", s.value = e, i.prevInput = t ? "" : "", s.selectionStart = 1, s.selectionEnd = e.length, o.selForContextMenu = r.doc.sel } } function n() { if (i.contextMenuPending = !1, i.wrapper.style.cssText = u, s.style.cssText = c, vs && ys < 9 && o.scrollbars.setScrollTop(o.scroller.scrollTop = l), null != s.selectionStart) { (!vs || vs && ys < 9) && e(); var t = 0, n = function () { o.selForContextMenu == r.doc.sel && 0 == s.selectionStart && s.selectionEnd > 0 && "" == i.prevInput ? pi(r, Pr)(r) : t++ < 10 ? o.detectingSelectAll = setTimeout(n, 500) : (o.selForContextMenu = null, o.input.reset()) }; o.detectingSelectAll = setTimeout(n, 200) } } var i = this, r = i.cm, o = r.display, s = i.textarea, a = Tn(r, t), l = o.scroller.scrollTop; if (a && !Cs) { r.options.resetSelectionOnContextMenu && -1 == r.doc.sel.contains(a) && pi(r, xr)(r.doc, Ri(a), Bs); var c = s.style.cssText, u = i.wrapper.style.cssText; i.wrapper.style.cssText = "position: absolute"; var h = i.wrapper.getBoundingClientRect(); s.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (t.clientY - h.top - 5) + "px; left: " + (t.clientX - h.left - 5) + "px;\n      z-index: 1000; background: " + (vs ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);"; var d; if (bs && (d = window.scrollY), o.input.focus(), bs && window.scrollTo(null, d), o.input.reset(), r.somethingSelected() || (s.value = i.prevInput = " "), i.contextMenuPending = !0, o.selForContextMenu = r.doc.sel, clearTimeout(o.detectingSelectAll), vs && ys >= 9 && e(), _s) { It(t); var f = function () { Tt(window, "mouseup", f), setTimeout(n, 20) }; ta(window, "mouseup", f) } else setTimeout(n, 50) } }, tl.prototype.readOnlyChanged = function (t) { t || this.reset(), this.textarea.disabled = "nocursor" == t }, tl.prototype.setUneditable = function () { }, tl.prototype.needsContentAttribute = !1, function (t) { function e(e, i, r, o) { t.defaults[e] = i, r && (n[e] = o ? function (t, e, n) { n != Ga && r(t, e, n) } : r) } var n = t.optionHandlers; t.defineOption = e, t.Init = Ga, e("value", "", function (t, e) { return t.setValue(e) }, !0), e("mode", null, function (t, e) { t.doc.modeOption = e, qi(t) }, !0), e("indentUnit", 2, qi, !0), e("indentWithTabs", !1), e("smartIndent", !0), e("tabSize", 4, function (t) { Ki(t), en(t), vi(t) }, !0), e("lineSeparator", null, function (t, e) { if (t.doc.lineSep = e, e) { var n = [], i = t.doc.first; t.doc.iter(function (t) { for (var r = 0; ;) { var o = t.text.indexOf(e, r); if (-1 == o) break; r = o + e.length, n.push(_(i, o)) } i++ }); for (var r = n.length - 1; r >= 0; r--)Fr(t.doc, e, n[r], _(n[r].line, n[r].ch + e.length)) } }), e("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (t, e, n) { t.state.specialChars = new RegExp(e.source + (e.test("\t") ? "" : "|\t"), "g"), n != Ga && t.refresh() }), e("specialCharPlaceholder", ce, function (t) { return t.refresh() }, !0), e("electricChars", !0), e("inputStyle", Ps ? "contenteditable" : "textarea", function () { throw new Error("inputStyle can not (yet) be changed in a running editor") }, !0), e("spellcheck", !1, function (t, e) { return t.getInputField().spellcheck = e }, !0), e("rtlMoveVisually", !Os), e("wholeLineUpdateBefore", !0), e("theme", "default", function (t) { jo(t), Bo(t) }, !0), e("keyMap", "default", function (t, e, n) { var i = uo(e), r = n != Ga && uo(n); r && r.detach && r.detach(t, i), i.attach && i.attach(t, r || null) }), e("extraKeys", null), e("configureMouse", null), e("lineWrapping", !1, Uo, !0), e("gutters", [], function (t) { _i(t.options), Bo(t) }, !0), e("fixedGutter", !0, function (t, e) { t.display.gutters.style.left = e ? Cn(t.display) + "px" : "0", t.refresh() }, !0), e("coverGutterNextToScrollbar", !1, function (t) { return ni(t) }, !0), e("scrollbarStyle", "native", function (t) { ri(t), ni(t), t.display.scrollbars.setScrollTop(t.doc.scrollTop), t.display.scrollbars.setScrollLeft(t.doc.scrollLeft) }, !0), e("lineNumbers", !1, function (t) { _i(t.options), Bo(t) }, !0), e("firstLineNumber", 1, Bo, !0), e("lineNumberFormatter", function (t) { return t }, Bo, !0), e("showCursorWhenSelecting", !1, En, !0), e("resetSelectionOnContextMenu", !0), e("lineWiseCopyCut", !0), e("pasteLinesPerSelection", !0), e("readOnly", !1, function (t, e) { "nocursor" == e && (Fn(t), t.display.input.blur()), t.display.input.readOnlyChanged(e) }), e("disableInput", !1, function (t, e) { e || t.display.input.reset() }, !0), e("dragDrop", !0, Wo), e("allowDropFileTypes", null), e("cursorBlinkRate", 530), e("cursorScrollMargin", 0), e("cursorHeight", 1, En, !0), e("singleCursorHeightPerLine", !0, En, !0), e("workTime", 100), e("workDelay", 100), e("flattenSpans", !0, Ki, !0), e("addModeClass", !1, Ki, !0), e("pollInterval", 100), e("undoDepth", 200, function (t, e) { return t.doc.history.undoDepth = e }), e("historyEventDelay", 1250), e("viewportMargin", 10, function (t) { return t.refresh() }, !0), e("maxHighlightLength", 1e4, Ki, !0), e("moveInputWithCursor", !0, function (t, e) { e || t.display.input.resetPosition() }), e("tabindex", null, function (t, e) { return t.display.input.getField().tabIndex = e || "" }), e("autofocus", null), e("direction", "ltr", function (t, e) { return t.doc.setDirection(e) }, !0) }(qo), function (t) { var e = t.optionHandlers, n = t.helpers = {}; t.prototype = { constructor: t, focus: function () { window.focus(), this.display.input.focus() }, setOption: function (t, n) { var i = this.options, r = i[t]; i[t] == n && "mode" != t || (i[t] = n, e.hasOwnProperty(t) && pi(this, e[t])(this, n, r), Mt(this, "optionChange", this, t)) }, getOption: function (t) { return this.options[t] }, getDoc: function () { return this.doc }, addKeyMap: function (t, e) { this.state.keyMaps[e ? "push" : "unshift"](uo(t)) }, removeKeyMap: function (t) { for (var e = this.state.keyMaps, n = 0; n < e.length; ++n)if (e[n] == t || e[n].name == t) return e.splice(n, 1), !0 }, addOverlay: gi(function (e, n) { var i = e.token ? e : t.getMode(this.options, e); if (i.startState) throw new Error("Overlays may not be stateful."); v(this.state.overlays, { mode: i, modeSpec: e, opaque: n && n.opaque, priority: n && n.priority || 0 }, function (t) { return t.priority }), this.state.modeGen++ , vi(this) }), removeOverlay: gi(function (t) { for (var e = this, n = this.state.overlays, i = 0; i < n.length; ++i) { var r = n[i].modeSpec; if (r == t || "string" == typeof t && r.name == t) return n.splice(i, 1), e.state.modeGen++ , void vi(e) } }), indentLine: gi(function (t, e, n) { "string" != typeof e && "number" != typeof e && (e = null == e ? this.options.smartIndent ? "smart" : "prev" : e ? "add" : "subtract"), D(this.doc, t) && Go(this, t, e, n) }), indentSelection: gi(function (t) { for (var e = this, n = this.doc.sel.ranges, i = -1, r = 0; r < n.length; r++) { var o = n[r]; if (o.empty()) o.head.line > i && (Go(e, o.head.line, t, !0), i = o.head.line, r == e.doc.sel.primIndex && Kn(e)); else { var s = o.from(), a = o.to(), l = Math.max(i, s.line); i = Math.min(e.lastLine(), a.line - (a.ch ? 0 : 1)) + 1; for (var c = l; c < i; ++c)Go(e, c, t); var u = e.doc.sel.ranges; 0 == s.ch && n.length == u.length && u[r].from().ch > 0 && mr(e.doc, r, new Pa(s, u[r].to()), Bs) } } }), getTokenAt: function (t, e) { return te(this, t, e) }, getLineTokens: function (t, e) { return te(this, _(t), e, !0) }, getTokenTypeAt: function (t) { t = j(this.doc, t); var e, n = Yt(this, E(this.doc, t.line)), i = 0, r = (n.length - 1) / 2, o = t.ch; if (0 == o) e = n[2]; else for (; ;) { var s = i + r >> 1; if ((s ? n[2 * s - 1] : 0) >= o) r = s; else { if (!(n[2 * s + 1] < o)) { e = n[2 * s + 2]; break } i = s + 1 } } var a = e ? e.indexOf("overlay ") : -1; return a < 0 ? e : 0 == a ? null : e.slice(0, a - 1) }, getModeAt: function (e) { var n = this.doc.mode; return n.innerMode ? t.innerMode(n, this.getTokenAt(e).state).mode : n }, getHelper: function (t, e) { return this.getHelpers(t, e)[0] }, getHelpers: function (t, e) { var i = this, r = []; if (!n.hasOwnProperty(e)) return r; var o = n[e], s = this.getModeAt(t); if ("string" == typeof s[e]) o[s[e]] && r.push(o[s[e]]); else if (s[e]) for (var a = 0; a < s[e].length; a++) { var l = o[s[e][a]]; l && r.push(l) } else s.helperType && o[s.helperType] ? r.push(o[s.helperType]) : o[s.name] && r.push(o[s.name]); for (var c = 0; c < o._global.length; c++) { var u = o._global[c]; u.pred(s, i) && -1 == d(r, u.val) && r.push(u.val) } return r }, getStateAfter: function (t, e) { var n = this.doc; return t = V(n, null == t ? n.first + n.size - 1 : t), Xt(this, t + 1, e).state }, cursorCoords: function (t, e) { var n, i = this.doc.sel.primary(); return n = null == t ? i.head : "object" == typeof t ? j(this.doc, t) : t ? i.from() : i.to(), cn(this, n, e || "page") }, charCoords: function (t, e) { return ln(this, j(this.doc, t), e || "page") }, coordsChar: function (t, e) { return t = an(this, t, e || "page"), dn(this, t.left, t.top) }, lineAtHeight: function (t, e) { return t = an(this, { top: t, left: 0 }, e || "page").top, N(this.doc, t + this.display.viewOffset) }, heightAtLine: function (t, e, n) { var i, r = !1; if ("number" == typeof t) { var o = this.doc.first + this.doc.size - 1; t < this.doc.first ? t = this.doc.first : t > o && (t = o, r = !0), i = E(this.doc, t) } else i = t; return sn(this, i, { top: 0, left: 0 }, e || "page", n || r).top + (r ? this.doc.height - yt(i) : 0) }, defaultTextHeight: function () { return bn(this.display) }, defaultCharWidth: function () { return xn(this.display) }, getViewport: function () { return { from: this.display.viewFrom, to: this.display.viewTo } }, addWidget: function (t, e, n, i, r) { var o = this.display; t = cn(this, j(this.doc, t)); var s = t.bottom, a = t.left; if (e.style.position = "absolute", e.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(e), o.sizer.appendChild(e), "over" == i) s = t.top; else if ("above" == i || "near" == i) { var l = Math.max(o.wrapper.clientHeight, this.doc.height), c = Math.max(o.sizer.clientWidth, o.lineSpace.clientWidth); ("above" == i || t.bottom + e.offsetHeight > l) && t.top > e.offsetHeight ? s = t.top - e.offsetHeight : t.bottom + e.offsetHeight <= l && (s = t.bottom), a + e.offsetWidth > c && (a = c - e.offsetWidth) } e.style.top = s + "px", e.style.left = e.style.right = "", "right" == r ? (a = o.sizer.clientWidth - e.offsetWidth, e.style.right = "0px") : ("left" == r ? a = 0 : "middle" == r && (a = (o.sizer.clientWidth - e.offsetWidth) / 2), e.style.left = a + "px"), n && Wn(this, { left: a, top: s, right: a + e.offsetWidth, bottom: s + e.offsetHeight }) }, triggerOnKeyDown: gi(To), triggerOnKeyPress: gi(Po), triggerOnKeyUp: Eo, triggerOnMouseDown: gi(Lo), execCommand: function (t) { if (ja.hasOwnProperty(t)) return ja[t].call(null, this) }, triggerElectric: gi(function (t) { Zo(this, t) }), findPosH: function (t, e, n, i) { var r = this, o = 1; e < 0 && (o = -1, e = -e); for (var s = j(this.doc, t), a = 0; a < e && (s = ns(r.doc, s, o, n, i), !s.hitSide); ++a); return s }, moveH: gi(function (t, e) { var n = this; this.extendSelectionsBy(function (i) { return n.display.shift || n.doc.extend || i.empty() ? ns(n.doc, i.head, t, e, n.options.rtlMoveVisually) : t < 0 ? i.from() : i.to() }, Us) }), deleteH: gi(function (t, e) { var n = this.doc.sel, i = this.doc; n.somethingSelected() ? i.replaceSelection("", null, "+delete") : ho(this, function (n) { var r = ns(i, n.head, t, e, !1); return t < 0 ? { from: r, to: n.head } : { from: n.head, to: r } }) }), findPosV: function (t, e, n, i) { var r = this, o = 1, s = i; e < 0 && (o = -1, e = -e); for (var a = j(this.doc, t), l = 0; l < e; ++l) { var c = cn(r, a, "div"); if (null == s ? s = c.left : c.left = s, a = is(r, c, o, n), a.hitSide) break } return a }, moveV: gi(function (t, e) { var n = this, i = this.doc, r = [], o = !this.display.shift && !i.extend && i.sel.somethingSelected(); if (i.extendSelectionsBy(function (s) { if (o) return t < 0 ? s.from() : s.to(); var a = cn(n, s.head, "div"); null != s.goalColumn && (a.left = s.goalColumn), r.push(a.left); var l = is(n, a, t, e); return "page" == e && s == i.sel.primary() && qn(n, ln(n, l, "div").top - a.top), l }, Us), r.length) for (var s = 0; s < i.sel.ranges.length; s++)i.sel.ranges[s].goalColumn = r[s] }), findWordAt: function (t) { var e = this.doc, n = E(e, t.line).text, i = t.ch, r = t.ch; if (n) { var o = this.getHelper(t, "wordChars"); "before" != t.sticky && r != n.length || !i ? ++r : --i; for (var s = n.charAt(i), a = w(s, o) ? function (t) { return w(t, o) } : /\s/.test(s) ? function (t) { return /\s/.test(t) } : function (t) { return !/\s/.test(t) && !w(t) }; i > 0 && a(n.charAt(i - 1));)--i; for (; r < n.length && a(n.charAt(r));)++r } return new Pa(_(t.line, i), _(t.line, r)) }, toggleOverwrite: function (t) { null != t && t == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? a(this.display.cursorDiv, "CodeMirror-overwrite") : Fs(this.display.cursorDiv, "CodeMirror-overwrite"), Mt(this, "overwriteToggle", this, this.state.overwrite)) }, hasFocus: function () { return this.display.input.getField() == s() }, isReadOnly: function () { return !(!this.options.readOnly && !this.doc.cantEdit) }, scrollTo: gi(function (t, e) { Gn(this, t, e) }), getScrollInfo: function () { var t = this.display.scroller; return { left: t.scrollLeft, top: t.scrollTop, height: t.scrollHeight - He(this) - this.display.barHeight, width: t.scrollWidth - He(this) - this.display.barWidth, clientHeight: Ve(this), clientWidth: Re(this) } }, scrollIntoView: gi(function (t, e) { null == t ? (t = { from: this.doc.sel.primary().head, to: null }, null == e && (e = this.options.cursorScrollMargin)) : "number" == typeof t ? t = { from: _(t, 0), to: null } : null == t.from && (t = { from: t, to: null }), t.to || (t.to = t.from), t.margin = e || 0, null != t.from.line ? Yn(this, t) : Jn(this, t.from, t.to, t.margin) }), setSize: gi(function (t, e) { var n = this, i = function (t) { return "number" == typeof t || /^\d+$/.test(String(t)) ? t + "px" : t }; null != t && (this.display.wrapper.style.width = i(t)), null != e && (this.display.wrapper.style.height = i(e)), this.options.lineWrapping && tn(this); var r = this.display.viewFrom; this.doc.iter(r, this.display.viewTo, function (t) { if (t.widgets) for (var e = 0; e < t.widgets.length; e++)if (t.widgets[e].noHScroll) { yi(n, r, "widget"); break } ++r }), this.curOp.forceUpdate = !0, Mt(this, "refresh", this) }), operation: function (t) { return fi(this, t) }, startOperation: function () { return oi(this) }, endOperation: function () { return si(this) }, refresh: gi(function () { var t = this.display.cachedTextHeight; vi(this), this.curOp.forceUpdate = !0, en(this), Gn(this, this.doc.scrollLeft, this.doc.scrollTop), Ni(this), (null == t || Math.abs(t - bn(this.display)) > .5) && Sn(this), Mt(this, "refresh", this) }), swapDoc: gi(function (t) { var e = this.doc; return e.cm = null, Ji(this, t), en(this), this.display.input.reset(), Gn(this, t.scrollLeft, t.scrollTop), this.curOp.forceScroll = !0, xe(this, "swapDoc", this, e), e }), getInputField: function () { return this.display.input.getField() }, getWrapperElement: function () { return this.display.wrapper }, getScrollerElement: function () { return this.display.scroller }, getGutterElement: function () { return this.display.gutters } }, Lt(t), t.registerHelper = function (e, i, r) { n.hasOwnProperty(e) || (n[e] = t[e] = { _global: [] }), n[e][i] = r }, t.registerGlobalHelper = function (e, i, r, o) { t.registerHelper(e, i, o), n[e]._global.push({ pred: r, val: o }) } }(qo); var el = "iter insert remove copy getEditor constructor".split(" "); for (var nl in Ia.prototype) Ia.prototype.hasOwnProperty(nl) && d(el, nl) < 0 && (qo.prototype[nl] = function (t) { return function () { return t.apply(this.doc, arguments) } }(Ia.prototype[nl])); return Lt(Ia), qo.inputStyles = { textarea: tl, contenteditable: Qa }, qo.defineMode = function (t) { qo.defaults.mode || "null" == t || (qo.defaults.mode = t), Rt.apply(this, arguments) }, qo.defineMIME = Vt, qo.defineMode("null", function () { return { token: function (t) { return t.skipToEnd() } } }), qo.defineMIME("text/plain", "null"), qo.defineExtension = function (t, e) { qo.prototype[t] = e }, qo.defineDocExtension = function (t, e) { Ia.prototype[t] = e }, qo.fromTextArea = us, function (t) { t.off = Tt, t.on = ta, t.wheelEventPixels = $i, t.Doc = Ia, t.splitLines = na, t.countColumn = h, t.findColumn = f, t.isWordChar = x, t.Pass = js, t.signal = Mt, t.Line = fa, t.changeEnd = Vi, t.scrollbarModel = Ca, t.Pos = _, t.cmpPos = F, t.modes = sa, t.mimeModes = aa, t.resolveMode = jt, t.getMode = Bt, t.modeExtensions = la, t.extendMode = Wt, t.copyState = Ut, t.startState = Kt, t.innerMode = qt, t.commands = ja, t.keyMap = Va, t.keyName = co, t.isModifierKey = ao, t.lookupKey = so, t.normalizeKeyMap = oo, t.StringStream = ca, t.SharedTextMarker = Na, t.TextMarker = Oa, t.LineWidget = Aa, t.e_preventDefault = Ot, t.e_stopPropagation = Nt, t.e_stop = It, t.addClass = a, t.contains = o, t.rmClass = Fs, t.keyNames = $a }(qo), qo.version = "5.31.0", qo }) }, function (t, e, n) { "use strict"; (function (e, n) { var i = e.$; t.exports = e.View.extend({ events: { change: "onChange" }, initialize: function (t) { var e = this.model; this.config = t.config || {}, this.pfx = this.config.stylePrefix || "", this.ppfx = this.config.pStylePrefix || "", this.target = e.target, this.className = this.pfx + "trait", this.labelClass = this.ppfx + "label", this.fieldClass = this.ppfx + "field " + this.ppfx + "field-" + e.get("type"), this.inputhClass = this.ppfx + "input-holder", e.off("change:value", this.onValueChange), this.listenTo(e, "change:value", this.onValueChange), this.tmpl = '<div class="' + this.fieldClass + '"><div class="' + this.inputhClass + '"></div></div>' }, onChange: function () { this.model.set("value", this.getInputEl().value) }, getValueForTarget: function () { return this.model.get("value") }, onValueChange: function () { var t = this.model, e = this.target, i = t.get("name"), r = this.getValueForTarget(); if (t.get("changeProp")) e.set(i, r); else { var o = n.clone(e.get("attributes")); o[i] = r, e.set("attributes", o) } }, renderLabel: function () { this.$el.html('<div class="' + this.labelClass + '">' + this.getLabel() + "</div>") }, getLabel: function () { var t = this.model, e = t.get("label") || t.get("name"); return e.charAt(0).toUpperCase() + e.slice(1).replace(/-/g, " ") }, getInputEl: function () { if (!this.$input) { var t = this.model, e = this.target, n = t.get("name"), r = t.get("placeholder") || t.get("default") || "", o = t.get("type") || "text", s = e.get("attributes"), a = t.get("min"), l = t.get("max"), c = t.get("changeProp") ? e.get(n) : t.get("value") || s[n], u = i('<input type="' + o + '" placeholder="' + r + '">'); c && u.prop("value", c), a && u.prop("min", a), l && u.prop("max", l), this.$input = u } return this.$input.get(0) }, getModelValue: function () { var t, e = this.model, n = this.target, i = e.get("name"); if (e.get("changeProp")) t = n.get(i); else { var r = n.get("attributes"); t = e.get("value") || r[i] } return t }, renderField: function () { if (!this.$input) { this.$el.append(this.tmpl); var t = this.getInputEl(), e = this.el.querySelector("." + this.inputhClass); e.insertBefore(t, e.childNodes[0]) } }, render: function () { return this.renderLabel(), this.renderField(), this.el.className = this.className, this } }) }).call(e, n(0), n(1)) }, function (t, e, n) { "use strict"; var i, r; !function (o, s) { i = s, void 0 !== (r = "function" == typeof i ? i.call(e, n, e, t) : i) && (t.exports = r) }(0, function () { function t(t, e) { return e = e || E, $.test(t) ? e.getElementsByClassName(t.slice(1)) : H.test(t) ? e.getElementsByTagName(t) : e.querySelectorAll(t) } function e(t) { if (!M) { M = E.implementation.createHTMLDocument(); var e = M.createElement("base"); e.href = E.location.href, M.head.appendChild(e) } return M.body.innerHTML = t, M.body.childNodes } function n(t) { "loading" !== E.readyState ? t() : E.addEventListener("DOMContentLoaded", t) } function i(i, r) { if (!i) return this; if (i.cash && i !== P) return i; var o, s = i, a = 0; if (_(i)) s = F.test(i) ? E.getElementById(i.slice(1)) : z.test(i) ? e(i) : t(i, r); else if (I(i)) return n(i), this; if (!s) return this; if (s.nodeType || s === P) this[0] = s, this.length = 1; else for (o = this.length = s.length; a < o; a++)this[a] = s[a]; return this } function r(t, e) { return new i(t, e) } function o(t, e) { for (var n = t.length, i = 0; i < n && !1 !== e.call(t[i], t[i], i, t); i++); } function s(t, e) { var n = t && (t.matches || t.webkitMatchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector); return !!n && n.call(t, e) } function a(t) { return _(t) ? s : t.cash ? function (e) { return t.is(e) } : function (t, e) { return t === e } } function l(t) { return r(L.call(t).filter(function (t, e, n) { return n.indexOf(t) === e })) } function c(t) { return t[V] = t[V] || {} } function u(t, e, n) { return c(t)[e] = n } function h(t, e) { var n = c(t); return void 0 === n[e] && (n[e] = t.dataset ? t.dataset[e] : r(t).attr("data-" + e)), n[e] } function d(t, e) { var n = c(t); n ? delete n[e] : t.dataset ? delete t.dataset[e] : r(t).removeAttr("data-" + name) } function f(t) { return _(t) && t.match(j) } function p(t, e) { return t.classList ? t.classList.contains(e) : new RegExp("(^| )" + e + "( |$)", "gi").test(t.className) } function g(t, e, n) { t.classList ? t.classList.add(e) : n.indexOf(" " + e + " ") && (t.className += " " + e) } function m(t, e) { t.classList ? t.classList.remove(e) : t.className = t.className.replace(e, "") } function v(t, e) { return parseInt(P.getComputedStyle(t[0], null)[e], 10) || 0 } function y(t, e, n) { var i = h(t, "_cashEvents") || u(t, "_cashEvents", {}); i[e] = i[e] || [], i[e].push(n), t.addEventListener(e, n) } function b(t, e, n) { var i, r = h(t, "_cashEvents"), s = r && r[e]; s && (n ? (t.removeEventListener(e, n), (i = s.indexOf(n)) >= 0 && s.splice(i, 1)) : (o(s, function (n) { t.removeEventListener(e, n) }), s = [])) } function x(t, e) { return "&" + encodeURIComponent(t) + "=" + encodeURIComponent(e).replace(/%20/g, "+") } function w(t) { var e = []; return o(t.options, function (t) { t.selected && e.push(t.value) }), e.length ? e : null } function C(t) { var e = t.selectedIndex; return e >= 0 ? t.options[e].value : null } function k(t) { var e = t.type; if (!e) return null; switch (e.toLowerCase()) { case "select-one": return C(t); case "select-multiple": return w(t); case "radio": case "checkbox": return t.checked ? t.value : null; default: return t.value ? t.value : null } } function S(t, e, n) { if (n) { var i = t.childNodes[0]; t.insertBefore(e, i) } else t.appendChild(e) } function T(t, e, n) { var i = _(e); if (!i && e.length) return void o(e, function (e) { return T(t, e, n) }); o(t, i ? function (t) { return t.insertAdjacentHTML(n ? "afterbegin" : "beforeend", e) } : function (t, i) { return S(t, 0 === i ? e : e.cloneNode(!0), n) }) } var M, E = document, P = window, A = Array.prototype, L = A.slice, O = A.filter, N = A.push, D = function () { }, I = function (t) { return typeof t == typeof D && t.call }, _ = function (t) { return "string" == typeof t }, F = /^#[\w-]*$/, $ = /^\.[\w-]*$/, z = /<.+>/, H = /^\w+$/, R = r.fn = r.prototype = i.prototype = { cash: !0, length: 0, push: N, splice: A.splice, map: A.map, init: i }; Object.defineProperty(R, "constructor", { value: r }), r.parseHTML = e, r.noop = D, r.isFunction = I, r.isString = _, r.extend = R.extend = function (t) { t = t || {}; var e = L.call(arguments), n = e.length, i = 1; for (1 === e.length && (t = this, i = 0); i < n; i++)if (e[i]) for (var r in e[i]) e[i].hasOwnProperty(r) && (t[r] = e[i][r]); return t }, r.extend({ merge: function (t, e) { for (var n = +e.length, i = t.length, r = 0; r < n; i++ , r++)t[i] = e[r]; return t.length = i, t }, each: o, matches: s, unique: l, isArray: Array.isArray, isNumeric: function (t) { return !isNaN(parseFloat(t)) && isFinite(t) } }); var V = r.uid = "_cash" + Date.now(); R.extend({ data: function (t, e) { if (_(t)) return void 0 === e ? h(this[0], t) : this.each(function (n) { return u(n, t, e) }); for (var n in t) this.data(n, t[n]); return this }, removeData: function (t) { return this.each(function (e) { return d(e, t) }) } }); var j = /\S+/g; R.extend({ addClass: function (t) { var e = f(t); return e ? this.each(function (t) { var n = " " + t.className + " "; o(e, function (e) { g(t, e, n) }) }) : this }, attr: function (t, e) { if (t) { if (_(t)) return void 0 === e ? this[0] ? this[0].getAttribute ? this[0].getAttribute(t) : this[0][t] : void 0 : this.each(function (n) { n.setAttribute ? n.setAttribute(t, e) : n[t] = e }); for (var n in t) this.attr(n, t[n]); return this } }, hasClass: function (t) { var e = !1, n = f(t); return n && n.length && this.each(function (t) { return !(e = p(t, n[0])) }), e }, prop: function (t, e) { if (_(t)) return void 0 === e ? this[0][t] : this.each(function (n) { n[t] = e }); for (var n in t) this.prop(n, t[n]); return this }, removeAttr: function (t) { return this.each(function (e) { e.removeAttribute ? e.removeAttribute(t) : delete e[t] }) }, removeClass: function (t) { if (!arguments.length) return this.attr("class", ""); var e = f(t); return e ? this.each(function (t) { o(e, function (e) { m(t, e) }) }) : this }, removeProp: function (t) { return this.each(function (e) { delete e[t] }) }, toggleClass: function (t, e) { if (void 0 !== e) return this[e ? "addClass" : "removeClass"](t); var n = f(t); return n ? this.each(function (t) { var e = " " + t.className + " "; o(n, function (n) { p(t, n) ? m(t, n) : g(t, n, e) }) }) : this } }), R.extend({ add: function (t, e) { return l(r.merge(this, r(t, e))) }, each: function (t) { return o(this, t), this }, eq: function (t) { return r(this.get(t)) }, filter: function (t) { if (!t) return this; var e = I(t) ? t : a(t); return r(O.call(this, function (n) { return e(n, t) })) }, first: function () { return this.eq(0) }, get: function (t) { return void 0 === t ? L.call(this) : t < 0 ? this[t + this.length] : this[t] }, index: function (t) { var e = t ? r(t)[0] : this[0], n = t ? this : r(e).parent().children(); return L.call(n).indexOf(e) }, last: function () { return this.eq(-1) } }); var B = function () { var t = /(?:^\w|[A-Z]|\b\w)/g, e = /[\s-_]+/g; return function (n) { return n.replace(t, function (t, e) { return t[0 === e ? "toLowerCase" : "toUpperCase"]() }).replace(e, "") } }(), W = function () { var t = {}, e = document, n = e.createElement("div"), i = n.style; return function (e) { if (e = B(e), t[e]) return t[e]; var n = e.charAt(0).toUpperCase() + e.slice(1); return o((e + " " + ["webkit", "moz", "ms", "o"].join(n + " ") + n).split(" "), function (n) { if (n in i) return t[n] = e = t[e] = n, !1 }), t[e] } }(); r.prefixedProp = W, r.camelCase = B, R.extend({ css: function (t, e) { if (_(t)) return t = W(t), arguments.length > 1 ? this.each(function (n) { return n.style[t] = e }) : P.getComputedStyle(this[0])[t]; for (var n in t) this.css(n, t[n]); return this } }), o(["Width", "Height"], function (t) { var e = t.toLowerCase(); R[e] = function () { return this[0].getBoundingClientRect()[e] }, R["inner" + t] = function () { return this[0]["client" + t] }, R["outer" + t] = function (e) { return this[0]["offset" + t] + (e ? v(this, "margin" + ("Width" === t ? "Left" : "Top")) + v(this, "margin" + ("Width" === t ? "Right" : "Bottom")) : 0) } }), R.extend({ off: function (t, e) { return this.each(function (n) { return b(n, t, e) }) }, on: function (t, e, i, r) { var o; if (!_(t)) { for (var a in t) this.on(a, e, t[a]); return this } return I(e) && (i = e, e = null), "ready" === t ? (n(i), this) : (e && (o = i, i = function (t) { for (var n = t.target; !s(n, e);) { if (n === this) return n = !1; n = n.parentNode } n && o.call(n, t) }), this.each(function (e) { var n = i; r && (n = function () { i.apply(this, arguments), b(e, t, n) }), y(e, t, n) })) }, one: function (t, e, n) { return this.on(t, e, n, !0) }, ready: n, trigger: function (t, e) { var n = E.createEvent("HTMLEvents"); return n.data = e, n.initEvent(t, !0, !1), this.each(function (t) { return t.dispatchEvent(n) }) } }), R.extend({ serialize: function () { var t = ""; return o(this[0].elements || this, function (e) { if (!e.disabled && "FIELDSET" !== e.tagName) { var n = e.name; switch (e.type.toLowerCase()) { case "file": case "reset": case "submit": case "button": break; case "select-multiple": var i = k(e); null !== i && o(i, function (e) { t += x(n, e) }); break; default: var r = k(e); null !== r && (t += x(n, r)) } } }), t.substr(1) }, val: function (t) { return void 0 === t ? k(this[0]) : this.each(function (e) { return e.value = t }) } }), R.extend({ after: function (t) { return r(t).insertAfter(this), this }, append: function (t) { return T(this, t), this }, appendTo: function (t) { return T(r(t), this), this }, before: function (t) { return r(t).insertBefore(this), this }, clone: function () { return r(this.map(function (t) { return t.cloneNode(!0) })) }, empty: function () { return this.html(""), this }, html: function (t) { if (void 0 === t) return this[0].innerHTML; var e = t.nodeType ? t[0].outerHTML : t; return this.each(function (t) { return t.innerHTML = e }) }, insertAfter: function (t) { var e = this; return r(t).each(function (t, n) { var i = t.parentNode, r = t.nextSibling; e.each(function (t) { i.insertBefore(0 === n ? t : t.cloneNode(!0), r) }) }), this }, insertBefore: function (t) { var e = this; return r(t).each(function (t, n) { var i = t.parentNode; e.each(function (e) { i.insertBefore(0 === n ? e : e.cloneNode(!0), t) }) }), this }, prepend: function (t) { return T(this, t, !0), this }, prependTo: function (t) { return T(r(t), this, !0), this }, remove: function () { return this.each(function (t) { return t.parentNode.removeChild(t) }) }, text: function (t) { return void 0 === t ? this[0].textContent : this.each(function (e) { return e.textContent = t }) } }); var U = E.documentElement; return R.extend({ position: function () { var t = this[0]; return { left: t.offsetLeft, top: t.offsetTop } }, offset: function () { var t = this[0].getBoundingClientRect(); return { top: t.top + P.pageYOffset - U.clientTop, left: t.left + P.pageXOffset - U.clientLeft } }, offsetParent: function () { return r(this[0].offsetParent) } }), R.extend({ children: function (t) { var e = []; return this.each(function (t) { N.apply(e, t.children) }), e = l(e), t ? e.filter(function (e) { return s(e, t) }) : e }, closest: function (t) { return !t || this.length < 1 ? r() : this.is(t) ? this.filter(t) : this.parent().closest(t) }, is: function (t) { if (!t) return !1; var e = !1, n = a(t); return this.each(function (i) { return !(e = n(i, t)) }), e }, find: function (e) { if (!e || e.nodeType) return r(e && this.has(e).length ? e : null); var n = []; return this.each(function (i) { N.apply(n, t(e, i)) }), l(n) }, has: function (e) { var n = _(e) ? function (n) { return 0 !== t(e, n).length } : function (t) { return t.contains(e) }; return this.filter(n) }, next: function () { return r(this[0].nextElementSibling) }, not: function (t) { if (!t) return this; var e = a(t); return this.filter(function (n) { return !e(n, t) }) }, parent: function () { var t = []; return this.each(function (e) { e && e.parentNode && t.push(e.parentNode) }), l(t) }, parents: function (t) { var e, n = []; return this.each(function (i) { for (e = i; e && e.parentNode && e !== E.body.parentNode;)e = e.parentNode, (!t || t && s(e, t)) && n.push(e) }), l(n) }, prev: function () { return r(this[0].previousElementSibling) }, siblings: function () { var t = this.parent().children(), e = this[0]; return t.filter(function (t) { return t !== e }) } }), r }) }, function (t, e, n) { "use strict"; var i = n(0), r = i.Model.extend({ idAttribute: "name", defaults: { name: "", label: "", type: "class", active: !0, private: !1, protected: !1 }, initialize: function () { var t = this.get("name"), e = this.get("label"); t ? e || this.set("label", t) : this.set("name", e), this.set("name", r.escapeName(this.get("name"))) }, getFullName: function () { var t = ""; switch (this.get("type")) { case "class": t = "."; break; case "id": t = "#" }return t + this.get("name") } }, { escapeName: function (t) { return ("" + t).trim().replace(/([^a-z0-9\w-]+)/gi, "-") } }); t.exports = r }, function (t, e, n) { "use strict"; var i = n(30), r = function (t) { return t && t.__esModule ? t : { default: t } }(i), o = n(11); t.exports = n(0).Collection.extend(r.default).extend({ types: [{ id: "stack", model: n(114), view: n(32), isType: function (t) { if (t && "stack" == t.type) return t } }, { id: "composite", model: n(31), view: n(16), isType: function (t) { if (t && "composite" == t.type) return t } }, { id: "file", model: o, view: n(38), isType: function (t) { if (t && "file" == t.type) return t } }, { id: "color", model: o, view: n(36), isType: function (t) { if (t && "color" == t.type) return t } }, { id: "select", model: n(39), view: n(35), isType: function (t) { if (t && "select" == t.type) return t } }, { id: "radio", model: n(39), view: n(34), isType: function (t) { if (t && "radio" == t.type) return t } }, { id: "slider", model: n(120), view: n(121), isType: function (t) { if (t && "slider" == t.type) return t } }, { id: "integer", model: n(40), view: n(13), isType: function (t) { if (t && "integer" == t.type) return t } }, { id: "base", model: o, view: n(5), isType: function (t) { return t.type = "base", t } }], deepClone: function () { var t = this.clone(); return t.reset(t.map(function (t) { var e = t.clone(); return e.typeView = t.typeView, e })), t }, parseValue: function (t) { var e = this, n = []; return t.split(" ").forEach(function (t, i) { var r = e.at(i); n.push(Object.assign({}, r.attributes, { value: t })) }), n }, getFullValue: function () { var t = ""; return this.each(function (e) { return t += e.getFullValue() + " " }), t.trim() } }) }, function (t, e, n) { "use strict"; var i = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }; t.exports = n(0).Model.extend({ defaults: { name: "", property: "", type: "", defaults: "", info: "", value: "", icon: "", functionName: "", status: "", visible: !0, fixedValues: ["initial", "inherit"] }, initialize: function (t) { var e = this.get("name"), n = this.get("property"); e || this.set("name", n.charAt(0).toUpperCase() + n.slice(1).replace(/-/g, " ")); var i = this.init && this.init.bind(this); i && i() }, setValue: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r = this.parseValue(t); this.set(r, i({}, n, { avoidStore: 1 })), e && (this.set("value", "", n), this.set(r, n)) }, setValueFromInput: function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; this.setValue(t, e, i({}, n, { fromInput: 1 })) }, parseValue: function (t) { var e = { value: t }; if (!this.get("functionName")) return e; var n = [], i = "" + t, r = i.indexOf("(") + 1, o = i.lastIndexOf(")"); return n.push(r), o >= 0 && n.push(o), e.value = String.prototype.substring.apply(i, n), e }, getDefaultValue: function () { return this.get("defaults") }, getFullValue: function (t) { var e = this.get("functionName"), n = t || this.get("value"); return e && (n = e + "(" + n + ")"), n } }) }, function (t, e, n) { "use strict"; (function (e) { n(5), n(13), n(34), n(35), n(36), n(38), n(16), n(32); t.exports = e.View.extend({ initialize: function (t) { this.config = t.config || {}, this.pfx = this.config.stylePrefix || "", this.target = t.target || {}, this.propTarget = t.propTarget || {}, this.onChange = t.onChange, this.onInputRender = t.onInputRender || {}, this.customValue = t.customValue || {}; var e = this.collection; this.listenTo(e, "add", this.addTo), this.listenTo(e, "reset", this.render) }, addTo: function (t) { this.add(t) }, add: function (t, e) { var n = new t.typeView({ model: t, name: t.get("name"), id: this.pfx + t.get("property"), target: this.target, propTarget: this.propTarget, onChange: this.onChange, onInputRender: this.onInputRender, config: this.config }); "composite" != t.get("type") && (n.customValue = this.customValue), n.render(); var i = n.el; e ? e.appendChild(i) : this.el.appendChild(i) }, render: function () { var t = this, e = document.createDocumentFragment(); return this.collection.each(function (n) { return t.add(n, e) }), this.$el.append(e), this.$el.attr("class", this.pfx + "properties"), this } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; (function (e) { var i = (n(17), e.$); t.exports = n(5).extend({ templateInput: function () { return "" }, init: function () { var t = this.model; this.listenTo(t, "change:unit", this.modelValueChanged), this.listenTo(t, "el:change", this.elementUpdated) }, setValue: function (t) { this.inputInst.setValue(t, { silent: 1 }) }, onRender: function () { var t = this.ppfx; if (!this.input) { var e = this.model.input; e.ppfx = t, e.render(); this.el.querySelector("." + t + "fields").appendChild(e.el), this.$input = e.inputEl, this.unit = e.unitEl, this.$unit = i(this.unit), this.input = this.$input.get(0), this.inputInst = e } } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; var i = (n(0), n(4)); t.exports = i.extend({ tagName: "img", events: { dblclick: "openModal", click: "initResize" }, initialize: function (t) { i.prototype.initialize.apply(this, arguments), this.listenTo(this.model, "change:src", this.updateSrc), this.listenTo(this.model, "dblclick active", this.openModal), this.classEmpty = this.ppfx + "plh-image", this.config.modal && (this.modal = this.config.modal), this.config.am && (this.am = this.config.am) }, updateSrc: function () { var t = this.model.get("src"); this.$el.attr("src", t), t ? this.$el.removeClass(this.classEmpty) : this.$el.addClass(this.classEmpty) }, openModal: function (t) { var e = this.opts.config.em, n = e ? e.get("Editor") : ""; n && n.runCommand("open-assets", { target: this.model, onSelect: function () { n.Modal.close(), n.AssetManager.setTarget(null) } }) }, render: function () { this.updateAttributes(), this.updateClasses(); var t = this.$el.attr("class") || ""; return this.model.get("src") || this.$el.attr("class", (t + " " + this.classEmpty).trim()), this.$el.attr("onmousedown", "return false"), this } }) }, function (t, e) { var n; n = function () { return this }(); try { n = n || Function("return this")() || (0, eval)("this") } catch (t) { "object" == typeof window && (n = window) } t.exports = n }, function (t, e, n) { "use strict"; (function (e) { var i = n(5), r = e.$; t.exports = i.extend({ templateInput: function () { var t = this.pfx; return '\n      <div class="' + t + "field " + t + 'composite">\n        <span id="' + t + 'input-holder"></span>\n      </div>\n    ' }, inputValueChanged: function () { if (!this.model.get("detached")) { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; i.prototype.inputValueChanged.apply(this, e) } }, onRender: function () { var t = this.model, e = t.get("properties") || []; if (e.length && (this.$input || (this.$input = r('<input type="hidden" value="0">'), this.input = this.$input.get(0)), this.props || (this.props = t.get("properties")), !this.$props)) { this.props.each(function (e, n) { e && "composite" == e.get("type") && (this.props.remove(e), console.warn("Nested composite types not yet allowed.")), e.parent = t }, this); var i = n(12), o = new i(this.getPropsConfig()); this.$props = o.render().$el, this.$el.find("#" + this.pfx + "input-holder").append(this.$props) } }, getPropsConfig: function (t) { var e = this, n = this.model, i = { config: this.config, collection: this.props, target: this.target, propTarget: this.propTarget, onChange: function (t, e, i) { n.set("value", n.getFullValue(), i) }, customValue: function (t, n) { return e.valueOnIndex(n, t) } }; return n.get("detached") && delete i.onChange, i }, valueOnIndex: function (t, e) { var n = void 0, i = this.getTargetValue({ ignoreDefault: 1 }); if (i) { n = i.split(" ")[t] } else n = e && e.getTargetValue({ ignoreCustomValue: 1, ignoreDefault: 1 }); return e && (n = e.model.parseValue(n).value), n } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; (function (e) { var i = n(1), r = n(2), o = n(33), s = n(0); s.$; t.exports = o.extend({ events: { "change input": "handleChange", "change select": "handleUnitChange", "click [data-arrow-up]": "upArrowClick", "click [data-arrow-down]": "downArrowClick", "mousedown [data-arrows]": "downIncrement" }, template: function () { var t = this.ppfx; return '\n      <span class="' + t + 'input-holder"></span>\n      <span class="' + t + 'field-units"></span>\n      <div class="' + t + 'field-arrows" data-arrows>\n        <div class="' + t + 'field-arrow-u" data-arrow-up></div>\n        <div class="' + t + 'field-arrow-d" data-arrow-down></div>\n      </div>\n    ' }, inputClass: function () { var t = this.ppfx; return this.opts.contClass || t + "field " + t + "field-integer" }, initialize: function () { arguments.length > 0 && void 0 !== arguments[0] && arguments[0]; o.prototype.initialize.apply(this, arguments), (0, i.bindAll)(this, "moveIncrement", "upIncrement"), this.doc = document, this.listenTo(this.model, "change:unit", this.handleModelChange) }, setValue: function (t, e) { var n = e || {}, i = this.validateInputValue(t, { deepCheck: 1 }), r = { value: i.value }; (i.unit || i.force) && (r.unit = i.unit), this.model.set(r, n), n.silent && this.handleModelChange() }, handleChange: function (t) { t.stopPropagation(), this.setValue(this.getInputEl().value), this.elementUpdated() }, handleUnitChange: function (t) { t.stopPropagation(); var e = this.getUnitEl().value; this.model.set("unit", e), this.elementUpdated() }, elementUpdated: function () { this.model.trigger("el:change") }, handleModelChange: function () { var t = this.model; this.getInputEl().value = t.get("value"); var e = this.getUnitEl(); e && (e.value = t.get("unit")) }, getUnitEl: function () { if (!this.unitEl) { var t = this.model, e = t.get("units") || []; if (e.length) { var n = []; e.forEach(function (e) { var i = e == t.get("unit") ? "selected" : ""; n.push("<option " + i + ">" + e + "</option>") }); var i = document.createElement("div"); i.innerHTML = '<select class="' + this.ppfx + 'input-unit">' + n.join("") + "</select>", this.unitEl = i.firstChild } } return this.unitEl }, upArrowClick: function () { var t = this.model, e = t.get("step"), n = t.get("value"); n = this.normalizeValue(n + e); var i = this.validateInputValue(n); t.set("value", i.value), this.elementUpdated() }, downArrowClick: function () { var t = this.model, e = t.get("step"), n = t.get("value"), i = this.normalizeValue(n - e), r = this.validateInputValue(i); t.set("value", r.value), this.elementUpdated() }, downIncrement: function (t) { t.preventDefault(), this.moved = 0; var e = this.model.get("value"); e = this.normalizeValue(e), this.current = { y: t.pageY, val: e }, (0, r.on)(this.doc, "mousemove", this.moveIncrement), (0, r.on)(this.doc, "mouseup", this.upIncrement) }, moveIncrement: function (t) { this.moved = 1; var e = this.model, n = e.get("step"), i = this.current, r = this.normalizeValue(i.val + (i.y - t.pageY) * n); return this.prValue = this.validateInputValue(r).value, e.set("value", this.prValue, { avoidStore: 1 }), !1 }, upIncrement: function () { var t = this.model, e = t.get("step"); if ((0, r.off)(this.doc, "mouseup", this.upIncrement), (0, r.off)(this.doc, "mousemove", this.moveIncrement), this.prValue && this.moved) { var n = this.prValue - e; t.set("value", n, { avoidStore: 1 }).set("value", n + e), this.elementUpdated() } }, normalizeValue: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n = this.model, i = n.get("step"), r = 0; if (isNaN(t)) return e; if (t = parseFloat(t), Math.floor(t) !== t) { var o = i.toString().split(".")[1]; r = o ? o.length : 0 } return r ? parseFloat(t.toFixed(r)) : t }, validateInputValue: function (t, n) { var i = 0, r = n || {}, o = this.model, s = "" !== t ? t : o.get("defaults"), a = o.get("units") || [], l = o.get("unit") || a.length && a[0] || "", c = o.get("max"), u = o.get("min"); if (r.deepCheck) { var h = o.get("fixedValues") || []; if (s) { var d = new RegExp("^" + h.join("|"), "g"); if (h.length && d.test(s)) s = s.match(d)[0], l = "", i = 1; else { var f = s + ""; s += "", s = parseFloat(s.replace(",", ".")), s = isNaN(s) ? o.get("defaults") : s; var p = f.replace(s, ""); e.indexOf(a, p) >= 0 && (l = p) } } } return void 0 !== c && "" !== c && (s = s > c ? c : s), void 0 !== u && "" !== u && (s = s < u ? u : s), { force: i, value: s, unit: l } }, render: function () { o.prototype.render.call(this); var t = this.getUnitEl(); return t && this.$el.find("." + this.ppfx + "field-units").get(0).appendChild(t), this } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; (function (e) { var i = n(3); t.exports = i.extend({ defaults: e.extend({}, i.prototype.defaults, { type: "image", tagName: "img", src: "", void: 1, droppable: 0, highlightable: 0, resizable: 1, traits: ["alt"] }), initialize: function (t, e) { i.prototype.initialize.apply(this, arguments); var n = this.get("attributes"); n.src && this.set("src", n.src) }, initToolbar: function () { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; if (i.prototype.initToolbar.apply(this, e), this.sm && this.sm.get) { var r = this.sm.get("Commands"); if (r.has("image-editor")) { var o = this.get("toolbar"); o.push({ attributes: { class: "fa fa-pencil" }, command: "image-editor" }), this.set("toolbar", o) } } }, getAttrToHTML: function () { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; var r = i.prototype.getAttrToHTML.apply(this, e); delete r.onmousedown; var o = this.get("src"); return o && (r.src = o), r }, parseUri: function (t) { var e = document.createElement("a"); e.href = t; for (var n = {}, i = e.search.substring(1).split("&"), r = 0; r < i.length; r++) { var o = i[r].split("="), s = decodeURIComponent(o[0]); s && (n[s] = decodeURIComponent(o[1])) } return { hostname: e.hostname, pathname: e.pathname, protocol: e.protocol, search: e.search, hash: e.hash, port: e.port, query: n } } }, { isComponent: function (t) { var e = ""; return "IMG" == t.tagName && (e = { type: "image" }), e } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, r = n(1), o = n(2), s = n(177), a = n(179), l = n(50), c = n(0), u = void 0, h = c.$; t.exports = { init: function (t) { (0, r.bindAll)(this, "onHover", "onOut", "onClick", "onKeyPress", "copyComp", "pasteComp", "onFrameScroll") }, enable: function () { this.frameOff = this.canvasOff = this.adjScroll = null; var t = this.config.em.get("Config"); this.startSelectComponent(), this.toggleClipboard(t.copyPaste); var e = this.config.em; u = 1, e.on("component:update", this.updateAttached, this), e.on("change:canvasOffset", this.updateAttached, this) }, toggleClipboard: function (t) { t || 0 ? (l("+c, ctrl+c", this.copyComp), l("+v, ctrl+v", this.pasteComp)) : (l.unbind("+c, ctrl+c"), l.unbind("+v, ctrl+v")) }, copyComp: function () { var t = this.editorModel.get("selectedComponent"); t && t.get("copyable") && this.editorModel.set("clipboard", t) }, pasteComp: function () { var t = this.editorModel.get("clipboard"), e = this.editorModel.get("selectedComponent"); if (t && e && e.collection) { var n = e.collection.indexOf(e), i = t.clone(); e.collection.add(i, { at: n + 1 }) } }, startSelectComponent: function () { this.toggleSelectComponent(1) }, stopSelectComponent: function () { this.toggleSelectComponent() }, toggleSelectComponent: function (t) { var e = this.em, n = t ? "on" : "off", i = { on: o.on, off: o.off }, r = this.getCanvasBody(), s = this.getContentWindow(); i[n](r, "mouseover", this.onHover), i[n](r, "mouseout", this.onOut), i[n](r, "click", this.onClick), i[n](s, "scroll", this.onFrameScroll), i[n](s, "keydown", this.onKeyPress), e[n]("change:selectedComponent", this.onSelect, this) }, onKeyPress: function (t) { var e = t.which || t.keyCode, n = this.editorModel.get("selectedComponent"), i = "BODY" !== this.frameEl.contentDocument.activeElement.tagName; if ((8 == e || 46 == e) && (i || t.preventDefault(), n && !i)) { if (!n.get("removable")) return; n.set("status", ""), n.destroy(), this.hideBadge(), this.clean(), this.hideHighlighter(), this.editorModel.set("selectedComponent", null) } }, onHover: function (t) { t.stopPropagation(); var e = t.target; this.adjScroll || (this.adjScroll = 1, this.onFrameScroll(t), this.updateAttached()); var n = this.getElementPos(e); this.updateBadge(e, n), this.updateHighlighter(e, n), this.showElementOffset(e, n) }, onOut: function (t) { t.stopPropagation(), this.hideBadge(), this.hideHighlighter(), this.hideElementOffset() }, showElementOffset: function (t, e) { var n = h(t), i = n.data("model"); i && "selected" == i.get("status") || !u || this.editor.runCommand("show-offset", { el: t, elPos: e }) }, hideElementOffset: function (t, e) { this.editor.stopCommand("show-offset") }, showFixedElementOffset: function (t, e) { this.editor.runCommand("show-offset", { el: t, elPos: e, state: "Fixed" }) }, hideFixedElementOffset: function (t, e) { this.editor && this.editor.stopCommand("show-offset", { state: "Fixed" }) }, hideHighlighter: function () { this.canvas.getHighlighter().style.display = "none" }, onClick: function (t) { t.stopPropagation(); var e = h(t.target).data("model"); e && this.editor.select(e) }, updateBadge: function (t, e) { var n = h(t), i = this.canvas, r = i.getConfig(), o = r.customBadgeLabel; this.cacheEl = t; var s = n.data("model"); if (s && s.get("badgable")) { var a = this.getBadge(), l = s.getIcon() + s.getName(); l = o ? o(s) : l, a.innerHTML = l; var c = a.style; c.display = "block"; var u = i.getCanvasView().getPosition(), d = a ? a.offsetHeight : 0, f = a ? a.offsetWidth : 0, p = e.top - d < u.top ? u.top : e.top - d, g = e.left + f < u.left ? u.left : e.left; c.top = p + "px", c.left = g + "px" } }, updateHighlighter: function (t, e) { var n = h(t), i = n.data("model"); if (i && (!i || "selected" != i.get("status"))) { var r = this.canvas.getHighlighter(), o = r.style; o.left = e.left + "px", o.top = e.top + "px", o.height = e.height + "px", o.width = e.width + "px", o.display = "block" } }, onSelect: function () { var t = this.editor, e = this.em.getSelected(); if (this.updateToolbar(e), e) { var n = e.view.el; this.showFixedElementOffset(n), this.hideElementOffset(), this.hideHighlighter(), this.initResize(n) } else t.stopCommand("resize") }, initResize: function (t) { var e, n = this.em, r = n ? n.get("Editor") : "", s = n ? n.get("Config") : "", a = s.stylePrefix || "", l = a + "resizing", c = n.get("selectedComponent"), h = c.get("resizable"), d = {}, f = function (t, e, n) { var i = n.docs; i && i.forEach(function (e) { var n = e.body, i = n.className || ""; n.className = ("add" == t ? i + " " + l : i.replace(l, "")).trim() }) }; r && h && (d = { onStart: function (t) { var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r = i.el, s = i.config, a = i.resizer, l = s.keyHeight, h = s.keyWidth, d = s.currentUnit; f("add", 0, i), e = n.get("StyleManager").getModelToStyle(c); var p = getComputedStyle(r), g = e.getStyle(), m = g[h] || p[h], v = g[l] || p[l]; a.startDim.w = parseFloat(m), a.startDim.h = parseFloat(v), u = 0, d && (s.unitHeight = (0, o.getUnitFromValue)(v), s.unitWidth = (0, o.getUnitFromValue)(m)) }, onMove: function () { r.trigger("change:canvasOffset") }, onEnd: function (t, e) { f("remove", 0, e), r.trigger("change:canvasOffset"), u = 1 }, updateTarget: function (t, i) { var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; if (e) { var o = r.store, s = r.selectedHandler, a = r.config, l = a.keyHeight, c = a.keyWidth, u = ["tc", "bc"].indexOf(s) >= 0, h = ["cl", "cr"].indexOf(s) >= 0, d = e.getStyle(); u || (d[c] = i.w + a.unitWidth), h || (d[l] = i.h + a.unitHeight), e.setStyle(d, { avoidStore: 1 }); n && n.trigger("update:component:style:height update:component:style:width"), o && e.trigger("change:style", e, d, {}) } } }, "object" == (void 0 === h ? "undefined" : i(h)) && (d = Object.assign(d, h)), r.runCommand("resize", { el: t, options: d })) }, updateToolbar: function (t) { var e = this.config.em, n = t == e ? e.get("selectedComponent") : t, i = this.canvas.getToolbarEl(), r = i.style; if (!n) return void (r.opacity = 0); var o = n.get("toolbar"); this.ppfx; if (e.get("Config").showToolbar && o && o.length) { if (r.opacity = "", r.display = "", !this.toolbar) { i.innerHTML = "", this.toolbar = new a(o); var l = new s({ collection: this.toolbar, editor: this.editor }); i.appendChild(l.render().el) } this.toolbar.reset(o); var c = n.view; c && this.updateToolbarPos(c.el) } else r.display = "none" }, updateToolbarPos: function (t, e) { var n = this.canvas.getToolbarEl(), i = n.style, r = this.canvas.getTargetToElementDim(n, t, { elPos: e, event: "toolbarPosUpdate" }), o = r.left + r.elementWidth - r.targetWidth; i.top = r.top + "px", i.left = o + "px" }, getCanvasPosition: function () { return this.canvas.getCanvasView().getPosition() }, clean: function () { this.selEl && this.selEl.removeClass(this.hoverClass) }, getBadge: function () { return this.canvas.getBadgeEl() }, onFrameScroll: function (t) { var e = this.cacheEl; if (e) { var n = this.getElementPos(e); this.updateBadge(e, n); var i = this.em.get("selectedComponent"); i && this.updateToolbarPos(i.view.el) } }, updateAttached: function () { var t = this.em.get("selectedComponent"); if (t) { var e = t.view; this.updateToolbarPos(e.el), this.showFixedElementOffset(e.el) } }, getElementPos: function (t, e) { return this.canvas.getCanvasView().getElementPos(t) }, hideBadge: function () { this.getBadge().style.display = "none" }, cleanPrevious: function (t) { t && t.set({ status: "", state: "" }) }, getContentWindow: function () { return this.frameEl.contentWindow }, run: function (t) { this.editor = t && t.get("Editor"), this.enable() }, stop: function () { this.stopSelectComponent(), this.cleanPrevious(this.em.get("selectedComponent")), this.clean(), this.em.set("selectedComponent", null), this.toggleClipboard(), this.hideBadge(), this.hideFixedElementOffset(), this.canvas.getToolbarEl().style.display = "none", this.em.off("component:update", this.updateAttached, this), this.em.off("change:canvasOffset", this.updateAttached, this), this.em.off("change:selectedComponent", this.updateToolbar, this) } } }, function (t, e, n) { "use strict"; (function (e, i) { var r = n(51), o = e.$; t.exports = i.extend({}, r, { init: function (t) { i.bindAll(this, "startDraw", "draw", "endDraw", "rollback"), this.config = t || {}, this.hType = this.config.newFixedH ? "height" : "min-height", this.allowDraw = 1 }, enable: function () { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; r.enable.apply(this, e), this.$wr.css("cursor", "crosshair"), this.allowDraw && this.$wr.on("mousedown", this.startDraw), this.ghost = this.canvas.getGhostEl() }, startDraw: function (t) { t.preventDefault(), this.stopSelectPosition(), this.ghost.style.display = "block", this.frameOff = this.getOffsetDim(), this.startPos = { top: t.pageY + this.frameOff.top, left: t.pageX + this.frameOff.left }, this.isDragged = !1, this.tempComponent = { style: {} }, this.beforeDraw(this.tempComponent), this.updateSize(this.startPos.top, this.startPos.left, 0, 0), this.toggleEvents(1) }, toggleEvents: function (t) { var e = t ? "on" : "off"; this.$wr[e]("mousemove", this.draw), this.$wr[e]("mouseup", this.endDraw), this.$canvas[e]("mousemove", this.draw), o(document)[e]("mouseup", this.endDraw), o(document)[e]("keypress", this.rollback) }, draw: function (t) { this.isDragged = !0, this.updateComponentSize(t) }, endDraw: function (t) { this.toggleEvents(); var e = {}; if (this.isDragged) { this.updateComponentSize(t), this.setRequirements(this.tempComponent); var n = this.sorter.lastPos; e = this.create(this.sorter.target, this.tempComponent, n.index, n.method), this.sorter.prevTarget = null } this.ghost.style.display = "none", this.startSelectPosition(), this.afterDraw(e) }, create: function (t, e, n, i, r) { n = "after" === i ? n + 1 : n; var s = r || {}, a = o(t), l = a.data("model"), c = a.data("collection"), u = l ? l.get("droppable") : 1; if (s.at = n, c && u) return c.add(e, s); console.warn("Invalid target position") }, setRequirements: function (t) { var e = this.config, n = t.style; n.width.replace(/\D/g, "") < e.minComponentW && (n.width = e.minComponentW + "px"), n[this.hType].replace(/\D/g, "") < e.minComponentH && (n[this.hType] = e.minComponentH + "px"), e.newFixedH && (n.overflow = "auto"), this.absoluteMode ? n.position = "absolute" : (delete n.left, delete n.top); var i = this.sorter.lastPos; return this.nearFloat(i.index, i.method, this.sorter.lastDims) && (n.float = "left"), this.config.firstCentered && this.getCanvasWrapper() == this.sorter.target && (n.margin = "0 auto"), t }, updateComponentSize: function (t) { var e = t.pageY + this.frameOff.top, n = t.pageX + this.frameOff.left, i = this.startPos, r = i.top, o = i.left, s = e - r, a = n - o; n < o && (o = n, a = i.left - n), e < r && (r = e, s = i.top - e), this.updateSize(r, o, a, s) }, updateSize: function (t, e, n, i) { var r = "px", o = this.ghost.style, s = this.tempComponent.style; o.top = s.top = t + r, o.left = s.left = e + r, o.width = s.width = n + r, o[this.hType] = s[this.hType] = i + r }, rollback: function (t, e) { ((t.which || t.keyCode) == this.config.ESCAPE_KEY || e) && (this.isDragged = !1, this.endDraw()) }, beforeDraw: function (t) { t.editable = !1 }, afterDraw: function (t) { }, run: function (t, e, n) { this.editor = t, this.sender = e, this.$wr = this.$wrapper, this.enable() }, stop: function () { this.stopSelectPosition(), this.$wrapper.css("cursor", ""), this.$wrapper.unbind() } }) }).call(e, n(0), n(1)) }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = n(70), r = function (t) { return t && t.__esModule ? t : { default: t } }(i); window.Promise = window.Promise || r.default, e.default = "function" == typeof fetch ? fetch.bind() : function (t, e) { return new r.default(function (n, i) { var o = new XMLHttpRequest; o.open(e.method || "get", t), o.withCredentials = "include" == e.credentials; for (var s in e.headers || {}) o.setRequestHeader(s, e.headers[s]); o.onload = function (t) { return n({ status: o.status, statusText: o.statusText, text: function () { return r.default.resolve(o.responseText) } }) }, o.onerror = i, o.upload && e.onProgress && (o.upload.onprogress = e.onProgress), e.body ? o.send(e.body) : o.send() }) } }, function (t, e, n) { "use strict"; t.exports = function (t) { var e = t; return { compTypes: "", parseStyle: function (t) { for (var e = {}, n = t.split(";"), i = 0, r = n.length; i < r; i++) { var o = n[i].trim(); if (o) { var s = o.split(":"); e[s[0].trim()] = s.slice(1).join(":").trim() } } return e }, parseClass: function (t) { for (var n = [], i = t.split(" "), r = 0, o = i.length; r < o; r++) { var s = i[r].trim(), a = new RegExp("^" + e.pStylePrefix); s && !a.test(s) && n.push(s) } return n }, parseNode: function (t) { for (var n = [], i = t.childNodes, r = 0, o = i.length; r < o; r++) { var s = i[r], a = {}, l = s.attributes || [], c = l.length, u = n.length - 1, h = n[u], d = this.compTypes; if (d) { for (var f = "", p = 0; p < d.length; p++) { if (f = d[p].model.isComponent(s)) break } a = f } a.tagName || (a.tagName = s.tagName ? s.tagName.toLowerCase() : ""), c && (a.attributes = {}); for (var g = 0; g < c; g++) { var m = l[g].nodeName, v = l[g].nodeValue; if ("style" == m) a.style = this.parseStyle(v); else if ("class" == m) a.classes = this.parseClass(v); else { if ("contenteditable" == m) continue; if (0 === m.indexOf("data-gjs-")) { var y = m.replace("data-gjs-", ""), b = v.length, x = v && v.substr(0, 1), w = v && v.substr(b - 1); v = "true" === v || v, v = "false" !== v && v; try { v = "{" == x && "}" == w || "[" == x && "]" == w ? JSON.parse(v) : v } catch (t) { } a[y] = v } else a.attributes[m] = v } } var C = s.childNodes.length; if (C && !a.components) { var k = s.childNodes[0]; if (1 === C && 3 === k.nodeType) a.type || (a.type = "text"), a.content = k.nodeValue; else { var S = this.parseNode(s); 1 == S.length && "text" == S[0].type && "span" == S[0].tagName ? (a.type = "text", a.content = S[0].content) : a.components = S } } if ("textnode" == a.type) { if (h && "textnode" == h.type) { h.content += a.content; continue } var T = s.nodeValue; if (" " != T && !T.trim()) continue } var M = a.components; if (!a.type && M) { for (var E = 1, P = 0, A = 0; A < M.length; A++) { var L = M[A]; if ("text" != L.type && "textnode" != L.type && e.textTags.indexOf(L.tagName) < 0) { E = 0; break } "textnode" == L.type && (P = 1) } E && P && (a.type = "text") } (a.tagName || "textnode" == a.type) && n.push(a) } return n }, parse: function (t, n) { var i = e.em && e.em.get("Config") || {}, r = { html: "", css: "" }, o = document.createElement("div"); o.innerHTML = t; var s = o.querySelectorAll("script"), a = s.length; if (!i.allowScripts) for (; a--;)s[a].parentNode.removeChild(s[a]); if (n) { for (var l = "", c = o.querySelectorAll("style"), u = c.length; u--;)l = c[u].innerHTML + l, c[u].parentNode.removeChild(c[u]); l && (r.css = n.parse(l)) } var h = this.parseNode(o); return 1 == h.length && (h = h[0]), r.html = h, r } } } }, function (t, e, n) { "use strict"; (function (e) { var i = n(0), r = n(9); t.exports = i.Collection.extend({ model: r, getStyleable: function () { return e.filter(this.models, function (t) { return t.get("active") && !t.get("private") }) }, getValid: function () { return e.filter(this.models, function (t) { return !t.get("private") }) } }) }).call(e, n(1)) }, function (t, e, n) { !function (t) { t(n(6)) }(function (t) { "use strict"; function e(t) { for (var e = {}, n = 0; n < t.length; ++n)e[t[n].toLowerCase()] = !0; return e } function n(t, e) { for (var n, i = !1; null != (n = t.next());) { if (i && "/" == n) { e.tokenize = null; break } i = "*" == n } return ["comment", "comment"] } t.defineMode("css", function (e, n) { function i(t, e) { return p = e, t } function r(t, e) { var n = t.next(); if (v[n]) { var r = v[n](t, e); if (!1 !== r) return r } return "@" == n ? (t.eatWhile(/[\w\\\-]/), i("def", t.current())) : "=" == n || ("~" == n || "|" == n) && t.eat("=") ? i(null, "compare") : '"' == n || "'" == n ? (e.tokenize = o(n), e.tokenize(t, e)) : "#" == n ? (t.eatWhile(/[\w\\\-]/), i("atom", "hash")) : "!" == n ? (t.match(/^\s*\w*/), i("keyword", "important")) : /\d/.test(n) || "." == n && t.eat(/\d/) ? (t.eatWhile(/[\w.%]/), i("number", "unit")) : "-" !== n ? /[,+>*\/]/.test(n) ? i(null, "select-op") : "." == n && t.match(/^-?[_a-z][_a-z0-9-]*/i) ? i("qualifier", "qualifier") : /[:;{}\[\]\(\)]/.test(n) ? i(null, n) : "u" == n && t.match(/rl(-prefix)?\(/) || "d" == n && t.match("omain(") || "r" == n && t.match("egexp(") ? (t.backUp(1), e.tokenize = s, i("property", "word")) : /[\w\\\-]/.test(n) ? (t.eatWhile(/[\w\\\-]/), i("property", "word")) : i(null, null) : /[\d.]/.test(t.peek()) ? (t.eatWhile(/[\w.%]/), i("number", "unit")) : t.match(/^-[\w\\\-]+/) ? (t.eatWhile(/[\w\\\-]/), t.match(/^\s*:/, !1) ? i("variable-2", "variable-definition") : i("variable-2", "variable")) : t.match(/^\w+-/) ? i("meta", "meta") : void 0 } function o(t) { return function (e, n) { for (var r, o = !1; null != (r = e.next());) { if (r == t && !o) { ")" == t && e.backUp(1); break } o = !o && "\\" == r } return (r == t || !o && ")" != t) && (n.tokenize = null), i("string", "string") } } function s(t, e) { return t.next(), t.match(/\s*[\"\')]/, !1) ? e.tokenize = null : e.tokenize = o(")"), i(null, "(") } function a(t, e, n) { this.type = t, this.indent = e, this.prev = n } function l(t, e, n, i) { return t.context = new a(n, e.indentation() + (!1 === i ? 0 : m), t.context), n } function c(t) { return t.context.prev && (t.context = t.context.prev), t.context.type } function u(t, e, n) { return O[n.context.type](t, e, n) } function h(t, e, n, i) { for (var r = i || 1; r > 0; r--)n.context = n.context.prev; return u(t, e, n) } function d(t) { var e = t.current().toLowerCase(); g = E.hasOwnProperty(e) ? "atom" : M.hasOwnProperty(e) ? "keyword" : "variable" } var f = n.inline; n.propertyKeywords || (n = t.resolveMode("text/css")); var p, g, m = e.indentUnit, v = n.tokenHooks, y = n.documentTypes || {}, b = n.mediaTypes || {}, x = n.mediaFeatures || {}, w = n.mediaValueKeywords || {}, C = n.propertyKeywords || {}, k = n.nonStandardPropertyKeywords || {}, S = n.fontProperties || {}, T = n.counterDescriptors || {}, M = n.colorKeywords || {}, E = n.valueKeywords || {}, P = n.allowNested, A = n.lineComment, L = !0 === n.supportsAtComponent, O = {}; return O.top = function (t, e, n) { if ("{" == t) return l(n, e, "block"); if ("}" == t && n.context.prev) return c(n); if (L && /@component/.test(t)) return l(n, e, "atComponentBlock"); if (/^@(-moz-)?document$/.test(t)) return l(n, e, "documentTypes"); if (/^@(media|supports|(-moz-)?document|import)$/.test(t)) return l(n, e, "atBlock"); if (/^@(font-face|counter-style)/.test(t)) return n.stateArg = t, "restricted_atBlock_before"; if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(t)) return "keyframes"; if (t && "@" == t.charAt(0)) return l(n, e, "at"); if ("hash" == t) g = "builtin"; else if ("word" == t) g = "tag"; else { if ("variable-definition" == t) return "maybeprop"; if ("interpolation" == t) return l(n, e, "interpolation"); if (":" == t) return "pseudo"; if (P && "(" == t) return l(n, e, "parens") } return n.context.type }, O.block = function (t, e, n) { if ("word" == t) { var i = e.current().toLowerCase(); return C.hasOwnProperty(i) ? (g = "property", "maybeprop") : k.hasOwnProperty(i) ? (g = "string-2", "maybeprop") : P ? (g = e.match(/^\s*:(?:\s|$)/, !1) ? "property" : "tag", "block") : (g += " error", "maybeprop") } return "meta" == t ? "block" : P || "hash" != t && "qualifier" != t ? O.top(t, e, n) : (g = "error", "block") }, O.maybeprop = function (t, e, n) { return ":" == t ? l(n, e, "prop") : u(t, e, n) }, O.prop = function (t, e, n) { if (";" == t) return c(n); if ("{" == t && P) return l(n, e, "propBlock"); if ("}" == t || "{" == t) return h(t, e, n); if ("(" == t) return l(n, e, "parens"); if ("hash" != t || /^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(e.current())) { if ("word" == t) d(e); else if ("interpolation" == t) return l(n, e, "interpolation") } else g += " error"; return "prop" }, O.propBlock = function (t, e, n) { return "}" == t ? c(n) : "word" == t ? (g = "property", "maybeprop") : n.context.type }, O.parens = function (t, e, n) { return "{" == t || "}" == t ? h(t, e, n) : ")" == t ? c(n) : "(" == t ? l(n, e, "parens") : "interpolation" == t ? l(n, e, "interpolation") : ("word" == t && d(e), "parens") }, O.pseudo = function (t, e, n) { return "meta" == t ? "pseudo" : "word" == t ? (g = "variable-3", n.context.type) : u(t, e, n) }, O.documentTypes = function (t, e, n) { return "word" == t && y.hasOwnProperty(e.current()) ? (g = "tag", n.context.type) : O.atBlock(t, e, n) }, O.atBlock = function (t, e, n) { if ("(" == t) return l(n, e, "atBlock_parens"); if ("}" == t || ";" == t) return h(t, e, n); if ("{" == t) return c(n) && l(n, e, P ? "block" : "top"); if ("interpolation" == t) return l(n, e, "interpolation"); if ("word" == t) { var i = e.current().toLowerCase(); g = "only" == i || "not" == i || "and" == i || "or" == i ? "keyword" : b.hasOwnProperty(i) ? "attribute" : x.hasOwnProperty(i) ? "property" : w.hasOwnProperty(i) ? "keyword" : C.hasOwnProperty(i) ? "property" : k.hasOwnProperty(i) ? "string-2" : E.hasOwnProperty(i) ? "atom" : M.hasOwnProperty(i) ? "keyword" : "error" } return n.context.type }, O.atComponentBlock = function (t, e, n) { return "}" == t ? h(t, e, n) : "{" == t ? c(n) && l(n, e, P ? "block" : "top", !1) : ("word" == t && (g = "error"), n.context.type) }, O.atBlock_parens = function (t, e, n) { return ")" == t ? c(n) : "{" == t || "}" == t ? h(t, e, n, 2) : O.atBlock(t, e, n) }, O.restricted_atBlock_before = function (t, e, n) { return "{" == t ? l(n, e, "restricted_atBlock") : "word" == t && "@counter-style" == n.stateArg ? (g = "variable", "restricted_atBlock_before") : u(t, e, n) }, O.restricted_atBlock = function (t, e, n) { return "}" == t ? (n.stateArg = null, c(n)) : "word" == t ? (g = "@font-face" == n.stateArg && !S.hasOwnProperty(e.current().toLowerCase()) || "@counter-style" == n.stateArg && !T.hasOwnProperty(e.current().toLowerCase()) ? "error" : "property", "maybeprop") : "restricted_atBlock" }, O.keyframes = function (t, e, n) { return "word" == t ? (g = "variable", "keyframes") : "{" == t ? l(n, e, "top") : u(t, e, n) }, O.at = function (t, e, n) { return ";" == t ? c(n) : "{" == t || "}" == t ? h(t, e, n) : ("word" == t ? g = "tag" : "hash" == t && (g = "builtin"), "at") }, O.interpolation = function (t, e, n) { return "}" == t ? c(n) : "{" == t || ";" == t ? h(t, e, n) : ("word" == t ? g = "variable" : "variable" != t && "(" != t && ")" != t && (g = "error"), "interpolation") }, { startState: function (t) { return { tokenize: null, state: f ? "block" : "top", stateArg: null, context: new a(f ? "block" : "top", t || 0, null) } }, token: function (t, e) { if (!e.tokenize && t.eatSpace()) return null; var n = (e.tokenize || r)(t, e); return n && "object" == typeof n && (p = n[1], n = n[0]), g = n, "comment" != p && (e.state = O[e.state](p, t, e)), g }, indent: function (t, e) { var n = t.context, i = e && e.charAt(0), r = n.indent; return "prop" != n.type || "}" != i && ")" != i || (n = n.prev), n.prev && ("}" != i || "block" != n.type && "top" != n.type && "interpolation" != n.type && "restricted_atBlock" != n.type ? (")" != i || "parens" != n.type && "atBlock_parens" != n.type) && ("{" != i || "at" != n.type && "atBlock" != n.type) || (r = Math.max(0, n.indent - m)) : (n = n.prev, r = n.indent)), r }, electricChars: "}", blockCommentStart: "/*", blockCommentEnd: "*/", blockCommentContinue: " * ", lineComment: A, fold: "brace" } }); var i = ["domain", "regexp", "url", "url-prefix"], r = e(i), o = ["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"], s = e(o), a = ["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid", "orientation", "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio", "pointer", "any-pointer", "hover", "any-hover"], l = e(a), c = ["landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover", "interlace", "progressive"], u = e(c), h = ["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "justify-items", "justify-self", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "z-index", "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "text-anchor", "writing-mode"], d = e(h), f = ["scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color", "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "zoom"], p = e(f), g = ["font-family", "src", "unicode-range", "font-variant", "font-feature-settings", "font-stretch", "font-weight", "font-style"], m = e(g), v = ["additive-symbols", "fallback", "negative", "pad", "prefix", "range", "speak-as", "suffix", "symbols", "system"], y = e(v), b = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"], x = e(b), w = ["above", "absolute", "activeborder", "additive", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content", "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "difference", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "japanese-formal", "japanese-informal", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal", "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "simp-chinese-formal", "simp-chinese-informal", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "tamil", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "trad-chinese-formal", "trad-chinese-informal", "transform", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"], C = e(w), k = i.concat(o).concat(a).concat(c).concat(h).concat(f).concat(b).concat(w); t.registerHelper("hintWords", "css", k), t.defineMIME("text/css", { documentTypes: r, mediaTypes: s, mediaFeatures: l, mediaValueKeywords: u, propertyKeywords: d, nonStandardPropertyKeywords: p, fontProperties: m, counterDescriptors: y, colorKeywords: x, valueKeywords: C, tokenHooks: { "/": function (t, e) { return !!t.eat("*") && (e.tokenize = n, n(t, e)) } }, name: "css" }), t.defineMIME("text/x-scss", { mediaTypes: s, mediaFeatures: l, mediaValueKeywords: u, propertyKeywords: d, nonStandardPropertyKeywords: p, colorKeywords: x, valueKeywords: C, fontProperties: m, allowNested: !0, lineComment: "//", tokenHooks: { "/": function (t, e) { return t.eat("/") ? (t.skipToEnd(), ["comment", "comment"]) : t.eat("*") ? (e.tokenize = n, n(t, e)) : ["operator", "operator"] }, ":": function (t) { return !!t.match(/\s*\{/, !1) && [null, null] }, $: function (t) { return t.match(/^[\w-]+/), t.match(/^\s*:/, !1) ? ["variable-2", "variable-definition"] : ["variable-2", "variable"] }, "#": function (t) { return !!t.eat("{") && [null, "interpolation"] } }, name: "css", helperType: "scss" }), t.defineMIME("text/x-less", { mediaTypes: s, mediaFeatures: l, mediaValueKeywords: u, propertyKeywords: d, nonStandardPropertyKeywords: p, colorKeywords: x, valueKeywords: C, fontProperties: m, allowNested: !0, lineComment: "//", tokenHooks: { "/": function (t, e) { return t.eat("/") ? (t.skipToEnd(), ["comment", "comment"]) : t.eat("*") ? (e.tokenize = n, n(t, e)) : ["operator", "operator"] }, "@": function (t) { return t.eat("{") ? [null, "interpolation"] : !t.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/, !1) && (t.eatWhile(/[\w\\\-]/), t.match(/^\s*:/, !1) ? ["variable-2", "variable-definition"] : ["variable-2", "variable"]) }, "&": function () { return ["atom", "atom"] } }, name: "css", helperType: "less" }), t.defineMIME("text/x-gss", { documentTypes: r, mediaTypes: s, mediaFeatures: l, propertyKeywords: d, nonStandardPropertyKeywords: p, fontProperties: m, counterDescriptors: y, colorKeywords: x, valueKeywords: C, supportsAtComponent: !0, tokenHooks: { "/": function (t, e) { return !!t.eat("*") && (e.tokenize = n, n(t, e)) } }, name: "css", helperType: "gss" }) }) }, function (t, e, n) { "use strict"; var i = n(0), r = n(26); t.exports = i.Model.extend({ defaults: { id: "", content: "", visible: !0, buttons: [] }, initialize: function (t) { this.btn = this.get("buttons") || [], this.buttons = new r(this.btn), this.set("buttons", this.buttons) } }) }, function (t, e, n) { "use strict"; var i = n(0), r = n(104); t.exports = i.Collection.extend({ model: r, deactivateAllExceptOne: function (t, e) { this.forEach(function (n, i) { n !== t && (n.set("active", !1), e && n.get("buttons").length && n.get("buttons").deactivateAllExceptOne(t, e)) }) }, deactivateAll: function (t) { var e = t || ""; this.forEach(function (t, n) { t.get("context") == e && (t.set("active", !1), t.get("buttons").length && t.get("buttons").deactivateAll(e)) }) }, disableAllButtons: function (t) { var e = t || ""; this.forEach(function (t, n) { t.get("context") == e && (t.set("disable", !0), t.get("buttons").length && t.get("buttons").disableAllButtons(e)) }) }, disableAllButtonsExceptOne: function (t, e) { this.forEach(function (n, i) { n !== t && (n.set("disable", !0), e && n.get("buttons").length && n.get("buttons").disableAllButtonsExceptOne(t, e)) }) } }) }, function (t, e, n) { "use strict"; var i = n(0), r = n(28); t.exports = i.View.extend({ initialize: function (t) { this.config = t.config || {}, this.pfx = this.config.stylePrefix || "", this.buttons = this.model.get("buttons"), this.className = this.pfx + "panel", this.id = this.pfx + this.model.get("id"), this.listenTo(this.model, "change:appendContent", this.appendContent), this.listenTo(this.model, "change:content", this.updateContent) }, appendContent: function () { this.$el.append(this.model.get("appendContent")) }, updateContent: function () { this.$el.html(this.model.get("content")) }, initResize: function () { var t = this.config.em, e = t ? t.get("Editor") : "", n = this.model.get("resizable"); if (e && n) { var i, r, o, s = !0 === n ? [1, 1, 1, 1] : n, a = s.length, l = 0; 2 == a ? (i = s[0], o = s[0], r = s[1], l = s[1]) : 4 == a && (i = s[0], r = s[1], o = s[2], l = s[3]); var c = e.Utils.Resizer.init({ tc: i, cr: r, bc: o, cl: l, tl: 0, tr: 0, bl: 0, br: 0, appendTo: this.el, prefix: e.getConfig().stylePrefix, posFetcher: function (t) { var e = t.getBoundingClientRect(); return { left: 0, top: 0, width: e.width, height: e.height } } }); c.blur = function () { }, c.focus(this.el) } }, render: function () { if (this.$el.attr("class", this.className), this.id && this.$el.attr("id", this.id), this.buttons.length) { var t = new r({ collection: this.buttons, config: this.config }); this.$el.append(t.render().el) } return this.$el.append(this.model.get("content")), this } }) }, function (t, e, n) { "use strict"; (function (e) { var i = n(0), r = n(106); t.exports = i.View.extend({ initialize: function (t) { this.opt = t || {}, this.config = this.opt.config || {}, this.pfx = this.config.stylePrefix || "", this.parentM = this.opt.parentM || null, this.listenTo(this.collection, "add", this.addTo), this.listenTo(this.collection, "reset", this.render), this.className = this.pfx + "buttons" }, addTo: function (t) { this.addToCollection(t) }, addToCollection: function (t, e) { var n = e || null, i = r, o = new i({ model: t, config: this.config, parentM: this.parentM }), s = o.render().el; return n ? n.appendChild(s) : this.$el.append(s), s }, render: function () { var t = document.createDocumentFragment(); return this.$el.empty(), this.collection.each(function (e) { this.addToCollection(e, t) }, this), this.$el.append(t), this.$el.attr("class", e.result(this, "className")), this } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; var i = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }; t.exports = function () { var t, e, r = {}, o = n(111), s = n(112), a = n(10), l = n(123), c = void 0; return { name: "StyleManager", getConfig: function () { return r }, init: function (n) { r = n || {}; for (var i in o) i in r || (r[i] = o[i]); var u = r.pStylePrefix; return u && (r.stylePrefix = u + r.stylePrefix), c = new a, t = new s(r.sectors, r), e = new l({ collection: t, target: r.em, config: r }), this }, addSector: function (e, n) { var i = this.getSector(e); return i || (n.id = e, i = t.add(n)), i }, getSector: function (e) { var n = t.where({ id: e }); return n.length ? n[0] : null }, getSectors: function () { return t }, addProperty: function (t, e) { var n = null, i = this.getSector(t); return i && (n = i.get("properties").add(e)), n }, getProperty: function (t, e) { var n = null, i = this.getSector(t); return i && (n = i.get("properties").where({ property: e }), n = 1 == n.length ? n[0] : n), n }, getProperties: function (t) { var e = null, n = this.getSector(t); return n && (e = n.get("properties")), e }, getModelToStyle: function (t) { var e = t.get("classes"); if (r.em && e && e.length) { var n = r.em.get("Config").devicePreviewMode, i = r.em.getDeviceModel(), o = n ? "" : t.get("state"), s = i && !n ? i.get("width") : "", a = r.em.get("CssComposer"), l = e.getStyleable(), c = a.get(l, o, s); if (c && l.length) return c } return t }, addType: function (t, e) { c.addType(t, e) }, getType: function (t) { return c.getType(t) }, getTypes: function () { return c.getTypes() }, createType: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e.model, o = void 0 === n ? {} : n, s = e.view, a = void 0 === s ? {} : s, l = this.getType(t); if (l) return new l.view(i({ model: new l.model(o), config: r }, a)) }, render: function () { return e.render().el } } } }, function (t, e, n) { "use strict"; (function (t) { Object.defineProperty(e, "__esModule", { value: !0 }); var n = t.Model, i = t.View; e.default = { types: [], initialize: function (t, e) { var n = this; this.model = function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = void 0, r = void 0, o = void 0; if (t && t.type) { var s = n.getBaseType(); o = n.getType(t.type), i = o ? o.model : s.model, r = o ? o.view : s.view } else { var a = n.recognizeType(t); o = a.type, i = o.model, r = o.view, t = a.attributes } var l = new i(t, e); return l.typeView = r, l }; var i = this.init && this.init.bind(this); i && i() }, recognizeType: function (t) { for (var e = this.getTypes(), n = 0; n < e.length; n++) { var i = e[n], r = i.isType(t); if (r = "boolean" == typeof r && r ? { type: i.id } : r) return { type: i, attributes: r } } return { type: this.getBaseType(), attributes: t } }, getBaseType: function () { var t = this.getTypes(); return t[t.length - 1] }, getTypes: function () { return this.types }, getType: function (t) { for (var e = this.getTypes(), n = 0; n < e.length; n++) { var i = e[n]; if (i.id === t) return i } }, addType: function (t, e) { var r = this.getType(t), o = this.getBaseType(), s = r ? r.model : o.model, a = r ? r.view : o.view, l = e.model, c = e.view, u = e.isType; l = l instanceof n ? l : s.extend(l || {}), c = c instanceof i ? c : a.extend(c || {}), r ? (r.model = l, r.view = c, r.isType = u || r.isType) : (e.id = t, e.model = l, e.view = c, e.isType = u || function (e) { if (e && e.type == t) return !0 }, this.getTypes().unshift(e)) } } }).call(e, n(0)) }, function (t, e, n) { "use strict"; var i = n(11); t.exports = i.extend({ defaults: Object.assign({}, i.prototype.defaults, { detached: 0, properties: [], separator: " " }), init: function () { var t = this.get("properties") || [], e = n(10); this.set("properties", new e(t)), this.listenTo(this, "change:value", this.updateValues) }, updateValues: function () { var t = this.get("value").split(this.get("separator")); this.get("properties").each(function (e, n) { var i = t.length; t[n] || t[n % i + (1 != i && i % 2 ? 1 : 0)] }) }, getDefaultValue: function (t) { var e = this.get("defaults"); return e && !t ? e : (e = "", this.get("properties").each(function (t, n) { return e += t.getDefaultValue() + " " }), e.trim()) }, getFullValue: function () { return this.get("detached") ? "" : this.get("properties").getFullValue() } }) }, function (t, e, n) { "use strict"; var i = n(16), r = n(118); t.exports = i.extend({ templateInput: function () { var t = this.pfx; this.ppfx; return '\n      <div class="' + t + "field " + t + 'stack">\n        <button type="button" id="' + t + 'add" data-add-layer>+</button>\n        <div data-layers-wrapper></div>\n      </div>\n    ' }, init: function () { var t = this.model; this.pfx; t.set("stackIndex", null), this.events["click [data-add-layer]"] = "addLayer", this.listenTo(t, "change:stackIndex", this.indexChanged), this.listenTo(t, "updateValue", this.inputValueChanged), this.delegateEvents() }, targetUpdated: function () { if (this.model.get("detached")) this.checkVisibility(); else { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; i.prototype.targetUpdated.apply(this, e) } this.refreshLayers() }, getLayers: function () { return this.model.get("layers") }, indexChanged: function (t) { var e = this.model; this.getLayers().active(e.get("stackIndex")) }, addLayer: function () { var t = this.model, e = this.getLayers(), n = t.get("properties").deepClone(); n.each(function (t) { return t.set("value", "") }); var i = e.add({ properties: n }); this.inputValueChanged(), t.set("stackIndex", e.indexOf(i)) }, inputValueChanged: function () { var t = this.model; this.elementUpdated(), t.get("detached") ? t.get("properties").each(function (t) { return t.trigger("change:value") }) : t.set("value", this.getLayerValues()) }, setValue: function () { }, getLayerValues: function () { return this.getLayers().getFullValue() }, refreshLayers: function () { var t = [], e = this.model, n = this.getLayers(); if (e.get("detached")) { var i = this.getTarget(), r = i ? i.getStyle() : {}; t = n.getLayersFromStyle(r) } else { var o = this.getTargetValue(); o = o == e.getDefaultValue() ? "" : o, t = n.getLayersFromValue(o) } n.reset(), n.add(t), e.set({ stackIndex: null }, { silent: !0 }) }, onRender: function () { var t = this, e = this.model, i = this.el.querySelector("[data-layers-wrapper]"), o = n(12), s = { propTarget: this.propTarget, onChange: function (n, i, r) { var o = i.model; if (e.get("detached")) { var s = o.get("property"), a = t.getLayers().getPropertyValues(s); i.updateTargetStyle(a, null, r) } else e.set("value", e.getFullValue(), r) } }, a = new r({ collection: this.getLayers(), stackModel: e, preview: e.get("preview"), config: this.config, propsConfig: s }).render().el; new o({ collection: this.model.get("properties"), stackModel: e, config: this.config, onChange: s.onChange, propTarget: s.propTarget, customValue: s.customValue }).render(), i.appendChild(a) } }) }, function (t, e, n) { "use strict"; (function (e) { var n = e.$; t.exports = e.View.extend({ events: { change: "handleChange" }, template: function () { return '<span class="' + this.holderClass() + '"></span>' }, inputClass: function () { return this.ppfx + "field" }, holderClass: function () { return this.ppfx + "input-holder" }, initialize: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = t.ppfx || ""; this.opts = t, this.ppfx = e, this.target = t.target || {}, this.listenTo(this.model, "change:value", this.handleModelChange) }, elementUpdated: function () { this.model.trigger("el:change") }, setValue: function (t) { var e = this.model, n = t || e.get("defaults"), i = this.getInputEl(); i && (i.value = n) }, handleModelChange: function (t, e, n) { this.setValue(e, n) }, handleChange: function (t) { t.stopPropagation(), this.model.set("value", this.getInputEl().value), this.elementUpdated() }, getInputEl: function () { if (!this.inputEl) { var t = this.model.get("defaults"); this.inputEl = n('<input type="text" placeholder="' + t + '">') } return this.inputEl.get(0) }, render: function () { var t = this.$el; return t.addClass(this.inputClass()), t.html(this.template()), t.find("." + this.holderClass()).append(this.getInputEl()), this } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; t.exports = n(5).extend({ templateInput: function () { var t = (this.pfx, this.ppfx); return '\n      <div class="' + t + "field " + t + 'field-radio">\n      </div>\n    ' }, onRender: function () { var t = this.pfx, e = this.ppfx, n = e + "radio-item-label", i = this.model, r = i.get("property"), o = i.get("list") || i.get("options") || []; if (!this.input && o && o.length) { var s = ""; o.forEach(function (i) { var o = i.className ? i.className + " " + t + "icon " + n : "", a = r + "-" + i.value, l = i.name || i.value, c = i.title ? 'title="' + i.title + '"' : ""; s += '\n            <div class="' + e + 'radio-item">\n              <input type="radio" class="' + t + 'radio" id="' + a + '" name="' + r + '" value="' + i.value + '"/>\n              <label class="' + (o || n) + '" ' + c + ' for="' + a + '">' + (o ? "" : l) + "</label>\n            </div>\n          " }); var a = this.el.querySelector("." + e + "field"); a.innerHTML = '<div class="' + e + 'radio-items">' + s + "</div>", this.input = a.firstChild } }, getInputValue: function () { var t = this.getCheckedEl(); return t ? t.value : "" }, getCheckedEl: function () { var t = this.getInputEl(); return t ? t.querySelector("input:checked") : "" }, setValue: function (t) { var e = this.model, n = t || e.get("value") || e.getDefaultValue(), i = this.getInputEl(), r = i ? i.querySelector('[value="' + n + '"]') : ""; if (r) r.checked = !0; else { var o = this.getCheckedEl(); o && (o.checked = !1) } } }) }, function (t, e, n) { "use strict"; (function (e) { e.$; t.exports = n(5).extend({ templateInput: function () { var t = this.pfx, e = this.ppfx; return '\n      <div class="' + e + "field " + e + 'select">\n        <span id="' + t + 'input-holder"></span>\n        <div class="' + e + 'sel-arrow">\n          <div class="' + e + 'd-s-arrow"></div>\n        </div>\n      </div>\n    ' }, onRender: function () { var t = this.pfx, e = this.model, n = e.get("list") || e.get("options") || []; if (!this.input) { var i = ""; n.forEach(function (t) { var e = t.name || t.value, n = t.style ? t.style.replace(/"/g, "&quot;") : "", r = n ? 'style="' + n + '"' : "", o = t.value.replace(/"/g, "&quot;"); i += '<option value="' + o + '" ' + r + ">" + e + "</option>" }); var r = this.el.querySelector("#" + t + "input-holder"); r.innerHTML = "<select>" + i + "</select>", this.input = r.firstChild } } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; var i = n(37); t.exports = n(13).extend({ setValue: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; e = Object.assign({}, e, { silent: 1 }), this.inputInst.setValue(t, e) }, onRender: function () { if (!this.input) { var t = this.ppfx, e = new i({ target: this.target, model: this.model, ppfx: t }), n = e.render(); this.el.querySelector("." + t + "fields").appendChild(n.el), this.$input = n.inputEl, this.$color = n.colorEl, this.input = this.$input.get(0), this.inputInst = n } } }) }, function (t, e, n) { "use strict"; (function (e) { n(117); var i = n(33), r = e.$; t.exports = i.extend({ template: function () { var t = this.ppfx; return '\n      <div class="' + this.holderClass() + '"></div>\n      <div class="' + t + 'field-colorp">\n        <div class="' + t + 'field-colorp-c" data-colorp-c>\n          <div class="' + t + 'checker-bg"></div>\n        </div>\n      </div>\n    ' }, inputClass: function () { var t = this.ppfx; return t + "field " + t + "field-color" }, holderClass: function () { return this.ppfx + "input-holder" }, setValue: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = this.model, i = t || n.get("defaults"), r = this.getInputEl(), o = this.getColorEl(), s = "none" != i ? i : ""; r.value = i, o.get(0).style.backgroundColor = s, e.fromTarget && (o.spectrum("set", s), this.noneColor = "none" == i) }, getColorEl: function () { if (!this.colorEl) { var t = this, e = this.model, n = r('<div class="' + this.ppfx + 'field-color-picker"></div>'), i = n.get(0).style, o = this.target && this.target.config ? this.target.config.el : "", s = function (t) { return (1 == t.getAlpha() ? t.toHexString() : t.toRgbString()).replace(/ /g, "") }, a = 0, l = void 0; this.$el.find("[data-colorp-c]").append(n), n.spectrum({ appendTo: o || "body", maxSelectionSize: 8, showPalette: !0, showAlpha: !0, chooseText: "Ok", cancelText: "", palette: [], move: function (t) { var n = s(t); i.backgroundColor = n, e.setValueFromInput(n, 0) }, change: function (n) { a = 1; var r = s(n); i.backgroundColor = r, e.setValueFromInput(r), t.noneColor = 0 }, show: function (t) { a = 0, l = s(t) }, hide: function (r) { !a && l && (t.noneColor && (l = ""), i.backgroundColor = l, n.spectrum("set", l), e.setValueFromInput(l, 0)) } }), this.colorEl = n } return this.colorEl }, render: function () { return i.prototype.render.call(this), this.getColorEl(), this } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; (function (e) { var i = n(5), r = e.$; t.exports = i.extend({ templateInput: function () { var t = this.pfx; this.ppfx; return '\n    <div class="' + t + "field " + t + "file\">\n      <div id='" + t + "input-holder'>\n        <div class=\"" + t + 'btn-c">\n          <button class="' + t + 'btn" id="' + t + 'images" type="button">\n            ' + (this.config.assetsLabel || "Images") + '\n          </button>\n        </div>\n        <div style="clear:both;"></div>\n      </div>\n      <div id="' + t + 'preview-box">\n        <div id="' + t + 'preview-file"></div>\n        <div id="' + t + 'close">&Cross;</div>\n      </div>\n    </div>\n    ' }, init: function () { var t = this.em; this.modal = t.get("Modal"), this.am = t.get("AssetManager"), this.events["click #" + this.pfx + "close"] = "removeFile", this.events["click #" + this.pfx + "images"] = "openAssetManager", this.delegateEvents() }, onRender: function () { if (!this.$input) { var t = this.model.getDefaultValue(); this.$input = r('<input placeholder="' + t + '">') } this.$preview || (this.$preview = this.$el.find("#" + this.pfx + "preview-file")), this.$previewBox || (this.$previewBox = this.$el.find("#" + this.pfx + "preview-box")), this.setValue(this.componentValue, 0) }, setValue: function (t, e) { i.prototype.setValue.apply(this, arguments), this.setPreviewView(t && t != this.model.getDefaultValue()), this.setPreview(t) }, setPreviewView: function (t) { var e = this.$previewBox; e && e[t ? "addClass" : "removeClass"](this.pfx + "show") }, spreadUrl: function (t) { this.model.set("value", t), this.setPreviewView(1) }, setPreview: function (t) { var e = this.$preview; t = t && t.indexOf("url(") < 0 ? "url(" + t + ")" : t, e && e.css("background-image", t) }, cleanValue: function () { this.setPreviewView(0), this.model.set({ value: "" }, { silent: !0 }) }, removeFile: function () { this.model.set("value", this.model.getDefaultValue()); for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; i.prototype.cleanValue.apply(this, e), this.setPreviewView(0) }, openAssetManager: function (t) { var e = this, n = this.em, i = n ? n.get("Editor") : ""; i && (this.modal.setTitle("Select image"), this.modal.setContent(this.am.getContainer()), this.am.setTarget(null), i.runCommand("open-assets", { target: this.model, onSelect: function (t) { e.modal.close(), e.spreadUrl(t.get("src")) } })) } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; var i = n(11); t.exports = i.extend({ defaults: Object.assign({}, i.prototype.defaults, { options: [] }) }) }, function (t, e, n) { "use strict"; var i = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, r = n(11), o = n(17); t.exports = r.extend({ defaults: i({}, r.prototype.defaults, { units: [], unit: "", step: 1, min: "", max: "" }), init: function () { var t = this.get("unit"), e = this.get("units"); this.input = new o({ model: this }), e.length && !t && this.set("unit", e[0]) }, parseValue: function (t) { var e = r.prototype.parseValue.apply(this, arguments), n = this.input.validateInputValue(e.value, { deepCheck: 1 }), i = n.value, o = n.unit; return e.value = i, e.unit = o, e }, getFullValue: function () { var t = this.get("value") + this.get("unit"); return r.prototype.getFullValue.apply(this, [t]) } }) }, function (t, e, n) { "use strict"; t.exports = n(42).extend({ events: { click: "onClick", dblclick: "onDblClick", "click [data-toggle=asset-remove]": "onRemove" }, getPreview: function () { var t = this.pfx; return '\n      <div class="' + t + 'preview" style="background-image: url(' + this.model.get("src") + ');"></div>\n      <div class="' + t + "preview-bg " + this.ppfx + 'checker-bg"></div>\n    ' }, getInfo: function () { var t = this.pfx, e = this.model, n = e.get("name"), i = e.get("width"), r = e.get("height"), o = e.get("unitDim"), s = i && r ? i + "x" + r + o : ""; return n = n || e.getFilename(), '\n      <div class="' + t + 'name">' + n + '</div>\n      <div class="' + t + 'dimensions">' + s + "</div>\n    " }, init: function (t) { var e = this.pfx; this.className += " " + e + "asset-image" }, onClick: function () { var t = this.config.onClick, e = this.model; this.collection.trigger("deselectAll"), this.$el.addClass(this.pfx + "highlight"), "function" == typeof t ? t(e) : this.updateTarget(this.collection.target) }, onDblClick: function () { var t = this.em, e = this.config.onDblClick, n = this.model; "function" == typeof e ? e(n) : (this.updateTarget(this.collection.target), t && t.get("Modal").close()); var i = this.collection.onSelect; "function" == typeof i && i(this.model) }, onRemove: function (t) { t.stopPropagation(), this.model.collection.remove(this.model) } }) }, function (t, e, n) { "use strict"; (function (e, n) { t.exports = e.View.extend({ initialize: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.options = t, this.collection = t.collection; var e = t.config || {}; this.config = e, this.pfx = e.stylePrefix || "", this.ppfx = e.pStylePrefix || "", this.em = e.em, this.className = this.pfx + "asset", this.listenTo(this.model, "destroy remove", this.remove), this.model.view = this; var n = this.init && this.init.bind(this); n && n(t) }, template: function () { var t = this.pfx; return '\n      <div class="' + t + 'preview-cont">\n        ' + this.getPreview() + '\n      </div>\n      <div class="' + t + 'meta">\n        ' + this.getInfo() + '\n      </div>\n      <div class="' + t + 'close" data-toggle="asset-remove">\n        &Cross;\n      </div>\n    ' }, updateTarget: function (t) { t && t.set && (t.set("attributes", n.clone(t.get("attributes"))), t.set("src", this.model.get("src"))) }, getPreview: function () { return "" }, getInfo: function () { return "" }, render: function () { var t = this.el; return t.innerHTML = this.template(this, this.model), t.className = this.className, this } }) }).call(e, n(0), n(1)) }, function (t, e, n) { "use strict"; (function (e, i) { var r = n(21), o = function (t) { return t && t.__esModule ? t : { default: t } }(r); t.exports = e.View.extend({ template: i.template('\n  <form>\n    <div id="<%= pfx %>title"><%= title %></div>\n    <input type="file" id="<%= uploadId %>" name="file" accept="image/*" <%= disabled ? \'disabled\' : \'\' %> multiple/>\n    <div style="clear:both;"></div>\n  </form>\n  '), events: {}, initialize: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.options = t; var e = t.config || {}; this.config = e, this.pfx = e.stylePrefix || "", this.ppfx = e.pStylePrefix || "", this.target = this.options.globalCollection || {}, this.uploadId = this.pfx + "uploadFile", this.disabled = void 0 !== e.disableUpload ? e.disableUpload : !e.upload && !e.embedAsBase64, this.events["change #" + this.uploadId] = "uploadFile"; var n = e.uploadFile; n ? this.uploadFile = n.bind(this) : e.embedAsBase64 && (this.uploadFile = this.constructor.embedAsBase64), this.delegateEvents() }, onUploadStart: function () { var t = this.config.em; t && t.trigger("asset:upload:start") }, onUploadEnd: function (t) { var e = this.config.em; e && e.trigger("asset:upload:end", t) }, onUploadError: function (t) { var e = this.config.em; console.error(t), this.onUploadEnd(t), e && e.trigger("asset:upload:error", t) }, onUploadResponse: function (t) { var e = this.config.em, n = this.config, i = this.target, r = "string" == typeof t ? JSON.parse(t) : t; e && e.trigger("asset:upload:response", r), n.autoAdd && i && i.add(r.data, { at: 0 }), this.onUploadEnd(t) }, uploadFile: function (t) { for (var e = this, n = t.dataTransfer ? t.dataTransfer.files : t.target.files, i = new FormData, r = this.config, s = r.params, a = 0; a < n.length; a++)i.append(r.uploadName + "[]", n[a]); for (var l in s) i.append(l, s[l]); var c = (this.target, r.upload), u = r.headers; if (void 0 === u["X-Requested-With"] && (u["X-Requested-With"] = "XMLHttpRequest"), c) return this.onUploadStart(), (0, o.default)(c, { method: "post", credentials: "include", headers: u, body: i }).then(function (t) { return 1 == (t.status / 200 | 0) ? t.text() : t.text().then(function (t) { return Promise.reject(t) }) }).then(function (t) { return e.onUploadResponse(t) }).catch(function (t) { return e.onUploadError(t) }) }, initDrop: function () { var t = this; if (!this.uploadForm && (this.uploadForm = this.$el.find("form").get(0), "draggable" in this.uploadForm)) { this.uploadFile; this.uploadForm.ondragover = function () { return this.className = t.pfx + "hover", !1 }, this.uploadForm.ondragleave = function () { return this.className = "", !1 }, this.uploadForm.ondrop = function (e) { this.className = "", e.preventDefault(), t.uploadFile(e) } } }, initDropzone: function (t) { var e = this, n = 0, i = this.config, r = t.model, o = t.el, s = r.get("Editor"), a = (r.get("Config").el, r.get("Canvas").getBody()), l = this.ppfx, c = l + "dropzone-active", u = l + "dropzone", h = function () { o.className = o.className.replace(c, "").trim(), n = 0 }, d = function () { return n || (o.className += " " + c, n = 1), !1 }, f = function () { return h(), !1 }, p = function (t) { if (h(), t.preventDefault(), t.stopPropagation(), e.uploadFile(t), i.openAssetsOnDrop && s) { var n = s.getSelected(); s.runCommand("open-assets", { target: n, onSelect: function () { s.Modal.close(), s.AssetManager.setTarget(null) } }) } return !1 }; t.$el.append('<div class="' + u + '">' + i.dropzoneContent + "</div>"), h(), "draggable" in o && [o, a].forEach(function (t) { t.ondragover = d, t.ondragleave = f, t.ondrop = p }) }, render: function () { return this.$el.html(this.template({ title: this.config.uploadText, uploadId: this.uploadId, disabled: this.disabled, pfx: this.pfx })), this.initDrop(), this.$el.attr("class", this.pfx + "file-uploader"), this } }, { embedAsBase64: function (t) { var e = this, n = t.dataTransfer ? t.dataTransfer.files : t.target.files, i = { data: [] }; if (!FileReader) return void this.onUploadError(new Error("Unsupported platform, FileReader is not defined")); var r = [], o = /^(.+)\/(.+)$/, s = !0, a = !1, l = void 0; try { for (var c, u = n[Symbol.iterator](); !(s = (c = u.next()).done); s = !0) { var h = c.value; !function (t) { var e = new Promise(function (e, n) { var i = new FileReader; i.addEventListener("load", function (r) { var s = void 0, a = t.name, l = o.exec(t.type); if ("image" === (s = l ? l[1] : t.type)) { var c = { src: i.result, name: a, type: s, height: 0, width: 0 }, u = new Image; u.addEventListener("error", function (t) { n(t) }), u.addEventListener("load", function () { c.height = u.height, c.width = u.width, e(c) }), u.src = c.src } else e(s ? { src: i.result, name: a, type: s } : i.result) }), i.addEventListener("error", function (t) { n(t) }), i.addEventListener("abort", function (t) { n("Aborted") }), i.readAsDataURL(t) }); r.push(e) }(h) } } catch (t) { a = !0, l = t } finally { try { !s && u.return && u.return() } finally { if (a) throw l } } Promise.all(r).then(function (t) { i.data = t, e.onUploadResponse(i) }, function (t) { e.onUploadError(t) }) } }) }).call(e, n(0), n(1)) }, function (t, e, n) { "use strict"; (function (e) { var i = n(45), r = function (t) { return t && t.__esModule ? t : { default: t } }(i), o = n(0), s = n(46); t.exports = o.Model.extend(r.default).extend({ defaults: { selectors: {}, selectorsAdd: "", style: {}, mediaText: "", state: "", stylable: !0 }, initialize: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this.config = t || {}; var n = e.em, i = this.config.selectors || []; if (this.em = n, n) { var r = n.get("SelectorManager"), o = []; i.forEach(function (t) { o.push(r.add(t)) }), i = o } this.set("selectors", new s(i)) }, compare: function (t, n, i, r) { var o = r || {}, s = n || "", a = i || "", l = o.selectorsAdd || ""; t instanceof Array || t.models || (t = [t]); var c = e.map(t.models || t, function (t) { return t.get("name") }), u = e.map(this.get("selectors").models, function (t) { return t.get("name") }); if (c.length !== u.length) return !1; for (var h = 0; h < c.length; h++) { for (var d = 0, f = 0; f < u.length; f++)c[h] === u[f] && (d = 1); if (0 === d) return !1 } return this.get("state") === s && (this.get("mediaText") === a && this.get("selectorsAdd") === l) } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; Object.defineProperty(e, "__esModule", { value: !0 }); var i = n(1), r = n(22), o = function (t) { return t && t.__esModule ? t : { default: t } }(r), s = (0, o.default)().parseStyle; e.default = { extendStyle: function (t) { return Object.assign({}, this.getStyle(), t) }, getStyle: function () { return Object.assign({}, this.get("style")) }, setStyle: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; (0, i.isString)(t) && (t = s(t)), this.set("style", Object.assign({}, t), e); for (var n in t) this.trigger("change:style:" + n) }, addStyle: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; "string" == typeof t ? t = { prop: e } : n = e || {}, t = this.extendStyle(t), this.setStyle(t, n) }, removeStyle: function (t) { var e = this.getStyle(); delete e[t], this.setStyle(e) } } }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.Collection.extend({ initialize: function (t, e) { this.model = function (t, e) { return this.ClassTag || (this.ClassTag = n(9)), new this.ClassTag(t, e) } } }) }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.View.extend({ itemView: "", itemsView: "", itemType: "type", initialize: function (t, e) { this.config = e || {} }, addTo: function (t) { this.add(t) }, add: function (t, e) { var n = e || null, i = this.itemView, r = t.get(this.itemType); this.itemsView && this.itemsView[r] && (i = this.itemsView[r]); var o = new i({ model: t, config: this.config }, this.config), s = o.render().el; n ? n.appendChild(s) : this.$el.append(s) }, render: function () { var t = document.createDocumentFragment(); return this.$el.empty(), this.collection.length && this.collection.each(function (e) { this.add(e, t) }, this), this.$el.append(t), this } }) }, function (t, e, n) { "use strict"; var i = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, r = n(3); t.exports = r.extend({ defaults: i({}, r.prototype.defaults, { type: "text", droppable: !1, editable: !0 }) }) }, function (t, e, n) { "use strict"; var i = n(2), r = n(4); t.exports = r.extend({ events: { dblclick: "enableEditing" }, initialize: function (t) { r.prototype.initialize.apply(this, arguments), this.disableEditing = this.disableEditing.bind(this); var e = this.model, n = this.em; this.listenTo(e, "focus active", this.enableEditing), this.listenTo(e, "change:content", this.updateContent), this.rte = n && n.get("RichTextEditor") }, enableEditing: function () { var t = this.rte; if (!this.rteEnabled && this.model.get("editable")) { if (t) try { this.activeRte = t.enable(this, this.activeRte) } catch (t) { console.error(t) } this.rteEnabled = 1, this.toggleEvents(1) } }, disableEditing: function () { var t = this.model, e = t.get("editable"), n = this.rte; if (n && e) { try { n.disable(this, this.activeRte) } catch (t) { console.error(t) } var i = this.getChildrenContainer().innerHTML, r = t.get("components"); if (r.length && r.reset(), n.customRte) t.set("content", "").set("content", i); else { var o = function t(e) { e.set({ editable: 0, highlightable: 0, removable: 0, draggable: 0, copyable: 0, toolbar: "" }), e.get("components").each(function (e) { return t(e) }) }; t.set("content", ""), r.add(i), r.each(function (t) { return o(t) }), r.trigger("resetNavigator") } } this.rteEnabled = 0, this.toggleEvents() }, disablePropagation: function (t) { t.stopPropagation() }, toggleEvents: function (t) { var e = t ? "on" : "off", n = { on: i.on, off: i.off }, r = [this.el.ownerDocument, document]; n.off(r, "mousedown", this.disableEditing), n[e](r, "mousedown", this.disableEditing), this.$el.off("mousedown", this.disablePropagation), this.$el[e]("mousedown", this.disablePropagation) } }) }, function (t, e, n) { !function (e) { function n(t, e) { for (var n = t.length; n--;)if (t[n] === e) return n; return -1 } function i(t, e) { if (t.length != e.length) return !1; for (var n = 0; n < t.length; n++)if (t[n] !== e[n]) return !1; return !0 } function r(t) { for (x in C) C[x] = t[P[x]] } function o(t) { var e, i, o, s, a, c; if (e = t.keyCode, -1 == n(E, e) && E.push(e), 93 != e && 224 != e || (e = 91), e in C) { C[e] = !0; for (o in S) S[o] == e && (l[o] = !0) } else if (r(t), l.filter.call(this, t) && e in w) for (c = p(), s = 0; s < w[e].length; s++)if (i = w[e][s], i.scope == c || "all" == i.scope) { a = i.mods.length > 0; for (o in C) (!C[o] && n(i.mods, +o) > -1 || C[o] && -1 == n(i.mods, +o)) && (a = !1); (0 != i.mods.length || C[16] || C[18] || C[17] || C[91]) && !a || !1 === i.method(t, i) && (t.preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation && t.stopPropagation(), t.cancelBubble && (t.cancelBubble = !0)) } } function s(t) { var e, i = t.keyCode, r = n(E, i); if (r >= 0 && E.splice(r, 1), 93 != i && 224 != i || (i = 91), i in C) { C[i] = !1; for (e in S) S[e] == i && (l[e] = !1) } } function a() { for (x in C) C[x] = !1; for (x in S) l[x] = !1 } function l(t, e, n) { var i, r; i = m(t), void 0 === n && (n = e, e = "all"); for (var o = 0; o < i.length; o++)r = [], t = i[o].split("+"), t.length > 1 && (r = v(t), t = [t[t.length - 1]]), t = t[0], t = M(t), t in w || (w[t] = []), w[t].push({ shortcut: i[o], scope: e, method: n, key: i[o], mods: r }) } function c(t, e) { var n, r, o, s, a, l = []; for (n = m(t), s = 0; s < n.length; s++) { if (r = n[s].split("+"), r.length > 1 && (l = v(r), t = r[r.length - 1]), t = M(t), void 0 === e && (e = p()), !w[t]) return; for (o = 0; o < w[t].length; o++)a = w[t][o], a.scope === e && i(a.mods, l) && (w[t][o] = {}) } } function u(t) { return "string" == typeof t && (t = M(t)), -1 != n(E, t) } function h() { return E.slice(0) } function d(t) { var e = (t.target || t.srcElement).tagName; return !("INPUT" == e || "SELECT" == e || "TEXTAREA" == e) } function f(t) { k = t || "all" } function p() { return k || "all" } function g(t) { var e, n, i; for (e in w) for (n = w[e], i = 0; i < n.length;)n[i].scope === t ? n.splice(i, 1) : i++ } function m(t) { var e; return t = t.replace(/\s/g, ""), e = t.split(","), "" == e[e.length - 1] && (e[e.length - 2] += ","), e } function v(t) { for (var e = t.slice(0, t.length - 1), n = 0; n < e.length; n++)e[n] = S[e[n]]; return e } function y(t, e, n) { t.addEventListener ? t.addEventListener(e, n, !1) : t.attachEvent && t.attachEvent("on" + e, function () { n(window.event) }) } function b() { var t = e.key; return e.key = A, t } var x, w = {}, C = { 16: !1, 18: !1, 17: !1, 91: !1 }, k = "all", S = { "": 16, shift: 16, "": 18, alt: 18, option: 18, "": 17, ctrl: 17, control: 17, "": 91, command: 91 }, T = { backspace: 8, tab: 9, clear: 12, enter: 13, return: 13, esc: 27, escape: 27, space: 32, left: 37, up: 38, right: 39, down: 40, del: 46, delete: 46, home: 36, end: 35, pageup: 33, pagedown: 34, ",": 188, ".": 190, "/": 191, "`": 192, "-": 189, "=": 187, ";": 186, "'": 222, "[": 219, "]": 221, "\\": 220 }, M = function (t) { return T[t] || t.toUpperCase().charCodeAt(0) }, E = []; for (x = 1; x < 20; x++)T["f" + x] = 111 + x; var P = { 16: "shiftKey", 18: "altKey", 17: "ctrlKey", 91: "metaKey" }; for (x in S) l[x] = !1; y(document, "keydown", function (t) { o(t) }), y(document, "keyup", s), y(window, "focus", a); var A = e.key; e.key = l, e.key.setScope = f, e.key.getScope = p, e.key.deleteScope = g, e.key.filter = d, e.key.isPressed = u, e.key.getPressedKeyCodes = h, e.key.noConflict = b, e.key.unbind = c, t.exports = l }(this) }, function (t, e, n) { "use strict"; (function (e) { var n = e.$; t.exports = { startSelectPosition: function (t, e) { this.isPointed = !1; var n = this.editorModel.get("Utils"); n && !this.sorter && (this.sorter = new n.Sorter({ container: this.getCanvasBody(), placer: this.canvas.getPlacerEl(), containerSel: "*", itemSel: "*", pfx: this.ppfx, direction: "a", document: e, wmargin: 1, nested: 1, em: this.editorModel, canvasRelative: 1 })), this.sorter.startSort(t) }, getOffsetDim: function () { var t = this.offset(this.canvas.getFrameEl()), e = this.offset(this.canvas.getElement()); return { top: t.top - e.top, left: t.left - e.left } }, stopSelectPosition: function () { this.posTargetCollection = null, this.posIndex = "after" == this.posMethod && 0 !== this.cDim.length ? this.posIndex + 1 : this.posIndex, this.sorter && (this.sorter.moved = 0, this.sorter.endMove()), this.cDim && (this.posIsLastEl = 0 !== this.cDim.length && "after" == this.posMethod && this.posIndex == this.cDim.length, this.posTargetEl = 0 === this.cDim.length ? n(this.outsideElem) : !this.posIsLastEl && this.cDim[this.posIndex] ? n(this.cDim[this.posIndex][5]).parent() : n(this.outsideElem), this.posTargetModel = this.posTargetEl.data("model"), this.posTargetCollection = this.posTargetEl.data("model-comp")) }, enable: function () { this.startSelectPosition() }, nearFloat: function (t, e, n) { var i = t || 0, r = e || "before", o = n.length, s = 0 !== o && "after" == r && i == o; return 0 !== o && (!s && !n[i][4] || n[i - 1] && !n[i - 1][4] || s && !n[i - 1][4]) ? 1 : 0 }, run: function () { this.enable() }, stop: function () { this.stopSelectPosition(), this.$wrapper.css("cursor", ""), this.$wrapper.unbind() } } }).call(e, n(0)) }, function (t, e, n) { "use strict"; (function (e) { var i = (n(0), n(20)); t.exports = e.extend({}, i, { init: function () { for (var t = arguments.length, n = Array(t), r = 0; r < t; r++)n[r] = arguments[r]; i.init.apply(this, n), e.bindAll(this, "insertComponent"), this.allowDraw = 0 }, run: function (t, e, n) { this.em = t, this.sender = e, this.opt = n || {}, this.$wr = this.$wrapper, this.enable() }, enable: function () { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; i.enable.apply(this, e), this.$wr.on("click", this.insertComponent) }, insertComponent: function () { this.$wr.off("click", this.insertComponent), this.stopSelectPosition(); var t = this.buildContent(); this.beforeInsert(t); var e = this.sorter.lastPos.index, n = this.create(this.sorter.target, t, e, null, { silent: !1 }); this.opt.terminateAfterInsert && this.sender ? this.sender.set("active", !1) : this.enable(), n && (this.em && this.em.editor.initChildrenComp(n), this.afterInsert(n, this)) }, beforeInsert: function (t) { }, afterInsert: function (t) { }, buildContent: function () { return this.opt.content || {} } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; (function (e) { var i, r = n(0), o = n(4); t.exports = r.View.extend({ events: { "mousedown [data-toggle-move]": "startSort", "click [data-toggle-visible]": "toggleVisibility", "click [data-toggle-select]": "handleSelect", "click [data-toggle-open]": "toggleOpening", "click [data-toggle-edit]": "handleEdit", "focusout input": "handleEditEnd" }, template: e.template('\n  <% if (hidable) { %>\n    <i id="<%= prefix %>btn-eye" class="btn fa fa-eye <%= (visible ? \'\' : \'fa-eye-slash\') %>" data-toggle-visible></i>\n  <% } %>\n\n  <div class="<%= prefix %>title-c">\n    <div class="<%= prefix %>title <%= addClass %>" style="padding-left: <%= 42 + level * 10 %>px" data-toggle-select>\n      <div class="<%= prefix %>title-inn">\n        <i class="fa fa-pencil <%= editBtnCls %>" data-toggle-edit></i>\n        <i id="<%= prefix %>caret" class="fa fa-chevron-right <%= caretCls %>" data-toggle-open></i>\n        <%= icon %>\n        <input class="<%= ppfx %>no-app <%= inputNameCls %>" value="<%= title %>" readonly>\n      </div>\n    </div>\n  </div>\n\n  <div id="<%= prefix %>counter"><%= (count ? count : \'\') %></div>\n\n  <div id="<%= prefix %>move" data-toggle-move>\n    <i class="fa fa-arrows"></i>\n  </div>\n\n  <div class="<%= prefix %>children"></div>'), initialize: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.opt = t, this.level = t.level, this.config = t.config, this.em = t.config.em, this.ppfx = this.em.get("Config").stylePrefix, this.sorter = t.sorter || "", this.pfx = this.config.stylePrefix; var e = this.pfx, n = this.ppfx, i = this.model, r = i.get("components"); i.set("open", !1), this.listenTo(r, "remove add change reset", this.checkChildren), this.listenTo(i, "destroy remove", this.remove), this.listenTo(i, "change:status", this.updateStatus), this.listenTo(i, "change:open", this.updateOpening), this.className = e + "item no-select", this.editBtnCls = e + "nav-item-edit", this.inputNameCls = n + "nav-comp-name", this.caretCls = n + "nav-item-caret", this.titleCls = e + "title", this.$el.data("model", i), this.$el.data("collection", r) }, handleEdit: function (t) { t.stopPropagation(); var e = this.getInputName(); e.readOnly = !1, e.focus() }, handleEditEnd: function (t) { t.stopPropagation(); var e = this.getInputName(); e.readOnly = !0, this.model.set("custom-name", e.value) }, getInputName: function () { return this.inputName || (this.inputName = this.el.querySelector("." + this.inputNameCls)), this.inputName }, updateOpening: function () { var t = this.opt.opened || {}, e = this.model; e.get("open") ? (this.$el.addClass("open"), this.getCaret().addClass("fa-chevron-down"), t[e.cid] = e) : (this.$el.removeClass("open"), this.getCaret().removeClass("fa-chevron-down"), delete t[e.cid]) }, toggleOpening: function (t) { t.stopPropagation(), this.model.get("components").length && this.model.set("open", !this.model.get("open")) }, handleSelect: function (t) { t.stopPropagation(), this.em && this.em.setSelected(this.model, { fromLayers: 1 }) }, startSort: function (t) { t.stopPropagation(), 0 === t.button && this.sorter && this.sorter.startSort(t.target) }, freeze: function () { this.$el.addClass(this.pfx + "opac50"), this.model.set("open", 0) }, unfreeze: function () { this.$el.removeClass(this.pfx + "opac50") }, updateStatus: function (t) { o.prototype.updateStatus.apply(this, arguments) }, toggleVisibility: function (t) { t.stopPropagation(); var n = this.pfx; this.$eye || (this.$eye = this.$el.children("#" + n + "btn-eye")); var i = e.clone(this.model.get("style")), r = this.pfx + "hide"; this.isVisible() ? (this.$el.addClass(r), this.$eye.addClass("fa-eye-slash"), i.display = "none") : (this.$el.removeClass(r), this.$eye.removeClass("fa-eye-slash"), delete i.display), this.model.set("style", i) }, isVisible: function () { var t = this.model.get("style"), e = t.display; if (!e || "none" != e) return 1 }, checkChildren: function () { var t = this.model, e = this.countChildren(t), n = this.pfx, i = n + "no-chld", r = this.$el.children("." + n + "title-c").children("." + n + "title"); this.$counter || (this.$counter = this.$el.children("#" + n + "counter")), e ? (r.removeClass(i), this.$counter.html(e)) : (r.addClass(i), this.$counter.empty(), t.set("open", 0)) }, countChildren: function (t) { var e = 0; return t.get("components").each(function (t) { var n = this.opt.isCountable, i = this.config.hideTextnode; n && !n(t, i) || e++ }, this), e }, getCaret: function () { if (!this.caret) { var t = this.pfx; this.caret = this.$el.children("." + t + "title-c").find("#" + t + "caret") } return this.caret }, render: function () { var t = this.model, r = this.pfx, o = this.isVisible(), s = this.countChildren(t), a = this.$el, l = this.level + 1; a.html(this.template({ title: t.getName(), icon: t.getIcon(), addClass: s ? "" : r + "no-chld", editBtnCls: this.editBtnCls, inputNameCls: this.inputNameCls, caretCls: this.caretCls, count: s, visible: o, hidable: this.config.hidable, prefix: r, ppfx: this.ppfx, level: l })), void 0 === i && (i = n(54)); var c = new i({ collection: t.get("components"), config: this.config, sorter: this.sorter, opened: this.opt.opened, parent: t, level: l }).render().$el; return a.find("." + r + "children").append(c), t.get("draggable") && this.config.sortable || a.children("#" + r + "move").remove(), o || (this.className += " " + r + "hide"), a.attr("class", e.result(this, "className")), this.updateOpening(), this.updateStatus(), this } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; var i = n(0), r = n(53); t.exports = i.View.extend({ initialize: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.opt = t; var e = t.config || {}; if (this.level = t.level, this.config = e, this.preview = t.preview, this.ppfx = e.pStylePrefix || "", this.pfx = e.stylePrefix || "", this.parent = t.parent, this.listenTo(this.collection, "add", this.addTo), this.listenTo(this.collection, "reset resetNavigator", this.render), this.className = this.pfx + "items", e.sortable && !this.opt.sorter) { var n = this.pfx, i = e.em.get("Utils"); this.opt.sorter = new i.Sorter({ container: e.sortContainer || this.el, containerSel: "." + n + "items", itemSel: "." + n + "item", ppfx: this.ppfx, ignoreViewChildren: 1, avoidSelectOnEnd: 1, pfx: n, nested: 1 }) } this.sorter = this.opt.sorter || "", this.$el.data("collection", this.collection), this.parent && this.$el.data("model", this.parent) }, addTo: function (t) { var e = this.collection.indexOf(t); this.addToCollection(t, null, e) }, addToCollection: function (t, e, n) { var i = this.level, o = e || null, s = r; if (this.isCountable(t, this.config.hideTextnode)) { var a = new s({ level: i, model: t, config: this.config, sorter: this.sorter, isCountable: this.isCountable, opened: this.opt.opened }), l = a.render().el; if (o) o.appendChild(l); else if (void 0 !== n) { var c = "before"; this.$el.children().length == n && (n-- , c = "after"), n < 0 ? this.$el.append(l) : this.$el.children().eq(n)[c](l) } else this.$el.append(l); return l } }, isCountable: function (t, e) { var n = t.get("type"), i = t.get("tagName"); return !(("textnode" == n || "br" == i) && e || !t.get("layerable")) }, render: function () { var t = this, e = document.createDocumentFragment(); return this.el.innerHTML = "", this.collection.each(function (n) { return t.addToCollection(n, e) }), this.el.appendChild(e), this.$el.attr("class", this.className), this } }) }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.Model.extend({ defaults: { id: "", label: "", open: !0, attributes: {} } }) }, function (t, e, n) { "use strict"; t.exports = n(57) }, function (t, e, n) { "use strict"; var i = n(8), r = function (t) { return t && t.__esModule ? t : { default: t } }(i), o = n(1); t.exports = function () { var t = n(58), e = n(59), i = n(212), s = new i, a = []; return { $: r.default, editors: a, plugins: s, version: "0.12.25", init: function () { var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, i = n.container; if (!i) throw new Error("'container' is required"); (0, o.defaults)(n, t), n.el = i instanceof window.HTMLElement ? i : document.querySelector(i); var r = new e(n).init(); return n.plugins.forEach(function (t) { var e = s.get(t); e ? e(r, n.pluginsOpts[t] || {}) : console.warn("Plugin " + t + " not found") }), r.getModel().loadOnStart(), n.autorender && r.render(), a.push(r), r } } }() }, function (t, e, n) { "use strict"; t.exports = { autorender: 1, container: "", components: "", style: "", fromElement: 0, copyPaste: !0, undoManager: !0, storageManager: {}, plugins: [], pluginsOpts: {} } }, function (t, e, n) { "use strict"; var i = n(8), r = function (t) { return t && t.__esModule ? t : { default: t } }(i); t.exports = function (t) { var e = t || {}, i = n(60), o = n(61), s = n(211); for (var a in i) a in e || (e[a] = i[a]); e.pStylePrefix = e.stylePrefix; var l = new o(e), c = new s({ model: l, config: e }); return { $: r.default, editor: l, DomComponents: l.get("DomComponents"), CssComposer: l.get("CssComposer"), StorageManager: l.get("StorageManager"), AssetManager: l.get("AssetManager"), BlockManager: l.get("BlockManager"), TraitManager: l.get("TraitManager"), SelectorManager: l.get("SelectorManager"), CodeManager: l.get("CodeManager"), Commands: l.get("Commands"), Modal: l.get("Modal"), Panels: l.get("Panels"), StyleManager: l.get("StyleManager"), Canvas: l.get("Canvas"), UndoManager: l.get("UndoManager"), DeviceManager: l.get("DeviceManager"), RichTextEditor: l.get("RichTextEditor"), Utils: l.get("Utils"), Config: l.get("Config"), init: function () { return l.init(this), this }, getConfig: function () { return e }, getHtml: function () { return l.getHtml() }, getCss: function () { return l.getCss() }, getJs: function () { return l.getJs() }, getComponents: function () { return l.get("DomComponents").getComponents() }, setComponents: function (t) { return l.setComponents(t), this }, addComponents: function (t, e) { return this.getComponents().add(t, e) }, getStyle: function () { return l.get("CssComposer").getAll() }, setStyle: function (t) { return l.setStyle(t), this }, getSelected: function () { return l.getSelected() }, getSelectedToStyle: function () { var t = l.getSelected(); if (t) return this.StyleManager.getModelToStyle(t) }, select: function (t) { return l.setSelected(t), this }, setDevice: function (t) { return l.set("device", t), this }, getDevice: function () { return l.get("device") }, runCommand: function (t, e) { var n, i = l.get("Commands").get(t); return i && (n = i.run(this, this, e), this.trigger("run:" + t)), n }, stopCommand: function (t, e) { var n, i = l.get("Commands").get(t); return i && (n = i.stop(this, this, e), this.trigger("stop:" + t)), n }, store: function (t) { return l.store(t) }, load: function (t) { return l.load(t) }, getContainer: function () { return e.el }, refresh: function () { l.refreshCanvas() }, setCustomRte: function (t) { this.RichTextEditor.customRte = t }, on: function (t, e) { return l.on(t, e) }, off: function (t, e) { return l.off(t, e) }, trigger: function (t) { return l.trigger.apply(l, arguments) }, getEl: function () { return c.el }, getModel: function () { return l }, render: function () { return l.on("loaded", function () { l.get("modules").forEach(function (t) { t.postRender && t.postRender(c) }) }), c.render(), c.el } } } }, function (t, e, n) { "use strict"; t.exports = { stylePrefix: "gjs-", components: "", copyPaste: !0, noticeOnUnload: !0, undoManager: !0, showOffsets: !1, showOffsetsSelected: !1, forceClass: !0, height: "900px", width: "100%", protectedCss: "*{box-sizing: border-box;}", canvasCss: "", defaultCommand: "select-comp", showToolbar: 1, allowScripts: 0, showDevices: 1, devicePreviewMode: 0, mediaCondition: "max-width", tagVarStart: "{[ ", tagVarEnd: " ]}", jsInHtml: !0, exportWrapper: 0, wrappesIsBody: 1, el: "", assetManager: {}, canvas: {}, layers: {}, storageManager: {}, rte: {}, domComponents: {}, modal: {}, codeManager: {}, panels: {}, commands: {}, cssComposer: {}, selectorManager: {}, deviceManager: { devices: [{ name: "Desktop", width: "" }, { name: "Tablet", width: "768px", widthMedia: "992px" }, { name: "Mobile landscape", width: "568px", widthMedia: "768px" }, { name: "Mobile portrait", width: "320px", widthMedia: "480px" }] }, styleManager: { sectors: [{ name: "General", open: !1, buildProps: ["float", "display", "position", "top", "right", "left", "bottom"] }, { name: "Dimension", open: !1, buildProps: ["width", "height", "max-width", "min-height", "margin", "padding"] }, { name: "Typography", open: !1, buildProps: ["font-family", "font-size", "font-weight", "letter-spacing", "color", "line-height", "text-align", "text-shadow"], properties: [{ property: "text-align", list: [{ value: "left", className: "fa fa-align-left" }, { value: "center", className: "fa fa-align-center" }, { value: "right", className: "fa fa-align-right" }, { value: "justify", className: "fa fa-align-justify" }] }] }, { name: "Decorations", open: !1, buildProps: ["border-radius-c", "background-color", "border-radius", "border", "box-shadow", "background"] }, { name: "Extra", open: !1, buildProps: ["transition", "perspective", "transform"] }] }, blockManager: {} } }, function (t, e, n) { "use strict"; var i = n(1), r = [n(62), n(66), n(74), n(79), n(82), n(86), n(90), n(102), n(108), n(29), n(125), n(131), n(136), n(143), n(168), n(174), n(200)], o = n(0), s = n(208), a = n(50), l = void 0; n(210)({ Backbone: o, $: o.$ }); var c = o.$; t.exports = o.Model.extend({ defaults: { clipboard: null, designerMode: !1, selectedComponent: null, previousModel: null, changesCount: 0, storables: [], modules: [], toLoad: [], opened: {}, device: "" }, initialize: function (t) { this.config = t, this.set("Config", t), this.set("modules", []), t.el && t.fromElement && (this.config.components = t.el.innerHTML), r.forEach(function (t) { this.loadModule(t) }, this), this.initUndoManager(), this.on("change:selectedComponent", this.componentSelected, this), this.on("change:changesCount", this.updateChanges, this) }, loadOnStart: function () { var t = this, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, n = this.get("StorageManager"); this.get("toLoad").forEach(function (t) { t.onLoad() }); var i = function () { t.um.clear(), t.initUndoManager(), t.get("modules").forEach(function (e) { return e.postLoad && e.postLoad(t) }), e && e() }; n && n.getConfig().autoload ? this.load(i) : i() }, updateChanges: function () { var t = this.get("StorageManager"), e = this.get("changesCount"); this.config.noticeOnUnload && e ? window.onbeforeunload = function (t) { return 1 } : window.onbeforeunload = null, t.isAutosave() && e >= t.getStepsBeforeSave() && this.store() }, loadModule: function (t) { var e = this.config, n = new t, i = n.name.charAt(0).toLowerCase() + n.name.slice(1), r = e[i] || e[n.name] || {}; r.pStylePrefix = e.pStylePrefix || ""; var o = this.get("StorageManager"); if (n.storageKey && n.store && n.load && o) { r.stm = o; var s = this.get("storables"); s.push(n), this.set("storables", s) } return r.em = this, n.init(Object.create(r)), n.private || this.set(n.name, n), n.onLoad && this.get("toLoad").push(n), this.get("modules").push(n), this }, init: function (t) { this.set("Editor", t) }, listenRules: function (t) { this.stopListening(t, "add remove", this.listenRule), this.listenTo(t, "add remove", this.listenRule), t.each(function (t) { this.listenRule(t) }, this) }, listenRule: function (t) { this.stopListening(t, "change:style", this.handleUpdates), this.listenTo(t, "change:style", this.handleUpdates) }, handleUpdates: function (t, e) { var n = this, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; i.temporary || (l && clearInterval(l), l = setTimeout(function () { i.avoidStore || n.set("changesCount", n.get("changesCount") + 1, i) }, 0)) }, initUndoManager: function () { var t = this.get("Canvas"); if (!this.um) { var e = this.get("DomComponents"); if (e && this.config.undoManager) { var n = this; this.um = new s({ register: [e.getComponents(), this.get("CssComposer").getAll()], track: !0 }), this.UndoManager = this.um, this.set("UndoManager", this.um), a("+z, ctrl+z", function () { t.isInputFocused() || (n.um.undo(!0), n.trigger("component:update")) }), a("+shift+z, ctrl+shift+z", function () { t.isInputFocused() || (n.um.redo(!0), n.trigger("component:update")) }); var i, r = { on: function (t, e, n) { var r = n || {}; if (i || (i = t.previousAttributes()), !r || !r.avoidStore) { var o = { object: t, before: i, after: t.toJSON() }; return i = null, o } }, undo: function (t, e, i, r) { t.set(e), n.trigger("change:selectedComponent") }, redo: function (t, e, i, r) { t.set(i), n.trigger("change:selectedComponent") } }; s.removeUndoType("change"), s.addUndoType("change:style", r), s.addUndoType("change:content", r) } } }, componentSelected: function (t, e, n) { this.get("selectedComponent") ? (this.trigger("select-comp", [t, e, n]), this.trigger("component:selected", arguments)) : this.trigger("deselect-comp") }, updateComponents: function (t, e, n) { var i = t.get("components"), r = t.get("classes"), o = n ? n.avoidStore : 0; this.um && this.um.register(i), this.stopListening(i, "add", this.updateComponents), this.stopListening(i, "remove", this.rmComponents), this.listenTo(i, "add", this.updateComponents), this.listenTo(i, "remove", this.rmComponents), this.stopListening(r, "add remove", this.handleUpdates), this.listenTo(r, "add remove", this.handleUpdates); var s = "change:style change:content change:attributes"; this.stopListening(t, s, this.handleUpdates), this.listenTo(t, s, this.handleUpdates), o || this.handleUpdates(t, e, n) }, initChildrenComp: function (t) { var e = t.get("components"); this.updateComponents(t, null, { avoidStore: 1 }), e.each(function (t) { this.initChildrenComp(t), this.um && this.um.register(t) }, this) }, rmComponents: function (t, e, n) { (n ? n.avoidStore : 0) || this.handleUpdates(t, e, n) }, getSelected: function () { return this.get("selectedComponent") }, setSelected: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = t; t instanceof HTMLElement && (n = c(t).data("model")), this.set("selectedComponent", n, e) }, setComponents: function (t) { return this.get("DomComponents").setComponents(t) }, getComponents: function () { var t = this.get("DomComponents"), e = this.get("CodeManager"); if (t && e) { var n = t.getComponents(); return e.getCode(n, "json") } }, setStyle: function (t) { for (var e = this.get("CssComposer").getAll(), n = 0, i = e.length; n < i; n++)e.pop(); return e.add(t), this }, getStyle: function () { return this.get("CssComposer").getAll() }, getHtml: function () { var t = this.config, e = t.exportWrapper, n = t.wrappesIsBody, i = t.jsInHtml ? this.getJs() : "", r = this.get("DomComponents").getComponent(), o = this.get("CodeManager").getCode(r, "html", { exportWrapper: e, wrappesIsBody: n }); return o += i ? "<script>" + i + "<\/script>" : "" }, getCss: function () { var t = this.config, e = t.wrappesIsBody, n = this.get("CssComposer"), i = this.get("DomComponents").getComponent(); return t.protectedCss + this.get("CodeManager").getCode(i, "css", { cssc: n, wrappesIsBody: e }) }, getJs: function () { var t = this.get("DomComponents").getWrapper(); return this.get("CodeManager").getCode(t, "js").trim() }, store: function (t) { var e = this, n = this.get("StorageManager"), i = {}; if (n) return this.get("storables").forEach(function (t) { var e = t.store(1); for (var n in e) i[n] = e[n] }), n.store(i, function () { t && t(), e.set("changesCount", 0), e.trigger("storage:store", i) }), i }, load: function () { var t = this, e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null; this.getCacheLoad(1, function (n) { t.get("storables").forEach(function (t) { return t.load(n) }), e && e(n) }) }, getCacheLoad: function (t, e) { var n = this, i = t ? 1 : 0; if (this.cacheLoad && !i) return this.cacheLoad; var r = this.get("StorageManager"), o = []; if (!r) return {}; this.get("storables").forEach(function (t) { var e = t.storageKey; e = "function" == typeof e ? e() : e, (e instanceof Array ? e : [e]).forEach(function (t) { o.push(t) }) }), r.load(o, function (t) { n.cacheLoad = t, e && e(t), n.trigger("storage:load", t) }) }, getDeviceModel: function () { var t = this.get("device"); return this.get("DeviceManager").get(t) }, runDefault: function () { var t = this.get("Commands").get(this.config.defaultCommand); t && !this.defaultRunning && (t.stop(this, this), t.run(this, this), this.defaultRunning = 1) }, stopDefault: function () { var t = this.get("Commands").get(this.config.defaultCommand); t && (t.stop(this, this), this.defaultRunning = 0) }, refreshCanvas: function () { this.set("canvasOffset", this.get("Canvas").getOffset()) }, clearSelection: function (t) { (t || window).getSelection().removeAllRanges() }, data: function (t, e, n) { if (t["_gjs-data"] || (t["_gjs-data"] = {}), (0, i.isUndefined)(n)) return t["_gjs-data"][e]; t["_gjs-data"][e] = n } }) }, function (t, e, n) { "use strict"; t.exports = function () { var t = n(63), e = n(64), i = n(65); return { name: "Utils", init: function () { return this }, Sorter: t, Resizer: e, Dragger: i } } }, function (t, e, n) { "use strict"; (function (e, i) { var r = n(2), o = e.$; t.exports = e.View.extend({ initialize: function (t) { this.opt = t || {}, i.bindAll(this, "startSort", "onMove", "endMove", "rollback", "udpateOffset", "moveDragHelper"); var e = t || {}; this.elT = 0, this.elL = 0, this.borderOffset = e.borderOffset || 10; var n = e.container; this.el = "string" == typeof n ? document.querySelector(n) : n, this.$el = o(this.el), this.containerSel = e.containerSel || "div", this.itemSel = e.itemSel || "div", this.draggable = e.draggable || !0, this.nested = e.nested || 0, this.pfx = e.pfx || "", this.ppfx = e.ppfx || "", this.freezeClass = e.freezeClass || this.pfx + "freezed", this.onStart = e.onStart || "", this.onEndMove = e.onEndMove || "", this.direction = e.direction || "v", this.onMoveClb = e.onMove || "", this.relative = e.relative || 0, this.ignoreViewChildren = e.ignoreViewChildren || 0, this.ignoreModels = e.ignoreModels || 0, this.plh = e.placer || "", this.wmargin = e.wmargin || 0, this.offTop = e.offsetTop || 0, this.offLeft = e.offsetLeft || 0, this.document = e.document || document, this.$document = o(this.document), this.dropContent = null, this.em = e.em || "", this.dragHelper = null, this.canvasRelative = e.canvasRelative || 0, this.selectOnEnd = !e.avoidSelectOnEnd, this.em && this.em.on && (this.em.on("change:canvasOffset", this.udpateOffset), this.udpateOffset()) }, getContainerEl: function () { if (!this.el) { var t = this.opt.container; this.el = "string" == typeof t ? document.querySelector(t) : t, this.$el = o(this.el) } return this.el }, getDocuments: function () { var t = this.em, e = t && t.get("Canvas").getBody().ownerDocument, n = [document]; return e && n.push(e), n }, udpateOffset: function () { var t = this.em.get("canvasOffset"); this.offTop = t.top, this.offLeft = t.left }, setDropContent: function (t) { this.dropContent = t }, toggleSortCursor: function (t) { var e = this.em, n = document.body, i = this.ppfx || this.pfx, r = i + "grabbing", o = e ? e.get("Canvas").getBody() : ""; t ? (e && e.get("Canvas").startAutoscroll(), n.className += " " + r, e && (o.className += " " + r)) : (e && e.get("Canvas").stopAutoscroll(), n.className = n.className.replace(r, "").trim(), e && (o.className = o.className.replace(r, "").trim())) }, setDragHelper: function (t, e) { for (var n = e || "", i = t.cloneNode(1), r = "", s = getComputedStyle(t), a = 0; a < s.length; a++)r += s[a] + ":" + s.getPropertyValue(s[a]) + ";"; i.setAttribute("style", r), i.className += " " + this.pfx + "bdrag", document.body.appendChild(i), this.dragHelper = i, n && this.moveDragHelper(n), this.em && o(this.em.get("Canvas").getBody().ownerDocument).off("mousemove", this.moveDragHelper).on("mousemove", this.moveDragHelper), o(document).off("mousemove", this.moveDragHelper).on("mousemove", this.moveDragHelper) }, moveDragHelper: function (t) { var e = t.target.ownerDocument; if (this.dragHelper && e) { var n = e.defaultView || e.parentWindow, i = 0, r = 0, o = n.frameElement; if (o) { var s = o.getBoundingClientRect(); i = s.top || 0, r = s.left || 0 } var a = this.dragHelper.style; a.left = t.pageX - n.pageXOffset + r + "px", a.top = t.pageY - n.pageYOffset + i + "px" } }, matches: function (t, e, n) { for (var i = t.parentNode || document.body, r = i.querySelectorAll(e), o = 0; r[o] && r[o] !== t;)++o; return !!r[o] }, closest: function (t, e) { if (t) { for (var n = t.parentNode; n && 1 === n.nodeType;) { if (this.matches(n, e)) return n; n = n.parentNode } return null } }, offset: function (t) { var e = t.getBoundingClientRect(); return { top: e.top + document.body.scrollTop, left: e.left + document.body.scrollLeft } }, createPlaceholder: function () { var t = this.pfx, e = document.createElement("div"), n = document.createElement("div"); return e.className = t + "placeholder", e.style.display = "none", e.style["pointer-events"] = "none", n.className = t + "placeholder-int", e.appendChild(n), e }, startSort: function (t) { var e = this.em, n = this.itemSel, i = this.containerSel, o = this.getContainerEl(), s = this.getDocuments(), a = this.onStart, l = this.plh; if (this.dropModel = null, this.moved = 0, t && !this.matches(t, n + ", " + i) && (t = this.closest(t, n)), this.eV = t, l || (l = this.createPlaceholder(), o.appendChild(l), this.plh = l), t) { var c = this.getSourceModel(t); c && c.set && c.set("status", "freezed") } (0, r.on)(o, "mousemove", this.onMove), (0, r.on)(s, "mouseup", this.endMove), (0, r.on)(s, "keydown", this.rollback), a && a(), e && e.clearSelection(), this.toggleSortCursor(1) }, getTargetModel: function (t) { var e = t || this.target; return o(e).data("model") }, getSourceModel: function (t) { var e = t || this.eV, n = this.dropContent, i = this.dropModel, r = this.em; if (n && r) { if (!i) { var s = r.get("DomComponents").getComponents(), a = s.add(n, { avoidUpdateStyle: 1, temporary: 1 }); i = s.remove(a, { temporary: 1 }), this.dropModel = i instanceof Array ? i[0] : i } return i } if (e) return o(e).data("model") }, selectTargetModel: function (t) { if (!(t instanceof e.Collection)) { var n = this.targetModel; n && n.set("status", ""), t && t.set && (t.set("status", "selected-parent"), this.targetModel = t) } }, onMove: function (t) { this.moved = 1; var e = this.plh, n = e.style.display; n && "none" !== n || (e.style.display = "block"); var i = this.offset(this.el); this.elT = this.wmargin ? Math.abs(i.top) : i.top, this.elL = this.wmargin ? Math.abs(i.left) : i.left; var r = t.pageY - this.elT + this.el.scrollTop, s = t.pageX - this.elL + this.el.scrollLeft; if (this.canvasRelative && this.em) { var a = this.em.get("Canvas").getMouseRelativeCanvas(t); s = a.x, r = a.y } this.rX = s, this.rY = r, this.eventMove = t; var l = this.dimsFromTarget(t.target, s, r), c = this.getTargetModel(this.target); this.selectTargetModel(c), this.lastDims = l; var u = this.findPosition(l, s, r); this.lastPos && this.lastPos.index == u.index && this.lastPos.method == u.method || (this.movePlaceholder(this.plh, l, u, this.prevTargetDim), this.$plh || (this.$plh = o(this.plh)), this.canvasRelative || (this.offTop && this.$plh.css("top", "+=" + this.offTop + "px"), this.offLeft && this.$plh.css("left", "+=" + this.offLeft + "px")), this.lastPos = u), "function" == typeof this.onMoveClb && this.onMoveClb(t) }, isInFlow: function (t, e) { if (!t) return !1; e = e || document.body; var n = t; return n.offsetHeight, !!this.styleInFlow(n, e) }, styleInFlow: function (t, e) { var n = t.style, i = o(t); if (!(n.overflow && "visible" !== n.overflow || "none" !== i.css("float") || e && "flex" == o(e).css("display"))) { switch (n.position) { case "static": case "relative": case "": break; default: return }switch (t.tagName) { case "TR": case "TBODY": case "THEAD": case "TFOOT": return !0 }switch (i.css("display")) { case "block": case "list-item": case "table": case "flex": return !0 } } }, validTarget: function (t) { var n = this.getSourceModel(), i = n && n.view && n.view.el, r = this.getTargetModel(t); t = r && r.view && r.view.el; var o = { valid: !0, src: i, srcModel: n, trg: t, trgModel: r }; if (!i || !t) return o.valid = !1, o; var s = r.get("droppable"); s = s instanceof e.Collection ? 1 : s, s = s instanceof Array ? s.join(", ") : s, o.dropInfo = s, s = "string" == typeof s ? this.matches(i, s) : s, o.droppable = s; var a = n.get("draggable"); return a = a instanceof Array ? a.join(", ") : a, o.dragInfo = a, a = "string" == typeof a ? this.matches(t, a) : a, o.draggable = a, s && a || (o.valid = !1), o }, dimsFromTarget: function (t, e, n) { var i = []; if (!t) return i; if (this.matches(t, this.itemSel + ", " + this.containerSel) || (t = this.closest(t, this.itemSel)), this.draggable instanceof Array && (t = this.closest(t, this.draggable.join(","))), !t) return i; if (this.prevTarget && this.prevTarget != t && (this.prevTarget = null), !this.prevTarget) { this.targetP = this.closest(t, this.containerSel); if (!this.validTarget(t).valid && this.targetP) return this.dimsFromTarget(this.targetP, e, n); this.prevTarget = t, this.prevTargetDim = this.getDim(t), this.cacheDimsP = this.getChildrenDim(this.targetP), this.cacheDims = this.getChildrenDim(t) } if (this.prevTarget == t && (i = this.cacheDims), this.target = this.prevTarget, this.nearBorders(this.prevTargetDim, e, n) || !this.nested && !this.cacheDims.length) { var r = this.targetP; r && this.validTarget(r).valid && (i = this.cacheDimsP, this.target = r) } return this.lastPos = null, i }, getTargetFromEl: function (t) { var e = t, n = void 0, i = this.targetPrev, r = this.containerSel; if (this.matches(e, this.itemSel + ", " + r) || (e = this.closest(e, this.itemSel)), this.draggable instanceof Array && (e = this.closest(e, this.draggable.join(","))), i && i != e && (this.targetPrev = ""), !this.targetPrev) { if (n = this.closest(e, r), !this.validTarget(e).valid && n) return this.getTargetFromEl(n); this.targetPrev = e } return this.nearElBorders(e) && (n = this.closest(e, r)) && this.validTarget(n).valid && (e = n), e }, nearElBorders: function (t) { var e = t.getBoundingClientRect(), n = t.ownerDocument.body, i = this.getCurrentPos(), r = i.x, o = i.y, s = e.top + n.scrollTop, a = e.left + n.scrollLeft, l = e.width, c = e.height; if (o < s + 10 || o > s + c - 10 || r < a + 10 || r > a + l - 10) return 1 }, getCurrentPos: function () { var t = this.eventMove; return { x: t.pageX || 0, y: t.pageY || 0 } }, getDim: function (t) { var e, n, i, r; if (this.canvasRelative && this.em) { var o = this.em.get("Canvas").getElementPos(t), s = window.getComputedStyle(t), a = parseFloat(s.marginTop), l = parseFloat(s.marginBottom), c = parseFloat(s.marginRight), u = parseFloat(s.marginLeft); e = o.top - a, n = o.left - u, i = o.height + a + l, r = o.width + u + c } else { var h = this.offset(t); e = this.relative ? t.offsetTop : h.top - (this.wmargin ? -1 : 1) * this.elT, n = this.relative ? t.offsetLeft : h.left - (this.wmargin ? -1 : 1) * this.elL, i = t.offsetHeight, r = t.offsetWidth } return [e, n, i, r] }, getChildrenDim: function (t) { var e = []; if (!t) return e; var n = this.getTargetModel(t); n && n.view && !this.ignoreViewChildren && (t = n.view.getChildrenContainer()); for (var i = t.children, r = 0, o = i.length; r < o; r++) { var s = i[r]; if (this.matches(s, this.itemSel)) { var a = this.getDim(s), l = this.direction; l = "v" == l || "h" != l && this.isInFlow(s, t), a.push(l), a.push(s), e.push(a) } } return e }, nearBorders: function (t, e, n) { var i = 0, r = this.borderOffset, o = e || 0, s = n || 0, a = t[0], l = t[1], c = t[2], u = t[3]; return (a + r > s || s > a + c - r || l + r > o || o > l + u - r) && (i = 1), !!i }, findPosition: function (t, e, n) { for (var i = { index: 0, method: "before" }, r = 0, o = 0, s = 0, a = 0, l = 0, c = 0, u = 0, h = 0, d = 0, f = t.length; d < f; d++)if (h = t[d], s = h[1] + h[3], u = h[0] + h[2], l = h[1] + h[3] / 2, c = h[0] + h[2] / 2, !(o && h[1] > o || a && c >= a || r && s < r)) if (i.index = d, h[4]) { if (n < c) { i.method = "before"; break } i.method = "after" } else n < u && (a = u), e < l ? (o = l, i.method = "before") : (r = l, i.method = "after"); return i }, movePlaceholder: function (t, e, n, i) { var r = 0, o = 0, s = 0, a = 0, l = "px", c = n.method, u = e[n.index]; if (t.style.borderColor = "transparent #62c462", t.style.borderWidth = "3px 5px", t.style.margin = "-3px 0 0", u) u[4] ? (s = u[3] + l, a = "auto", r = "before" == c ? u[0] - 0 : u[0] + u[2] - 0, o = u[1]) : (s = "auto", a = u[2] - 0 + l, r = u[0] + 0, o = "before" == c ? u[1] - 0 : u[1] + u[3] - 0, t.style.borderColor = "#62c462 transparent", t.style.borderWidth = "5px 3px", t.style.margin = "0 0 0 -3px"); else { if (!this.nested) return void (t.style.display = "none"); i && (r = i[0] + 5, o = i[1] + 5, s = parseInt(i[3]) - 10 + l, a = "auto") } t.style.top = r + l, t.style.left = o + l, s && (t.style.width = s), a && (t.style.height = a) }, endMove: function (t) { var e, n = this.getDocuments(), i = this.getContainerEl(); (0, r.off)(i, "mousemove", this.onMove), (0, r.off)(n, "mouseup", this.endMove), (0, r.off)(n, "keydown", this.rollback), this.plh.style.display = "none"; var o = (new RegExp("(?:^|\\s)" + this.freezeClass + "(?!\\S)", "gi"), this.eV); if (o) { var s = this.getSourceModel(); s && s.set && (s.set("status", ""), s.set("status", "selected")) } this.moved && (e = this.move(this.target, o, this.lastPos)), this.plh && (this.plh.style.display = "none"), "function" == typeof this.onEndMove && this.onEndMove(e); var a = this.dragHelper; a && (a.remove(), this.dragHelper = null), this.selectTargetModel(), this.toggleSortCursor() }, move: function (t, n, i) { var r = this.em; r && r.trigger("component:dragEnd:before", t, n, i); var s, a, l, c = [], u = i.index, h = this.validTarget(t), d = o(t).data("collection"), f = h.srcModel, p = h.droppable, g = h.draggable, m = h.dropInfo, v = h.dragInfo, y = this.dropContent; if (p = h.trgModel instanceof e.Collection ? 1 : p, d && p && g) { u = "after" === i.method ? u + 1 : u; var b = { at: u, noIncrement: 1 }; y ? (s = y, b.silent = !1, b.avoidUpdateStyle = 1) : (a = d.add({}, b), f && (s = f.collection.remove(f))), l = d.add(s, b), y ? this.dropContent = null : d.remove(a), this.prevTarget = null } else d || c.push("Target collection not found"), p || c.push("Target is not droppable, accepts [" + m + "]"), g || c.push("Component not draggable, acceptable by [" + v + "]"), console.warn("Invalid target position: " + c.join(", ")); return r && r.trigger("component:dragEnd", d, s, c), l }, rollback: function (t) { (0, r.off)(this.getDocuments(), "keydown", this.rollback), 27 == (t.which || t.keyCode) && (this.moved = 0, this.endMove()) } }) }).call(e, n(0), n(1)) }, function (t, e, n) { "use strict"; function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } var r = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), o = n(1), s = n(2), a = { mousePosFetcher: null, updateTarget: null, ratioDefault: 0, posFetcher: null, onStart: null, onMove: null, onEnd: null, minDim: 32, unitHeight: "px", unitWidth: "px", keyHeight: "height", keyWidth: "width", currentUnit: 1, tl: 1, tc: 1, tr: 1, cl: 1, cr: 1, bl: 1, bc: 1, br: 1 }, l = function (t, e) { var n = e.prefix || "", i = document.createElement("i"); return i.className = n + "resizer-h " + n + "resizer-h-" + t, i.setAttribute("data-" + n + "handler", t), i }, c = function (t, e) { var n = e || window, i = t.getBoundingClientRect(); return { left: i.left + n.pageXOffset, top: i.top + n.pageYOffset, width: i.width, height: i.height } }, u = function () { function t() { var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return i(this, t), this.setOptions(e), (0, o.bindAll)(this, "handleKeyDown", "handleMouseDown", "move", "stop"), this } return r(t, [{ key: "getConfig", value: function () { return this.opts } }, { key: "setOptions", value: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.opts = (0, o.defaults)(t, a), this.setup() } }, { key: "setup", value: function () { var t = this.opts, e = t.prefix || "", n = t.appendTo || document.body, i = this.container; for (i || (i = document.createElement("div"), i.className = e + "resizer-c", n.appendChild(i), this.container = i); i.firstChild;)i.removeChild(i.firstChild); var r = {};["tl", "tc", "tr", "cl", "cr", "bl", "bc", "br"].forEach(function (e) { return r[e] = t[e] ? l(e, t) : "" }); for (var o in r) { var s = r[o]; s && i.appendChild(s) } this.handlers = r, this.mousePosFetcher = t.mousePosFetcher, this.updateTarget = t.updateTarget, this.posFetcher = t.posFetcher, this.onStart = t.onStart, this.onMove = t.onMove, this.onEnd = t.onEnd } }, { key: "isHandler", value: function (t) { var e = this.handlers; for (var n in e) if (e[n] === t) return !0; return !1 } }, { key: "getFocusedEl", value: function () { return this.el } }, { key: "getDocumentEl", value: function () { return [this.el.ownerDocument, document] } }, { key: "getElementPos", value: function (t) { var e = this.posFetcher || ""; return e ? e(t) : c(t) } }, { key: "focus", value: function (t) { if (!t || t !== this.el) { this.el = t; var e = this.getElementPos(t), n = this.container, i = n.style; i.left = e.left + "px", i.top = e.top + "px", i.width = e.width + "px", i.height = e.height + "px", n.style.display = "block", (0, s.on)(this.getDocumentEl(), "mousedown", this.handleMouseDown) } } }, { key: "blur", value: function () { this.container.style.display = "none", this.el && ((0, s.off)(this.getDocumentEl(), "mousedown", this.handleMouseDown), this.el = null) } }, { key: "start", value: function (t) { if (0 === t.button) { t.preventDefault(), t.stopPropagation(); var e = this.el, n = this, i = this.opts || {}, r = "data-" + i.prefix + "handler", a = this.getElementPos(e); this.handlerAttr = t.target.getAttribute(r), this.clickedHandler = t.target, this.startDim = { t: a.top, l: a.left, w: a.width, h: a.height }, this.rectDim = { t: a.top, l: a.left, w: a.width, h: a.height }, this.startPos = { x: t.clientX, y: t.clientY }; var l = this.getDocumentEl(); (0, s.on)(l, "mousemove", this.move), (0, s.on)(l, "keydown", this.handleKeyDown), (0, s.on)(l, "mouseup", this.stop), (0, o.isFunction)(this.onStart) && this.onStart(t, { docs: l, config: i, el: e, resizer: n }), this.move(t) } } }, { key: "move", value: function (t) { var e = this.onMove, n = this.mousePosFetcher, i = n ? n(t) : { x: t.clientX, y: t.clientY }; this.currentPos = i, this.delta = { x: i.x - this.startPos.x, y: i.y - this.startPos.y }, this.keys = { shift: t.shiftKey, ctrl: t.ctrlKey, alt: t.altKey }, this.rectDim = this.calc(this), this.updateRect(0), e && e(t), 0 === t.which && this.stop(t) } }, { key: "stop", value: function (t) { var e = this.opts, n = this.getDocumentEl(); (0, s.off)(n, "mousemove", this.move), (0, s.off)(n, "keydown", this.handleKeyDown), (0, s.off)(n, "mouseup", this.stop), this.updateRect(1), (0, o.isFunction)(this.onEnd) && this.onEnd(t, { docs: n, config: e }) } }, { key: "updateRect", value: function (t) { var e = this.el, n = this, i = this.opts, r = this.rectDim, s = this.container.style, a = this.updateTarget, l = this.getSelectedHandler(), c = i.unitHeight, u = i.unitWidth; if ((0, o.isFunction)(a)) a(e, r, { store: t, selectedHandler: l, resizer: n, config: i }); else { var h = e.style; h.width = r.w + u, h.height = r.h + c } var d = this.getElementPos(e); s.left = d.left + "px", s.top = d.top + "px", s.width = d.width + "px", s.height = d.height + "px" } }, { key: "getSelectedHandler", value: function () { var t = this.handlers; if (this.selectedHandler) for (var e in t) if (t[e] === this.selectedHandler) return e } }, { key: "handleKeyDown", value: function (t) { 27 === t.keyCode && (this.rectDim = this.startDim, this.stop(t)) } }, { key: "handleMouseDown", value: function (t) { var e = t.target; this.isHandler(e) ? (this.selectedHandler = e, this.start(t)) : e !== this.el && (this.selectedHandler = "", this.blur()) } }, { key: "calc", value: function (t) { var e = this.opts || {}, n = this.startDim, i = e.minDim, r = { t: 0, l: 0, w: n.w, h: n.h }; if (t) { var o = t.handlerAttr; ~o.indexOf("r") && (r.w = Math.max(i, n.w + t.delta.x)), ~o.indexOf("b") && (r.h = Math.max(i, n.h + t.delta.y)), ~o.indexOf("l") && (r.w = Math.max(i, n.w - t.delta.x)), ~o.indexOf("t") && (r.h = Math.max(i, n.h - t.delta.y)); var s = e.ratioDefault ? !t.keys.shift : t.keys.shift; if (o.indexOf("c") < 0 && s) { var a = n.w / n.h; r.w / r.h > a ? r.h = Math.round(r.w / a) : r.w = Math.round(r.h * a) } return ~o.indexOf("l") && (r.l = n.w - r.w), ~o.indexOf("t") && (r.t = n.h - r.h), r } } }]), t }(); t.exports = { init: function (t) { return new u(t) } } }, function (t, e, n) { "use strict"; (function (e) { var n = e.$, i = function (t, e) { var n = e || window, i = t.getBoundingClientRect(); return { left: i.left + n.pageXOffset, top: i.top + n.pageYOffset, width: i.width, height: i.height } }; t.exports = { setKey: function (t, e) { }, getElementRect: function (t) { var e = this.opts.posFetcher || ""; return e ? e(t, { avoidFrameOffset: 1 }) : i(t) }, init: function (t) { return this.setOptions(t), this.handleMouseDown = this.handleMouseDown.bind(this), this.drag = this.drag.bind(this), this.move = this.move.bind(this), this.stop = this.stop.bind(this), this.setKey("up, right, down, left", this.handleKey), this }, setOptions: function (t) { this.opts = t || {} }, focus: function (t) { if (!t || t !== this.el) { this.getDocumentEl(t), this.blur(), this.el = t, this.handlers = this.opts.dragHandlers || [t]; var e = this.getElementRect(t); this.elRect = e, this.startTop = e.top, this.startLeft = e.left, this.getDocumentEl().on("mousedown", this.handleMouseDown) } }, blur: function () { this.getDocumentEl().off("mousedown", this.handleMouseDown), this.el = null }, start: function (t) { this.startPos = this.getMousePos(t); var e = this.getDocumentEl(); e.on("mousemove", this.drag), e.on("mouseup", this.stop); var n = this.opts.onStart; "function" == typeof n && n(t, { docs: e, el: this.el, start: this.startPos, elRect: this.elRect }), this.drag(t) }, stop: function (t) { var e = this.getDocumentEl(); e.off("mousemove", this.drag), e.off("mouseup", this.stop), this.lockedAxis = null; var n = this.opts.onEnd; "function" == typeof n && n(t, { docs: e, delta: this.delta, end: { x: this.startLeft + this.delta.x, y: this.startTop + this.delta.y } }) }, handleMouseDown: function (t) { var e = t.target; this.isHandler(e) && this.start(t) }, isHandler: function (t) { var e = this.handlers; for (var n in e) if (e[n] === t) return !0; return !1 }, handleKey: function (t, e) { switch (e.shortcut) { case "up": this.move(0, -1); break; case "right": this.move(1, 0); break; case "down": this.move(0, 1); break; case "left": this.move(-1, 0) } }, getDocumentEl: function (t) { var t = t || this.el; if (!this.$doc) { var e = [document]; t && e.push(t.ownerDocument), this.$doc = n(e) } return this.$doc }, getMousePos: function (t) { var e = this.opts.mousePosFetcher; return e ? e(t) : { x: t.clientX, y: t.clientY } }, drag: function (t) { var e = this.lockedAxis, n = this.getMousePos(t), i = { x: n.x - this.startPos.x, y: n.y - this.startPos.y }; if (t.shiftKey) { if (!e) { var r = i.x, o = i.y, s = Math.abs(r), a = Math.abs(o); o >= s || o <= -s ? e = "x" : (r > a || r < -a) && (e = "y") } } else e = null; "x" === e && (i.x = this.startPos.x), "y" === e && (i.y = this.startPos.y), this.lockedAxis = e, this.delta = i, this.move(i.x, i.y); var l = this.opts.onDrag; "function" == typeof l && l(t, { delta: i, current: { x: this.startLeft + i.x, y: this.startTop + i.y }, lockedAxis: e }), 0 === t.which && this.stop(t) }, move: function (t, e) { this.moveX(t), this.moveY(e) }, moveX: function (t) { var e = this.el, n = (this.opts, this.startLeft + t), i = this.opts.setX; "function" == typeof i ? i(n, { el: e, start: this.startLeft, delta: t }) : e.style.left = n + "px" }, moveY: function (t) { var e = this.el, n = (this.opts, this.startTop + t), i = this.opts.setY; "function" == typeof i ? i(n, { el: e, start: this.startTop, delta: t }) : e.style.top = n + "px" } } }).call(e, n(0)) }, function (t, e, n) { "use strict"; t.exports = function () { var t = {}, e = n(67), i = n(68), r = n(69), o = {}, s = {}; return { name: "StorageManager", init: function (n) { t = n || {}; for (var o in e) o in t || (t[o] = e[o]); return s.remote = new r(t), s.local = new i(t), t.currentStorage = t.type, this.loadDefaultProviders().setCurrent(t.type), this }, isAutosave: function () { return !!t.autosave }, setAutosave: function (e) { return t.autosave = !!e, this }, getStepsBeforeSave: function () { return t.stepsBeforeSave }, setStepsBeforeSave: function (e) { return t.stepsBeforeSave = e, this }, add: function (t, e) { return o[t] = e, this }, get: function (t) { return o[t] || null }, getStorages: function () { return o }, getCurrent: function () { return t.currentStorage }, setCurrent: function (e) { return t.currentStorage = e, this }, store: function (e, n) { var i = this.get(this.getCurrent()), r = {}; for (var o in e) r[t.id + o] = e[o]; return i ? i.store(r, n) : null }, load: function (e, n) { var i = this.get(this.getCurrent()), r = [], o = {}; "string" == typeof e && (e = [e]); for (var s = 0, a = e.length; s < a; s++)r.push(t.id + e[s]); i && i.load(r, function (e) { for (var i in e) { var r = new RegExp("^" + t.id), s = i.replace(r, ""); o[s] = e[i] } n && n(o) }) }, loadDefaultProviders: function () { for (var t in s) this.add(t, s[t]); return this }, getConfig: function () { return t } } } }, function (t, e, n) { "use strict"; t.exports = { id: "gjs-", autosave: 1, autoload: 1, type: "local", stepsBeforeSave: 1, storeComponents: 1, storeStyles: 1, storeHtml: 1, storeCss: 1, checkLocal: 1, params: {}, headers: {}, urlStore: "", urlLoad: "", beforeSend: function (t, e) { }, onComplete: function (t, e) { }, contentTypeJson: !1 } }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.Model.extend({ defaults: { checkLocal: !0 }, store: function (t, e) { this.checkStorageEnvironment(); for (var n in t) localStorage.setItem(n, t[n]); "function" == typeof e && e() }, load: function (t, e) { this.checkStorageEnvironment(); for (var n = {}, i = 0, r = t.length; i < r; i++) { var o = localStorage.getItem(t[i]); o && (n[t[i]] = o) } return "function" == typeof e && e(n), n }, remove: function (t) { this.checkStorageEnvironment(); for (var e = 0, n = t.length; e < n; e++)localStorage.removeItem(t[e]) }, checkStorageEnvironment: function () { this.get("checkLocal") && !localStorage && console.warn("Your browser doesn't support localStorage") } }) }, function (t, e, n) { "use strict"; var i = n(21), r = function (t) { return t && t.__esModule ? t : { default: t } }(i), o = n(1); t.exports = n(0).Model.extend({ fetch: r.default, defaults: { urlStore: "", urlLoad: "", params: {}, beforeSend: function () { }, onComplete: function () { }, contentTypeJson: !1 }, onStart: function () { var t = this.get("em"), e = this.get("beforeSend"); e && e(), t && t.trigger("storage:start") }, onError: function (t) { var e = this.get("em"); console.error(t), e && e.trigger("storage:error", t), this.onEnd(t) }, onEnd: function (t) { var e = this.get("em"); e && e.trigger("storage:end", t) }, onResponse: function (t, e) { var n = this.get("em"), i = this.get("onComplete"), r = this.get("contentTypeJson"), o = r && "string" == typeof t ? JSON.parse(t) : t; i && i(o), e && e(o), n && n.trigger("storage:response", o), this.onEnd(t) }, store: function (t, e) { var n = {}; for (var i in t) n[i] = t[i]; this.request(this.get("urlStore"), { body: n }, e) }, load: function (t, e) { this.request(this.get("urlLoad"), { method: "get" }, e) }, request: function (t) { var e = this, n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r = this.get("contentTypeJson"), s = this.get("headers") || {}, a = this.get("params"), l = n.body || {}, c = void 0, u = void 0; for (var h in a) l[h] = a[h]; if ((0, o.isUndefined)(s["X-Requested-With"]) && (s["X-Requested-With"] = "XMLHttpRequest"), (0, o.isUndefined)(s["Content-Type"]) && r && (s["Content-Type"] = "application/json; charset=utf-8"), r) u = JSON.stringify(l); else { u = new FormData; for (var d in l) u.append(d, l[d]) } c = { method: n.method || "post", credentials: "include", headers: s }, "post" === c.method && (c.body = u), this.onStart(), this.fetch(t, c).then(function (t) { return 1 == (t.status / 200 | 0) ? t.text() : t.text().then(function (t) { return Promise.reject(t) }) }).then(function (t) { return e.onResponse(t, i) }).catch(function (t) { return e.onError(t) }) } }) }, function (t, e, n) { (function (e) { !function (n) { function i() { } function r(t, e) { return function () { t.apply(e, arguments) } } function o(t) { if ("object" != typeof this) throw new TypeError("Promises must be constructed via new"); if ("function" != typeof t) throw new TypeError("not a function"); this._state = 0, this._handled = !1, this._value = void 0, this._deferreds = [], h(t, this) } function s(t, e) { for (; 3 === t._state;)t = t._value; if (0 === t._state) return void t._deferreds.push(e); t._handled = !0, o._immediateFn(function () { var n = 1 === t._state ? e.onFulfilled : e.onRejected; if (null === n) return void (1 === t._state ? a : l)(e.promise, t._value); var i; try { i = n(t._value) } catch (t) { return void l(e.promise, t) } a(e.promise, i) }) } function a(t, e) { try { if (e === t) throw new TypeError("A promise cannot be resolved with itself."); if (e && ("object" == typeof e || "function" == typeof e)) { var n = e.then; if (e instanceof o) return t._state = 3, t._value = e, void c(t); if ("function" == typeof n) return void h(r(n, e), t) } t._state = 1, t._value = e, c(t) } catch (e) { l(t, e) } } function l(t, e) { t._state = 2, t._value = e, c(t) } function c(t) { 2 === t._state && 0 === t._deferreds.length && o._immediateFn(function () { t._handled || o._unhandledRejectionFn(t._value) }); for (var e = 0, n = t._deferreds.length; e < n; e++)s(t, t._deferreds[e]); t._deferreds = null } function u(t, e, n) { this.onFulfilled = "function" == typeof t ? t : null, this.onRejected = "function" == typeof e ? e : null, this.promise = n } function h(t, e) { var n = !1; try { t(function (t) { n || (n = !0, a(e, t)) }, function (t) { n || (n = !0, l(e, t)) }) } catch (t) { if (n) return; n = !0, l(e, t) } } var d = setTimeout; o.prototype.catch = function (t) { return this.then(null, t) }, o.prototype.then = function (t, e) { var n = new this.constructor(i); return s(this, new u(t, e, n)), n }, o.all = function (t) { var e = Array.prototype.slice.call(t); return new o(function (t, n) { function i(o, s) { try { if (s && ("object" == typeof s || "function" == typeof s)) { var a = s.then; if ("function" == typeof a) return void a.call(s, function (t) { i(o, t) }, n) } e[o] = s, 0 == --r && t(e) } catch (t) { n(t) } } if (0 === e.length) return t([]); for (var r = e.length, o = 0; o < e.length; o++)i(o, e[o]) }) }, o.resolve = function (t) { return t && "object" == typeof t && t.constructor === o ? t : new o(function (e) { e(t) }) }, o.reject = function (t) { return new o(function (e, n) { n(t) }) }, o.race = function (t) { return new o(function (e, n) { for (var i = 0, r = t.length; i < r; i++)t[i].then(e, n) }) }, o._immediateFn = "function" == typeof e && function (t) { e(t) } || function (t) { d(t, 0) }, o._unhandledRejectionFn = function (t) { "undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", t) }, o._setImmediateFn = function (t) { o._immediateFn = t }, o._setUnhandledRejectionFn = function (t) { o._unhandledRejectionFn = t }, void 0 !== t && t.exports ? t.exports = o : n.Promise || (n.Promise = o) }(this) }).call(e, n(71).setImmediate) }, function (t, e, n) { function i(t, e) { this._id = t, this._clearFn = e } var r = Function.prototype.apply; e.setTimeout = function () { return new i(r.call(setTimeout, window, arguments), clearTimeout) }, e.setInterval = function () { return new i(r.call(setInterval, window, arguments), clearInterval) }, e.clearTimeout = e.clearInterval = function (t) { t && t.close() }, i.prototype.unref = i.prototype.ref = function () { }, i.prototype.close = function () { this._clearFn.call(window, this._id) }, e.enroll = function (t, e) { clearTimeout(t._idleTimeoutId), t._idleTimeout = e }, e.unenroll = function (t) { clearTimeout(t._idleTimeoutId), t._idleTimeout = -1 }, e._unrefActive = e.active = function (t) { clearTimeout(t._idleTimeoutId); var e = t._idleTimeout; e >= 0 && (t._idleTimeoutId = setTimeout(function () { t._onTimeout && t._onTimeout() }, e)) }, n(72), e.setImmediate = setImmediate, e.clearImmediate = clearImmediate }, function (t, e, n) { (function (t, e) { !function (t, n) { "use strict"; function i(t) { "function" != typeof t && (t = new Function("" + t)); for (var e = new Array(arguments.length - 1), n = 0; n < e.length; n++)e[n] = arguments[n + 1]; var i = { callback: t, args: e }; return c[l] = i, a(l), l++ } function r(t) { delete c[t] } function o(t) { var e = t.callback, i = t.args; switch (i.length) { case 0: e(); break; case 1: e(i[0]); break; case 2: e(i[0], i[1]); break; case 3: e(i[0], i[1], i[2]); break; default: e.apply(n, i) } } function s(t) { if (u) setTimeout(s, 0, t); else { var e = c[t]; if (e) { u = !0; try { o(e) } finally { r(t), u = !1 } } } } if (!t.setImmediate) { var a, l = 1, c = {}, u = !1, h = t.document, d = Object.getPrototypeOf && Object.getPrototypeOf(t); d = d && d.setTimeout ? d : t, "[object process]" === {}.toString.call(t.process) ? function () { a = function (t) { e.nextTick(function () { s(t) }) } }() : function () { if (t.postMessage && !t.importScripts) { var e = !0, n = t.onmessage; return t.onmessage = function () { e = !1 }, t.postMessage("", "*"), t.onmessage = n, e } }() ? function () { var e = "setImmediate$" + Math.random() + "$", n = function (n) { n.source === t && "string" == typeof n.data && 0 === n.data.indexOf(e) && s(+n.data.slice(e.length)) }; t.addEventListener ? t.addEventListener("message", n, !1) : t.attachEvent("onmessage", n), a = function (n) { t.postMessage(e + n, "*") } }() : t.MessageChannel ? function () { var t = new MessageChannel; t.port1.onmessage = function (t) { s(t.data) }, a = function (e) { t.port2.postMessage(e) } }() : h && "onreadystatechange" in h.createElement("script") ? function () { var t = h.documentElement; a = function (e) { var n = h.createElement("script"); n.onreadystatechange = function () { s(e), n.onreadystatechange = null, t.removeChild(n), n = null }, t.appendChild(n) } }() : function () { a = function (t) { setTimeout(s, 0, t) } }(), d.setImmediate = i, d.clearImmediate = r } }("undefined" == typeof self ? void 0 === t ? this : t : self) }).call(e, n(15), n(73)) }, function (t, e) { function n() { throw new Error("setTimeout has not been defined") } function i() { throw new Error("clearTimeout has not been defined") } function r(t) { if (u === setTimeout) return setTimeout(t, 0); if ((u === n || !u) && setTimeout) return u = setTimeout, setTimeout(t, 0); try { return u(t, 0) } catch (e) { try { return u.call(null, t, 0) } catch (e) { return u.call(this, t, 0) } } } function o(t) { if (h === clearTimeout) return clearTimeout(t); if ((h === i || !h) && clearTimeout) return h = clearTimeout, clearTimeout(t); try { return h(t) } catch (e) { try { return h.call(null, t) } catch (e) { return h.call(this, t) } } } function s() { g && f && (g = !1, f.length ? p = f.concat(p) : m = -1, p.length && a()) } function a() { if (!g) { var t = r(s); g = !0; for (var e = p.length; e;) { for (f = p, p = []; ++m < e;)f && f[m].run(); m = -1, e = p.length } f = null, g = !1, o(t) } } function l(t, e) { this.fun = t, this.array = e } function c() { } var u, h, d = t.exports = {}; !function () { try { u = "function" == typeof setTimeout ? setTimeout : n } catch (t) { u = n } try { h = "function" == typeof clearTimeout ? clearTimeout : i } catch (t) { h = i } }(); var f, p = [], g = !1, m = -1; d.nextTick = function (t) { var e = new Array(arguments.length - 1); if (arguments.length > 1) for (var n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; p.push(new l(t, e)), 1 !== p.length || g || r(a) }, l.prototype.run = function () { this.fun.apply(null, this.array) }, d.title = "browser", d.browser = !0, d.env = {}, d.argv = [], d.version = "", d.versions = {}, d.on = c, d.addListener = c, d.once = c, d.off = c, d.removeListener = c, d.removeAllListeners = c, d.emit = c, d.prependListener = c, d.prependOnceListener = c, d.listeners = function (t) { return [] }, d.binding = function (t) { throw new Error("process.binding is not supported") }, d.cwd = function () { return "/" }, d.chdir = function (t) { throw new Error("process.chdir is not supported") }, d.umask = function () { return 0 } }, function (t, e, n) { "use strict"; t.exports = function () { var t, e, i = {}, r = n(75), o = n(76), s = n(78); return { name: "DeviceManager", init: function (n) { i = n || {}; for (var a in r) a in i || (i[a] = r[a]); return t = new o(i.devices), e = new s({ collection: t, config: i }), this }, add: function (e, n, i) { var r = i || {}; return r.name = e, r.width = n, t.add(r) }, get: function (e) { return t.get(e) }, getAll: function () { return t }, render: function () { return e.render().el } } } }, function (t, e, n) { "use strict"; t.exports = { devices: [], deviceLabel: "Device" } }, function (t, e, n) { "use strict"; var i = n(0), r = n(77); t.exports = i.Collection.extend({ model: r }) }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.Model.extend({ idAttribute: "name", defaults: { name: "", width: "", widthMedia: null }, initialize: function () { null == this.get("widthMedia") && this.set("widthMedia", this.get("width")) } }) }, function (t, e, n) { "use strict"; (function (e) { var i = n(0); t.exports = i.View.extend({ template: e.template('\n    <div class="<%= ppfx %>device-label"><%= deviceLabel %></div>\n    <div class="<%= ppfx %>field <%= ppfx %>select">\n      <span id="<%= ppfx %>input-holder">\n        <select class="<%= ppfx %>devices"></select>\n      </span>\n      <div class="<%= ppfx %>sel-arrow">\n        <div class="<%= ppfx %>d-s-arrow"></div>\n      </div>\n    </div>\n    <button style="display:none" class="<%= ppfx %>add-trasp">+</button>'), events: { change: "updateDevice" }, initialize: function (t) { this.config = t.config || {}, this.em = this.config.em, this.ppfx = this.config.pStylePrefix || "", this.events["click ." + this.ppfx + "add-trasp"] = this.startAdd, this.listenTo(this.em, "change:device", this.updateSelect), this.delegateEvents() }, startAdd: function () { }, updateDevice: function () { var t = this.em; if (t) { var e = this.devicesEl, n = e ? e.val() : ""; t.set("device", n) } }, updateSelect: function () { var t = this.em, e = this.devicesEl; if (t && t.getDeviceModel && e) { var n = t.getDeviceModel(), i = n ? n.get("name") : ""; e.val(i) } }, getOptions: function () { var t = ""; return this.collection.each(function (e) { var n = e.get("name"); t += '<option value="' + n + '">' + n + "</option>" }), t }, render: function () { var t = this.ppfx; return this.$el.html(this.template({ ppfx: t, deviceLabel: this.config.deviceLabel })), this.devicesEl = this.$el.find("." + t + "devices"), this.devicesEl.append(this.getOptions()), this.el.className = t + "devices-c", this } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; t.exports = function () { var t, e, i = {}, r = n(80), o = n(81), s = n(22); return { compTypes: "", name: "Parser", init: function (n) { i = n || {}; for (var a in r) a in i || (i[a] = r[a]); return t = new s(i), e = new o(i), this }, parseHtml: function (n) { return t.compTypes = this.compTypes, t.parse(n, e) }, parseCss: function (t) { return e.parse(t) } } } }, function (t, e, n) { "use strict"; t.exports = { textTags: ["br", "b", "i", "u"] } }, function (t, e, n) { "use strict"; t.exports = function (t) { return { parseSelector: function (t) { for (var e = [], n = [], i = t.split(","), r = 0, o = i.length; r < o; r++) { var s = i[r].trim(); if (/^(\.{1}[\w\-]+)+(:{1,2}[\w\-()]+)?$/gi.test(s)) { var a = s.split(".").filter(Boolean); n.push(a) } else e.push(s) } return { result: n, add: e } }, parseNode: function (t) { for (var e = [], n = t.cssRules, i = 0, r = n.length; i < r; i++) { var o = n[i], s = o.selectorText, a = []; if (o.cssRules) { for (var l = this.parseNode(o), c = o.media.mediaText, u = 0, h = l.length; u < h; u++) { l[u].mediaText = c ? c.trim() : "" } e = e.concat(l) } if (s) { var d = this.parseSelector(s); s = d.result, a = d.add; for (var f = o.style, p = {}, g = 0, m = f.length; g < m; g++) { var v = f[g], y = f.getPropertyValue(v), b = f.getPropertyPriority(v); p[v] = y + (b ? " !" + b : "") } for (var x = "", w = 0, C = s.length; w < C; w++) { var k = s[w], S = {}, T = k[k.length - 1].split(/:(.+)/); T[1] && (k[k.length - 1] = T[0], S.state = T[1], T.splice(T.length - 1, 1)), S.selectors = k, S.style = p, x = S, e.push(S) } if (a.length) { var M = a.join(", "); x ? x.selectorsAdd = M : e.push({ selectors: [], selectorsAdd: M, style: p }) } } } return e }, parse: function (t) { var e = document.createElement("style"); e.innerHTML = t, document.head.appendChild(e); var n = e.sheet; document.head.removeChild(e); var i = this.parseNode(n); return 1 == i.length && (i = i[0]), i } } } }, function (t, e, n) { "use strict"; var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, r = n(1); t.exports = function (t) { var e, o, s = t || {}, a = n(83), l = n(9), c = n(23), u = n(84); return { name: "SelectorManager", init: function (t) { s = t || {}; for (var n in a) n in s || (s[n] = a[n]); var i = s.em, r = s.pStylePrefix; return r && (s.stylePrefix = r + s.stylePrefix), o = new u({ collection: new c([], { em: i, config: s }), config: s }), e = new c(s.selectors), e.on("add", function (t) { return i.trigger("selector:add", t) }), this }, add: function (t) { var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; "object" == (void 0 === t ? "undefined" : i(t)) ? n = t : n.name = t, n.label && !n.name && (n.name = l.escapeName(n.label)); var r = n.name, o = r ? this.get(r) : e.where(n)[0]; return o || e.add(n) }, addClass: function (t) { var n = []; return (0, r.isString)(t) && (t = t.trim().split(" ")), t.forEach(function (t) { return n.push(e.add({ name: t })) }), n }, get: function (t) { return e.where({ name: t })[0] }, getAll: function () { return e }, render: function (t) { if (t) { return new u({ collection: new c(t), config: s }).render().el } return o.render().el } } } }, function (t, e, n) { "use strict"; t.exports = { stylePrefix: "clm-", selectors: [], label: "Classes", statesLabel: "- State -", selectedLabel: "Selected", states: [{ name: "hover", label: "Hover" }, { name: "active", label: "Click" }, { name: "nth-of-type(2n)", label: "Even/Odd" }] } }, function (t, e, n) { "use strict"; (function (e) { var i = n(0), r = n(85); t.exports = i.View.extend({ template: e.template('\n  <div id="<%= pfx %>up">\n    <div id="<%= pfx %>label"><%= label %></div>\n    <div id="<%= pfx %>status-c">\n      <span id="<%= pfx %>input-c">\n        <div class="<%= ppfx %>field <%= ppfx %>select">\n          <span id="<%= ppfx %>input-holder">\n            <select id="<%= pfx %>states">\n              <option value=""><%= statesLabel %></option>\n            </select>\n          </span>\n          <div class="<%= ppfx %>sel-arrow">\n            <div class="<%= ppfx %>d-s-arrow"></div>\n          </div>\n        </div>\n      </span>\n    </div>\n  </div>\n  <div id="<%= pfx %>tags-field" class="<%= ppfx %>field">\n    <div id="<%= pfx %>tags-c"></div>\n    <input id="<%= pfx %>new" />\n    <span id="<%= pfx %>add-tag" class="fa fa-plus"></span>\n  </div>\n  <div id="<%= pfx %>sel-help">\n    <div id="<%= pfx %>label"><%= selectedLabel %></div>\n    <div id="<%= pfx %>sel"></div>\n    <div style="clear:both"></div>\n  </div>'), events: {}, initialize: function (t) { this.config = t.config || {}, this.pfx = this.config.stylePrefix || "", this.ppfx = this.config.pStylePrefix || "", this.className = this.pfx + "tags", this.addBtnId = this.pfx + "add-tag", this.newInputId = this.pfx + "new", this.stateInputId = this.pfx + "states", this.stateInputC = this.pfx + "input-c", this.states = this.config.states || [], this.events["click #" + this.addBtnId] = "startNewTag", this.events["blur #" + this.newInputId] = "endNewTag", this.events["keyup #" + this.newInputId] = "onInputKeyUp", this.events["change #" + this.stateInputId] = "stateChanged", this.target = this.config.em, this.listenTo(this.target, "change:selectedComponent", this.componentChanged), this.listenTo(this.target, "targetClassUpdated", this.updateSelector), this.listenTo(this.collection, "add", this.addNew), this.listenTo(this.collection, "reset", this.renderClasses), this.listenTo(this.collection, "remove", this.tagRemoved), this.delegateEvents() }, tagRemoved: function (t) { this.updateStateVis() }, getStateOptions: function () { for (var t = "", e = 0; e < this.states.length; e++)t += '<option value="' + this.states[e].name + '">' + this.states[e].label + "</option>"; return t }, addNew: function (t) { this.addToClasses(t) }, startNewTag: function (t) { this.$addBtn.get(0).style.display = "none", this.$input.show().focus() }, endNewTag: function (t) { this.$addBtn.get(0).style.display = "", this.$input.hide().val("") }, onInputKeyUp: function (t) { 13 === t.keyCode ? this.addNewTag(this.$input.val()) : 27 === t.keyCode && this.endNewTag() }, componentChanged: function (t) { this.compTarget = this.target.get("selectedComponent"); var e = this.compTarget, n = []; e && (this.getStates().val(e.get("state")), n = e.get("classes").getValid()), this.collection.reset(n), this.updateStateVis() }, updateStateVis: function () { this.collection.length ? this.getStatesC().css("display", "block") : this.getStatesC().css("display", "none"), this.updateSelector() }, updateSelector: function () { var t = this.target.get("selectedComponent"); if (this.compTarget = t, t && t.get) { var e = ""; this.collection.each(function (t) { t.get("active") && (e += "." + t.get("name")) }); var n = t.get("state"); e = n ? e + ":" + n : e, e = e || t.getName(); var i = this.el.querySelector("#" + this.pfx + "sel"); i && (i.innerHTML = e) } }, stateChanged: function (t) { this.compTarget && (this.compTarget.set("state", this.$states.val()), this.target && this.target.trigger("targetStateUpdated"), this.updateSelector()) }, addNewTag: function (t) { var e = this.target, n = this.compTarget; if (t.trim()) { if (e) { var i = e.get("SelectorManager"), r = i.add({ label: t }); if (n) { var o = n.get("classes"), s = o.length; o.add(r); var a = o.length; this.collection.add(r), a > s && e.trigger("targetClassAdded"), this.updateStateVis() } } this.endNewTag() } }, addToClasses: function (t, e) { var n = e || null, i = new r({ model: t, config: this.config, coll: this.collection }), o = i.render().el; return n ? n.appendChild(o) : this.getClasses().append(o), o }, renderClasses: function () { var t = document.createDocumentFragment(); return this.collection.each(function (e) { this.addToClasses(e, t) }, this), this.getClasses() && this.getClasses().empty().append(t), this }, getClasses: function () { return this.$classes || (this.$classes = this.$el.find("#" + this.pfx + "tags-c")), this.$classes }, getStates: function () { return this.$states || (this.$states = this.$el.find("#" + this.stateInputId)), this.$states }, getStatesC: function () { return this.$statesC || (this.$statesC = this.$el.find("#" + this.stateInputC)), this.$statesC }, render: function () { var t = this.config; return this.$el.html(this.template({ selectedLabel: t.selectedLabel, statesLabel: t.statesLabel, label: t.label, pfx: this.pfx, ppfx: this.ppfx })), this.$input = this.$el.find("input#" + this.newInputId), this.$addBtn = this.$el.find("#" + this.addBtnId), this.$classes = this.$el.find("#" + this.pfx + "tags-c"), this.$states = this.$el.find("#" + this.stateInputId), this.$statesC = this.$el.find("#" + this.stateInputC), this.$states.append(this.getStateOptions()), this.renderClasses(), this.$el.attr("class", this.className), this } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; (function (e) { var i = n(0), r = n(9); t.exports = i.View.extend({ template: e.template('\n  <span id="<%= pfx %>checkbox" class="fa"></span>\n  <span id="<%= pfx %>tag-label">\n      <input class="<%= ppfx %>no-app" value="<%= label %>" <%= inputProp %>/>\n  </span>\n  <span id="<%= pfx %>close">&Cross;</span>'), initialize: function (t) { this.config = t.config || {}, this.coll = t.coll || null, this.pfx = this.config.stylePrefix || "", this.ppfx = this.config.pStylePrefix || "", this.inputProp = "readonly", this.target = this.config.em, this.className = this.pfx + "tag", this.closeId = this.pfx + "close", this.chkId = this.pfx + "checkbox", this.labelId = this.pfx + "tag-label", this.events = {}, this.events["click #" + this.closeId] = "removeTag", this.events["click #" + this.chkId] = "changeStatus", this.events["dblclick #" + this.labelId] = "startEditTag", this.events["keypress #" + this.labelId + " input"] = "updateInputLabel", this.events["blur #" + this.labelId + " input"] = "endEditTag", this.listenTo(this.model, "change:active", this.updateStatus), this.delegateEvents() }, startEditTag: function () { this.$labelInput.prop(this.inputProp, !1) }, endEditTag: function () { var t = this.$labelInput.val(), e = r.escapeName(t); if (this.target) { var n = this.target.get("SelectorManager"); n && (n.get(e) ? this.$labelInput.val(this.model.get("label")) : this.model.set({ name: e, label: t })) } this.$labelInput.prop(this.inputProp, !0) }, changeStatus: function () { this.model.set("active", !this.model.get("active")), this.target.trigger("targetClassUpdated") }, removeTag: function (t) { var e = this, n = this.target, i = this.model, r = this.coll, o = (this.el, n && n.get("selectedComponent")); o && (o.get, o.get("classes").remove(i)), r && r.remove(i), setTimeout(function () { return e.remove() }, 0), n && n.trigger("targetClassRemoved") }, updateStatus: function () { var t = "fa-check-square-o"; this.$chk || (this.$chk = this.$el.find("#" + this.pfx + "checkbox")), this.model.get("active") ? (this.$chk.removeClass("fa-square-o").addClass(t), this.$el.removeClass("opac50")) : (this.$chk.removeClass(t).addClass("fa-square-o"), this.$el.addClass("opac50")) }, updateInputLabel: function () { this.$labelInput || (this.$labelInput = this.$el.find("input")), this.$labelInput.prop(this.inputProp, !0); var t = this.$labelInput.val().length - 1; t = t < 1 ? 1 : t, this.$labelInput.attr("size", t) }, render: function () { return this.$el.html(this.template({ label: this.model.get("label"), pfx: this.pfx, ppfx: this.ppfx, inputProp: this.inputProp })), this.$el.attr("class", this.className), this.updateStatus(), this.updateInputLabel(), this } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; t.exports = function () { var t, e, i = {}, r = n(87), o = n(88), s = n(89); return { name: "Modal", init: function (n) { i = n || {}; for (var a in r) a in i || (i[a] = r[a]); var l = i.pStylePrefix; return l && (i.stylePrefix = l + i.stylePrefix), t = new o(i), e = new s({ model: t, config: i }), this }, postRender: function (t) { this.render().appendTo(t.el) }, open: function () { return e.show(), this }, close: function () { return e.hide(), this }, isOpen: function () { return !!t.get("open") }, setTitle: function (e) { return t.set("title", e), this }, getTitle: function () { return t.get("title") }, setContent: function (e) { return t.set("content", " "), t.set("content", e), this }, getContent: function () { return t.get("content") }, getContentEl: function () { return e.getContent().get(0) }, getModel: function () { return t }, render: function () { return e.render().$el } } } }, function (t, e, n) { "use strict"; t.exports = { stylePrefix: "mdl-", title: "", content: "", backdrop: !0 } }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.Model.extend({ defaults: { title: "", content: "", open: !1 } }) }, function (t, e, n) { "use strict"; (function (e) { var i = n(0); t.exports = i.View.extend({ template: e.template('\n    <div class="<%= pfx %>dialog">\n      <div class="<%= pfx %>header">\n        <div class="<%= pfx %>title"><%= title %></div>\n        <div class="<%= pfx %>btn-close">&Cross;</div>\n      </div>\n      <div class="<%= pfx %>content">\n        <div id="<%= pfx %>c"> <%= content %> </div>\n        <div style="clear:both"></div>\n      </div>\n    </div>\n    <div class="<%= pfx %>backlayer"></div>\n    <div class="<%= pfx %>collector" style="display: none"></div>'), events: {}, initialize: function (t) { this.config = t.config || {}, this.pfx = this.config.stylePrefix || "", this.listenTo(this.model, "change:open", this.updateOpen), this.listenTo(this.model, "change:title", this.updateTitle), this.listenTo(this.model, "change:content", this.updateContent), this.events["click ." + this.pfx + "btn-close"] = "hide", this.config.backdrop && (this.events["click ." + this.pfx + "backlayer"] = "hide"), this.delegateEvents() }, getCollector: function () { return this.$collector || (this.$collector = this.$el.find("." + this.pfx + "collector")), this.$collector }, getContent: function () { var t = this.pfx; return this.$content || (this.$content = this.$el.find("." + t + "content #" + t + "c")), this.$content }, getTitle: function () { return this.$title || (this.$title = this.$el.find("." + this.pfx + "title")), this.$title.get(0) }, updateContent: function () { var t = this.getContent(), e = t.children(), n = this.getCollector(), i = this.model.get("content"); e.length && n.append(e), t.empty().append(i) }, updateTitle: function () { var t = this.getTitle(); t && (t.innerHTML = this.model.get("title")) }, updateOpen: function () { this.el.style.display = this.model.get("open") ? "" : "none" }, hide: function () { this.model.set("open", 0) }, show: function () { this.model.set("open", 1) }, render: function () { var t = this.model.toJSON(); return t.pfx = this.pfx, this.$el.html(this.template(t)), this.$el.attr("class", this.pfx + "container"), this.updateOpen(), this } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; t.exports = function () { var t = {}, e = n(91), i = n(92), r = n(93), o = n(94), s = n(95), a = n(96), l = n(101), c = {}, u = {}, h = {}, d = {}; return { getConfig: function () { return t }, config: t, EditorView: l, name: "CodeManager", init: function (n) { t = n || {}; for (var l in e) l in t || (t[l] = e[l]); var c = t.pStylePrefix; return c && (t.stylePrefix = c + t.stylePrefix), u.html = new i, u.css = new r, u.json = new o, u.js = new s, d.CodeMirror = new a, this.loadDefaultGenerators().loadDefaultViewers(), this }, addGenerator: function (t, e) { return c[t] = e, this }, getGenerator: function (t) { return c[t] || null }, getGenerators: function () { return c }, addViewer: function (t, e) { return h[t] = e, this }, getViewer: function (t) { return h[t] || null }, getViewers: function () { return h }, updateViewer: function (t, e) { t.setContent(e) }, getCode: function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = this.getGenerator(e); return i ? i.build(t, n) : "" }, loadDefaultGenerators: function () { for (var t in u) this.addGenerator(t, u[t]); return this }, loadDefaultViewers: function () { for (var t in d) this.addViewer(t, d[t]); return this } } } }, function (t, e, n) { "use strict"; t.exports = { stylePrefix: "cm-", inlineCss: !1 } }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.Model.extend({ build: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = t.get("components"); return e.exportWrapper ? e.wrappesIsBody ? "<body>" + this.buildModels(n) + "</body>" : t.toHTML() : this.buildModels(n) }, buildModels: function (t) { var e = ""; return t.each(function (t) { e += t.toHTML() }), e } }) }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.Model.extend({ initialize: function () { this.compCls = [] }, buildFromModel: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = "", i = t.get("style"), r = t.get("classes"), o = e.wrappesIsBody; if (r && r.each(function (t) { this.compCls.push(t.get("name")) }, this), i && 0 !== Object.keys(i).length) { var s = "#" + t.getId(); s = o && t.get("wrapper") ? "body" : s, n += s + "{"; for (var a in i) i.hasOwnProperty(a) && (n += a + ":" + i[a] + ";"); n += "}" } return n }, buildFromComp: function (t) { var e = t.get("components") || t, n = ""; return e.each(function (t) { var e = t.get("components"); n += this.buildFromModel(t), e.length && (n += this.buildFromComp(e)) }, this), n }, build: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e.cssc; this.compCls = []; var i = this.buildFromModel(t, e); i += this.buildFromComp(t); this.compCls; if (n) { var r = n.getAll(), o = {}; r.each(function (t) { var e = t.get("mediaText"); if (e) { var n = o[e]; return void (n ? n.push(t) : o[e] = [t]) } i += this.buildFromRule(t) }, this); for (var s in o) { for (var a = o[s], l = "", c = 0, u = a.length; c < u; c++)l += this.buildFromRule(a[c]); l && (i += "@media " + s + "{" + l + "}") } } return i }, buildFromRule: function (t) { var e = "", n = t.get("selectorsAdd"), i = t.get("selectors"), r = t.get("style"), o = t.get("state"), s = "", a = 0, l = this.compCls; if (i.each(function (t) { s += "." + t.get("name"), l.indexOf(t.get("name")) > -1 && (a = 1) }), s && a || n) { s += o ? ":" + o : "", s += n ? (s ? ", " : "") + n : ""; var c = ""; if (r && 0 !== Object.keys(r).length) for (var u in r) r.hasOwnProperty(u) && (c += u + ":" + r[u] + ";"); c && (e += s + "{" + c + "}") } return e } }) }, function (t, e, n) { "use strict"; (function (e) { var i = n(0); t.exports = i.Model.extend({ build: function (t) { var n = t.toJSON(); return this.beforeEach(n), e.each(n, function (t, e) { var r = n[e]; if (r instanceof i.Model) n[e] = this.build(r); else if (r instanceof i.Collection) { var o = r; n[e] = [], o.length && o.each(function (t, i) { n[e][i] = this.build(t) }, this) } }, this), n }, beforeEach: function (t) { delete t.status } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; (function (e) { var i = n(0); t.exports = i.Model.extend({ mapModel: function (t) { var n = "", i = t.get("script"), r = t.get("type"), o = t.get("components"), s = t.getId(); if (i) { var a = t.get("attributes"); a = e.extend({}, a, { id: s }), t.set("attributes", a); var l = t.getScriptString(); if (t.get("scriptUpdated")) this.mapJs[r + "-" + s] = { ids: [s], code: l }; else { var c = this.mapJs[r]; c ? c.ids.push(s) : this.mapJs[r] = { ids: [s], code: l } } } return o.each(function (t) { n += this.mapModel(t) }, this), n }, build: function (t) { this.mapJs = {}, this.mapModel(t); var e = ""; for (var n in this.mapJs) { var i = this.mapJs[n]; e += "\n        var items = document.querySelectorAll('" + ("#" + i.ids.join(", #")) + "');\n        for (var i = 0, len = items.length; i < len; i++) {\n          (function(){" + i.code + "}.bind(items[i]))();\n        }" } return e } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; var i = n(0), r = n(6); n(97), n(24), n(100); t.exports = i.Model.extend({ defaults: { input: "", label: "", codeName: "", theme: "", readOnly: !0, lineNumbers: !0 }, init: function (t) { return this.editor = r.fromTextArea(t, { dragDrop: !1, lineWrapping: !0, lineNumbers: this.get("lineNumbers"), readOnly: this.get("readOnly"), mode: this.get("codeName"), theme: this.get("theme") }), this }, setContent: function (t) { this.editor && (this.editor.setValue(t), this.editor.autoFormatRange && (r.commands.selectAll(this.editor), this.editor.autoFormatRange(this.editor.getCursor(!0), this.editor.getCursor(!1)), r.commands.goDocStart(this.editor))) } }) }, function (t, e, n) { !function (t) { t(n(6), n(98), n(99), n(24)) }(function (t) { "use strict"; function e(t, e, n) { var i = t.current(), r = i.search(e); return r > -1 ? t.backUp(i.length - r) : i.match(/<\/?$/) && (t.backUp(i.length), t.match(e, !1) || t.match(i)), n } function n(t) { var e = l[t]; return e || (l[t] = new RegExp("\\s+" + t + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*")) } function i(t, e) { var i = t.match(n(e)); return i ? /^\s*(.*?)\s*$/.exec(i[2])[1] : "" } function r(t, e) { return new RegExp((e ? "^" : "") + "</s*" + t + "s*>", "i") } function o(t, e) { for (var n in t) for (var i = e[n] || (e[n] = []), r = t[n], o = r.length - 1; o >= 0; o--)i.unshift(r[o]) } function s(t, e) { for (var n = 0; n < t.length; n++) { var r = t[n]; if (!r[0] || r[1].test(i(e, r[0]))) return r[2] } } var a = { script: [["lang", /(javascript|babel)/i, "javascript"], ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"], ["type", /./, "text/plain"], [null, null, "javascript"]], style: [["lang", /^css$/i, "css"], ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"], ["type", /./, "text/plain"], [null, null, "css"]] }, l = {}; t.defineMode("htmlmixed", function (n, i) { function l(i, o) { var a, h = c.token(i, o.htmlState), d = /\btag\b/.test(h); if (d && !/[<>\s\/]/.test(i.current()) && (a = o.htmlState.tagName && o.htmlState.tagName.toLowerCase()) && u.hasOwnProperty(a)) o.inTag = a + " "; else if (o.inTag && d && />$/.test(i.current())) { var f = /^([\S]+) (.*)/.exec(o.inTag); o.inTag = null; var p = ">" == i.current() && s(u[f[1]], f[2]), g = t.getMode(n, p), m = r(f[1], !0), v = r(f[1], !1); o.token = function (t, n) { return t.match(m, !1) ? (n.token = l, n.localState = n.localMode = null, null) : e(t, v, n.localMode.token(t, n.localState)) }, o.localMode = g, o.localState = t.startState(g, c.indent(o.htmlState, "")) } else o.inTag && (o.inTag += i.current(), i.eol() && (o.inTag += " ")); return h } var c = t.getMode(n, { name: "xml", htmlMode: !0, multilineTagIndentFactor: i.multilineTagIndentFactor, multilineTagIndentPastTag: i.multilineTagIndentPastTag }), u = {}, h = i && i.tags, d = i && i.scriptTypes; if (o(a, u), h && o(h, u), d) for (var f = d.length - 1; f >= 0; f--)u.script.unshift(["type", d[f].matches, d[f].mode]); return { startState: function () { return { token: l, inTag: null, localMode: null, localState: null, htmlState: t.startState(c) } }, copyState: function (e) { var n; return e.localState && (n = t.copyState(e.localMode, e.localState)), { token: e.token, inTag: e.inTag, localMode: e.localMode, localState: n, htmlState: t.copyState(c, e.htmlState) } }, token: function (t, e) { return e.token(t, e) }, indent: function (e, n, i) { return !e.localMode || /^\s*<\//.test(n) ? c.indent(e.htmlState, n) : e.localMode.indent ? e.localMode.indent(e.localState, n, i) : t.Pass }, innerMode: function (t) { return { state: t.localState || t.htmlState, mode: t.localMode || c } } } }, "xml", "javascript", "css"), t.defineMIME("text/html", "htmlmixed") }) }, function (t, e, n) { !function (t) { t(n(6)) }(function (t) { "use strict"; var e = { autoSelfClosers: { area: !0, base: !0, br: !0, col: !0, command: !0, embed: !0, frame: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0, menuitem: !0 }, implicitlyClosed: { dd: !0, li: !0, optgroup: !0, option: !0, p: !0, rp: !0, rt: !0, tbody: !0, td: !0, tfoot: !0, th: !0, tr: !0 }, contextGrabbers: { dd: { dd: !0, dt: !0 }, dt: { dd: !0, dt: !0 }, li: { li: !0 }, option: { option: !0, optgroup: !0 }, optgroup: { optgroup: !0 }, p: { address: !0, article: !0, aside: !0, blockquote: !0, dir: !0, div: !0, dl: !0, fieldset: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, menu: !0, nav: !0, ol: !0, p: !0, pre: !0, section: !0, table: !0, ul: !0 }, rp: { rp: !0, rt: !0 }, rt: { rp: !0, rt: !0 }, tbody: { tbody: !0, tfoot: !0 }, td: { td: !0, th: !0 }, tfoot: { tbody: !0 }, th: { td: !0, th: !0 }, thead: { tbody: !0, tfoot: !0 }, tr: { tr: !0 } }, doNotIndent: { pre: !0 }, allowUnquoted: !0, allowMissing: !0, caseFold: !0 }, n = { autoSelfClosers: {}, implicitlyClosed: {}, contextGrabbers: {}, doNotIndent: {}, allowUnquoted: !1, allowMissing: !1, caseFold: !1 }; t.defineMode("xml", function (i, r) { function o(t, e) { function n(n) { return e.tokenize = n, n(t, e) } var i = t.next(); if ("<" == i) return t.eat("!") ? t.eat("[") ? t.match("CDATA[") ? n(l("atom", "]]>")) : null : t.match("--") ? n(l("comment", "--\x3e")) : t.match("DOCTYPE", !0, !0) ? (t.eatWhile(/[\w\._\-]/), n(c(1))) : null : t.eat("?") ? (t.eatWhile(/[\w\._\-]/), e.tokenize = l("meta", "?>"), "meta") : (M = t.eat("/") ? "closeTag" : "openTag", e.tokenize = s, "tag bracket"); if ("&" == i) { var r; return r = t.eat("#") ? t.eat("x") ? t.eatWhile(/[a-fA-F\d]/) && t.eat(";") : t.eatWhile(/[\d]/) && t.eat(";") : t.eatWhile(/[\w\.\-:]/) && t.eat(";"), r ? "atom" : "error" } return t.eatWhile(/[^&<]/), null } function s(t, e) { var n = t.next(); if (">" == n || "/" == n && t.eat(">")) return e.tokenize = o, M = ">" == n ? "endTag" : "selfcloseTag", "tag bracket"; if ("=" == n) return M = "equals", null; if ("<" == n) { e.tokenize = o, e.state = f, e.tagName = e.tagStart = null; var i = e.tokenize(t, e); return i ? i + " tag error" : "tag error" } return /[\'\"]/.test(n) ? (e.tokenize = a(n), e.stringStartCol = t.column(), e.tokenize(t, e)) : (t.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/), "word") } function a(t) { var e = function (e, n) { for (; !e.eol();)if (e.next() == t) { n.tokenize = s; break } return "string" }; return e.isInAttribute = !0, e } function l(t, e) { return function (n, i) { for (; !n.eol();) { if (n.match(e)) { i.tokenize = o; break } n.next() } return t } } function c(t) { return function (e, n) { for (var i; null != (i = e.next());) { if ("<" == i) return n.tokenize = c(t + 1), n.tokenize(e, n); if (">" == i) { if (1 == t) { n.tokenize = o; break } return n.tokenize = c(t - 1), n.tokenize(e, n) } } return "meta" } } function u(t, e, n) { this.prev = t.context, this.tagName = e, this.indent = t.indented, this.startOfLine = n, (k.doNotIndent.hasOwnProperty(e) || t.context && t.context.noIndent) && (this.noIndent = !0) } function h(t) { t.context && (t.context = t.context.prev) } function d(t, e) { for (var n; ;) { if (!t.context) return; if (n = t.context.tagName, !k.contextGrabbers.hasOwnProperty(n) || !k.contextGrabbers[n].hasOwnProperty(e)) return; h(t) } } function f(t, e, n) { return "openTag" == t ? (n.tagStart = e.column(), p) : "closeTag" == t ? g : f } function p(t, e, n) { return "word" == t ? (n.tagName = e.current(), E = "tag", y) : (E = "error", p) } function g(t, e, n) { if ("word" == t) { var i = e.current(); return n.context && n.context.tagName != i && k.implicitlyClosed.hasOwnProperty(n.context.tagName) && h(n), n.context && n.context.tagName == i || !1 === k.matchClosing ? (E = "tag", m) : (E = "tag error", v) } return E = "error", v } function m(t, e, n) { return "endTag" != t ? (E = "error", m) : (h(n), f) } function v(t, e, n) { return E = "error", m(t, e, n) } function y(t, e, n) { if ("word" == t) return E = "attribute", b; if ("endTag" == t || "selfcloseTag" == t) { var i = n.tagName, r = n.tagStart; return n.tagName = n.tagStart = null, "selfcloseTag" == t || k.autoSelfClosers.hasOwnProperty(i) ? d(n, i) : (d(n, i), n.context = new u(n, i, r == n.indented)), f } return E = "error", y } function b(t, e, n) { return "equals" == t ? x : (k.allowMissing || (E = "error"), y(t, e, n)) } function x(t, e, n) { return "string" == t ? w : "word" == t && k.allowUnquoted ? (E = "string", y) : (E = "error", y(t, e, n)) } function w(t, e, n) { return "string" == t ? w : y(t, e, n) } var C = i.indentUnit, k = {}, S = r.htmlMode ? e : n; for (var T in S) k[T] = S[T]; for (var T in r) k[T] = r[T]; var M, E; return o.isInText = !0, { startState: function (t) { var e = { tokenize: o, state: f, indented: t || 0, tagName: null, tagStart: null, context: null }; return null != t && (e.baseIndent = t), e }, token: function (t, e) { if (!e.tagName && t.sol() && (e.indented = t.indentation()), t.eatSpace()) return null; M = null; var n = e.tokenize(t, e); return (n || M) && "comment" != n && (E = null, e.state = e.state(M || n, t, e), E && (n = "error" == E ? n + " error" : E)), n }, indent: function (e, n, i) { var r = e.context; if (e.tokenize.isInAttribute) return e.tagStart == e.indented ? e.stringStartCol + 1 : e.indented + C; if (r && r.noIndent) return t.Pass; if (e.tokenize != s && e.tokenize != o) return i ? i.match(/^(\s*)/)[0].length : 0; if (e.tagName) return !1 !== k.multilineTagIndentPastTag ? e.tagStart + e.tagName.length + 2 : e.tagStart + C * (k.multilineTagIndentFactor || 1); if (k.alignCDATA && /<!\[CDATA\[/.test(n)) return 0; var a = n && /^<(\/)?([\w_:\.-]*)/.exec(n); if (a && a[1]) for (; r;) { if (r.tagName == a[2]) { r = r.prev; break } if (!k.implicitlyClosed.hasOwnProperty(r.tagName)) break; r = r.prev } else if (a) for (; r;) { var l = k.contextGrabbers[r.tagName]; if (!l || !l.hasOwnProperty(a[2])) break; r = r.prev } for (; r && r.prev && !r.startOfLine;)r = r.prev; return r ? r.indent + C : e.baseIndent || 0 }, electricInput: /<\/[\s\w:]+>$/, blockCommentStart: "\x3c!--", blockCommentEnd: "--\x3e", configuration: k.htmlMode ? "html" : "xml", helperType: k.htmlMode ? "html" : "xml", skipAttribute: function (t) { t.state == x && (t.state = y) } } }), t.defineMIME("text/xml", "xml"), t.defineMIME("application/xml", "xml"), t.mimeModes.hasOwnProperty("text/html") || t.defineMIME("text/html", { name: "xml", htmlMode: !0 }) }) }, function (t, e, n) { !function (t) { t(n(6)) }(function (t) { "use strict"; t.defineMode("javascript", function (e, n) { function i(t) { for (var e, n = !1, i = !1; null != (e = t.next());) { if (!n) { if ("/" == e && !i) return; "[" == e ? i = !0 : i && "]" == e && (i = !1) } n = !n && "\\" == e } } function r(t, e, n) { return Tt = t, Mt = n, e } function o(t, e) { var n = t.next(); if ('"' == n || "'" == n) return e.tokenize = s(n), e.tokenize(t, e); if ("." == n && t.match(/^\d+(?:[eE][+\-]?\d+)?/)) return r("number", "number"); if ("." == n && t.match("..")) return r("spread", "meta"); if (/[\[\]{}\(\),;\:\.]/.test(n)) return r(n); if ("=" == n && t.eat(">")) return r("=>", "operator"); if ("0" == n && t.eat(/x/i)) return t.eatWhile(/[\da-f]/i), r("number", "number"); if ("0" == n && t.eat(/o/i)) return t.eatWhile(/[0-7]/i), r("number", "number"); if ("0" == n && t.eat(/b/i)) return t.eatWhile(/[01]/i), r("number", "number"); if (/\d/.test(n)) return t.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/), r("number", "number"); if ("/" == n) return t.eat("*") ? (e.tokenize = a, a(t, e)) : t.eat("/") ? (t.skipToEnd(), r("comment", "comment")) : St(t, e, 1) ? (i(t), t.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/), r("regexp", "string-2")) : (t.eat("="), r("operator", "operator", t.current())); if ("`" == n) return e.tokenize = l, l(t, e); if ("#" == n) return t.skipToEnd(), r("error", "error"); if (It.test(n)) return ">" == n && e.lexical && ">" == e.lexical.type || (t.eat("=") ? "!" != n && "=" != n || t.eat("=") : /[<>*+\-]/.test(n) && (t.eat(n), ">" == n && t.eat(n))), r("operator", "operator", t.current()); if (Nt.test(n)) { t.eatWhile(Nt); var o = t.current(); if ("." != e.lastType) { if (Dt.propertyIsEnumerable(o)) { var c = Dt[o]; return r(c.type, c.style, o) } if ("async" == o && t.match(/^\s*[\(\w]/, !1)) return r("async", "keyword", o) } return r("variable", "variable", o) } } function s(t) { return function (e, n) { var i, s = !1; if (At && "@" == e.peek() && e.match(_t)) return n.tokenize = o, r("jsonld-keyword", "meta"); for (; null != (i = e.next()) && (i != t || s);)s = !s && "\\" == i; return s || (n.tokenize = o), r("string", "string") } } function a(t, e) { for (var n, i = !1; n = t.next();) { if ("/" == n && i) { e.tokenize = o; break } i = "*" == n } return r("comment", "comment") } function l(t, e) { for (var n, i = !1; null != (n = t.next());) { if (!i && ("`" == n || "$" == n && t.eat("{"))) { e.tokenize = o; break } i = !i && "\\" == n } return r("quasi", "string-2", t.current()) } function c(t, e) { e.fatArrowAt && (e.fatArrowAt = null); var n = t.string.indexOf("=>", t.start); if (!(n < 0)) { if (Ot) { var i = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(t.string.slice(t.start, n)); i && (n = i.index) } for (var r = 0, o = !1, s = n - 1; s >= 0; --s) { var a = t.string.charAt(s), l = Ft.indexOf(a); if (l >= 0 && l < 3) { if (!r) { ++s; break } if (0 == --r) { "(" == a && (o = !0); break } } else if (l >= 3 && l < 6)++r; else if (Nt.test(a)) o = !0; else { if (/["'\/]/.test(a)) return; if (o && !r) { ++s; break } } } o && !r && (e.fatArrowAt = s) } } function u(t, e, n, i, r, o) { this.indented = t, this.column = e, this.type = n, this.prev = r, this.info = o, null != i && (this.align = i) } function h(t, e) { for (var n = t.localVars; n; n = n.next)if (n.name == e) return !0; for (var i = t.context; i; i = i.prev)for (var n = i.vars; n; n = n.next)if (n.name == e) return !0 } function d(t, e, n, i, r) { var o = t.cc; for (zt.state = t, zt.stream = r, zt.marked = null, zt.cc = o, zt.style = e, t.lexical.hasOwnProperty("align") || (t.lexical.align = !0); ;) { if ((o.length ? o.pop() : Lt ? C : w)(n, i)) { for (; o.length && o[o.length - 1].lex;)o.pop()(); return zt.marked ? zt.marked : "variable" == n && h(t, i) ? "variable-2" : e } } } function f() { for (var t = arguments.length - 1; t >= 0; t--)zt.cc.push(arguments[t]) } function p() { return f.apply(null, arguments), !0 } function g(t) { function e(e) { for (var n = e; n; n = n.next)if (n.name == t) return !0; return !1 } var i = zt.state; if (zt.marked = "def", i.context) { if (e(i.localVars)) return; i.localVars = { name: t, next: i.localVars } } else { if (e(i.globalVars)) return; n.globalVars && (i.globalVars = { name: t, next: i.globalVars }) } } function m() { zt.state.context = { prev: zt.state.context, vars: zt.state.localVars }, zt.state.localVars = Ht } function v() { zt.state.localVars = zt.state.context.vars, zt.state.context = zt.state.context.prev } function y(t, e) { var n = function () { var n = zt.state, i = n.indented; if ("stat" == n.lexical.type) i = n.lexical.indented; else for (var r = n.lexical; r && ")" == r.type && r.align; r = r.prev)i = r.indented; n.lexical = new u(i, zt.stream.column(), t, null, n.lexical, e) }; return n.lex = !0, n } function b() { var t = zt.state; t.lexical.prev && (")" == t.lexical.type && (t.indented = t.lexical.indented), t.lexical = t.lexical.prev) } function x(t) { function e(n) { return n == t ? p() : ";" == t ? f() : p(e) } return e } function w(t, e) { return "var" == t ? p(y("vardef", e.length), J, x(";"), b) : "keyword a" == t ? p(y("form"), S, w, b) : "keyword b" == t ? p(y("form"), w, b) : "keyword d" == t ? zt.stream.match(/^\s*$/, !1) ? p() : p(y("stat"), M, x(";"), b) : "debugger" == t ? p(x(";")) : "{" == t ? p(y("}"), B, b) : ";" == t ? p() : "if" == t ? ("else" == zt.state.lexical.info && zt.state.cc[zt.state.cc.length - 1] == b && zt.state.cc.pop()(), p(y("form"), S, w, b, nt)) : "function" == t ? p(lt) : "for" == t ? p(y("form"), it, w, b) : "variable" == t ? Ot && "type" == e ? (zt.marked = "keyword", p(U, x("operator"), U, x(";"))) : Ot && "declare" == e ? (zt.marked = "keyword", p(w)) : p(y("stat"), F) : "switch" == t ? p(y("form"), S, x("{"), y("}", "switch"), B, b, b) : "case" == t ? p(C, x(":")) : "default" == t ? p(x(":")) : "catch" == t ? p(y("form"), m, x("("), ct, x(")"), w, b, v) : "class" == t ? p(y("form"), ht, b) : "export" == t ? p(y("stat"), gt, b) : "import" == t ? p(y("stat"), vt, b) : "module" == t ? p(y("form"), Z, x("{"), y("}"), B, b, b) : "async" == t ? p(w) : "@" == e ? p(C, w) : f(y("stat"), C, x(";"), b) } function C(t) { return T(t, !1) } function k(t) { return T(t, !0) } function S(t) { return "(" != t ? f() : p(y(")"), C, x(")"), b) } function T(t, e) { if (zt.state.fatArrowAt == zt.stream.start) { var n = e ? N : O; if ("(" == t) return p(m, y(")"), V(ct, ")"), b, x("=>"), n, v); if ("variable" == t) return f(m, Z, x("=>"), n, v) } var i = e ? P : E; return $t.hasOwnProperty(t) ? p(i) : "function" == t ? p(lt, i) : "class" == t ? p(y("form"), ut, b) : "keyword c" == t || "async" == t ? p(e ? k : C) : "(" == t ? p(y(")"), M, x(")"), b, i) : "operator" == t || "spread" == t ? p(e ? k : C) : "[" == t ? p(y("]"), Ct, b, i) : "{" == t ? j(z, "}", null, i) : "quasi" == t ? f(A, i) : "new" == t ? p(D(e)) : p() } function M(t) { return t.match(/[;\}\)\],]/) ? f() : f(C) } function E(t, e) { return "," == t ? p(C) : P(t, e, !1) } function P(t, e, n) { var i = 0 == n ? E : P, r = 0 == n ? C : k; return "=>" == t ? p(m, n ? N : O, v) : "operator" == t ? /\+\+|--/.test(e) || Ot && "!" == e ? p(i) : "?" == e ? p(C, x(":"), r) : p(r) : "quasi" == t ? f(A, i) : ";" != t ? "(" == t ? j(k, ")", "call", i) : "." == t ? p($, i) : "[" == t ? p(y("]"), M, x("]"), b, i) : Ot && "as" == e ? (zt.marked = "keyword", p(U, i)) : "regexp" == t ? (zt.state.lastType = zt.marked = "operator", zt.stream.backUp(zt.stream.pos - zt.stream.start - 1), p(r)) : void 0 : void 0 } function A(t, e) { return "quasi" != t ? f() : "${" != e.slice(e.length - 2) ? p(A) : p(C, L) } function L(t) { if ("}" == t) return zt.marked = "string-2", zt.state.tokenize = l, p(A) } function O(t) { return c(zt.stream, zt.state), f("{" == t ? w : C) } function N(t) { return c(zt.stream, zt.state), f("{" == t ? w : k) } function D(t) { return function (e) { return "." == e ? p(t ? _ : I) : "variable" == e && Ot ? p(X, t ? P : E) : f(t ? k : C) } } function I(t, e) { if ("target" == e) return zt.marked = "keyword", p(E) } function _(t, e) { if ("target" == e) return zt.marked = "keyword", p(P) } function F(t) { return ":" == t ? p(b, w) : f(E, x(";"), b) } function $(t) { if ("variable" == t) return zt.marked = "property", p() } function z(t, e) { if ("async" == t) return zt.marked = "property", p(z); if ("variable" == t || "keyword" == zt.style) { if (zt.marked = "property", "get" == e || "set" == e) return p(H); var n; return Ot && zt.state.fatArrowAt == zt.stream.start && (n = zt.stream.match(/^\s*:\s*/, !1)) && (zt.state.fatArrowAt = zt.stream.pos + n[0].length), p(R) } return "number" == t || "string" == t ? (zt.marked = At ? "property" : zt.style + " property", p(R)) : "jsonld-keyword" == t ? p(R) : "modifier" == t ? p(z) : "[" == t ? p(C, x("]"), R) : "spread" == t ? p(k, R) : "*" == e ? (zt.marked = "keyword", p(z)) : ":" == t ? f(R) : void 0 } function H(t) { return "variable" != t ? f(R) : (zt.marked = "property", p(lt)) } function R(t) { return ":" == t ? p(k) : "(" == t ? f(lt) : void 0 } function V(t, e, n) { function i(r, o) { if (n ? n.indexOf(r) > -1 : "," == r) { var s = zt.state.lexical; return "call" == s.info && (s.pos = (s.pos || 0) + 1), p(function (n, i) { return n == e || i == e ? f() : f(t) }, i) } return r == e || o == e ? p() : p(x(e)) } return function (n, r) { return n == e || r == e ? p() : f(t, i) } } function j(t, e, n) { for (var i = 3; i < arguments.length; i++)zt.cc.push(arguments[i]); return p(y(e, n), V(t, e), b) } function B(t) { return "}" == t ? p() : f(w, B) } function W(t, e) { if (Ot) { if (":" == t) return p(U); if ("?" == e) return p(W) } } function U(t, e) { return "variable" == t || "void" == e ? "keyof" == e ? (zt.marked = "keyword", p(U)) : (zt.marked = "type", p(Y)) : "string" == t || "number" == t || "atom" == t ? p(Y) : "[" == t ? p(y("]"), V(U, "]", ","), b, Y) : "{" == t ? p(y("}"), V(K, "}", ",;"), b, Y) : "(" == t ? p(V(G, ")"), q) : void 0 } function q(t) { if ("=>" == t) return p(U) } function K(t, e) { return "variable" == t || "keyword" == zt.style ? (zt.marked = "property", p(K)) : "?" == e ? p(K) : ":" == t ? p(U) : "[" == t ? p(C, W, x("]"), K) : void 0 } function G(t) { return "variable" == t ? p(G) : ":" == t ? p(U) : void 0 } function Y(t, e) { return "<" == e ? p(y(">"), V(U, ">"), b, Y) : "|" == e || "." == t ? p(U) : "[" == t ? p(x("]"), Y) : "extends" == e ? p(U) : void 0 } function X(t, e) { if ("<" == e) return p(y(">"), V(U, ">"), b, Y) } function J() { return f(Z, W, tt, et) } function Z(t, e) { return "modifier" == t ? p(Z) : "variable" == t ? (g(e), p()) : "spread" == t ? p(Z) : "[" == t ? j(Z, "]") : "{" == t ? j(Q, "}") : void 0 } function Q(t, e) { return "variable" != t || zt.stream.match(/^\s*:/, !1) ? ("variable" == t && (zt.marked = "property"), "spread" == t ? p(Z) : "}" == t ? f() : p(x(":"), Z, tt)) : (g(e), p(tt)) } function tt(t, e) { if ("=" == e) return p(k) } function et(t) { if ("," == t) return p(J) } function nt(t, e) { if ("keyword b" == t && "else" == e) return p(y("form", "else"), w, b) } function it(t) { if ("(" == t) return p(y(")"), rt, x(")"), b) } function rt(t) { return "var" == t ? p(J, x(";"), st) : ";" == t ? p(st) : "variable" == t ? p(ot) : f(C, x(";"), st) } function ot(t, e) { return "in" == e || "of" == e ? (zt.marked = "keyword", p(C)) : p(E, st) } function st(t, e) { return ";" == t ? p(at) : "in" == e || "of" == e ? (zt.marked = "keyword", p(C)) : f(C, x(";"), at) } function at(t) { ")" != t && p(C) } function lt(t, e) { return "*" == e ? (zt.marked = "keyword", p(lt)) : "variable" == t ? (g(e), p(lt)) : "(" == t ? p(m, y(")"), V(ct, ")"), b, W, w, v) : Ot && "<" == e ? p(y(">"), V(U, ">"), b, lt) : void 0 } function ct(t, e) { return "@" == e && p(C, ct), "spread" == t || "modifier" == t ? p(ct) : f(Z, W, tt) } function ut(t, e) { return "variable" == t ? ht(t, e) : dt(t, e) } function ht(t, e) { if ("variable" == t) return g(e), p(dt) } function dt(t, e) { return "<" == e ? p(y(">"), V(U, ">"), b, dt) : "extends" == e || "implements" == e || Ot && "," == t ? p(Ot ? U : C, dt) : "{" == t ? p(y("}"), ft, b) : void 0 } function ft(t, e) { return "modifier" == t || "async" == t || "variable" == t && ("static" == e || "get" == e || "set" == e) && zt.stream.match(/^\s+[\w$\xa1-\uffff]/, !1) ? (zt.marked = "keyword", p(ft)) : "variable" == t || "keyword" == zt.style ? (zt.marked = "property", p(Ot ? pt : lt, ft)) : "[" == t ? p(C, x("]"), Ot ? pt : lt, ft) : "*" == e ? (zt.marked = "keyword", p(ft)) : ";" == t ? p(ft) : "}" == t ? p() : "@" == e ? p(C, ft) : void 0 } function pt(t, e) { return "?" == e ? p(pt) : ":" == t ? p(U, tt) : "=" == e ? p(k) : f(lt) } function gt(t, e) { return "*" == e ? (zt.marked = "keyword", p(wt, x(";"))) : "default" == e ? (zt.marked = "keyword", p(C, x(";"))) : "{" == t ? p(V(mt, "}"), wt, x(";")) : f(w) } function mt(t, e) { return "as" == e ? (zt.marked = "keyword", p(x("variable"))) : "variable" == t ? f(k, mt) : void 0 } function vt(t) { return "string" == t ? p() : f(yt, bt, wt) } function yt(t, e) { return "{" == t ? j(yt, "}") : ("variable" == t && g(e), "*" == e && (zt.marked = "keyword"), p(xt)) } function bt(t) { if ("," == t) return p(yt, bt) } function xt(t, e) { if ("as" == e) return zt.marked = "keyword", p(yt) } function wt(t, e) { if ("from" == e) return zt.marked = "keyword", p(C) } function Ct(t) { return "]" == t ? p() : f(V(k, "]")) } function kt(t, e) { return "operator" == t.lastType || "," == t.lastType || It.test(e.charAt(0)) || /[,.]/.test(e.charAt(0)) } function St(t, e, n) { return e.tokenize == o && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(e.lastType) || "quasi" == e.lastType && /\{\s*$/.test(t.string.slice(0, t.pos - (n || 0))) } var Tt, Mt, Et = e.indentUnit, Pt = n.statementIndent, At = n.jsonld, Lt = n.json || At, Ot = n.typescript, Nt = n.wordCharacters || /[\w$\xa1-\uffff]/, Dt = function () { function t(t) { return { type: t, style: "keyword" } } var e = t("keyword a"), n = t("keyword b"), i = t("keyword c"), r = t("keyword d"), o = t("operator"), s = { type: "atom", style: "atom" }, a = { if: t("if"), while: e, with: e, else: n, do: n, try: n, finally: n, return: r, break: r, continue: r, new: t("new"), delete: i, void: i, throw: i, debugger: t("debugger"), var: t("var"), const: t("var"), let: t("var"), function: t("function"), catch: t("catch"), for: t("for"), switch: t("switch"), case: t("case"), default: t("default"), in: o, typeof: o, instanceof: o, true: s, false: s, null: s, undefined: s, NaN: s, Infinity: s, this: t("this"), class: t("class"), super: t("atom"), yield: i, export: t("export"), import: t("import"), extends: i, await: i }; if (Ot) { var l = { type: "variable", style: "type" }, c = { interface: t("class"), implements: i, namespace: i, module: t("module"), enum: t("module"), public: t("modifier"), private: t("modifier"), protected: t("modifier"), abstract: t("modifier"), readonly: t("modifier"), string: l, number: l, boolean: l, any: l }; for (var u in c) a[u] = c[u] } return a }(), It = /[+\-*&%=<>!?|~^@]/, _t = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/, Ft = "([{}])", $t = { atom: !0, number: !0, variable: !0, string: !0, regexp: !0, this: !0, "jsonld-keyword": !0 }, zt = { state: null, column: null, marked: null, cc: null }, Ht = { name: "this", next: { name: "arguments" } }; return b.lex = !0, { startState: function (t) { var e = { tokenize: o, lastType: "sof", cc: [], lexical: new u((t || 0) - Et, 0, "block", !1), localVars: n.localVars, context: n.localVars && { vars: n.localVars }, indented: t || 0 }; return n.globalVars && "object" == typeof n.globalVars && (e.globalVars = n.globalVars), e }, token: function (t, e) { if (t.sol() && (e.lexical.hasOwnProperty("align") || (e.lexical.align = !1), e.indented = t.indentation(), c(t, e)), e.tokenize != a && t.eatSpace()) return null; var n = e.tokenize(t, e); return "comment" == Tt ? n : (e.lastType = "operator" != Tt || "++" != Mt && "--" != Mt ? Tt : "incdec", d(e, n, Tt, Mt, t)) }, indent: function (e, i) { if (e.tokenize == a) return t.Pass; if (e.tokenize != o) return 0; var r, s = i && i.charAt(0), l = e.lexical; if (!/^\s*else\b/.test(i)) for (var c = e.cc.length - 1; c >= 0; --c) { var u = e.cc[c]; if (u == b) l = l.prev; else if (u != nt) break } for (; ("stat" == l.type || "form" == l.type) && ("}" == s || (r = e.cc[e.cc.length - 1]) && (r == E || r == P) && !/^[,\.=+\-*:?[\(]/.test(i));)l = l.prev; Pt && ")" == l.type && "stat" == l.prev.type && (l = l.prev); var h = l.type, d = s == h; return "vardef" == h ? l.indented + ("operator" == e.lastType || "," == e.lastType ? l.info + 1 : 0) : "form" == h && "{" == s ? l.indented : "form" == h ? l.indented + Et : "stat" == h ? l.indented + (kt(e, i) ? Pt || Et : 0) : "switch" != l.info || d || 0 == n.doubleIndentSwitch ? l.align ? l.column + (d ? 0 : 1) : l.indented + (d ? 0 : Et) : l.indented + (/^(?:case|default)\b/.test(i) ? Et : 2 * Et) }, electricInput: /^\s*(?:case .*?:|default:|\{|\})$/, blockCommentStart: Lt ? null : "/*", blockCommentEnd: Lt ? null : "*/", blockCommentContinue: Lt ? null : " * ", lineComment: Lt ? null : "//", fold: "brace", closeBrackets: "()[]{}''\"\"``", helperType: Lt ? "json" : "javascript", jsonldMode: At, jsonMode: Lt, expressionAllowed: St, skipExpression: function (t) { var e = t.cc[t.cc.length - 1]; e != C && e != k || t.cc.pop() } } }), t.registerHelper("wordChars", "javascript", /[\w$]/), t.defineMIME("text/javascript", "javascript"), t.defineMIME("text/ecmascript", "javascript"), t.defineMIME("application/javascript", "javascript"), t.defineMIME("application/x-javascript", "javascript"), t.defineMIME("application/ecmascript", "javascript"), t.defineMIME("application/json", { name: "javascript", json: !0 }), t.defineMIME("application/x-json", { name: "javascript", json: !0 }), t.defineMIME("application/ld+json", { name: "javascript", jsonld: !0 }), t.defineMIME("text/typescript", { name: "javascript", typescript: !0 }), t.defineMIME("application/typescript", { name: "javascript", typescript: !0 }) }) }, function (t, e, n) { !function (t) { t(n(6)) }(function (t) { t.extendMode("css", { commentStart: "/*", commentEnd: "*/", newlineAfterToken: function (t, e) { return /^[;{}]$/.test(e) } }), t.extendMode("javascript", { commentStart: "/*", commentEnd: "*/", newlineAfterToken: function (t, e, n, i) { return this.jsonMode ? /^[\[,{]$/.test(e) || /^}/.test(n) : (";" != e || !i.lexical || ")" != i.lexical.type) && (/^[;{}]$/.test(e) && !/^;/.test(n)) } }); var e = /^(a|abbr|acronym|area|base|bdo|big|br|button|caption|cite|code|col|colgroup|dd|del|dfn|em|frame|hr|iframe|img|input|ins|kbd|label|legend|link|map|object|optgroup|option|param|q|samp|script|select|small|span|strong|sub|sup|textarea|tt|var)$/; t.extendMode("xml", { commentStart: "\x3c!--", commentEnd: "--\x3e", newlineAfterToken: function (t, n, i, r) { var o = !1; return "html" == this.configuration && (o = !!r.context && e.test(r.context.tagName)), !o && ("tag" == t && />$/.test(n) && r.context || /^</.test(i)) } }), t.defineExtension("commentRange", function (e, n, i) { var r = this, o = t.innerMode(r.getMode(), r.getTokenAt(n).state).mode; r.operation(function () { if (e) r.replaceRange(o.commentEnd, i), r.replaceRange(o.commentStart, n), n.line == i.line && n.ch == i.ch && r.setCursor(n.line, n.ch + o.commentStart.length); else { var t = r.getRange(n, i), s = t.indexOf(o.commentStart), a = t.lastIndexOf(o.commentEnd); s > -1 && a > -1 && a > s && (t = t.substr(0, s) + t.substring(s + o.commentStart.length, a) + t.substr(a + o.commentEnd.length)), r.replaceRange(t, n, i) } }) }), t.defineExtension("autoIndentRange", function (t, e) { var n = this; this.operation(function () { for (var i = t.line; i <= e.line; i++)n.indentLine(i, "smart") }) }), t.defineExtension("autoFormatRange", function (e, n) { function i() { c += "\n", h = !0, ++u } for (var r = this, o = r.getMode(), s = r.getRange(e, n).split("\n"), a = t.copyState(o, r.getTokenAt(e).state), l = r.getOption("tabSize"), c = "", u = 0, h = 0 === e.ch, d = 0; d < s.length; ++d) { for (var f = new t.StringStream(s[d], l); !f.eol();) { var p = t.innerMode(o, a), g = o.token(f, a), m = f.current(); f.start = f.pos, h && !/\S/.test(m) || (c += m, h = !1), !h && p.mode.newlineAfterToken && p.mode.newlineAfterToken(g, m, f.string.slice(f.pos) || s[d + 1] || "", p.state) && i() } !f.pos && o.blankLine && o.blankLine(a), !h && d < s.length - 1 && i() } r.operation(function () { r.replaceRange(c, e, n); for (var t = e.line + 1, i = e.line + u; t <= i; ++t)r.indentLine(t, "smart"); r.setSelection(e, r.getCursor(!1)) }) }) }) }, function (t, e, n) { "use strict"; (function (e) { var i = n(0); t.exports = i.View.extend({ template: e.template('\n  <div class="<%= pfx %>editor" id="<%= pfx %><%= codeName %>">\n  \t<div id="<%= pfx %>title"><%= label %></div>\n  \t<div id="<%= pfx %>code"></div>\n  </div>'), initialize: function (t) { this.config = t.config || {}, this.pfx = this.config.stylePrefix }, render: function () { var t = this.model.toJSON(); return t.pfx = this.pfx, this.$el.html(this.template(t)), this.$el.attr("class", this.pfx + "editor-c"), this.$el.find("#" + this.pfx + "code").append(this.model.get("input")), this } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; t.exports = function () { var t, e, i = {}, r = n(103), o = n(25), s = n(105), a = (n(27), n(107)); return { name: "Panels", init: function (n) { i = n || {}; for (var o in r) o in i || (i[o] = r[o]); var l = i.pStylePrefix; return l && (i.stylePrefix = l + i.stylePrefix), t = new s(i.defaults), e = new a({ collection: t, config: i }), this }, getPanels: function () { return t }, getPanelsEl: function () { return e.el }, addPanel: function (e) { return t.add(e) }, getPanel: function (e) { var n = t.where({ id: e }); return n.length ? n[0] : null }, addButton: function (t, e) { var n = this.getPanel(t); return n ? n.get("buttons").add(e) : null }, getButton: function (t, e) { var n = this.getPanel(t); if (n) { var i = n.get("buttons").where({ id: e }); return i.length ? i[0] : null } return null }, render: function () { return e.render().el }, active: function () { this.getPanels().each(function (t) { t.get("buttons").each(function (t) { t.get("active") && t.trigger("updateActive") }) }) }, disableButtons: function () { this.getPanels().each(function (t) { t.get("buttons").each(function (t) { t.get("disable") && t.trigger("change:disable") }) }) }, Panel: o } } }, function (t, e, n) { "use strict"; var i = "sw-visibility", r = "export-template", o = "open-layers", s = "open-blocks", a = "fullscreen", l = "preview"; t.exports = { stylePrefix: "pn-", defaults: [{ id: "commands", buttons: [{}] }, { id: "options", buttons: [{ active: !0, id: i, className: "fa fa-square-o", command: i, context: i, attributes: { title: "View components" } }, { id: l, className: "fa fa-eye", command: l, context: l, attributes: { title: "Preview" } }, { id: a, className: "fa fa-arrows-alt", command: a, context: a, attributes: { title: "Fullscreen" } }, { id: r, className: "fa fa-code", command: r, attributes: { title: "View code" } }] }, { id: "views", buttons: [{ id: "open-sm", className: "fa fa-paint-brush", command: "open-sm", active: !0, attributes: { title: "Open Style Manager" } }, { id: "open-tm", className: "fa fa-cog", command: "open-tm", attributes: { title: "Settings" } }, { id: o, className: "fa fa-bars", command: o, attributes: { title: "Open Layer Manager" } }, { id: s, className: "fa fa-th-large", command: s, attributes: { title: "Open Blocks" } }] }], em: null, delayBtnsShow: 300 } }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.Model.extend({ defaults: { id: "", className: "", command: "", context: "", buttons: [], attributes: {}, options: {}, active: !1, dragDrop: !1, runDefaultCommand: !0, stopDefaultCommand: !1, disable: !1 }, initialize: function (t) { if (this.get("buttons").length) { var e = n(26); this.set("buttons", new e(this.get("buttons"))) } } }) }, function (t, e, n) { "use strict"; var i = n(0), r = n(25); t.exports = i.Collection.extend({ model: r }) }, function (t, e, n) { "use strict"; (function (e, i) { var r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, o = e.$; t.exports = e.View.extend({ tagName: "span", initialize: function (t) { i.bindAll(this, "startTimer", "stopTimer", "showButtons", "hideButtons", "closeOnKeyPress", "onDrop", "initSorter", "stopDrag"); var e = this.model.get("className"); this.config = t.config || {}, this.em = this.config.em || {}, this.pfx = this.config.stylePrefix || "", this.ppfx = this.config.pStylePrefix || "", this.id = this.pfx + this.model.get("id"), this.activeCls = this.pfx + "active", this.disableCls = this.pfx + "active", this.btnsVisCls = this.pfx + "visible", this.parentM = t.parentM || null, this.className = this.pfx + "btn" + (e ? " " + e : ""), this.listenTo(this.model, "change:active updateActive", this.updateActive), this.listenTo(this.model, "checkActive", this.checkActive), this.listenTo(this.model, "change:bntsVis", this.updateBtnsVis), this.listenTo(this.model, "change:attributes", this.updateAttributes), this.listenTo(this.model, "change:className", this.updateClassName), this.listenTo(this.model, "change:disable", this.updateDisable), this.model.get("buttons").length && (this.$el.on("mousedown", this.startTimer), this.$el.append(o("<div>", { class: this.pfx + "arrow-rd" }))), this.em && this.em.get && (this.commands = this.em.get("Commands")), this.events = {}, this.model.get("dragDrop") ? (this.events.mousedown = "initDrag", this.em.on("loaded", this.initSorter)) : this.events.click = "clicked", this.delegateEvents() }, initSorter: function () { if (this.em.Canvas) { var t = this.em.Canvas; this.canvasEl = t.getBody(), this.sorter = new this.em.Utils.Sorter({ container: this.canvasEl, placer: t.getPlacerEl(), containerSel: "*", itemSel: "*", pfx: this.ppfx, onMove: this.onDrag, onEndMove: this.onDrop, document: t.getFrameEl().contentDocument, direction: "a", wmargin: 1, nested: 1 }); var e = t.getOffset(); this.sorter.offTop = e.top, this.sorter.offLeft = e.left } }, initDrag: function () { this.model.collection.deactivateAll(this.model.get("context")), this.sorter.startSort(this.el), this.sorter.setDropContent(this.model.get("options").content), this.canvasEl.style.cursor = "grabbing", o(document).on("mouseup", this.stopDrag) }, stopDrag: function () { o(document).off("mouseup", this.stopDrag), this.sorter.endMove() }, onDrag: function (t) { }, onDrop: function (t) { this.canvasEl.style.cursor = "default" }, updateClassName: function () { var t = this.model.get("className"); this.$el.attr("class", this.pfx + "btn" + (t ? " " + t : "")) }, updateAttributes: function () { this.$el.attr(this.model.get("attributes")) }, updateBtnsVis: function () { this.$buttons && (this.model.get("bntsVis") ? this.$buttons.addClass(this.btnsVisCls) : this.$buttons.removeClass(this.btnsVisCls)) }, startTimer: function () { this.timeout = setTimeout(this.showButtons, this.config.delayBtnsShow), o(document).on("mouseup", this.stopTimer) }, stopTimer: function () { o(document).off("mouseup", this.stopTimer), this.timeout && clearTimeout(this.timeout) }, showButtons: function () { clearTimeout(this.timeout), this.model.set("bntsVis", !0), o(document).on("mousedown", this.hideButtons), o(document).on("keypress", this.closeOnKeyPress) }, hideButtons: function (t) { t && o(t.target).trigger("click"), this.model.set("bntsVis", !1), o(document).off("mousedown", this.hideButtons), o(document).off("keypress", this.closeOnKeyPress) }, closeOnKeyPress: function (t) { 27 == (t.which || t.keyCode) && this.hideButtons() }, updateActive: function () { var t = null, e = this.em && this.em.get ? this.em.get("Editor") : null, n = this.model.get("command"); this.commands && "string" == typeof n ? t = this.commands.get(n) : null !== n && "object" === (void 0 === n ? "undefined" : r(n)) ? t = n : "function" == typeof n && (t = { run: n }), this.model.get("active") ? (this.model.collection.deactivateAll(this.model.get("context")), this.model.set("active", !0, { silent: !0 }).trigger("checkActive"), this.parentM && this.parentM.set("active", !0, { silent: !0 }).trigger("checkActive"), t && t.run && (t.run(e, this.model, this.model.get("options")), e.trigger("run:" + n))) : (this.$el.removeClass(this.activeCls), this.model.collection.deactivateAll(this.model.get("context")), this.parentM && this.parentM.set("active", !1, { silent: !0 }).trigger("checkActive"), t && t.stop && (t.stop(e, this.model, this.model.get("options")), e.trigger("stop:" + n))) }, updateDisable: function () { this.model.get("disable") ? this.$el.addClass(this.disableCls) : this.$el.removeClass(this.disableCls) }, checkActive: function () { this.model.get("active") ? this.$el.addClass(this.activeCls) : this.$el.removeClass(this.activeCls) }, clicked: function (t) { this.model.get("bntsVis") || this.model.get("disable") || this.toogleActive() }, toogleActive: function () { this.parentM && this.swapParent(); var t = this.model.get("active"); this.model.set("active", !t); this.em.get("Commands").get("select-comp"); t ? this.model.get("runDefaultCommand") && this.em.runDefault() : this.model.get("stopDefaultCommand") && this.em.stopDefault() }, swapParent: function () { this.parentM.collection.deactivateAll(this.model.get("context")), this.parentM.set("attributes", this.model.get("attributes")), this.parentM.set("options", this.model.get("options")), this.parentM.set("command", this.model.get("command")), this.parentM.set("className", this.model.get("className")), this.parentM.set("active", !0, { silent: !0 }).trigger("checkActive") }, render: function () { if (this.updateAttributes(), this.$el.attr("class", this.className), this.model.get("buttons").length) { var t = n(28), e = new t({ collection: this.model.get("buttons"), config: this.config, parentM: this.model }); this.$buttons = e.render().$el, this.$buttons.append(o("<div>", { class: this.pfx + "arrow-l" })), this.$el.append(this.$buttons) } return this } }) }).call(e, n(0), n(1)) }, function (t, e, n) { "use strict"; var i = n(0), r = n(27); t.exports = i.View.extend({ initialize: function (t) { this.opt = t || {}, this.config = this.opt.config || {}, this.pfx = this.config.stylePrefix || "", this.listenTo(this.collection, "add", this.addTo), this.listenTo(this.collection, "reset", this.render), this.className = this.pfx + "panels" }, addTo: function (t) { this.addToCollection(t) }, addToCollection: function (t, e) { var n = e || null, i = new r({ model: t, config: this.config }), o = i.render().el, s = t.get("appendTo"); if (s) { document.querySelector(s).appendChild(o) } else n ? n.appendChild(o) : this.$el.append(o); return i.initResize(), o }, render: function () { var t = document.createDocumentFragment(); return this.$el.empty(), this.collection.each(function (e) { this.addToCollection(e, t) }, this), this.$el.append(t), this.$el.attr("class", this.className), this } }) }, function (t, e, n) { "use strict"; var i = n(109), r = function (t) { return t && t.__esModule ? t : { default: t } }(i), o = n(2); t.exports = function () { var t = {}, e = n(110), i = void 0, s = void 0, a = void 0, l = void 0, c = function () { var t = i.style; t.top = "-100px", t.left = "-100px", t.display = "none" }; return { customRte: null, name: "RichTextEditor", init: function () { var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t = n; for (var r in e) r in t || (t[r] = e[r]); var a = t.pStylePrefix; return a && (t.stylePrefix = a + t.stylePrefix), this.pfx = t.stylePrefix, s = t.actions || [], i = document.createElement("div"), i.className = a + "rte-toolbar", l = this.initRte(document.createElement("div")), (0, o.on)(i, "mousedown", function (t) { return t.stopPropagation() }), this }, postRender: function (t) { var e = t.model.get("Canvas"); i.style.pointerEvents = "all", c(), e.getToolsEl().appendChild(i) }, initRte: function (e) { var n = this.pfx, o = i, s = this.actionbar, a = this.actions || t.actions, c = { actionbar: n + "actionbar", button: n + "action", active: n + "active" }, u = new r.default({ el: e, classes: c, actions: a, actionbar: s, actionbarContainer: o }); return l && l.setEl(e), u.actionbar && (this.actionbar = u.actionbar), u.actions && (this.actions = u.actions), u }, add: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; e.name = t, l.addAction(e, { sync: 1 }) }, get: function (t) { var e = void 0; return l.getActions().forEach(function (n) { n.name == t && (e = n) }), e }, getAll: function () { return l.getActions() }, remove: function (t) { var e = this.getAll(), n = this.get(t); if (n) { var i = n.btn, r = e.indexOf(n); i.parentNode.removeChild(i), e.splice(r, 1) } return n }, getToolbarEl: function () { return i }, udpatePosition: function () { var e = t.em.get("Canvas"), n = e.getTargetToElementDim(i, a, { event: "rteToolbarPosUpdate" }); t.adjustToolbar && n.top <= n.canvasTop && (n.top = n.elementTop + n.elementHeight); var r = i.style; r.top = n.top + "px", r.left = n.left + "px" }, enable: function (e, n) { a = e.el; var r = t.em, o = e.getChildrenContainer(), s = this.customRte; if (i.style.display = "", n = s ? s.enable(o, n) : this.initRte(o).enable(), r) { setTimeout(this.udpatePosition.bind(this), 0); var l = "change:canvasOffset canvasScroll"; r.off(l, this.udpatePosition, this), r.on(l, this.udpatePosition, this), r.trigger("rte:enable", e, n) } return n }, disable: function (e, n) { var i = t.em, r = this.customRte, o = e.getChildrenContainer(); r ? r.disable(o, n) : n.disable(), c(), i && i.trigger("rte:disable", e, n) } } } }, function (t, e, n) { "use strict"; function i(t, e) { if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function") } Object.defineProperty(e, "__esModule", { value: !0 }); var r = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, o = function () { function t(t, e) { for (var n = 0; n < e.length; n++) { var i = e[n]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i) } } return function (e, n, i) { return n && t(e.prototype, n), i && t(e, i), e } }(), s = n(2), a = "_rte", l = { bold: { name: "bold", icon: "<b>B</b>", attributes: { title: "Bold" }, result: function (t) { return t.exec("bold") } }, italic: { name: "italic", icon: "<i>I</i>", attributes: { title: "Italic" }, result: function (t) { return t.exec("italic") } }, underline: { name: "underline", icon: "<u>U</u>", attributes: { title: "Underline" }, result: function (t) { return t.exec("underline") } }, strikethrough: { name: "strikethrough", icon: "<strike>S</strike>", attributes: { title: "Strike-through" }, result: function (t) { return t.exec("strikeThrough") } }, link: { icon: '<span style="transform:rotate(45deg)">&supdsub;</span>', name: "link", attributes: { style: "font-size:1.4rem;padding:0 4px 2px;", title: "Link" }, result: function (t) { return t.insertHTML('<a class="link" href="">' + t.selection() + "</a>") } } }, c = function () { function t() { var e = this, n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; i(this, t); var o = n.el; if (o[a]) return o[a]; o[a] = this, this.setEl(o), this.updateActiveActions = this.updateActiveActions.bind(this); var s = n.actions || []; s.forEach(function (t, e) { "string" == typeof t ? t = l[t] : l[t.name] && (t = r({}, l[t.name], t)), s[e] = t }); var c = s.length ? s : Object.keys(l).map(function (t) { return l[t] }); n.classes = r({ actionbar: "actionbar", button: "action", active: "active" }, n.classes); var u = n.classes, h = n.actionbar; if (this.actionbar = h, this.settings = n, this.classes = u, this.actions = c, !h) { var d = n.actionbarContainer; h = document.createElement("div"), h.className = u.actionbar, d.appendChild(h), this.actionbar = h, c.forEach(function (t) { return e.addAction(t) }) } return n.styleWithCSS && this.exec("styleWithCSS"), this.syncActions(), this } return o(t, [{ key: "setEl", value: function (t) { this.el = t, this.doc = t.ownerDocument } }, { key: "updateActiveActions", value: function () { var t = this; this.getActions().forEach(function (e) { var n = e.btn, i = e.update, r = t.classes.active, o = e.name, s = t.doc; n.className = n.className.replace(r, "").trim(), s.queryCommandState(o) && (n.className += " " + r), i && i(t, e) }) } }, { key: "enable", value: function () { return this.enabled ? this : (this.actionbarEl().style.display = "", this.el.contentEditable = !0, (0, s.on)(this.el, "mouseup keyup", this.updateActiveActions), this.syncActions(), this.updateActiveActions(), this.el.focus(), this.enabled = 1, this) } }, { key: "disable", value: function () { return this.actionbarEl().style.display = "none", this.el.contentEditable = !1, (0, s.off)(this.el, "mouseup keyup", this.updateActiveActions), this.enabled = 0, this } }, { key: "syncActions", value: function () { var t = this; this.getActions().forEach(function (e) { var n = e.event || "click"; e.btn["on" + n] = function (n) { e.result(t, e), t.updateActiveActions() } }) } }, { key: "addAction", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = e.sync, i = document.createElement("span"), r = t.icon, o = t.attributes || {}; i.className = this.classes.button, t.btn = i; for (var s in o) i.setAttribute(s, o[s]); "string" == typeof r ? i.innerHTML = r : i.appendChild(r), this.actionbarEl().appendChild(i), n && (this.actions.push(t), this.syncActions()) } }, { key: "getActions", value: function () { return this.actions } }, { key: "selection", value: function () { return this.doc.getSelection() } }, { key: "exec", value: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; this.doc.execCommand(t, !1, e) } }, { key: "actionbarEl", value: function () { return this.actionbar } }, { key: "insertHTML", value: function (t) { var e = void 0, n = this.doc, i = n.getSelection(); if (i && i.rangeCount) { var r = n.createElement("div"), o = i.getRangeAt(0); o.deleteContents(), r.innerHTML = t, Array.prototype.slice.call(r.childNodes).forEach(function (t) { o.insertNode(t), e = t }), i.removeAllRanges(), i.addRange(o), this.el.focus() } } }]), t }(); e.default = c }, function (t, e, n) { "use strict"; t.exports = { stylePrefix: "rte-", adjustToolbar: 1, actions: ["bold", "italic", "underline", "strikethrough", "link"] } }, function (t, e, n) { "use strict"; t.exports = { stylePrefix: "sm-", sectors: [], textNoElement: "Select an element before using Style Manager", hideNotStylable: !0, highlightChanged: !0, highlightComputed: !0, showComputed: !0, clearProperties: !1, avoidComputed: ["width", "height"] } }, function (t, e, n) { "use strict"; var i = n(113); t.exports = n(0).Collection.extend({ model: i }) }, function (t, e, n) { "use strict"; (function (e) { var i = n(0), r = n(10), o = n(122); t.exports = i.Model.extend({ defaults: { id: "", name: "", open: !0, buildProps: "", extendBuilded: 1, properties: [] }, initialize: function (t) { var e = t || {}, n = [], i = this.buildProperties(e.buildProps); this.get("id") || this.set("id", this.get("name")), n = i ? this.extendProperties(i) : this.get("properties"); var o = new r(n); o.sector = this, this.set("properties", o) }, extendProperties: function (t, n, i) { for (var r = t.length, o = n || this.get("properties"), s = this.get("extendBuilded"), a = [], l = 0, c = o.length; l < c; l++) { for (var u = o[l], h = 0, d = 0; d < r; d++) { var f = t[d]; if (u.property != f.property); else { var p = u.properties; p && p.length && (u.properties = this.extendProperties(f.properties, p, 1)), t[d] = s ? e.extend(f, u) : u, a[d] = t[d], h = 1 } } h || (t.push(u), a.push(u)) } return i ? a : t }, buildProperties: function (t) { var e = t || []; if (e.length) return this.propFactory || (this.propFactory = new o), this.propFactory.build(e) } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; var i = n(31), r = n(115); t.exports = i.extend({ defaults: Object.assign({}, i.prototype.defaults, { layers: [], preview: 0 }), init: function () { i.prototype.init.apply(this, arguments); var t = this.get("layers"), e = new r(t); e.properties = this.get("properties"), this.set("layers", e) }, getFullValue: function () { return this.get("detached") ? "" : this.get("layers").getFullValue() } }) }, function (t, e, n) { "use strict"; (function (e) { var i = n(116); t.exports = e.Collection.extend({ model: i, initialize: function () { this.idx = 1, this.on("add", this.onAdd), this.on("reset", this.onReset) }, onAdd: function (t, e, n) { n.noIncrement || t.set("index", this.idx++) }, onReset: function () { this.idx = 1 }, getLayersFromValue: function (t) { var e = this, n = []; return t.replace(/\(([\w\s,.]*)\)/g, function (e) { var n = e.replace(/,\s*/g, ","); t = t.replace(e, n) }), (t ? t.split(", ") : []).forEach(function (t) { n.push({ properties: e.properties.parseValue(t) }) }), n }, getLayersFromStyle: function (t) { var e = [], n = this.properties; n.pluck("property"); return n.each(function (n) { var i = t[n.get("property")]; (i ? i.split(", ") : []).forEach(function (t, i) { t = n.parseValue(t.trim()).value; var r = e[i], o = Object.assign({}, n.attributes, { value: t }); r ? r.properties.push(o) : e[i] = { properties: [o] } }) }), e.forEach(function (t) { var e = t.properties.map(function (t) { return t.property }); n.each(function (n) { var i = n.get("property"); e.indexOf(i) < 0 && t.properties.push(Object.assign({}, n.attributes)) }) }), e }, active: function (t) { this.each(function (t) { return t.set("active", 0) }); var e = this.at(t); e && e.set("active", 1) }, getFullValue: function () { var t = []; return this.each(function (e) { return t.push(e.getFullValue()) }), t.join(", ") }, getPropertyValues: function (t) { var e = []; return this.each(function (n) { var i = n.getPropertyValue(t); i && e.push(i) }), e.join(", ") } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; (function (e) { t.exports = e.Model.extend({ defaults: { index: "", value: "", values: {}, active: !1, preview: !1, properties: [] }, initialize: function () { var t = n(10), e = this.get("properties"), i = this.get("value"); if (this.set("properties", e instanceof t ? e : new t(e)), !i) { var r = "", o = this.get("values"); for (var s in o) r += " " + o[s]; this.set("value", r.trim()) } }, getPropertyValue: function (t) { var e = ""; return this.get("properties").each(function (n) { n.get("property") == t && (e = n.getFullValue()) }), e }, getFullValue: function () { var t = []; return this.get("properties").each(function (e) { return t.push(e.getFullValue()) }), t.join(" ") } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; (function (t) { var e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }; !function (n) { !function (t, n) { function i(e, n, i, r) { for (var o = [], s = 0; s < e.length; s++) { var a = e[s]; if (a) { var l = st(a), c = l.toHsl().l < .5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light"; c += st.equals(n, a) ? " sp-thumb-active" : ""; var u = l.toString(r.preferredFormat || "rgb"), h = Y ? "background-color:" + l.toRgbString() : "filter:" + l.toFilter(); o.push('<span title="' + u + '" data-color="' + l.toRgbString() + '" class="' + c + '"><span class="sp-thumb-inner" style="' + h + ';"></span></span>') } else { o.push(t("<div />").append(t('<span data-color="" style="background-color:transparent;" class="sp-clear-display"></span>').attr("title", r.noColorSelectedText)).html()) } } return "<div class='sp-cf " + i + "'>" + o.join("") + "</div>" } function r() { for (var t = 0; t < K.length; t++)K[t] && K[t].hide() } function o(e, n) { var i = t.extend({}, q, e); return i.callbacks = { move: u(i.move, n), change: u(i.change, n), show: u(i.show, n), hide: u(i.hide, n), beforeShow: u(i.beforeShow, n) }, i } function s(e, s) { function l() { if (R.showPaletteOnly && (R.showPalette = !0), zt.text(R.showPaletteOnly ? R.togglePaletteMoreText : R.togglePaletteLessText), R.palette) { ft = R.palette.slice(0), pt = t.isArray(ft[0]) ? ft : [ft], gt = {}; for (var e = 0; e < pt.length; e++)for (var n = 0; n < pt[e].length; n++) { var i = st(pt[e][n]).toRgbString(); gt[i] = !0 } } kt.toggleClass("sp-flat", V), kt.toggleClass("sp-input-disabled", !R.showInput), kt.toggleClass("sp-alpha-enabled", R.showAlpha), kt.toggleClass("sp-clear-enabled", Xt), kt.toggleClass("sp-buttons-disabled", !R.showButtons), kt.toggleClass("sp-palette-buttons-disabled", !R.togglePaletteOnly), kt.toggleClass("sp-palette-disabled", !R.showPalette), kt.toggleClass("sp-palette-only", R.showPaletteOnly), kt.toggleClass("sp-initial-disabled", !R.showInitial), kt.addClass(R.className).addClass(R.containerClassName), I() } function u() { if (B && window.localStorage) { try { var e = window.localStorage[B].split(",#"); e.length > 1 && (delete window.localStorage[B], t.each(e, function (t, e) { p(e) })) } catch (t) { } try { mt = window.localStorage[B].split(";") } catch (t) { } } } function p(e) { if (j) { var n = st(e).toRgbString(); if (!gt[n] && -1 === t.inArray(n, mt)) for (mt.push(n); mt.length > vt;)mt.shift(); if (B && window.localStorage) try { window.localStorage[B] = mt.join(";") } catch (t) { } } } function g() { var t = []; if (R.showPalette) for (var e = 0; e < mt.length; e++) { var n = st(mt[e]).toRgbString(); gt[n] || t.push(mt[e]) } return t.reverse().slice(0, R.maxSelectionSize) } function m() { var e = P(), n = t.map(pt, function (t, n) { return i(t, e, "sp-palette-row sp-palette-row-" + n, R) }); u(), mt && n.push(i(g(), e, "sp-palette-row sp-palette-row-selection", R)), Dt.html(n.join("")) } function v() { if (R.showInitial) { var t = qt, e = P(); It.html(i([t, e], e, "sp-palette-row-initial", R)) } } function y() { (et <= 0 || tt <= 0 || it <= 0) && I(), Q = !0, kt.addClass(yt), bt = null, wt.trigger("dragstart.spectrum", [P()]) } function b() { Q = !1, kt.removeClass(yt), wt.trigger("dragstop.spectrum", [P()]) } function x() { var t = Nt.val(); if (null !== t && "" !== t || !Xt) { var e = st(t); e.isValid() ? (E(e), D(!0)) : Nt.addClass("sp-validation-error") } else E(null), D(!0) } function w() { Z ? T() : C() } function C() { var e = t.Event("beforeShow.spectrum"); if (Z) return void I(); if (wt.trigger(e, [P()]), !1 !== U.beforeShow(P()) && !e.isDefaultPrevented()) { r(), Z = !0; var n = t(xt); n.bind("keydown.spectrum", k), n.bind("click.spectrum", S), t(window).bind("resize.spectrum", q), jt.addClass("sp-active"), kt.removeClass("sp-hidden"), I(), O(), qt = P(), v(), U.show(qt), wt.trigger("show.spectrum", [qt]) } } function k(t) { 27 === t.keyCode && T() } function S(t) { 2 != t.button && (Q || (Gt ? D(!0) : M(), T())) } function T() { Z && !V && (Z = !1, t(xt).unbind("keydown.spectrum", k), t(xt).unbind("click.spectrum", S), t(window).unbind("resize.spectrum", q), jt.removeClass("sp-active"), kt.addClass("sp-hidden"), U.hide(P()), wt.trigger("hide.spectrum", [P()])) } function M() { E(qt, !0) } function E(t, e) { if (st.equals(t, P())) return void O(); var n, i; !t && Xt ? Yt = !0 : (Yt = !1, n = st(t), i = n.toHsv(), ct = i.h % 360 / 360, ut = i.s, ht = i.v, dt = i.a), O(), n && n.isValid() && !e && (Kt = R.preferredFormat || n.getFormat()) } function P(t) { return t = t || {}, Xt && Yt ? null : st.fromRatio({ h: ct, s: ut, v: ht, a: Math.round(100 * dt) / 100 }, { format: t.format || Kt }) } function A() { return !Nt.hasClass("sp-validation-error") } function L() { O(), U.move(P()), wt.trigger("move.spectrum", [P()]) } function O() { Nt.removeClass("sp-validation-error"), N(); var t = st.fromRatio({ h: ct, s: 1, v: 1 }); Tt.css("background-color", t.toHexString()); var e = Kt; dt < 1 && (0 !== dt || "name" !== e) && ("hex" !== e && "hex3" !== e && "hex6" !== e && "name" !== e || (e = "rgb")); var n = P({ format: e }), i = ""; if (Wt.removeClass("sp-clear-display"), Wt.css("background-color", "transparent"), !n && Xt) Wt.addClass("sp-clear-display"); else { var r = n.toHexString(), o = n.toRgbString(); if (Y || 1 === n.alpha ? Wt.css("background-color", o) : (Wt.css("background-color", "transparent"), Wt.css("filter", n.toFilter())), R.showAlpha) { var s = n.toRgb(); s.a = 0; var a = st(s).toRgbString(), l = "linear-gradient(left, " + a + ", " + r + ")"; G ? At.css("filter", st(a).toFilter({ gradientType: 1 }, r)) : (At.css("background", "-webkit-" + l), At.css("background", "-moz-" + l), At.css("background", "-ms-" + l), At.css("background", "linear-gradient(to right, " + a + ", " + r + ")")) } i = n.toString(e) } R.showInput && Nt.val(i), R.showPalette && m(), v() } function N() { var t = ut, e = ht; if (Xt && Yt) Ot.hide(), Pt.hide(), Mt.hide(); else { Ot.show(), Pt.show(), Mt.show(); var n = t * tt, i = et - e * et; n = Math.max(-nt, Math.min(tt - nt, n - nt)), i = Math.max(-nt, Math.min(et - nt, i - nt)), Mt.css({ top: i + "px", left: n + "px" }); var r = dt * ot; Ot.css({ left: r - at / 2 + "px" }); var o = ct * it; Pt.css({ top: o - lt + "px" }) } } function D(t) { var e = P(), n = "", i = !st.equals(e, qt); e && (n = e.toString(Kt), p(e)), Ht && wt.val(n), t && i && (U.change(e), wt.trigger("change", [e])) } function I() { Z && (tt = Tt.width(), et = Tt.height(), nt = Mt.height(), rt = Et.width(), it = Et.height(), lt = Pt.height(), ot = Lt.width(), at = Ot.width(), V || (kt.css("position", "absolute"), R.offset ? kt.offset(R.offset) : kt.offset(a(kt, Bt))), N(), R.showPalette && m(), wt.trigger("reflow.spectrum")) } function _() { wt.show(), Bt.unbind("click.spectrum touchstart.spectrum"), kt.remove(), jt.remove(), K[Jt.id] = null } function F(e, i) { return e === n ? t.extend({}, R) : i === n ? R[e] : (R[e] = i, "preferredFormat" === e && (Kt = R.preferredFormat), void l()) } function $() { Ct = !1, wt.attr("disabled", !1), Bt.removeClass("sp-disabled") } function z() { T(), Ct = !0, wt.attr("disabled", !0), Bt.addClass("sp-disabled") } function H(t) { R.offset = t, I() } var R = o(s, e), V = R.flat, j = R.showSelectionPalette, B = R.localStorageKey, W = R.theme, U = R.callbacks, q = d(I, 10), Z = !1, Q = !1, tt = 0, et = 0, nt = 0, it = 0, rt = 0, ot = 0, at = 0, lt = 0, ct = 0, ut = 0, ht = 0, dt = 1, ft = [], pt = [], gt = {}, mt = R.selectionPalette.slice(0), vt = R.maxSelectionSize, yt = "sp-dragging", bt = null, xt = e.ownerDocument, wt = (xt.body, t(e)), Ct = !1, kt = t(J, xt).addClass(W), St = kt.find(".sp-picker-container"), Tt = kt.find(".sp-color"), Mt = kt.find(".sp-dragger"), Et = kt.find(".sp-hue"), Pt = kt.find(".sp-slider"), At = kt.find(".sp-alpha-inner"), Lt = kt.find(".sp-alpha"), Ot = kt.find(".sp-alpha-handle"), Nt = kt.find(".sp-input"), Dt = kt.find(".sp-palette"), It = kt.find(".sp-initial"), _t = kt.find(".sp-cancel"), Ft = kt.find(".sp-clear"), $t = kt.find(".sp-choose"), zt = kt.find(".sp-palette-toggle"), Ht = wt.is("input"), Rt = Ht && "color" === wt.attr("type") && f(), Vt = Ht && !V, jt = Vt ? t(X).addClass(W).addClass(R.className).addClass(R.replacerClassName) : t([]), Bt = Vt ? jt : wt, Wt = jt.find(".sp-preview-inner"), Ut = R.color || Ht && wt.val(), qt = !1, Kt = R.preferredFormat, Gt = !R.showButtons || R.clickoutFiresChange, Yt = !Ut, Xt = R.allowEmpty && !Rt; !function () { function e(e) { return e.data && e.data.ignore ? (E(t(e.target).closest(".sp-thumb-el").data("color")), L()) : (E(t(e.target).closest(".sp-thumb-el").data("color")), L(), D(!0), R.hideAfterPaletteSelect && T()), !1 } if (G && kt.find("*:not(input)").attr("unselectable", "on"), l(), Vt && wt.after(jt).hide(), Xt || Ft.hide(), V) wt.after(kt).hide(); else { var n = "parent" === R.appendTo ? wt.parent() : t(R.appendTo); 1 !== n.length && (n = t("body")), n.append(kt) } u(), Bt.bind("click.spectrum touchstart.spectrum", function (e) { Ct || w(), e.stopPropagation(), t(e.target).is("input") || e.preventDefault() }), (wt.is(":disabled") || !0 === R.disabled) && z(), kt.click(c), Nt.change(x), Nt.bind("paste", function () { setTimeout(x, 1) }), Nt.keydown(function (t) { 13 == t.keyCode && x() }), _t.text(R.cancelText), _t.bind("click.spectrum", function (t) { t.stopPropagation(), t.preventDefault(), M(), T() }), Ft.attr("title", R.clearText), Ft.bind("click.spectrum", function (t) { t.stopPropagation(), t.preventDefault(), Yt = !0, L(), V && D(!0) }), $t.text(R.chooseText), $t.bind("click.spectrum", function (t) { t.stopPropagation(), t.preventDefault(), G && Nt.is(":focus") && Nt.trigger("change"), A() && (D(!0), T()) }), zt.text(R.showPaletteOnly ? R.togglePaletteMoreText : R.togglePaletteLessText), zt.bind("click.spectrum", function (t) { t.stopPropagation(), t.preventDefault(), R.showPaletteOnly = !R.showPaletteOnly, R.showPaletteOnly || V || kt.css("left", "-=" + (St.outerWidth(!0) + 5)), l() }), h(Lt, function (t, e, n) { dt = t / ot, Yt = !1, n.shiftKey && (dt = Math.round(10 * dt) / 10), L() }, y, b), h(Et, function (t, e) { ct = parseFloat(e / it), Yt = !1, R.showAlpha || (dt = 1), L() }, y, b), h(Tt, function (t, e, n) { if (n.shiftKey) { if (!bt) { var i = ut * tt, r = et - ht * et, o = Math.abs(t - i) > Math.abs(e - r); bt = o ? "x" : "y" } } else bt = null; var s = !bt || "x" === bt, a = !bt || "y" === bt; s && (ut = parseFloat(t / tt)), a && (ht = parseFloat((et - e) / et)), Yt = !1, R.showAlpha || (dt = 1), L() }, y, b), Ut ? (E(Ut), O(), Kt = R.preferredFormat || st(Ut).format, p(Ut)) : O(), V && C(); var i = G ? "mousedown.spectrum" : "click.spectrum touchstart.spectrum"; Dt.delegate(".sp-thumb-el", i, e), It.delegate(".sp-thumb-el:nth-child(1)", i, { ignore: !0 }, e) }(); var Jt = { show: C, hide: T, toggle: w, reflow: I, option: F, enable: $, disable: z, offset: H, set: function (t) { E(t), D() }, get: P, destroy: _, container: kt }; return Jt.id = K.push(Jt) - 1, Jt } function a(e, n) { var i = e.outerWidth(), r = e.outerHeight(), o = n.outerHeight(), s = e[0].ownerDocument, a = s.documentElement, l = a.clientWidth, c = a.clientHeight, u = t(s).scrollLeft(), h = t(s).scrollTop(), d = l + u, f = c + h, p = n.offset(); return p.top += o, p.left -= Math.min(p.left, p.left + i > d && d > i ? Math.abs(p.left + i - d) : 0), p.top -= Math.min(p.top, p.top + r > f && f > r ? Math.abs(r + o - 0) : 0), p } function l() { } function c(t) { t.stopPropagation() } function u(t, e) { var n = Array.prototype.slice, i = n.call(arguments, 2); return function () { return t.apply(e, i.concat(n.call(arguments))) } } function h(e, n, i, r) { function o(t) { t.stopPropagation && t.stopPropagation(), t.preventDefault && t.preventDefault(), t.returnValue = !1 } function s(t) { if (u) { if (G && c.documentMode < 9 && !t.button) return l(); var i = t.originalEvent && t.originalEvent.touches && t.originalEvent.touches[0], r = i && i.pageX || t.pageX, s = i && i.pageY || t.pageY, a = Math.max(0, Math.min(r - h.left, f)), g = Math.max(0, Math.min(s - h.top, d)); p && o(t), n.apply(e, [a, g, t]) } } function a(n) { (n.which ? 3 == n.which : 2 == n.button) || u || !1 !== i.apply(e, arguments) && (u = !0, d = t(e).height(), f = t(e).width(), h = t(e).offset(), t(c).bind(g), t(c.body).addClass("sp-dragging"), s(n), o(n)) } function l() { u && (t(c).unbind(g), t(c.body).removeClass("sp-dragging"), setTimeout(function () { r.apply(e, arguments) }, 0)), u = !1 } n = n || function () { }, i = i || function () { }, r = r || function () { }; var c = document, u = !1, h = {}, d = 0, f = 0, p = "ontouchstart" in window, g = {}; g.selectstart = o, g.dragstart = o, g["touchmove mousemove"] = s, g["touchend mouseup"] = l, t(e).bind("touchstart mousedown", a) } function d(t, e, n) { var i; return function () { var r = this, o = arguments, s = function () { i = null, t.apply(r, o) }; n && clearTimeout(i), !n && i || (i = setTimeout(s, e)) } } function f() { return t.fn.spectrum.inputTypeColorSupport() } function p(t) { var n = { r: 0, g: 0, b: 0 }, i = 1, r = !1, o = !1; return "string" == typeof t && (t = U(t)), "object" == (void 0 === t ? "undefined" : e(t)) && (t.hasOwnProperty("r") && t.hasOwnProperty("g") && t.hasOwnProperty("b") ? (n = g(t.r, t.g, t.b), r = !0, o = "%" === String(t.r).substr(-1) ? "prgb" : "rgb") : t.hasOwnProperty("h") && t.hasOwnProperty("s") && t.hasOwnProperty("v") ? (t.s = j(t.s), t.v = j(t.v), n = b(t.h, t.s, t.v), r = !0, o = "hsv") : t.hasOwnProperty("h") && t.hasOwnProperty("s") && t.hasOwnProperty("l") && (t.s = j(t.s), t.l = j(t.l), n = v(t.h, t.s, t.l), r = !0, o = "hsl"), t.hasOwnProperty("a") && (i = t.a)), i = _(i), { ok: r, format: t.format || o, r: it(255, rt(n.r, 0)), g: it(255, rt(n.g, 0)), b: it(255, rt(n.b, 0)), a: i } } function g(t, e, n) { return { r: 255 * F(t, 255), g: 255 * F(e, 255), b: 255 * F(n, 255) } } function m(t, e, n) { t = F(t, 255), e = F(e, 255), n = F(n, 255); var i, r, o = rt(t, e, n), s = it(t, e, n), a = (o + s) / 2; if (o == s) i = r = 0; else { var l = o - s; switch (r = a > .5 ? l / (2 - o - s) : l / (o + s), o) { case t: i = (e - n) / l + (e < n ? 6 : 0); break; case e: i = (n - t) / l + 2; break; case n: i = (t - e) / l + 4 }i /= 6 } return { h: i, s: r, l: a } } function v(t, e, n) { function i(t, e, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t } var r, o, s; if (t = F(t, 360), e = F(e, 100), n = F(n, 100), 0 === e) r = o = s = n; else { var a = n < .5 ? n * (1 + e) : n + e - n * e, l = 2 * n - a; r = i(l, a, t + 1 / 3), o = i(l, a, t), s = i(l, a, t - 1 / 3) } return { r: 255 * r, g: 255 * o, b: 255 * s } } function y(t, e, n) { t = F(t, 255), e = F(e, 255), n = F(n, 255); var i, r, o = rt(t, e, n), s = it(t, e, n), a = o, l = o - s; if (r = 0 === o ? 0 : l / o, o == s) i = 0; else { switch (o) { case t: i = (e - n) / l + (e < n ? 6 : 0); break; case e: i = (n - t) / l + 2; break; case n: i = (t - e) / l + 4 }i /= 6 } return { h: i, s: r, v: a } } function b(t, e, n) { t = 6 * F(t, 360), e = F(e, 100), n = F(n, 100); var i = et.floor(t), r = t - i, o = n * (1 - e), s = n * (1 - r * e), a = n * (1 - (1 - r) * e), l = i % 6; return { r: 255 * [n, s, o, o, a, n][l], g: 255 * [a, n, n, s, o, o][l], b: 255 * [o, o, a, n, n, s][l] } } function x(t, e, n, i) { var r = [V(nt(t).toString(16)), V(nt(e).toString(16)), V(nt(n).toString(16))]; return i && r[0].charAt(0) == r[0].charAt(1) && r[1].charAt(0) == r[1].charAt(1) && r[2].charAt(0) == r[2].charAt(1) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) : r.join("") } function w(t, e, n, i) { return [V(B(i)), V(nt(t).toString(16)), V(nt(e).toString(16)), V(nt(n).toString(16))].join("") } function C(t, e) { e = 0 === e ? 0 : e || 10; var n = st(t).toHsl(); return n.s -= e / 100, n.s = $(n.s), st(n) } function k(t, e) { e = 0 === e ? 0 : e || 10; var n = st(t).toHsl(); return n.s += e / 100, n.s = $(n.s), st(n) } function S(t) { return st(t).desaturate(100) } function T(t, e) { e = 0 === e ? 0 : e || 10; var n = st(t).toHsl(); return n.l += e / 100, n.l = $(n.l), st(n) } function M(t, e) { e = 0 === e ? 0 : e || 10; var n = st(t).toRgb(); return n.r = rt(0, it(255, n.r - nt(-e / 100 * 255))), n.g = rt(0, it(255, n.g - nt(-e / 100 * 255))), n.b = rt(0, it(255, n.b - nt(-e / 100 * 255))), st(n) } function E(t, e) { e = 0 === e ? 0 : e || 10; var n = st(t).toHsl(); return n.l -= e / 100, n.l = $(n.l), st(n) } function P(t, e) { var n = st(t).toHsl(), i = (nt(n.h) + e) % 360; return n.h = i < 0 ? 360 + i : i, st(n) } function A(t) { var e = st(t).toHsl(); return e.h = (e.h + 180) % 360, st(e) } function L(t) { var e = st(t).toHsl(), n = e.h; return [st(t), st({ h: (n + 120) % 360, s: e.s, l: e.l }), st({ h: (n + 240) % 360, s: e.s, l: e.l })] } function O(t) { var e = st(t).toHsl(), n = e.h; return [st(t), st({ h: (n + 90) % 360, s: e.s, l: e.l }), st({ h: (n + 180) % 360, s: e.s, l: e.l }), st({ h: (n + 270) % 360, s: e.s, l: e.l })] } function N(t) { var e = st(t).toHsl(), n = e.h; return [st(t), st({ h: (n + 72) % 360, s: e.s, l: e.l }), st({ h: (n + 216) % 360, s: e.s, l: e.l })] } function D(t, e, n) { e = e || 6, n = n || 30; var i = st(t).toHsl(), r = 360 / n, o = [st(t)]; for (i.h = (i.h - (r * e >> 1) + 720) % 360; --e;)i.h = (i.h + r) % 360, o.push(st(i)); return o } function I(t, e) { e = e || 6; for (var n = st(t).toHsv(), i = n.h, r = n.s, o = n.v, s = [], a = 1 / e; e--;)s.push(st({ h: i, s: r, v: o })), o = (o + a) % 1; return s } function _(t) { return t = parseFloat(t), (isNaN(t) || t < 0 || t > 1) && (t = 1), t } function F(t, e) { H(t) && (t = "100%"); var n = R(t); return t = it(e, rt(0, parseFloat(t))), n && (t = parseInt(t * e, 10) / 100), et.abs(t - e) < 1e-6 ? 1 : t % e / parseFloat(e) } function $(t) { return it(1, rt(0, t)) } function z(t) { return parseInt(t, 16) } function H(t) { return "string" == typeof t && -1 != t.indexOf(".") && 1 === parseFloat(t) } function R(t) { return "string" == typeof t && -1 != t.indexOf("%") } function V(t) { return 1 == t.length ? "0" + t : "" + t } function j(t) { return t <= 1 && (t = 100 * t + "%"), t } function B(t) { return Math.round(255 * parseFloat(t)).toString(16) } function W(t) { return z(t) / 255 } function U(t) { t = t.replace(Z, "").replace(Q, "").toLowerCase(); var e = !1; if (at[t]) t = at[t], e = !0; else if ("transparent" == t) return { r: 0, g: 0, b: 0, a: 0, format: "name" }; var n; return (n = ct.rgb.exec(t)) ? { r: n[1], g: n[2], b: n[3] } : (n = ct.rgba.exec(t)) ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = ct.hsl.exec(t)) ? { h: n[1], s: n[2], l: n[3] } : (n = ct.hsla.exec(t)) ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = ct.hsv.exec(t)) ? { h: n[1], s: n[2], v: n[3] } : (n = ct.hsva.exec(t)) ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = ct.hex8.exec(t)) ? { a: W(n[1]), r: z(n[2]), g: z(n[3]), b: z(n[4]), format: e ? "name" : "hex8" } : (n = ct.hex6.exec(t)) ? { r: z(n[1]), g: z(n[2]), b: z(n[3]), format: e ? "name" : "hex" } : !!(n = ct.hex3.exec(t)) && { r: z(n[1] + "" + n[1]), g: z(n[2] + "" + n[2]), b: z(n[3] + "" + n[3]), format: e ? "name" : "hex" } } var q = { beforeShow: l, move: l, change: l, show: l, hide: l, color: !1, flat: !1, showInput: !1, allowEmpty: !1, showButtons: !0, clickoutFiresChange: !0, showInitial: !1, showPalette: !1, showPaletteOnly: !1, hideAfterPaletteSelect: !1, togglePaletteOnly: !1, showSelectionPalette: !0, localStorageKey: !1, appendTo: "body", maxSelectionSize: 7, cancelText: "cancel", chooseText: "choose", togglePaletteMoreText: "more", togglePaletteLessText: "less", clearText: "Clear Color Selection", noColorSelectedText: "No Color Selected", preferredFormat: !1, className: "", containerClassName: "", replacerClassName: "", showAlpha: !1, theme: "sp-light", palette: [["#ffffff", "#000000", "#ff0000", "#ff8000", "#ffff00", "#008000", "#0000ff", "#4b0082", "#9400d3"]], selectionPalette: [], disabled: !1, offset: null }, K = [], G = !!/msie/i.exec(window.navigator.userAgent), Y = function () { function t(t, e) { return !!~("" + t).indexOf(e) } var e = document.createElement("div"), n = e.style; return n.cssText = "background-color:rgba(0,0,0,.5)", t(n.backgroundColor, "rgba") || t(n.backgroundColor, "hsla") }(), X = ["<div class='sp-replacer'>", "<div class='sp-preview'><div class='sp-preview-inner'></div></div>", "<div class='sp-dd'>&#9660;</div>", "</div>"].join(""), J = function () { var t = ""; if (G) for (var e = 1; e <= 6; e++)t += "<div class='sp-" + e + "'></div>"; return ["<div class='sp-container sp-hidden'>", "<div class='sp-palette-container'>", "<div class='sp-palette sp-thumb sp-cf'></div>", "<div class='sp-palette-button-container sp-cf'>", "<button type='button' class='sp-palette-toggle'></button>", "</div>", "</div>", "<div class='sp-picker-container'>", "<div class='sp-top sp-cf'>", "<div class='sp-fill'></div>", "<div class='sp-top-inner'>", "<div class='sp-color'>", "<div class='sp-sat'>", "<div class='sp-val'>", "<div class='sp-dragger'></div>", "</div>", "</div>", "</div>", "<div class='sp-clear sp-clear-display'>", "</div>", "<div class='sp-hue'>", "<div class='sp-slider'></div>", t, "</div>", "</div>", "<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>", "</div>", "<div class='sp-input-container sp-cf'>", "<input class='sp-input' type='text' spellcheck='false'  />", "</div>", "<div class='sp-initial sp-thumb sp-cf'></div>", "<div class='sp-button-container sp-cf'>", "<a class='sp-cancel' href='#'></a>", "<button type='button' class='sp-choose'></button>", "</div>", "</div>", "</div>"].join("") }(); t.fn.spectrum = function (e, n) { if ("string" == typeof e) { var i = this, r = Array.prototype.slice.call(arguments, 1); return this.each(function () { var n = K[t(this).data("spectrum.id")]; if (n) { var o = n[e]; if (!o) throw new Error("Spectrum: no such method: '" + e + "'"); "get" == e ? i = n.get() : "container" == e ? i = n.container : "option" == e ? i = n.option.apply(n, r) : "destroy" == e ? (n.destroy(), t(this).removeData("spectrum.id")) : o.apply(n, r) } }), i } return this.spectrum("destroy").each(function () { var n = t.extend({}, e, t(this).data()), i = s(this, n); t(this).data("spectrum.id", i.id) }) }, t.fn.spectrum.load = !0, t.fn.spectrum.loadOpts = {}, t.fn.spectrum.draggable = h, t.fn.spectrum.defaults = q, t.fn.spectrum.inputTypeColorSupport = function e() { if (void 0 === e._cachedResult) { var n = t("<input type='color'/>")[0]; e._cachedResult = "color" === n.type && "" !== n.value } return e._cachedResult }, t.spectrum = {}, t.spectrum.localization = {}, t.spectrum.palettes = {}, t.fn.spectrum.processNativeColorInputs = function () { var e = t("input[type=color]"); e.length && !f() && e.spectrum({ preferredFormat: "hex6" }) }; var Z = /^[\s,#]+/, Q = /\s+$/, tt = 0, et = Math, nt = et.round, it = et.min, rt = et.max, ot = et.random, st = function t(e, n) { if (e = e || "", n = n || {}, e instanceof t) return e; if (!(this instanceof t)) return new t(e, n); var i = p(e); this._originalInput = e, this._r = i.r, this._g = i.g, this._b = i.b, this._a = i.a, this._roundA = nt(100 * this._a) / 100, this._format = n.format || i.format, this._gradientType = n.gradientType, this._r < 1 && (this._r = nt(this._r)), this._g < 1 && (this._g = nt(this._g)), this._b < 1 && (this._b = nt(this._b)), this._ok = i.ok, this._tc_id = tt++ }; st.prototype = { isDark: function () { return this.getBrightness() < 128 }, isLight: function () { return !this.isDark() }, isValid: function () { return this._ok }, getOriginalInput: function () { return this._originalInput }, getFormat: function () { return this._format }, getAlpha: function () { return this._a }, getBrightness: function () { var t = this.toRgb(); return (299 * t.r + 587 * t.g + 114 * t.b) / 1e3 }, setAlpha: function (t) { return this._a = _(t), this._roundA = nt(100 * this._a) / 100, this }, toHsv: function () { var t = y(this._r, this._g, this._b); return { h: 360 * t.h, s: t.s, v: t.v, a: this._a } }, toHsvString: function () { var t = y(this._r, this._g, this._b), e = nt(360 * t.h), n = nt(100 * t.s), i = nt(100 * t.v); return 1 == this._a ? "hsv(" + e + ", " + n + "%, " + i + "%)" : "hsva(" + e + ", " + n + "%, " + i + "%, " + this._roundA + ")" }, toHsl: function () { var t = m(this._r, this._g, this._b); return { h: 360 * t.h, s: t.s, l: t.l, a: this._a } }, toHslString: function () { var t = m(this._r, this._g, this._b), e = nt(360 * t.h), n = nt(100 * t.s), i = nt(100 * t.l); return 1 == this._a ? "hsl(" + e + ", " + n + "%, " + i + "%)" : "hsla(" + e + ", " + n + "%, " + i + "%, " + this._roundA + ")" }, toHex: function (t) { return x(this._r, this._g, this._b, t) }, toHexString: function (t) { return "#" + this.toHex(t) }, toHex8: function () { return w(this._r, this._g, this._b, this._a) }, toHex8String: function () { return "#" + this.toHex8() }, toRgb: function () { return { r: nt(this._r), g: nt(this._g), b: nt(this._b), a: this._a } }, toRgbString: function () { return 1 == this._a ? "rgb(" + nt(this._r) + ", " + nt(this._g) + ", " + nt(this._b) + ")" : "rgba(" + nt(this._r) + ", " + nt(this._g) + ", " + nt(this._b) + ", " + this._roundA + ")" }, toPercentageRgb: function () { return { r: nt(100 * F(this._r, 255)) + "%", g: nt(100 * F(this._g, 255)) + "%", b: nt(100 * F(this._b, 255)) + "%", a: this._a } }, toPercentageRgbString: function () { return 1 == this._a ? "rgb(" + nt(100 * F(this._r, 255)) + "%, " + nt(100 * F(this._g, 255)) + "%, " + nt(100 * F(this._b, 255)) + "%)" : "rgba(" + nt(100 * F(this._r, 255)) + "%, " + nt(100 * F(this._g, 255)) + "%, " + nt(100 * F(this._b, 255)) + "%, " + this._roundA + ")" }, toName: function () { return 0 === this._a ? "transparent" : !(this._a < 1) && (lt[x(this._r, this._g, this._b, !0)] || !1) }, toFilter: function (t) { var e = "#" + w(this._r, this._g, this._b, this._a), n = e, i = this._gradientType ? "GradientType = 1, " : ""; if (t) { n = st(t).toHex8String() } return "progid:DXImageTransform.Microsoft.gradient(" + i + "startColorstr=" + e + ",endColorstr=" + n + ")" }, toString: function (t) { var e = !!t; t = t || this._format; var n = !1, i = this._a < 1 && this._a >= 0; return e || !i || "hex" !== t && "hex6" !== t && "hex3" !== t && "name" !== t ? ("rgb" === t && (n = this.toRgbString()), "prgb" === t && (n = this.toPercentageRgbString()), "hex" !== t && "hex6" !== t || (n = this.toHexString()), "hex3" === t && (n = this.toHexString(!0)), "hex8" === t && (n = this.toHex8String()), "name" === t && (n = this.toName()), "hsl" === t && (n = this.toHslString()), "hsv" === t && (n = this.toHsvString()), n || this.toHexString()) : "name" === t && 0 === this._a ? this.toName() : this.toRgbString() }, _applyModification: function (t, e) { var n = t.apply(null, [this].concat([].slice.call(e))); return this._r = n._r, this._g = n._g, this._b = n._b, this.setAlpha(n._a), this }, lighten: function () { return this._applyModification(T, arguments) }, brighten: function () { return this._applyModification(M, arguments) }, darken: function () { return this._applyModification(E, arguments) }, desaturate: function () { return this._applyModification(C, arguments) }, saturate: function () { return this._applyModification(k, arguments) }, greyscale: function () { return this._applyModification(S, arguments) }, spin: function () { return this._applyModification(P, arguments) }, _applyCombination: function (t, e) { return t.apply(null, [this].concat([].slice.call(e))) }, analogous: function () { return this._applyCombination(D, arguments) }, complement: function () { return this._applyCombination(A, arguments) }, monochromatic: function () { return this._applyCombination(I, arguments) }, splitcomplement: function () { return this._applyCombination(N, arguments) }, triad: function () { return this._applyCombination(L, arguments) }, tetrad: function () { return this._applyCombination(O, arguments) } }, st.fromRatio = function (t, n) { if ("object" == (void 0 === t ? "undefined" : e(t))) { var i = {}; for (var r in t) t.hasOwnProperty(r) && (i[r] = "a" === r ? t[r] : j(t[r])); t = i } return st(t, n) }, st.equals = function (t, e) { return !(!t || !e) && st(t).toRgbString() == st(e).toRgbString() }, st.random = function () { return st.fromRatio({ r: ot(), g: ot(), b: ot() }) }, st.mix = function (t, e, n) { n = 0 === n ? 0 : n || 50; var i, r = st(t).toRgb(), o = st(e).toRgb(), s = n / 100, a = 2 * s - 1, l = o.a - r.a; i = a * l == -1 ? a : (a + l) / (1 + a * l), i = (i + 1) / 2; var c = 1 - i, u = { r: o.r * i + r.r * c, g: o.g * i + r.g * c, b: o.b * i + r.b * c, a: o.a * s + r.a * (1 - s) }; return st(u) }, st.readability = function (t, e) { var n = st(t), i = st(e), r = n.toRgb(), o = i.toRgb(), s = n.getBrightness(), a = i.getBrightness(), l = Math.max(r.r, o.r) - Math.min(r.r, o.r) + Math.max(r.g, o.g) - Math.min(r.g, o.g) + Math.max(r.b, o.b) - Math.min(r.b, o.b); return { brightness: Math.abs(s - a), color: l } }, st.isReadable = function (t, e) { var n = st.readability(t, e); return n.brightness > 125 && n.color > 500 }, st.mostReadable = function (t, e) { for (var n = null, i = 0, r = !1, o = 0; o < e.length; o++) { var s = st.readability(t, e[o]), a = s.brightness > 125 && s.color > 500, l = s.brightness / 125 * 3 + s.color / 500; (a && !r || a && r && l > i || !a && !r && l > i) && (r = a, i = l, n = st(e[o])) } return n }; var at = st.names = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" }, lt = st.hexNames = function (t) { var e = {}; for (var n in t) t.hasOwnProperty(n) && (e[t[n]] = n); return e }(at), ct = function () { var t = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)", e = "[\\s|\\(]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")\\s*\\)?", n = "[\\s|\\(]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")[,|\\s]+(" + t + ")\\s*\\)?"; return { rgb: new RegExp("rgb" + e), rgba: new RegExp("rgba" + n), hsl: new RegExp("hsl" + e), hsla: new RegExp("hsla" + n), hsv: new RegExp("hsv" + e), hsva: new RegExp("hsva" + n), hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ } }(); window.tinycolor = st, t(function () { t.fn.spectrum.load && t.fn.spectrum.processNativeColorInputs() }) }(t.$) }() }).call(e, n(0)) }, function (t, e, n) { "use strict"; var i = n(0), r = n(119); t.exports = i.View.extend({ initialize: function (t) { this.config = t.config || {}, this.stackModel = t.stackModel, this.preview = t.preview, this.pfx = this.config.stylePrefix || "", this.ppfx = this.config.pStylePrefix || "", this.propsConfig = t.propsConfig; var e = this.pfx, n = this.ppfx, i = this.collection; this.className = e + "layers " + n + "field", this.listenTo(i, "add", this.addTo), this.listenTo(i, "deselectAll", this.deselectAll), this.listenTo(i, "reset", this.render); var r = this.config.em || "", o = r ? r.get("Utils") : ""; this.sorter = o ? new o.Sorter({ container: this.el, ignoreViewChildren: 1, containerSel: "." + e + "layers", itemSel: "." + e + "layer", pfx: this.config.pStylePrefix }) : "", i.view = this, this.$el.data("model", i), this.$el.data("collection", i) }, addTo: function (t) { var e = this.collection.indexOf(t); this.addToCollection(t, null, e) }, addToCollection: function (t, e, n) { var i = e || null, o = this.stackModel, s = this.config, a = this.sorter, l = this.propsConfig; void 0 !== this.preview && t.set("preview", this.preview); var c = new r({ model: t, config: s, sorter: a, stackModel: o, propsConfig: l }), u = c.render().el; if (i) i.appendChild(u); else if (void 0 !== n) { var h = "before"; this.$el.children().length == n && (n-- , h = "after"), n < 0 ? this.$el.append(u) : this.$el.children().eq(n)[h](u) } else this.$el.append(u); return u }, deselectAll: function () { this.$el.find("." + this.pfx + "layer").removeClass(this.pfx + "active") }, render: function () { var t = document.createDocumentFragment(); return this.$el.empty(), this.collection.each(function (e) { this.addToCollection(e, t) }, this), this.$el.append(t), this.$el.attr("class", this.className), this.sorter && (this.sorter.plh = null), this } }) }, function (t, e, n) { "use strict"; (function (e) { t.exports = e.View.extend({ events: { click: "active", "click [data-close-layer]": "remove", "mousedown [data-move-layer]": "initSorter" }, template: function (t) { var e = this.pfx; return '\n      <div id="' + e + 'move" data-move-layer>\n        <i class="fa fa-arrows"></i>\n      </div>\n      <div id="' + e + 'label">Layer ' + t.get("index") + '</div>\n      <div id="' + e + 'preview-box">\n      \t<div id="' + e + 'preview" data-preview></div>\n      </div>\n      <div id="' + e + 'close-layer" class="' + e + 'btn-close" data-close-layer>\n        &Cross;\n      </div>\n      <div id="' + e + 'inputs" data-properties></div>\n      <div style="clear:both"></div>\n    ' }, initialize: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = this.model; this.stackModel = t.stackModel || {}, this.config = t.config || {}, this.pfx = this.config.stylePrefix || "", this.sorter = t.sorter || null, this.propsConfig = t.propsConfig || {}, this.customPreview = t.onPreview, this.listenTo(e, "destroy remove", this.remove), this.listenTo(e, "change:active", this.updateVisibility), this.listenTo(e.get("properties"), "change", this.updatePreview), e.get("preview") || this.$el.addClass(this.pfx + "no-preview"), e.view = this, e.set({ droppable: 0, draggable: 1 }), this.$el.data("model", e) }, initSorter: function (t) { this.sorter && this.sorter.startSort(this.el) }, remove: function (t) { t && t.stopPropagation && t.stopPropagation(); var n = this.model, i = n.collection, r = this.stackModel; e.View.prototype.remove.apply(this, arguments), i.contains(n) && i.remove(n), r && r.set && (r.set({ stackIndex: null }, { silent: !0 }), r.trigger("updateValue")) }, onPreview: function (t) { var e = t.split(" "), n = []; return this.model.get("properties").each(function (t, i) { var r = e[i] || ""; if (r && "integer" == t.get("type")) { var o = parseInt(r, 10), s = r.replace(o, ""); o = isNaN(o) ? 0 : o, o = o > 3 ? 3 : o, o = o < -3 ? -3 : o, r = o + s } n.push(r) }), n.join(" ") }, updatePreview: function () { var t = this.stackModel, e = this.customPreview, n = this.getPreviewEl(), i = this.model.getFullValue(), r = e ? e(i) : this.onPreview(i); r && t && n && (n.style[t.get("property")] = r) }, getPropertiesWrapper: function () { return this.propsWrapEl || (this.propsWrapEl = this.el.querySelector("[data-properties]")), this.propsWrapEl }, getPreviewEl: function () { return this.previewEl || (this.previewEl = this.el.querySelector("[data-preview]")), this.previewEl }, active: function () { var t = this.model, e = t.collection; e.active(e.indexOf(t)) }, updateVisibility: function () { var t = this.pfx, e = this.getPropertiesWrapper(), n = this.model.get("active"); e.style.display = n ? "" : "none", this.$el[n ? "addClass" : "removeClass"](t + "active") }, render: function () { var t = n(12), e = this.propsConfig, i = this.pfx + "layer", r = this.model, o = this.el, s = new t({ collection: r.get("properties"), config: this.config, customValue: e.customValue, propTarget: e.propTarget, onChange: e.onChange }).render().el; return o.innerHTML = this.template(r), o.className = i, this.getPropertiesWrapper().appendChild(s), this.updateVisibility(), this.updatePreview(), this } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; var i = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, r = n(40); t.exports = r.extend({ defaults: i({}, r.prototype.defaults, { showInput: 1 }) }) }, function (t, e, n) { "use strict"; var i = n(13); t.exports = i.extend({ events: { "change [type=range]": "inputValueChanged", "input [type=range]": "inputValueChangedSoft" }, templateInput: function (t) { var e = this.ppfx; return '\n      <div class="' + e + "field " + e + 'field-range">\n        <input type="range"\n          min="' + t.get("min") + '"\n          max="' + t.get("max") + '"\n          step="' + t.get("step") + '"/>\n      </div>\n    ' }, getSliderEl: function () { return this.slider || (this.slider = this.el.querySelector("input[type=range]")), this.slider }, inputValueChanged: function () { var t = this.model, e = t.get("step"); this.getInputEl().value = this.getSliderEl().value; var n = this.getInputValue() - e; t.set("value", n, { avoidStore: 1 }).set("value", n + e), this.elementUpdated() }, inputValueChangedSoft: function () { this.getInputEl().value = this.getSliderEl().value, this.model.set("value", this.getInputValue(), { avoidStore: 1 }), this.elementUpdated() }, setValue: function (t) { this.getSliderEl().value = t, this.inputInst.setValue(t, { silent: 1 }) }, onRender: function () { i.prototype.onRender.apply(this, arguments), this.model.get("showInput") || (this.inputInst.el.style.display = "none") } }) }, function (t, e, n) { "use strict"; n(0); t.exports = function () { return { build: function (t) { var e = []; "string" == typeof t && (t = [t]); for (var n = 0, i = t.length; n < i; n++) { var r = {}, o = t[n]; switch (r.property = o, o) { case "border-radius-c": r.property = "border-radius" }switch (o) { case "margin-top": case "margin-right": case "margin-bottom": case "margin-left": case "padding-top": case "padding-right": case "padding-bottom": case "padding-left": case "width": case "max-width": case "min-width": case "height": case "max-height": case "min-height": r.fixedValues = ["initial", "inherit", "auto"]; break; case "font-size": r.fixedValues = ["medium", "xx-small", "x-small", "small", "large", "x-large", "xx-large", "smaller", "larger", "length", "initial", "inherit"]; break; case "letter-spacing": case "line-height": r.fixedValues = ["normal", "initial", "inherit"] }switch (o) { case "float": case "position": case "text-align": r.type = "radio"; break; case "display": case "font-family": case "font-weight": case "border-style": case "box-shadow-type": case "background-repeat": case "background-position": case "background-attachment": case "background-size": case "transition-property": case "transition-timing-function": case "cursor": case "overflow": r.type = "select"; break; case "top": case "right": case "bottom": case "left": case "margin-top": case "margin-right": case "margin-bottom": case "margin-left": case "padding-top": case "padding-right": case "padding-bottom": case "padding-left": case "min-height": case "min-width": case "max-height": case "max-width": case "width": case "height": case "font-size": case "letter-spacing": case "line-height": case "text-shadow-h": case "text-shadow-v": case "text-shadow-blur": case "border-radius-c": case "border-top-left-radius": case "border-top-right-radius": case "border-bottom-left-radius": case "border-bottom-right-radius": case "border-width": case "box-shadow-h": case "box-shadow-v": case "box-shadow-blur": case "box-shadow-spread": case "transition-duration": case "perspective": case "transform-rotate-x": case "transform-rotate-y": case "transform-rotate-z": case "transform-scale-x": case "transform-scale-y": case "transform-scale-z": r.type = "integer"; break; case "margin": case "padding": case "border-radius": case "border": case "transform": r.type = "composite"; break; case "color": case "text-shadow-color": case "background-color": case "border-color": case "box-shadow-color": r.type = "color"; break; case "text-shadow": case "box-shadow": case "background": case "transition": r.type = "stack"; break; case "background-image": r.type = "file" }switch (o) { case "float": case "background-color": case "background-image": case "text-shadow": r.defaults = "none"; break; case "display": r.defaults = "block"; break; case "position": r.defaults = "static"; break; case "top": case "right": case "bottom": case "left": case "margin-top": case "margin-right": case "margin-bottom": case "margin-left": case "padding-top": case "padding-right": case "padding-bottom": case "padding-left": case "text-shadow-h": case "text-shadow-v": case "text-shadow-blur": case "border-radius-c": case "border-top-left-radius": case "border-top-right-radius": case "border-bottom-left-radius": case "border-bottom-right-radius": case "box-shadow-h": case "box-shadow-v": case "box-shadow-spread": case "perspective": case "transform-rotate-x": case "transform-rotate-y": case "transform-rotate-z": r.defaults = 0; break; case "transform-scale-x": case "transform-scale-y": case "transform-scale-z": r.defaults = 1; break; case "box-shadow-blur": r.defaults = "5px"; break; case "min-height": case "min-width": case "max-height": case "max-width": case "width": case "height": case "background-size": case "cursor": r.defaults = "auto"; break; case "font-family": r.defaults = "Arial, Helvetica, sans-serif"; break; case "font-size": case "border-width": r.defaults = "medium"; break; case "font-weight": r.defaults = "400"; break; case "letter-spacing": case "line-height": r.defaults = "normal"; break; case "color": case "text-shadow-color": case "border-color": case "box-shadow-color": r.defaults = "black"; break; case "text-align": r.defaults = "left"; break; case "border-style": r.defaults = "solid"; break; case "box-shadow-type": r.defaults = ""; break; case "background-repeat": r.defaults = "repeat"; break; case "background-position": r.defaults = "left top"; break; case "background-attachment": r.defaults = "scroll"; break; case "transition-property": r.defaults = "width"; break; case "transition-duration": r.defaults = "2"; break; case "transition-timing-function": r.defaults = "ease"; break; case "overflow": r.defaults = "visible" }switch (o) { case "top": case "right": case "bottom": case "left": case "margin-top": case "margin-right": case "margin-bottom": case "margin-left": case "padding-top": case "padding-right": case "padding-bottom": case "padding-left": case "min-height": case "min-width": case "max-height": case "max-width": case "width": case "height": case "text-shadow-h": case "text-shadow-v": case "text-shadow-blur": case "border-radius-c": case "border-top-left-radius": case "border-top-right-radius": case "border-bottom-left-radius": case "border-bottom-right-radius": case "box-shadow-h": case "box-shadow-v": r.units = ["px", "%"]; break; case "font-size": case "letter-spacing": case "line-height": r.units = ["px", "em", "rem", "%"]; break; case "border-width": r.units = ["px", "em"]; break; case "box-shadow-blur": case "box-shadow-spread": case "perspective": r.units = ["px"]; break; case "transition-duration": r.units = ["s"]; break; case "transform-rotate-x": case "transform-rotate-y": case "transform-rotate-z": r.units = ["deg"] }switch (o) { case "padding-top": case "padding-right": case "padding-bottom": case "padding-left": case "min-height": case "min-width": case "max-height": case "max-width": case "width": case "height": case "font-size": case "text-shadow-blur": case "border-radius-c": case "border-top-left-radius": case "border-top-right-radius": case "border-bottom-left-radius": case "border-bottom-right-radius": case "border-width": case "box-shadow-blur": case "transition-duration": case "perspective": r.min = 0 }switch (o) { case "text-shadow": case "box-shadow": case "background": r.preview = !0 }switch (o) { case "background": r.detached = !0 }switch (o) { case "transform-rotate-x": r.functionName = "rotateX"; break; case "transform-rotate-y": r.functionName = "rotateY"; break; case "transform-rotate-z": r.functionName = "rotateZ"; break; case "transform-scale-x": r.functionName = "scaleX"; break; case "transform-scale-y": r.functionName = "scaleY"; break; case "transform-scale-z": r.functionName = "scaleZ"; break; case "background-image": r.functionName = "url" }switch (o) { case "float": r.list = [{ value: "none" }, { value: "left" }, { value: "right" }]; break; case "display": r.list = [{ value: "block" }, { value: "inline" }, { value: "inline-block" }, { value: "none" }]; break; case "position": r.list = [{ value: "static" }, { value: "relative" }, { value: "absolute" }, { value: "fixed" }]; break; case "font-family": var s = ", sans-serif", a = ["Arial, Helvetica" + s, "Arial Black, Gadget" + s, "Brush Script MT" + s, "Comic Sans MS, cursive" + s, "Courier New, Courier, monospace", "Georgia, serif", "Helvetica, serif", "Impact, Charcoal" + s, "Lucida Sans Unicode, Lucida Grande" + s, "Tahoma, Geneva" + s, "Times New Roman, Times, serif", "Trebuchet MS, Helvetica" + s, "Verdana, Geneva" + s]; r.list = []; for (var l = 0, c = a.length; l < c; l++) { var u = {}; u.value = a[l], u.name = a[l].split(",")[0], r.list.push(u) } break; case "font-weight": r.list = [{ value: "100", name: "Thin" }, { value: "200", name: "Extra-Light" }, { value: "300", name: "Light" }, { value: "400", name: "Normal" }, { value: "500", name: "Medium" }, { value: "600", name: "Semi-Bold" }, { value: "700", name: "Bold" }, { value: "800", name: "Extra-Bold" }, { value: "900", name: "Ultra-Bold" }]; break; case "text-align": r.list = [{ value: "left" }, { value: "center" }, { value: "right" }, { value: "justify" }]; break; case "border-style": r.list = [{ value: "none" }, { value: "solid" }, { value: "dotted" }, { value: "dashed" }, { value: "double" }, { value: "groove" }, { value: "ridge" }, { value: "inset" }, { value: "outset" }]; break; case "box-shadow-type": r.list = [{ value: "", name: "Outside" }, { value: "inset", name: "Inside" }]; break; case "background-repeat": r.list = [{ value: "repeat" }, { value: "repeat-x" }, { value: "repeat-y" }, { value: "no-repeat" }]; break; case "background-position": r.list = [{ value: "left top" }, { value: "left center" }, { value: "left bottom" }, { value: "right top" }, { value: "right center" }, { value: "right bottom" }, { value: "center top" }, { value: "center center" }, { value: "center bottom" }]; break; case "background-attachment": r.list = [{ value: "scroll" }, { value: "fixed" }, { value: "local" }]; break; case "background-size": r.list = [{ value: "auto" }, { value: "cover" }, { value: "contain" }]; break; case "transition-property": r.list = [{ value: "all" }, { value: "width" }, { value: "height" }, { value: "background-color" }, { value: "transform" }, { value: "box-shadow" }, { value: "opacity" }]; break; case "transition-timing-function": r.list = [{ value: "linear" }, { value: "ease" }, { value: "ease-in" }, { value: "ease-out" }, { value: "ease-in-out" }]; break; case "cursor": r.list = [{ value: "auto" }, { value: "pointer" }, { value: "copy" }, { value: "crosshair" }, { value: "grab" }, { value: "grabbing" }, { value: "help" }, { value: "move" }, { value: "text" }]; break; case "overflow": r.list = [{ value: "visible" }, { value: "hidden" }, { value: "scroll" }, { value: "auto" }] }switch (o) { case "margin": r.properties = this.build(["margin-top", "margin-right", "margin-bottom", "margin-left"]); break; case "padding": r.properties = this.build(["padding-top", "padding-right", "padding-bottom", "padding-left"]); break; case "text-shadow": r.properties = this.build(["text-shadow-h", "text-shadow-v", "text-shadow-blur", "text-shadow-color"]); break; case "border": r.properties = this.build(["border-width", "border-style", "border-color"]); break; case "border-radius": r.properties = this.build(["border-top-left-radius", "border-top-right-radius", "border-bottom-left-radius", "border-bottom-right-radius"]); break; case "box-shadow": r.properties = this.build(["box-shadow-h", "box-shadow-v", "box-shadow-blur", "box-shadow-spread", "box-shadow-color", "box-shadow-type"]); break; case "background": r.properties = this.build(["background-image", "background-repeat", "background-position", "background-attachment", "background-size"]); break; case "transition": r.properties = this.build(["transition-property", "transition-duration", "transition-timing-function"]); break; case "transform": r.properties = this.build(["transform-rotate-x", "transform-rotate-y", "transform-rotate-z", "transform-scale-x", "transform-scale-y", "transform-scale-z"]) }e.push(r) } return e } } } }, function (t, e, n) { "use strict"; (function (e) { var i = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, r = n(1), o = n(124); t.exports = e.View.extend({ initialize: function (t) { this.config = t.config || {}, this.pfx = this.config.stylePrefix || "", this.target = t.target || {}; var n = {}; (0, r.extend)(n, e.Events); var o = document.body, s = document.createElement("el-" + (new Date).getTime()); o.appendChild(s), n.computedDefault = i({}, window.getComputedStyle(s)), o.removeChild(s), this.propTarget = n, this.listenTo(this.collection, "add", this.addTo), this.listenTo(this.collection, "reset", this.render), this.listenTo(this.target, "change:selectedComponent targetClassAdded targetClassRemoved targetClassUpdated targetStateUpdated targetStyleUpdated change:device", this.targetUpdated) }, addTo: function (t) { this.addToCollection(t) }, targetUpdated: function () { var t = this.target, e = t.get("selectedComponent"), n = t.get("UndoManager"); if (e) { var i = t.get("Config"), r = i.devicePreviewMode, o = e.get("classes"), s = this.propTarget, a = t.getDeviceModel(), l = r ? "" : e.get("state"), c = a && a.get("widthMedia"), u = l ? ":" + l : null, h = e.view, d = a && !r && c ? "(" + i.mediaCondition + ": " + c + ")" : ""; if (s.helper = null, h && (s.computed = window.getComputedStyle(h.el, u)), o.length) { var f = t.get("CssComposer"), p = o.getStyleable(), g = f.get(p, l, d); if (!g && p.length && (n.stopTracking(), g = f.add(p, l, d), g.set("style", e.get("style")), e.set("style", {}), n.startTracking()), !g) return s.model = e, void s.trigger("update"); if (l) { var m = t.get("SelectorManager"), v = m.add("hc-state"), y = f.get([v]); y ? (f.getAll().remove(y), f.getAll().add(y)) : y = f.add([v]), y.set("style", g.get("style")), s.helper = y } return s.model = g, void s.trigger("update") } s.model = e, s.trigger("update") } }, addToCollection: function (t, e) { var n = e || null, i = new o({ model: t, id: this.pfx + t.get("name").replace(" ", "_").toLowerCase(), name: t.get("name"), properties: t.get("properties"), target: this.target, propTarget: this.propTarget, config: this.config }), r = i.render().el; return n ? n.appendChild(r) : this.$el.append(r), r }, render: function () { var t = document.createDocumentFragment(); return this.$el.empty(), this.collection.each(function (e) { this.addToCollection(e, t) }, this), this.$el.attr("id", this.pfx + "sectors"), this.$el.append(t), this } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; (function (e) { var i = n(0), r = n(12); t.exports = i.View.extend({ template: e.template('\n  <div class="<%= pfx %>title" data-sector-title>\n    <i id="<%= pfx %>caret" class="fa"></i>\n    <%= label %>\n  </div>'), events: { "click [data-sector-title]": "toggle" }, initialize: function (t) { this.config = t.config || {}, this.pfx = this.config.stylePrefix || "", this.target = t.target || {}, this.propTarget = t.propTarget || {}, this.caretR = "fa-caret-right", this.caretD = "fa-caret-down"; var e = this.model; this.listenTo(e, "change:open", this.updateOpen), this.listenTo(e, "updateVisibility", this.updateVisibility) }, updateVisibility: function () { var t; this.model.get("properties").each(function (e) { e.get("visible") && (t = 1) }), this.el.style.display = t ? "block" : "none" }, updateOpen: function () { this.model.get("open") ? this.show() : this.hide() }, show: function () { this.$el.addClass(this.pfx + "open"), this.getPropertiesEl().style.display = "", this.$caret.removeClass(this.caretR).addClass(this.caretD) }, hide: function () { this.$el.removeClass(this.pfx + "open"), this.getPropertiesEl().style.display = "none", this.$caret.removeClass(this.caretD).addClass(this.caretR) }, getPropertiesEl: function () { return this.$el.find("." + this.pfx + "properties").get(0) }, toggle: function (t) { var e = this.model.get("open") ? 0 : 1; this.model.set("open", e) }, render: function () { return this.$el.html(this.template({ pfx: this.pfx, label: this.model.get("name") })), this.$caret = this.$el.find("#" + this.pfx + "caret"), this.renderProperties(), this.$el.attr("class", this.pfx + "sector no-select"), this.updateOpen(), this }, renderProperties: function () { var t = this.model.get("properties"); if (t) { var e = new r({ collection: t, target: this.target, propTarget: this.propTarget, config: this.config }); this.$el.append(e.render().el) } } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; t.exports = function () { var t = {}, e = n(126), i = n(127), r = n(130), o = n(43), s = void 0, a = void 0, l = void 0; return { name: "AssetManager", storageKey: "assets", getConfig: function () { return t }, init: function (n) { var c = this; t = n || {}; for (var u in e) u in t || (t[u] = e[u]); var h = t.pStylePrefix, d = t.em; h && (t.stylePrefix = h + t.stylePrefix), s = new i([]); var f = { collection: new i([]), globalCollection: s, config: t }; return l = new o(f), f.fu = l, a = new r(f), s.listenTo(s, "add", function (t) { c.getAllVisible().add(t), d && d.trigger("asset:add", t) }), s.listenTo(s, "remove", function (t) { c.getAllVisible().remove(t), d && d.trigger("asset:remove", t) }), this }, add: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return void 0 === e.at && (e.at = 0), s.add(t, e) }, get: function (t) { return s.where({ src: t })[0] }, getAll: function () { return s }, getAllVisible: function () { return a.collection }, remove: function (t) { var e = this.get(t); return this.getAll().remove(e), this }, store: function (e) { var n = {}, i = JSON.stringify(this.getAll().toJSON()); return n[this.storageKey] = i, !e && t.stm && t.stm.store(n), n }, load: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, e = this.storageKey, n = t[e] || []; if ("string" == typeof n) try { n = JSON.parse(t[e]) } catch (t) { } return n && n.length && this.getAll().reset(n), n }, getContainer: function () { return a.el }, getAssetsEl: function () { return a.el.querySelector("[data-el=assets]") }, render: function (t) { var e = t || this.getAll().models; return a.rendered || a.render(), a.collection.reset(e), this.getContainer() }, addType: function (t, e) { this.getAll().addType(t, e) }, getType: function (t) { return this.getAll().getType(t) }, getTypes: function () { return this.getAll().getTypes() }, AssetsView: function () { return a }, FileUploader: function () { return l }, onLoad: function () { this.getAll().reset(t.assets) }, postRender: function (e) { t.dropzone && l.initDropzone(e) }, setTarget: function (t) { a.collection.target = t }, onSelect: function (t) { a.collection.onSelect = t }, onClick: function (e) { t.onClick = e }, onDblClick: function (e) { t.onDblClick = e } } } }, function (t, e, n) { "use strict"; t.exports = { assets: [], noAssets: "", stylePrefix: "am-", upload: 0, uploadName: "files", headers: {}, params: {}, autoAdd: 1, uploadText: "Drop files here or click to upload", addBtnText: "Add image", uploadFile: "", handleAdd: "", dropzone: 1, openAssetsOnDrop: 1, dropzoneContent: "", modalTitle: "Select Image", inputPlaceholder: "http://path/to/the/image.jpg" } }, function (t, e, n) { "use strict"; var i = n(30), r = function (t) { return t && t.__esModule ? t : { default: t } }(i); t.exports = n(0).Collection.extend(r.default).extend({ types: [{ id: "image", model: n(128), view: n(41), isType: function (t) { return "string" == typeof t ? { type: "image", src: t } : t } }] }) }, function (t, e, n) { "use strict"; var i = n(129); t.exports = i.extend({ defaults: Object.assign({}, i.prototype.defaults, { type: "image", unitDim: "px", height: 0, width: 0 }) }) }, function (t, e, n) { "use strict"; t.exports = n(0).Model.extend({ idAttribute: "src", defaults: { type: "", src: "" }, getFilename: function () { return this.get("src").split("/").pop() }, getExtension: function () { return this.getFilename().split(".").pop() } }) }, function (t, e, n) { "use strict"; (function (e) { n(42), n(41), n(43); t.exports = e.View.extend({ events: { submit: "handleSubmit" }, template: function (t) { var e = t.pfx, n = t.ppfx; return '\n    <div class="' + e + 'assets-cont">\n      <div class="' + e + 'assets-header">\n        <form class="' + e + 'add-asset">\n          <div class="' + n + "field " + e + 'add-field">\n            <input placeholder="' + t.config.inputPlaceholder + '"/>\n          </div>\n          <button class="' + n + 'btn-prim">' + t.config.addBtnText + '</button>\n          <div style="clear:both"></div>\n        </form>\n        <div class="' + e + 'dips" style="display:none">\n          <button class="fa fa-th <%' + n + 'btnt"></button>\n          <button class="fa fa-th-list <%' + n + 'btnt"></button>\n        </div>\n      </div>\n      <div class="' + e + 'assets" data-el="assets"></div>\n      <div style="clear:both"></div>\n    </div>\n    ' }, initialize: function (t) { this.options = t, this.config = t.config, this.pfx = this.config.stylePrefix || "", this.ppfx = this.config.pStylePrefix || ""; var e = this.collection; this.listenTo(e, "reset", this.renderAssets), this.listenTo(e, "add", this.addToAsset), this.listenTo(e, "remove", this.removedAsset), this.listenTo(e, "deselectAll", this.deselectAll) }, handleSubmit: function (t) { t.preventDefault(); var e = this.getAddInput(), n = e.value.trim(), i = this.config.handleAdd; n && (e.value = "", this.getAssetsEl().scrollTop = 0, i ? i(n) : this.options.globalCollection.add(n, { at: 0 })) }, getAssetsEl: function () { return this.el.querySelector("." + this.pfx + "assets") }, getAddInput: function () { return this.inputUrl && this.inputUrl.value || (this.inputUrl = this.el.querySelector("." + this.pfx + "add-asset input")), this.inputUrl }, removedAsset: function (t) { this.collection.length || this.toggleNoAssets() }, addToAsset: function (t) { 1 == this.collection.length && this.toggleNoAssets(1), this.addAsset(t) }, addAsset: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n = e, i = this.collection, r = this.config, o = new t.typeView({ model: t, collection: i, config: r }).render().el; if (n) n.appendChild(o); else { var s = this.getAssetsEl(); s && s.insertBefore(o, s.firstChild) } return o }, toggleNoAssets: function (t) { var e = this.$el.find("." + this.pfx + "assets"); if (t) e.empty(); else { var n = this.config.noAssets; n && e.append(n) } }, deselectAll: function () { var t = this.pfx; this.$el.find("." + t + "highlight").removeClass(t + "highlight") }, renderAssets: function () { var t = this, e = document.createDocumentFragment(), n = this.$el.find("." + this.pfx + "assets"); n.empty(), this.toggleNoAssets(this.collection.length), this.collection.each(function (n) { return t.addAsset(n, e) }), n.append(e) }, render: function () { var t = this.options.fu.render().el; return this.$el.empty(), this.$el.append(t).append(this.template(this)), this.el.className = this.ppfx + "asset-manager", this.renderAssets(), this.rendered = 1, this } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; t.exports = function () { var t, e, i = {}, r = n(132), o = n(44), s = n(133), a = n(46), l = n(134); return { Selectors: a, name: "CssComposer", storageKey: function () { var t = [], e = i.stm && i.stm.getConfig() || {}; return e.storeCss && t.push("css"), e.storeStyles && t.push("styles"), t }, init: function (n) { i = n || {}; for (var o in r) o in i || (i[o] = r[o]); var a = i.pStylePrefix; a && (i.stylePrefix = a + i.stylePrefix); var c = i.em && i.em.config.style || ""; return i.rules = c || i.rules, i.sm = i.em, t = new s([], i), e = new l({ collection: t, config: i }), this }, onLoad: function () { t.add(i.rules) }, postLoad: function (t) { t.listenRules(this.getAll()) }, load: function (e) { var n = e || ""; !n && i.stm && (n = i.em.getCacheLoad()); var r = n.styles || ""; if (n.styles) try { r = JSON.parse(n.styles) } catch (t) { } else n.css && (r = i.em.get("Parser").parseCss(n.css)); return r && t.reset(r), r }, store: function (e) { if (i.stm) { var n = {}, r = this.storageKey(); return r.indexOf("css") >= 0 && (n.css = i.em.getCss()), r.indexOf("styles") >= 0 && (n.styles = JSON.stringify(t)), e || i.stm.store(n), n } }, add: function (e, n, r, s) { var a = n || "", l = r || "", c = s || {}, u = this.get(e, a, l, c); return u || (c.state = a, c.mediaText = l, c.selectors = "", u = new o(c, i), u.get("selectors").add(e), t.add(u), u) }, get: function (e, n, i, r) { var o = null; return t.each(function (t) { o || t.compare(e, n, i, r) && (o = t) }), o }, getAll: function () { return t }, addCollection: function (t) { for (var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n = [], r = t instanceof Array ? t : [t], o = 0, s = r.length; o < s; o++) { var a = r[o] || {}; if (a.selectors) { var l = i.em && i.em.get("SelectorManager"); l || console.warn("Selector Manager not found"); for (var c = a.selectors, u = c instanceof Array ? c : [c], h = [], d = 0, f = u.length; d < f; d++) { var p = l.add(u[d]); h.push(p) } var g = this.get(h, a.state, a.mediaText, a), m = this.add(h, a.state, a.mediaText, a), v = !g || !e.avoidUpdateStyle, y = a.style || {}; if (v) { var b = e.extend ? Object.assign({}, m.get("style"), y) : y; m.set("style", b) } n.push(m) } } return n }, render: function () { return e.render().el } } } }, function (t, e, n) { "use strict"; t.exports = { stylePrefix: "css-", staticRules: "", rules: [] } }, function (t, e, n) { "use strict"; var i = n(0), r = n(44); t.exports = i.Collection.extend({ initialize: function (t, e) { e && e.sm && (this.editor = e.sm), this.model = function (t, n) { return !n.sm && e && e.sm && (n.sm = e.sm), new r(t, n) } }, add: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return "string" == typeof t && (t = this.editor.get("Parser").parseCss(t)), e.em = this.editor, i.Collection.prototype.add.apply(this, [t, e]) } }) }, function (t, e, n) { "use strict"; var i = n(0), r = n(135); t.exports = i.View.extend({ initialize: function (t) { this.config = t.config || {}, this.pfx = this.config.stylePrefix || "", this.className = this.pfx + "rules", this.listenTo(this.collection, "add", this.addTo), this.listenTo(this.collection, "reset", this.render) }, addTo: function (t) { this.addToCollection(t) }, addToCollection: function (t, e) { var n = e || null, i = r, o = new i({ model: t, config: this.config }), s = o.render().el; return n ? n.appendChild(s) : this.$el.append(s), s }, render: function () { var t = document.createDocumentFragment(); return this.$el.empty(), this.collection.each(function (e) { this.addToCollection(e, t) }, this), this.$el.append(t), this.$el.attr("class", this.className), this } }) }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.View.extend({ tagName: "style", initialize: function (t) { this.config = t.config || {}, this.listenTo(this.model, "change:style", this.render), this.listenTo(this.model, "change:state", this.render), this.listenTo(this.model, "destroy remove", this.remove), this.listenTo(this.model, "change:mediaText", this.render), this.listenTo(this.model.get("selectors"), "change", this.selChanged) }, selChanged: function () { this.selStr = this.renderSelectors(), this.render() }, renderSelectors: function () { var t = [], e = this.model, n = e.get("selectorsAdd"); e.get("selectors").each(function (e) { t.push("." + e.get("name")) }); var i = t.join(""); return i + (i && n ? ", " : "") + n }, renderProperties: function () { var t = [], e = this.model.get("style"); for (var n in e) t.push(n + ":" + e[n] + ";"); return t.join("") }, render: function () { var t = "", e = ""; this.selStr || (this.selStr = this.renderSelectors()); var n = this.renderProperties(), i = this.model.get("state"), r = this.model.get("mediaText"); return this.selStr && (i = i ? ":" + i : "", t = "" !== n ? "{" + n + "}" : ""), e = this.selStr && t ? this.selStr + i + t : "", r && e && (e = "@media " + r + "{" + e + "}"), this.$el.html(e), this } }) }, function (t, e, n) { "use strict"; var i = n(1); t.exports = function () { var t = {}, e = n(137), r = n(138), o = void 0; return { TraitsView: r, name: "TraitManager", getConfig: function () { return t }, init: function () { var n = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; t = n, (0, i.defaults)(t, e); var s = t.pStylePrefix; return s && (t.stylePrefix = "" + s + t.stylePrefix), o = new r({ collection: [], editor: t.em, config: t }), this }, getTraitsViewer: function () { return o }, addType: function (t, e) { var n = o.itemView; o.itemsView[t] = n.extend(e) }, getType: function (t) { return o.itemsView[t] } } } }, function (t, e, n) { "use strict"; t.exports = { stylePrefix: "trt-", labelContainer: "Component settings", labelPlhText: "eg. Text here", labelPlhHref: "eg. https://google.com", optionsTarget: [{ value: "", name: "This window" }, { value: "_blank", name: "New window" }] } }, function (t, e, n) { "use strict"; var i = n(47), r = n(7), o = n(139), s = n(140), a = n(141), l = n(142); t.exports = i.extend({ itemView: r, itemsView: { text: r, number: a, select: o, checkbox: s, color: l }, initialize: function (t) { this.config = t.config || {}, this.em = t.editor, this.pfx = this.config.stylePrefix || "", this.className = this.pfx + "traits", this.listenTo(this.em, "change:selectedComponent", this.updatedCollection), this.updatedCollection() }, updatedCollection: function () { this.el.className = this.className; var t = this.em.get("selectedComponent"); t && (this.collection = t.get("traits"), this.render()) } }) }, function (t, e, n) { "use strict"; (function (e, i) { var r = n(7), o = e.$; t.exports = r.extend({ initialize: function (t) { r.prototype.initialize.apply(this, arguments); var e = this.ppfx; this.tmpl = '<div class="' + this.fieldClass + '"><div class="' + this.inputhClass + '"></div><div class="' + e + 'sel-arrow"><div class="' + e + 'd-s-arrow"></div></div> </div>' }, getInputEl: function () { if (!this.$input) { var t = this.model, e = t.get("options") || [], n = "<select>"; e.length && i.each(e, function (t) { var e, i, r, o = ""; "string" == typeof t ? (e = t, i = t) : (e = t.name ? t.name : t.value, i = t.value.replace(/"/g, "&quot;"), r = t.style ? t.style.replace(/"/g, "&quot;") : "", o += r ? 'style="' + r + '"' : ""), n += '<option value="' + i + '" ' + o + ">" + e + "</option>" }), n += "</select>", this.input = n, this.$input = o(this.input); var r = this.target, s = t.get("name"), a = t.get("value"); if (t.get("changeProp")) a = a || r.get(s); else { a = r.get("attributes")[s] } a && this.$input.val(a) } return this.$input.get(0) } }) }).call(e, n(0), n(1)) }, function (t, e, n) { "use strict"; var i = n(7); t.exports = i.extend({ initialize: function (t) { i.prototype.initialize.apply(this, arguments); var e = this.ppfx + "chk-icon"; this.tmpl = '<div class="' + this.fieldClass + '"><label class="' + this.inputhClass + '"><i class="' + e + '"></i></label></div>' }, onChange: function () { this.model.set("value", this.getInputEl().checked) }, getInputEl: function () { var t; this.$input || (t = 1); for (var e = arguments.length, n = Array(e), r = 0; r < e; r++)n[r] = arguments[r]; var o = i.prototype.getInputEl.apply(this, n); if (t) { var s = this.model, a = s.get("name"), l = this.target; if (s.get("changeProp")) o.checked = l.get(a); else { var c = l.get("attributes"); o.checked = !!c[a] } } return o } }) }, function (t, e, n) { "use strict"; var i = n(7), r = n(17); t.exports = i.extend({ getValueForTarget: function () { var t = this.model, e = t.get("value"), n = t.get("unit"); return e ? e + n : "" }, getInputEl: function () { if (!this.$input) { var t = this.getModelValue(), e = new r({ contClass: this.ppfx + "field-int", model: this.model, ppfx: this.ppfx }); this.input = e.render(), this.$input = this.input.inputEl, this.$unit = this.input.unitEl, this.model.set("value", t), this.$input.val(t) } return this.$input.get(0) }, renderField: function () { this.$input || (this.$el.append(this.tmpl), this.getInputEl(), this.$el.find("." + this.inputhClass).prepend(this.input.el)) } }) }, function (t, e, n) { "use strict"; var i = n(7), r = n(37); t.exports = i.extend({ getInputEl: function () { if (!this.$input) { var t = this.getModelValue(), e = new r({ contClass: this.ppfx + "field-color", model: this.model, ppfx: this.ppfx }); this.input = e.render(), this.$input = this.input.colorEl, t = t || "", this.model.set("value", t).trigger("change:value") } return this.$input.get(0) }, renderField: function () { this.$input || (this.getInputEl(), this.$el.append(this.input.el)) } }) }, function (t, e, n) { "use strict"; t.exports = function () { var t, e, i = {}, r = n(144), o = n(3), s = n(4), a = [{ id: "cell", model: n(150), view: n(151) }, { id: "row", model: n(152), view: n(153) }, { id: "table", model: n(154), view: n(155) }, { id: "map", model: n(156), view: n(157) }, { id: "link", model: n(158), view: n(159) }, { id: "video", model: n(160), view: n(161) }, { id: "image", model: n(18), view: n(14) }, { id: "script", model: n(162), view: n(163) }, { id: "svg", model: n(164), view: n(165) }, { id: "textnode", model: n(166), view: n(167) }, { id: "text", model: n(48), view: n(49) }, { id: "default", model: o, view: s }]; return { componentTypes: a, name: "DomComponents", getConfig: function () { return i }, storageKey: function () { var t = [], e = i.stm && i.stm.getConfig() || {}; return e.storeHtml && t.push("html"), e.storeComponents && t.push("components"), t }, init: function (n) { i = n || {}; var l = i.em; l && (i.components = l.config.components || i.components); for (var c in r) c in i || (i[c] = r[c]); var u = i.pStylePrefix; u && (i.stylePrefix = u + i.stylePrefix), l && (i.modal = l.get("Modal") || "", i.am = l.get("AssetManager") || "", l.get("Parser").compTypes = a, l.on("change:selectedComponent", this.componentChanged, this)); var h = i.components, d = Object.assign({}, i.wrapper); return d["custom-name"] = i.wrapperName, d.wrapper = 1, h && h.constructor === Object && h.wrapper && (d = Object.assign({}, h), h = h.components || [], d.components = [], l && (l.config.components = h, i.components = h)), t = new o(d, { sm: l, config: i, componentTypes: a }), t.set({ attributes: { id: "wrapper" } }), e = new s({ model: t, config: i, componentTypes: a }), this }, onLoad: function () { this.getComponents().reset(i.components) }, postLoad: function (t) { t.initChildrenComp(this.getWrapper()) }, load: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", e = ""; if (!t && i.stm && (t = i.em.getCacheLoad()), t.components) try { e = JSON.parse(t.components) } catch (t) { } else t.html && (e = t.html); var n = e && e.constructor === Object; return (e && e.length || n) && (this.clear(), this.getComponents().reset(), n ? this.getWrapper().set(e).initComponents().initClasses().loadTraits() : this.getComponents().add(e)), e }, store: function (t) { if (i.stm) { var e = {}, n = this.storageKey(); if (n.indexOf("html") >= 0 && (e.html = i.em.getHtml()), n.indexOf("components") >= 0) { var r = i.storeWrapper ? this.getWrapper() : this.getComponents(); e.components = JSON.stringify(r) } return t || i.stm.store(e), e } }, getComponent: function () { return t }, getWrapper: function () { return this.getComponent() }, getComponents: function () { return this.getWrapper().get("components") }, addComponent: function (t) { return this.getComponents().add(t) }, render: function () { return e.render().el }, clear: function () { for (var t = this.getComponents(), e = 0, n = t.length; e < n; e++)t.pop(); return this }, setComponents: function (t) { this.clear().addComponent(t) }, addType: function (t, e) { var n = this.getType(t); n ? (n.model = e.model, n.view = e.view) : (e.id = t, a.unshift(e)) }, getType: function (t) { for (var e = a, n = 0; n < e.length; n++) { if (e[n].id == t) return e[n] } }, componentChanged: function () { var t = i.em, e = t.get("selectedComponent"), n = t.previous("selectedComponent"); n && n.set({ status: "", state: "" }), e && e.set("status", "selected") } } } }, function (t, e, n) { "use strict"; t.exports = { stylePrefix: "comp-", wrapperId: "wrapper", wrapperName: "Body", wrapper: { style: { margin: 0 }, removable: !1, copyable: !1, draggable: !1, components: [], traits: [], stylable: ["background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position", "background-size"] }, components: [], imageCompClass: "fa fa-picture-o", oAssetsOnCreate: !0, storeWrapper: 0, voidElements: ["area", "base", "br", "col", "embed", "hr", "img", "input", "keygen", "link", "menuitem", "meta", "param", "source", "track", "wbr"] } }, function (t, e, n) { "use strict"; (function (e) { var i = n(0); t.exports = i.Collection.extend({ initialize: function (t, e) { this.on("add", this.onAdd), this.config = e && e.config ? e.config : null, e && (e.sm || e.em) && (this.editor = e.sm || e.em), this.model = function (t, n) { var i; !n.sm && e && e.sm && (n.sm = e.sm), !n.em && e && e.em && (n.em = e.em), e && e.config && (n.config = e.config), e && e.componentTypes && (n.componentTypes = e.componentTypes); for (var r = e.componentTypes, o = 0; o < r.length; o++) { if (r[o].id == t.type) { i = r[o].model; break } } return i || (i = r[r.length - 1].model), new i(t, n) } }, add: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if ("string" == typeof t) { var n = this.editor.get("Parser").parseHtml(t); t = n.html; var r = this.editor.get("CssComposer"); if (n.css && r) { var o = e.avoidUpdateStyle; r.addCollection(n.css, { extend: 1, avoidUpdateStyle: o }) } } return i.Collection.prototype.add.apply(this, [t, e]) }, onAdd: function (t, n, i) { var r = t.get("style"), o = this.editor; if (!e.isEmpty(r) && o && o.get && o.get("Config").forceClass) { var s = this.editor.get("CssComposer"), a = this.editor.get("SelectorManager").add(t.cid); t.set({ style: {} }), t.get("classes").add(a); s.add(a).set("style", r) } } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; var i = n(1), r = n(0), o = n(147), s = n(148); t.exports = r.Collection.extend({ model: o, initialize: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this.em = e.em || "" }, setTarget: function (t) { this.target = t }, add: function (t, e) { var n = this.em; if ((0, i.isString)(t) || (0, i.isArray)(t)) { var o = n && n.get && n.get("TraitManager"), a = o && o.getConfig(), l = s(a); (0, i.isString)(t) && (t = [t]); for (var c = 0, u = t.length; c < u; c++) { var h = t[c], d = (0, i.isString)(h) ? l.build(h)[0] : h; d.target = this.target, t[c] = d } } return r.Collection.prototype.add.apply(this, [t, e]) } }) }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.Model.extend({ defaults: { type: "text", label: "", name: "", min: "", max: "", value: "", target: "", default: "", placeholder: "", changeProp: 0, options: [] }, initialize: function () { this.get("target") && (this.target = this.get("target"), this.unset("target")) }, getInitValue: function () { var t = this.target, e = this.get("name"), n = void 0; if (t) { var i = t.get("attributes"); n = this.get("changeProp") ? t.get(e) : i[e] } return n || this.get("value") || this.get("default") } }) }, function (t, e, n) { "use strict"; t.exports = function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return { build: function (e) { var n = []; "string" == typeof e && (e = [e]); for (var i = 0; i < e.length; i++) { var r = {}, o = e[i]; switch (r.name = o, o) { case "target": r.type = "select" }switch (o) { case "title": case "alt": case "id": r.placeholder = t.labelPlhText; break; case "href": r.placeholder = t.labelPlhHref }switch (o) { case "target": r.options = t.optionsTarget }n.push(r) } return n } } } }, function (t, e, n) { "use strict"; (function (e) { var i = n(1); t.exports = e.View.extend({ initialize: function (t) { this.opts = t || {}, this.config = t.config || {}; var e = this.collection; this.listenTo(e, "add", this.addTo), this.listenTo(e, "reset", this.resetChildren) }, addTo: function (t) { var e = this.collection.indexOf(t); this.addToCollection(t, null, e); var n = this.config.em; n && (n.trigger("add:component", t), n.trigger("component:add", t)) }, addToCollection: function (t, e, r) { this.compView || (this.compView = n(4)); for (var o = e || null, s = this.compView, a = this.opts.componentTypes, l = t.get("type"), c = 0; c < a.length; c++) { if (a[c].id == l) { s = a[c].view; break } } var u = new s({ model: t, config: this.config, componentTypes: a }), h = u.render().el; if ("textnode" == u.model.get("type") && (h = document.createTextNode(u.model.get("content"))), o) o.appendChild(h); else { var d = this.parentEl, f = d.childNodes; if ((0, i.isUndefined)(r)) d.appendChild(h); else { var p = f.length == r; p && r-- , p || !f.length ? d.appendChild(h) : d.insertBefore(h, f[r]) } } return h }, resetChildren: function () { var t = this; this.parentEl.innerHTML = "", this.collection.each(function (e) { return t.addToCollection(e) }) }, render: function (t) { var e = this, n = this.el, i = document.createDocumentFragment(); return this.parentEl = t || this.el, this.collection.each(function (t) { return e.addToCollection(t, i) }), n.innerHTML = "", n.appendChild(i), this } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; (function (e) { var i = n(3); t.exports = i.extend({ defaults: e.extend({}, i.prototype.defaults, { type: "cell", tagName: "td", draggable: ["tr"] }) }, { isComponent: function (t) { var e = "", n = t.tagName; return "TD" != n && "TH" != n || (e = { type: "cell", tagName: n.toLowerCase() }), e } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; var i = (n(0), n(4)); t.exports = i.extend({}) }, function (t, e, n) { "use strict"; (function (e) { var i = n(3); t.exports = i.extend({ defaults: e.extend({}, i.prototype.defaults, { type: "row", tagName: "tr", draggable: ["table", "tbody", "thead"], droppable: ["th", "td"] }), initialize: function (t, e) { i.prototype.initialize.apply(this, arguments); var n = [], r = this.get("components"); r.each(function (t) { "cell" == t.get("type") && n.push(t) }), r.reset(n) } }, { isComponent: function (t) { var e = ""; return "TR" == t.tagName && (e = { type: "row" }), e } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; var i = (n(0), n(4)); t.exports = i.extend({}) }, function (t, e, n) { "use strict"; (function (e) { var i = n(3); t.exports = i.extend({ defaults: e.extend({}, i.prototype.defaults, { type: "table", tagName: "table", droppable: ["tr", "tbody", "thead", "tfoot"], columns: 3, rows: 2 }), initialize: function (t, e) { i.prototype.initialize.apply(this, arguments); var n = this.get("components"), r = this.get("rows"), o = this.get("columns"); if (!n.length) { for (var s = []; r--;) { for (var a = [], l = o; l--;)a.push({ type: "cell", classes: ["cell"] }); s.push({ type: "row", classes: ["row"], components: a }) } n.add(s) } var c = []; n.each(function (t) { "row" != t.get("type") ? t.get("components").each(function (t) { "row" == t.get("type") && (t.collection = n, c.push(t)) }) : c.push(t) }), n.reset(c) } }, { isComponent: function (t) { var e = ""; return "TABLE" == t.tagName && (e = { type: "table" }), e } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; var i = (n(0), n(4)); t.exports = i.extend({ events: {} }) }, function (t, e, n) { "use strict"; (function (e) { var i = n(18), r = n(3); t.exports = i.extend({ defaults: e.extend({}, i.prototype.defaults, { type: "map", void: 0, mapUrl: "https://maps.google.com/maps", tagName: "iframe", mapType: "q", address: "", zoom: "1", attributes: { frameborder: 0 }, toolbar: r.prototype.defaults.toolbar, traits: [{ label: "Address", name: "address", placeholder: "eg. London, UK", changeProp: 1 }, { type: "select", label: "Map type", name: "mapType", changeProp: 1, options: [{ value: "q", name: "Roadmap" }, { value: "w", name: "Satellite" }] }, { label: "Zoom", name: "zoom", type: "range", min: "1", max: "20", changeProp: 1 }] }), initialize: function (t, e) { this.get("src") ? this.parseFromSrc() : this.updateSrc(), i.prototype.initialize.apply(this, arguments), this.listenTo(this, "change:address change:zoom change:mapType", this.updateSrc) }, updateSrc: function () { this.set("src", this.getMapUrl()) }, getMapUrl: function () { var t = this, e = t.get("address"), n = t.get("zoom"), i = t.get("mapType"); e = e ? "&q=" + e : "", n = n ? "&z=" + n : "", i = i ? "&t=" + i : ""; var r = t.get("mapUrl") + "?" + e + n + i; return r += "&output=embed" }, parseFromSrc: function () { var t = this.parseUri(this.get("src")), e = t.query; e.q && this.set("address", e.q), e.z && this.set("zoom", e.z), e.t && this.set("mapType", e.t) } }, { isComponent: function (t) { var e = ""; return "IFRAME" == t.tagName && /maps\.google\.com/.test(t.src) && (e = { type: "map", src: t.src }), e } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; var i = (n(0), n(14)); t.exports = i.extend({ tagName: "div", events: {}, initialize: function (t) { i.prototype.initialize.apply(this, arguments), this.classEmpty = this.ppfx + "plh-map" }, updateSrc: function () { this.getIframe().src = this.model.get("src") }, getIframe: function () { if (!this.iframe) { var t = document.createElement("iframe"); t.src = this.model.get("src"), t.frameBorder = 0, t.style.height = "100%", t.style.width = "100%", t.className = this.ppfx + "no-pointer", this.iframe = t } return this.iframe }, render: function () { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return i.prototype.render.apply(this, e), this.updateClasses(), this.el.appendChild(this.getIframe()), this } }) }, function (t, e, n) { "use strict"; var i = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, r = n(48); t.exports = r.extend({ defaults: i({}, r.prototype.defaults, { type: "link", tagName: "a", traits: ["title", "href", "target"] }), getAttrToHTML: function () { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; var i = r.prototype.getAttrToHTML.apply(this, e); return delete i.onmousedown, i } }, { isComponent: function (t) { var e = void 0; if ("A" == t.tagName) { e = { type: "link", editable: 0 }; var n = t.childNodes, i = n.length; i || delete e.editable; for (var r = 0; r < i; r++) { var o = n[r]; if (3 == o.nodeType && "" != o.textContent.trim()) { delete e.editable; break } } } return e } }) }, function (t, e, n) { "use strict"; var i = (n(0), n(49)); t.exports = i.extend({ events: { dblclick: "enableEditing" }, render: function () { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return i.prototype.render.apply(this, e), this.el.addEventListener("click", this.prevDef, !0), this } }) }, function (t, e, n) { "use strict"; (function (e) { var i = n(18), r = n(3), o = "yt", s = "vi"; t.exports = i.extend({ defaults: e.extend({}, i.prototype.defaults, { type: "video", tagName: "video", videoId: "", void: 0, provider: "", ytUrl: "https://www.youtube.com/embed/", viUrl: "https://player.vimeo.com/video/", loop: 0, muted: 0, autoplay: 0, controls: 1, color: "", sources: [], attributes: { allowfullscreen: "allowfullscreen" }, toolbar: r.prototype.defaults.toolbar }), initialize: function (t, e) { var n = []; switch (this.get("provider")) { case o: n = this.getYoutubeTraits(); break; case s: n = this.getVimeoTraits(); break; default: n = this.getSourceTraits() }this.get("src") && this.parseFromSrc(), this.set("traits", n), i.prototype.initialize.apply(this, arguments), this.listenTo(this, "change:provider", this.updateTraits), this.listenTo(this, "change:videoId", this.updateSrc) }, parseFromSrc: function () { var t = this.get("provider"), e = this.parseUri(this.get("src")), n = e.query; switch (t) { case o: case s: var i = e.pathname.split("/").pop(); this.set("videoId", i), n.autoplay && this.set("autoplay", 1), n.loop && this.set("loop", 1), 0 === parseInt(n.controls) && this.set("controls", 0), n.color && this.set("color", n.color) } }, updateSrc: function () { switch (this.get("provider")) { case o: this.set("src", this.getYoutubeSrc()); break; case s: this.set("src", this.getVimeoSrc()) } }, getAttrToHTML: function () { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; var r = i.prototype.getAttrToHTML.apply(this, e); switch (this.get("provider")) { case o: case s: break; default: this.get("loop") && (r.loop = "loop"), this.get("autoplay") && (r.autoplay = "autoplay"), this.get("controls") && (r.controls = "controls") }return r }, updateTraits: function () { var t = this.get("provider"), e = this.getSourceTraits(); switch (t) { case o: this.set("tagName", "iframe"), e = this.getYoutubeTraits(); break; case s: this.set("tagName", "iframe"), e = this.getVimeoTraits(); break; default: this.set("tagName", "video") }this.loadTraits(e), this.sm.trigger("change:selectedComponent") }, getProviderTrait: function () { return { type: "select", label: "Provider", name: "provider", changeProp: 1, value: this.get("provider"), options: [{ value: "so", name: "HTML5 Source" }, { value: o, name: "Youtube" }, { value: s, name: "Vimeo" }] } }, getSourceTraits: function () { return [this.getProviderTrait(), { label: "Source", name: "src", placeholder: "eg. ./media/video.mp4", changeProp: 1 }, this.getAutoplayTrait(), this.getLoopTrait(), this.getControlsTrait()] }, getYoutubeTraits: function () { return [this.getProviderTrait(), { label: "Video ID", name: "videoId", placeholder: "eg. jNQXAC9IVRw", changeProp: 1 }, this.getAutoplayTrait(), this.getLoopTrait(), this.getControlsTrait()] }, getVimeoTraits: function () { return [this.getProviderTrait(), { label: "Video ID", name: "videoId", placeholder: "eg. 123456789", changeProp: 1 }, { label: "Color", name: "color", placeholder: "eg. FF0000", changeProp: 1 }, this.getAutoplayTrait(), this.getLoopTrait(), this.getControlsTrait()] }, getAutoplayTrait: function () { return { type: "checkbox", label: "Autoplay", name: "autoplay", changeProp: 1 } }, getLoopTrait: function () { return { type: "checkbox", label: "Loop", name: "loop", changeProp: 1 } }, getControlsTrait: function () { return { type: "checkbox", label: "Controls", name: "controls", changeProp: 1 } }, getYoutubeSrc: function () { var t = this.get("ytUrl"); return t += this.get("videoId") + "?", t += this.get("autoplay") ? "&autoplay=1" : "", t += this.get("controls") ? "" : "&controls=0", t += this.get("loop") ? "&loop=1" : "" }, getVimeoSrc: function () { var t = this.get("viUrl"); return t += this.get("videoId") + "?", t += this.get("autoplay") ? "&autoplay=1" : "", t += this.get("loop") ? "&loop=1" : "", t += this.get("controls") ? "" : "&title=0&portrait=0&badge=0", t += this.get("color") ? "&color=" + this.get("color") : "" } }, { isComponent: function (t) { var e = "", n = /youtube\.com\/embed/.test(t.src), i = /player\.vimeo\.com\/video/.test(t.src), r = n || i; return ("VIDEO" == t.tagName || "IFRAME" == t.tagName && r) && (e = { type: "video" }, t.src && (e.src = t.src), r && (n ? e.provider = o : i && (e.provider = s))), e } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; var i = (n(0), n(14)); t.exports = i.extend({ tagName: "div", events: {}, initialize: function (t) { i.prototype.initialize.apply(this, arguments), this.listenTo(this.model, "change:loop change:autoplay change:controls change:color", this.updateVideo), this.listenTo(this.model, "change:provider", this.updateProvider) }, updateProvider: function () { var t = this.model.get("provider"); this.el.innerHTML = "", this.el.appendChild(this.renderByProvider(t)) }, updateSrc: function () { var t = this.model.get("provider"), e = this.model.get("src"); switch (t) { case "yt": e = this.model.getYoutubeSrc(); break; case "vi": e = this.model.getVimeoSrc() }this.videoEl.src = e }, updateVideo: function () { var t = this.model.get("provider"), e = this.videoEl, n = this.model; switch (t) { case "yt": case "vi": this.model.trigger("change:videoId"); break; default: e.loop = n.get("loop"), e.autoplay = n.get("autoplay"), e.controls = n.get("controls") } }, renderByProvider: function (t) { var e; switch (t) { case "yt": e = this.renderYoutube(); break; case "vi": e = this.renderVimeo(); break; default: e = this.renderSource() }return this.videoEl = e, e }, renderSource: function () { var t = document.createElement("video"); return t.src = this.model.get("src"), this.initVideoEl(t), t }, renderYoutube: function () { var t = document.createElement("iframe"); return t.src = this.model.getYoutubeSrc(), t.frameBorder = 0, t.setAttribute("allowfullscreen", !0), this.initVideoEl(t), t }, renderVimeo: function () { var t = document.createElement("iframe"); return t.src = this.model.getVimeoSrc(), t.frameBorder = 0, t.setAttribute("allowfullscreen", !0), this.initVideoEl(t), t }, initVideoEl: function (t) { t.className = this.ppfx + "no-pointer", t.style.height = "100%", t.style.width = "100%" }, render: function () { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; i.prototype.render.apply(this, e), this.updateClasses(); var r = this.model.get("provider"); return this.el.appendChild(this.renderByProvider(r)), this } }) }, function (t, e, n) { "use strict"; (function (e) { var i = n(3); t.exports = i.extend({ defaults: e.extend({}, i.prototype.defaults, { type: "script", droppable: !1, draggable: !1, layerable: !1 }) }, { isComponent: function (t) { if ("SCRIPT" == t.tagName) { var e = { type: "script" }; return t.src && (e.src = t.src, e.onload = t.onload), e } } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; var i = (n(0), n(14)); t.exports = i.extend({ tagName: "script", events: {}, render: function () { var t = this.model, e = t.get("src"), n = this.em, i = n && n.get("scriptCount") ? n.get("scriptCount") : 0, r = ""; if (e) { var o = t.get("onload"), s = "script" + i, a = "script" + (i + 1); r = "var " + s + " = document.createElement('script');\n" + s + ".onload = function(){\n" + (o ? o + "();\n" : "") + "typeof " + a + "Start == 'function' && " + a + "Start();\n};\n" + s + ".src = '" + e + "';\nfunction " + s + "Start() { document.body.appendChild(" + s + "); };\n" + (i ? "" : s + "Start();"), n && n.set("scriptCount", i + 1) } else r = t.get("content"); return this.el.innerHTML = r, this } }) }, function (t, e, n) { "use strict"; var i = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]) } return t }, r = n(3); t.exports = r.extend({ defaults: i({}, r.prototype.defaults, { highlightable: 0 }), getName: function () { var t = this.get("tagName"), e = this.get("custom-name"); return t = t.charAt(0).toUpperCase() + t.slice(1), e || t } }, { isComponent: function (t) { if (SVGElement && t instanceof SVGElement) { var e = t.tagName; return { tagName: e, type: "svg", resizable: "svg" == e } } } }) }, function (t, e, n) { "use strict"; var i = n(4); t.exports = i.extend({ _createElement: function (t) { return document.createElementNS("http://www.w3.org/2000/svg", t) } }) }, function (t, e, n) { "use strict"; (function (e) { var i = n(3); t.exports = i.extend({ defaults: e.extend({}, i.prototype.defaults, { droppable: !1, editable: !0 }), toHTML: function () { return this.get("content") } }, { isComponent: function (t) { var e = ""; return 3 === t.nodeType && (e = { type: "textnode", content: t.textContent }), e } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.View.extend({}) }, function (t, e, n) { "use strict"; var i = n(2); t.exports = function () { var t, e, r = {}, o = n(169), s = n(170), a = n(172); return { getCanvasView: function () { return a }, name: "Canvas", init: function (e) { r = e || {}; for (var n in o) n in r || (r[n] = o[n]); var i = r.pStylePrefix; i && (r.stylePrefix = i + r.stylePrefix), t = new s(e), a = new a({ model: t, config: r }); var l = r.em.get("DomComponents"); return l && this.setWrapper(l), this.startAutoscroll = this.startAutoscroll.bind(this), this.stopAutoscroll = this.stopAutoscroll.bind(this), this.autoscroll = this.autoscroll.bind(this), this }, getConfig: function () { return r }, setWrapper: function (e) { t.set("wrapper", e) }, getElement: function () { return a.el }, getFrameEl: function () { return a.frame.el }, getBody: function () { return a.frame.el.contentDocument.body }, getWrapperEl: function () { return this.getBody().querySelector("#wrapper") }, getToolsEl: function () { return a.toolsEl }, getHighlighter: function () { return a.hlEl }, getBadgeEl: function () { return a.badgeEl }, getPlacerEl: function () { return a.placerEl }, getGhostEl: function () { return a.ghostEl }, getToolbarEl: function () { return a.toolbarEl }, getResizerEl: function () { return a.resizerEl }, getOffsetViewerEl: function () { return a.offsetEl }, getFixedOffsetViewerEl: function () { return a.fixedOffsetEl }, render: function () { return a.render().el }, getOffset: function () { var t = this.offset(this.getFrameEl()), e = this.offset(this.getElement()); return { top: t.top - e.top, left: t.left - e.left } }, offset: function (t) { return a.offset(t) }, setCustomBadgeLabel: function (t) { r.customBadgeLabel = t }, getElementPos: function (t, e) { return a.getElementPos(t, e) }, getTargetToElementDim: function (t, e, n) { var i = n || {}, o = a.getPosition(), s = i.elPos || a.getElementPos(e), l = n.toRight || 0, c = i.targetHeight || t.offsetHeight, u = i.targetWidth || t.offsetWidth, h = i.event || null, d = s.top - c, f = s.left; f += l ? s.width : 0, f = l ? f - u : f; var p = f < o.left ? o.left : f, g = d < o.top ? o.top : d; g = g > s.top + s.height ? s.top + s.height : g; var m = { top: g, left: p, elementTop: s.top, elementLeft: s.left, elementWidth: s.width, elementHeight: s.height, targetWidth: t.offsetWidth, targetHeight: t.offsetHeight, canvasTop: o.top, canvasLeft: o.left }; return h && r.em && r.em.trigger(h, m), m }, getMouseRelativePos: function (t, e) { var n = e || {}, i = 0, r = 0, o = n.subWinOffset, s = t.target.ownerDocument, a = s.defaultView || s.parentWindow, l = a.frameElement, c = o ? a.pageYOffset : 0, u = o ? a.pageXOffset : 0; if (l) { var h = l.getBoundingClientRect(); i = h.top || 0, r = h.left || 0 } return { y: t.clientY + i - c, x: t.clientX + r - u } }, getMouseRelativeCanvas: function (t, e) { var n = this.getFrameEl(), i = this.getBody(), r = n.offsetTop || 0, o = n.offsetLeft || 0, s = i.scrollTop || 0, a = i.scrollLeft || 0; return { y: t.clientY + r + s, x: t.clientX + o + a } }, isInputFocused: function () { return "BODY" !== this.getFrameEl().contentDocument.activeElement.tagName }, startAutoscroll: function () { this.dragging = 1; var t = this.getScrollListeners(); e = a.getFrameOffset(1), (0, i.on)(t, "mousemove", this.autoscroll), (0, i.on)(t, "mouseup", this.stopAutoscroll) }, autoscroll: function (t) { if (t.preventDefault(), this.dragging) { var n = this.getFrameEl().contentWindow, i = n.document.body.scrollTop, r = i, o = t.clientY, s = e.height - 50; o < 50 && (r -= 50 - o), o > s && (r += o - s), n.scrollTo(0, r) } }, stopAutoscroll: function () { this.dragging = 0; var t = this.getScrollListeners(); (0, i.off)(t, "mousemove", this.autoscroll), (0, i.off)(t, "mouseup", this.stopAutoscroll) }, getScrollListeners: function () { return [this.getFrameEl().contentWindow, this.getElement()] }, getFrameWrapperEl: function () { return a.frame.getWrapper() } } } }, function (t, e, n) { "use strict"; t.exports = { stylePrefix: "cv-", rulers: !1, scripts: [], styles: [], customBadgeLabel: "" } }, function (t, e, n) { "use strict"; var i = n(0), r = n(171); t.exports = i.Model.extend({ defaults: { frame: "", wrapper: "", rulers: !1 }, initialize: function (t) { var e = this.conf || {}; this.set("frame", new r(e.frame)) } }) }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.Model.extend({ defaults: { wrapper: "", width: "", height: "", attributes: {} } }) }, function (t, e, n) { "use strict"; (function (e, i) { var r = n(173), o = e.$; t.exports = e.View.extend({ initialize: function (t) { i.bindAll(this, "renderBody", "onFrameScroll", "clearOff"), this.config = t.config || {}, this.em = this.config.em || {}, this.ppfx = this.config.pStylePrefix || "", this.className = this.config.stylePrefix + "canvas", this.listenTo(this.em, "change:canvasOffset", this.clearOff), this.frame = new r({ model: this.model.get("frame"), config: this.config }) }, isElInViewport: function (t) { var e = t.getBoundingClientRect(), n = this.getFrameOffset(1), i = e.top, r = e.left; return i >= 0 && r >= 0 && i <= n.height && r <= n.width }, onFrameScroll: function () { var t = this.frame.el.contentDocument.body; this.toolsEl.style.top = "-" + t.scrollTop + "px", this.toolsEl.style.left = "-" + t.scrollLeft + "px", this.em.trigger("canvasScroll") }, renderScripts: function () { var t = this.frame, e = this; t.el.onload = function () { function n(i) { if (i.length > 0) { var r = document.createElement("script"); r.type = "text/javascript", r.src = i.shift(), r.onerror = r.onload = n.bind(null, i), t.el.contentDocument.head.appendChild(r) } else e.renderBody() } var i = e.config.scripts.slice(0); n(i) } }, renderBody: function () { var t = this.model.get("frame").get("wrapper"), e = this.config.em; if (t) { var n = this.ppfx, i = o(this.frame.el.contentWindow.document.body), r = e.get("CssComposer"), s = e.get("Config"), a = this.config, l = s.protectedCss, c = ""; a.styles.forEach(function (t) { c += '<link rel="stylesheet" href="' + t + '"/>' }); var u = "\n        \n        * {\n          box-sizing: border-box;\n        }\n        html, body, #wrapper {\n          min-height: 100%;\n        }\n        body {\n          margin: 0;\n          height: 100%;\n          background-color: #fff\n        }\n        #wrapper {\n          overflow: auto\n        }\n      \n\n        ." + n + "dashed *[data-highlightable] {\n          outline: 1px dashed rgba(170,170,170,0.7);\n          outline-offset: -3px\n        }\n\n        ." + n + "comp-selected {\n          outline: 3px solid #3b97e3 !important;\n        }\n\n        ." + n + "comp-selected-parent {\n          outline: 2px solid #ffca6f !important\n        }\n\n        ." + n + "no-select {\n          user-select: none;\n          -webkit-user-select:none;\n          -moz-user-select: none;\n        }\n\n        ." + n + "freezed {\n          opacity: 0.5;\n          pointer-events: none;\n        }\n\n        ." + n + "no-pointer {\n          pointer-events: none;\n        }\n\n        ." + n + "plh-image {\n          background: #f5f5f5;\n          border: none;\n          height: 50px;\n          width: 50px;\n          display: block;\n          outline: 3px solid #ffca6f;\n          cursor: pointer;\n          outline-offset: -2px\n        }\n\n        ." + n + "grabbing {\n          cursor: grabbing;\n          cursor: -webkit-grabbing;\n        }\n\n        * ::-webkit-scrollbar-track {\n          background: rgba(0, 0, 0, 0.1)\n        }\n\n        * ::-webkit-scrollbar-thumb {\n          background: rgba(255, 255, 255, 0.2)\n        }\n\n        * ::-webkit-scrollbar {\n          width: 10px\n        }\n\n        " + (s.canvasCss || "") + "\n        " + (l || "") + "\n      "; c && i.append(c), i.append("<style>" + u + "</style>"), i.append(t.render()).append(r.render()), i.append(this.getJsContainer()), e.trigger("loaded"), this.frame.el.contentWindow.onscroll = this.onFrameScroll, this.frame.udpateOffset(); var h = document, d = this.frame.el.contentDocument, f = function (t) { var e = new KeyboardEvent(t.type, t); return e.keyCodeVal = t.keyCode, ["keyCode", "which"].forEach(function (t) { Object.defineProperty(e, t, { get: function () { return this.keyCodeVal } }) }), e }; d.addEventListener("keydown", function (t) { h.dispatchEvent(f(t)) }), d.addEventListener("keyup", function (t) { h.dispatchEvent(f(t)) }) } }, offset: function (t) { var e = t.getBoundingClientRect(), n = t.ownerDocument.body; return { top: e.top + n.scrollTop, left: e.left + n.scrollLeft, width: e.width, height: e.height } }, clearOff: function () { this.frmOff = null, this.cvsOff = null }, getFrameOffset: function () { var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0; return this.frmOff && !t || (this.frmOff = this.offset(this.frame.el)), this.frmOff }, getCanvasOffset: function () { return this.cvsOff || (this.cvsOff = this.offset(this.el)), this.cvsOff }, getElementPos: function (t, e) { var n = e || {}, i = this.getFrameOffset(), r = this.getCanvasOffset(), o = this.offset(t), s = n.avoidFrameOffset ? 0 : i.top, a = n.avoidFrameOffset ? 0 : i.left; return { top: o.top + s - r.top, left: o.left + a - r.left, height: t.offsetHeight || t.clientHeight, width: t.offsetWidth || t.clientWidth } }, getPosition: function () { var t = this.frame.el.contentDocument.body, e = this.getFrameOffset(), n = this.getCanvasOffset(); return { top: e.top + t.scrollTop - n.top, left: e.left + t.scrollLeft - n.left } }, updateScript: function (t) { t.scriptContainer || (t.scriptContainer = o("<div>"), this.getJsContainer().append(t.scriptContainer.get(0))); var e = t.model, n = e.getId(); t.el.id = n, t.scriptContainer.html(""); var i = document.createElement("script"); i.innerText = "\n        setTimeout(function() {\n          var item = document.getElementById('" + n + "');\n          if (!item) return;\n          (function(){" + e.getScriptString() + "}.bind(item))()\n        }, 1);", t.scriptContainer.get(0).appendChild(i) }, getJsContainer: function () { return this.jsContainer || (this.jsContainer = o('<div class="' + this.ppfx + 'js-cont">').get(0)), this.jsContainer }, render: function () { if (this.wrapper = this.model.get("wrapper"), this.wrapper && "function" == typeof this.wrapper.render) { this.model.get("frame").set("wrapper", this.wrapper), this.$el.append(this.frame.render().el); var t = this.frame; 0 === this.config.scripts.length ? t.el.onload = this.renderBody : this.renderScripts() } var e = this.ppfx; this.$el.append('\n      <div id="' + e + 'tools" style="pointer-events:none">\n        <div class="' + e + 'highlighter"></div>\n        <div class="' + e + 'badge"></div>\n        <div class="' + e + 'placeholder">\n          <div class="' + e + 'placeholder-int"></div>\n        </div>\n        <div class="' + e + 'ghost"></div>\n        <div class="' + e + 'toolbar" style="pointer-events:all"></div>\n        <div class="' + e + 'resizer"></div>\n        <div class="' + e + 'offset-v"></div>\n        <div class="' + e + 'offset-fixed-v"></div>\n      </div>\n    '); var n = this.el, i = n.querySelector("#" + e + "tools"); return this.hlEl = n.querySelector("." + e + "highlighter"), this.badgeEl = n.querySelector("." + e + "badge"), this.placerEl = n.querySelector("." + e + "placeholder"), this.ghostEl = n.querySelector("." + e + "ghost"), this.toolbarEl = n.querySelector("." + e + "toolbar"), this.resizerEl = n.querySelector("." + e + "resizer"), this.offsetEl = n.querySelector("." + e + "offset-v"), this.fixedOffsetEl = n.querySelector("." + e + "offset-fixed-v"), this.toolsEl = i, this.el.className = this.className, this } }) }).call(e, n(0), n(1)) }, function (t, e, n) { "use strict"; (function (e) { var i = n(0); t.exports = i.View.extend({ tagName: "iframe", attributes: { src: "about:blank", allowfullscreen: "allowfullscreen" }, initialize: function (t) { e.bindAll(this, "udpateOffset"), this.config = t.config || {}, this.ppfx = this.config.pStylePrefix || "", this.em = this.config.em, this.motionsEv = "transitionend oTransitionEnd transitionend webkitTransitionEnd", this.listenTo(this.em, "change:device", this.updateWidth) }, updateWidth: function (t) { var e = this.em.getDeviceModel(); this.el.style.width = e ? e.get("width") : "", this.udpateOffset(), this.$el.on(this.motionsEv, this.udpateOffset) }, udpateOffset: function () { var t = this.em.get("Canvas").getOffset(); this.em.set("canvasOffset", t), this.$el.off(this.motionsEv, this.udpateOffset) }, getBody: function () { this.$el.contents().find("body") }, getWrapper: function () { return this.$el.contents().find("body > div") }, render: function () { return this.$el.attr({ class: this.ppfx + "frame" }), this } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; t.exports = function () { var t = {}, e = {}, i = {}, r = n(175), o = n(176), s = function (t, n) { return delete n.initialize, e[t] = o.extend(n), this }; return { name: "Commands", init: function (e) { t = e || {}; for (var o in r) o in t || (t[o] = r[o]); var s = t.pStylePrefix; s && (t.stylePrefix = s + t.stylePrefix); for (var a in t.defaults) { var l = t.defaults[a]; l.id && this.add(l.id, l) } return i["select-comp"] = n(19), i["create-comp"] = n(20), i["delete-comp"] = n(181), i["image-comp"] = n(182), i["move-comp"] = n(183), i["text-comp"] = n(184), i["insert-custom"] = n(52), i["export-template"] = n(185), i["sw-visibility"] = n(186), i["open-layers"] = n(187), i["open-sm"] = n(190), i["open-tm"] = n(191), i["open-blocks"] = n(192), i["open-assets"] = n(193), i["show-offset"] = n(194), i["select-parent"] = n(195), i.fullscreen = n(196), i.preview = n(197), i.resize = n(198), i.drag = n(199), i["tlb-delete"] = { run: function (t) { var e = t.getSelected(); if (!e || !e.get("removable")) return void console.warn("The element is not removable"); t.select(null), e.destroy() } }, i["tlb-clone"] = { run: function (t) { var e = t.getSelected(); if (!e || !e.get("copyable")) return void console.warn("The element is not clonable"); var n = e.collection, i = n.indexOf(e); n.add(e.clone(), { at: i + 1 }), t.trigger("component:update", e) } }, i["tlb-move"] = { run: function (t, e, n) { var i, r = t.getSelected(); if (!r || !r.get("draggable")) return void console.warn("The element is not draggable"); var o = function (t, e) { console.log("start mouse pos ", e.start), console.log("el rect ", e.elRect); var n = e.el; n.style.position = "absolute", n.style.margin = 0 }, s = function (e, n) { l.runDefault(), l.set("selectedComponent", r), t.trigger("component:update", r), i && i.blur() }, a = function (t, e) { console.log("Delta ", e.delta), console.log("Current ", e.current) }; t.Canvas.getToolbarEl().style.display = "none"; var l = t.getModel(); if (l.stopDefault(), l.get("designerMode")) i = editor.runCommand("drag", { el: r.view.el, options: { event: n && n.event, onStart: o, onDrag: a, onEnd: s } }); else { var c = t.Commands.get("move-comp"); c.onEndMoveFromModel = s, c.initSorterFromModel(r) } r.set("status", "selected") } }, t.em && (t.model = t.em.get("Canvas")), this.loadDefaultCommands(), this }, add: s, get: function (n) { var i = e[n]; return "function" == typeof i && (i = new i(t), e[n] = i), i }, has: function (t) { return !!e[t] }, loadDefaultCommands: function () { for (var t in i) this.add(t, i[t]); return this } } } }, function (t, e, n) { "use strict"; t.exports = { ESCAPE_KEY: 27, stylePrefix: "com-", defaults: [], em: null, firstCentered: !0, newFixedH: !1, minComponentH: 50, minComponentW: 50 } }, function (t, e, n) { "use strict"; (function (e) { var n = e.$; t.exports = e.View.extend({ initialize: function (t) { this.config = t || {}, this.editorModel = this.em = this.config.em || {}, this.pfx = this.config.stylePrefix, this.ppfx = this.config.pStylePrefix, this.hoverClass = this.pfx + "hover", this.badgeClass = this.pfx + "badge", this.plhClass = this.pfx + "placeholder", this.freezClass = this.ppfx + "freezed", this.canvas = this.em.get && this.em.get("Canvas"), this.em.get && this.setElement(this.getCanvas()), this.canvas && (this.$canvas = this.$el, this.$wrapper = n(this.getCanvasWrapper()), this.frameEl = this.canvas.getFrameEl(), this.canvasTool = this.getCanvasTools(), this.bodyEl = this.getCanvasBody()), this.init(this.config) }, onFrameScroll: function (t) { }, getCanvas: function () { return this.canvas.getElement() }, getCanvasBody: function () { return this.canvas.getBody() }, getCanvasWrapper: function () { return this.canvas.getWrapperEl() }, getCanvasTools: function () { return this.canvas.getToolsEl() }, offset: function (t) { var e = t.getBoundingClientRect(); return { top: e.top + t.ownerDocument.body.scrollTop, left: e.left + t.ownerDocument.body.scrollLeft } }, init: function (t) { }, run: function (t, e) { }, stop: function (t, e) { } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; var i = (n(0), n(47)), r = n(178); t.exports = i.extend({ itemView: r, initialize: function (t) { this.config = { editor: t.editor || "" }, this.listenTo(this.collection, "reset", this.render) } }) }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.View.extend({ events: { mousedown: "handleClick" }, attributes: function () { return this.model.get("attributes") }, initialize: function (t) { this.editor = t.config.editor }, handleClick: function (t) { t.preventDefault(), t.stopPropagation(); var e = { event: t }, n = this.model.get("command"), i = this.editor; "function" == typeof n && n(i, null, e), "string" == typeof n && i.runCommand(n, e) }, render: function () { var t = this.editor.getConfig(); return this.el.className += " " + t.stylePrefix + "toolbar-item", this } }) }, function (t, e, n) { "use strict"; var i = n(0), r = n(180); t.exports = i.Collection.extend({ model: r }) }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.Model.extend({ defaults: { command: "", attributes: {} } }) }, function (t, e, n) { "use strict"; (function (e, i) { var r = n(19), o = e.$; t.exports = i.extend({}, r, { init: function (t) { i.bindAll(this, "startDelete", "stopDelete", "onDelete"), this.hoverClass = this.pfx + "hover-delete", this.badgeClass = this.pfx + "badge-red" }, enable: function () { this.$el.find("*").mouseover(this.startDelete).mouseout(this.stopDelete).click(this.onDelete) }, startDelete: function (t) { t.stopPropagation(); var e = o(t.target); e.data("model").get("removable") && (e.addClass(this.hoverClass), this.attachBadge(e.get(0))) }, stopDelete: function (t) { t.stopPropagation(), o(t.target).removeClass(this.hoverClass), this.badge && this.badge.css({ left: -1e3, top: -1e3 }) }, onDelete: function (t) { t.stopPropagation(); var e = o(t.target); e.data("model").get("removable") && (e.data("model").destroy(), this.removeBadge(), this.clean()) }, updateBadgeLabel: function (t) { this.badge.html("Remove " + t.getName()) } }) }).call(e, n(0), n(1)) }, function (t, e, n) { "use strict"; (function (e) { var i = (n(0), n(52)); t.exports = e.extend({}, i, { beforeInsert: function (t) { t.type = "image", t.style = {}, t.attributes = {}, t.attributes.onmousedown = "return false", this.config.firstCentered && this.getCanvasWrapper() == this.sorter.target && (t.style.margin = "0 auto") }, afterInsert: function (t) { t.trigger("dblclick"), this.sender && this.sender.set("active", !1) } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; (function (e, i) { var r = n(2), o = n(19), s = n(51), a = e.$; t.exports = i.extend({}, s, o, { init: function (t) { o.init.apply(this, arguments), i.bindAll(this, "initSorter", "rollback", "onEndMove"), this.opt = t, this.hoverClass = this.ppfx + "highlighter-warning", this.badgeClass = this.ppfx + "badge-warning", this.noSelClass = this.ppfx + "no-select" }, enable: function () { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; o.enable.apply(this, e), this.getBadgeEl().addClass(this.badgeClass), this.getHighlighterEl().addClass(this.hoverClass); var i = this.$wrapper; i.css("cursor", "move"), i.on("mousedown", this.initSorter), i.addClass(this.noSelClass) }, toggleClipboard: function () { }, initSorter: function (t) { var e = a(t.target).data("model"), n = e.get("draggable"); n && (this.cacheEl = null, this.startSelectPosition(t.target, this.frameEl.contentDocument), this.sorter.draggable = n, this.sorter.onEndMove = this.onEndMove.bind(this), this.stopSelectComponent(), this.$wrapper.off("mousedown", this.initSorter), (0, r.on)(this.getContentWindow(), "keydown", this.rollback)) }, initSorterFromModel: function (t) { var e = t.get("draggable"); if (e) { this.cacheEl = null; var n = t.view.el; this.startSelectPosition(n, this.frameEl.contentDocument), this.sorter.draggable = e, this.sorter.onEndMove = this.onEndMoveFromModel.bind(this), this.stopSelectComponent(), (0, r.on)(this.getContentWindow(), "keydown", this.rollback) } }, onEndMoveFromModel: function () { (0, r.off)(this.getContentWindow(), "keydown", this.rollback) }, onEndMove: function () { this.enable(), (0, r.off)(this.getContentWindow(), "keydown", this.rollback) }, onSelect: function (t, e) { }, rollback: function (t, e) { ((t.which || t.keyCode) == this.opt.ESCAPE_KEY || e) && (this.sorter.moved = !1, this.sorter.endMove()) }, getBadgeEl: function () { return this.$badge || (this.$badge = a(this.getBadge())), this.$badge }, getHighlighterEl: function () { return this.$hl || (this.$hl = a(this.canvas.getHighlighter())), this.$hl }, stop: function () { for (var t = arguments.length, e = Array(t), n = 0; n < t; n++)e[n] = arguments[n]; o.stop.apply(this, e), this.getBadgeEl().removeClass(this.badgeClass), this.getHighlighterEl().removeClass(this.hoverClass), this.$wrapper.css("cursor", "").unbind().removeClass(this.noSelClass) } }) }).call(e, n(0), n(1)) }, function (t, e, n) { "use strict"; (function (e) { var i = (n(0), n(20)); t.exports = e.extend({}, i, { beforeDraw: function (t) { t.type = "text", t.style || (t.style = {}), t.style.padding = "10px" }, afterDraw: function (t) { t && t.set && (t.trigger("focus"), this.sender && this.sender.set("active", !1)) } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; (function (e) { var n = e.$; t.exports = { run: function (t, e) { this.sender = e, this.wrapper = t.DomComponents.getWrapper(), this.components = t.DomComponents.getComponents(), this.modal = t.Modal || null, this.cm = t.CodeManager || null, this.cssc = t.CssComposer || null, this.protCss = t.Config.protectedCss, this.pfx = t.Config.stylePrefix || "", this.enable() }, buildEditor: function (t, e, i) { this.codeMirror || (this.codeMirror = this.cm.getViewer("CodeMirror")); var r = n("<textarea>"), o = this.codeMirror.clone().set({ label: i, codeName: t, theme: e, input: r[0] }), s = new this.cm.EditorView({ model: o, config: this.cm.getConfig() }).render().$el; return o.init(r[0]), { el: o, $el: s } }, enable: function () { if (!this.$editors) { var t = this.buildEditor("htmlmixed", "hopscotch", "HTML"), e = this.buildEditor("css", "hopscotch", "CSS"); this.htmlEditor = t.el, this.cssEditor = e.el, this.$editors = n('<div class="' + this.pfx + 'export-dl">'), this.$editors.append(t.$el).append(e.$el) } this.modal && (this.modal.setTitle("Export template"), this.modal.setContent(this.$editors), this.modal.open()); var i = this.em; this.protCss; this.htmlEditor.setContent(i.getHtml()), this.cssEditor.setContent(i.getCss()), this.sender && this.sender.set("active", !1) }, stop: function () { } } }).call(e, n(0)) }, function (t, e, n) { "use strict"; t.exports = { run: function (t) { t.Canvas.getBody().className = this.ppfx + "dashed" }, stop: function (t) { t.Canvas.getBody().className = "" } } }, function (t, e, n) { "use strict"; (function (e) { var i = n(188), r = e.$; t.exports = { run: function (t, e) { if (!this.toAppend) { var n = t.DomComponents.getComponent().get("components"), o = t.getConfig(), s = o.stylePrefix, a = t.Panels, l = o.layers.stylePrefix || "nv-"; o.layers.stylePrefix = o.stylePrefix + l, o.layers.pStylePrefix = o.stylePrefix, o.layers.em = t.editor, o.layers.opened = t.editor.get("opened"), a.getPanel("views-container") ? this.panel = a.getPanel("views-container") : this.panel = a.addPanel({ id: "views-container" }); var c = r('<div class="' + s + 'layers"></div>'); this.panel.set("appendContent", c).trigger("change:appendContent"), o.layers.sortContainer = c.get(0); var u = (new i).init(n, o.layers); this.$layers = u.render(), c.append(this.$layers), this.toAppend = c } this.toAppend.show() }, stop: function () { this.toAppend && this.toAppend.hide() } } }).call(e, n(0)) }, function (t, e, n) { "use strict"; t.exports = function () { var t = void 0, e = {}, i = n(189), r = n(53), o = n(54); return { init: function (n, s) { e = s || e; var a = e.em; for (var l in i) l in e || (e[l] = i[l]); var c = o, u = s.opened || {}, h = { level: 0, config: e, opened: u }; return e.showWrapper && n.parent ? (c = r, h.model = n.parent) : h.collection = n, t = new c(h), a && a.on("change:selectedComponent", this.componentChanged), this.componentChanged(), this }, componentChanged: function (t, n) { if (!(arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}).fromLayers) { var i = e.em, r = i.get("opened"), o = i.get("selectedComponent"), s = o && o.collection ? o.collection.parent : null; for (var a in r) r[a].set("open", 0); for (; s;)s.set("open", 1), r[s.cid] = s, s = s.collection ? s.collection.parent : null } }, render: function () { return t.render().$el } } } }, function (t, e, n) { "use strict"; t.exports = { stylePrefix: "nv-", sortable: 1, hidable: 1, hideTextnode: 1, showWrapper: 1 } }, function (t, e, n) { "use strict"; var i = (n(29), n(0)), r = i.$; t.exports = { run: function (t, e) { if (this.sender = e, !this.$cn) { var n = t.getConfig(), i = t.Panels; this.$cn = r("<div></div>"), this.$cn2 = r("<div></div>"), this.$cn.append(this.$cn2); var o = t.DeviceManager; if (o && n.showDevices) { i.addPanel({ id: "devices-c" }).set("appendContent", o.render()).trigger("change:appendContent") } var s = t.SelectorManager; s && this.$cn2.append(s.render([])), this.$cn2.append(t.StyleManager.render()); var a = t.StyleManager.getConfig(), l = a.stylePrefix; this.$header = r('<div class="' + l + 'header">' + a.textNoElement + "</div>"), this.$cn.append(this.$header), i.getPanel("views-container") ? this.panel = i.getPanel("views-container") : this.panel = i.addPanel({ id: "views-container" }), this.panel.set("appendContent", this.$cn).trigger("change:appendContent"), this.target = t.editor, this.listenTo(this.target, "change:selectedComponent", this.toggleSm) } this.toggleSm() }, toggleSm: function () { this.sender.get("active") && (this.target.get("selectedComponent") ? (this.$cn2.show(), this.$header.hide()) : (this.$cn2.hide(), this.$header.show())) }, stop: function () { this.$cn2 && this.$cn2.hide(), this.$header && this.$header.hide() } } }, function (t, e, n) { "use strict"; (function (e) { var n = e.$; t.exports = { run: function (t, e) { var i, r = t.Config, o = r.stylePrefix, s = t.TraitManager; if (!this.obj) { var a = s.getTraitsViewer(), l = s.getConfig(); this.obj = n("<div></div>").append('<div class="' + o + 'traits-label">' + l.labelContainer + "</div>").get(0), this.obj.appendChild(a.render().el); var c = t.Panels; i = c.getPanel("views-container") ? c.getPanel("views-container") : c.addPanel({ id: "views-container" }), i.set("appendContent", this.obj).trigger("change:appendContent") } this.obj.style.display = "block" }, stop: function () { this.obj && (this.obj.style.display = "none") } } }).call(e, n(0)) }, function (t, e, n) { "use strict"; t.exports = { run: function (t, e) { var n = t.BlockManager, i = t.Panels; if (!this.blocks) { n.render(); var r = "views-container", o = document.createElement("div"), s = i.getPanel(r) || i.addPanel({ id: r }); o.appendChild(n.getContainer()), s.set("appendContent", o).trigger("change:appendContent"), this.blocks = o } this.blocks.style.display = "block" }, stop: function () { var t = this.blocks; t && (t.style.display = "none") } } }, function (t, e, n) { "use strict"; t.exports = { run: function (t, e) { var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, i = t.Modal, r = t.AssetManager, o = r.getConfig(), s = n.modalTitle || o.modalTitle || ""; r.setTarget(n.target), r.onClick(n.onClick), r.onDblClick(n.onDblClick), r.onSelect(n.onSelect), this.rendered || (r.render(r.getAll().filter(function (t) { return "image" == t.get("type") })), this.rendered = 1), i.setTitle(s), i.setContent(r.getContainer()), i.open() } } }, function (t, e, n) { "use strict"; (function (e) { var n = e.$; t.exports = { getOffsetMethod: function (t) { return "get" + (t || "") + "OffsetViewerEl" }, run: function (t, e, i) { var r = i || {}, o = r.state || "", s = t.getConfig(); if (s.showOffsets && (s.showOffsetsSelected || "Fixed" != o)) { var a = t.Canvas, l = r.el || "", c = r.elPos || a.getElementPos(l), u = window.getComputedStyle(l), h = this.ppfx, d = o + "State", f = this.getOffsetMethod(o), p = a[f](); p.style.display = "block"; var g = this["marginT" + o], m = this["marginB" + o], v = this["marginL" + o], y = this["marginR" + o], b = this["padT" + o], x = this["padB" + o], w = this["padL" + o], C = this["padR" + o]; if (!this[d]) { var k = o.toLowerCase(), S = k + "margin-v", T = k + "padding-v", M = n('<div class="' + h + 'marginName">').get(0), E = n('<div class="' + h + 'paddingName">').get(0), P = h + S + "-el", A = h + T + "-el", L = P + " " + (h + S), O = A + " " + (h + T); g = n('<div class="' + L + '-top"></div>').get(0), m = n('<div class="' + L + '-bottom"></div>').get(0), v = n('<div class="' + L + '-left"></div>').get(0), y = n('<div class="' + L + '-right"></div>').get(0), b = n('<div class="' + O + '-top"></div>').get(0), x = n('<div class="' + O + '-bottom"></div>').get(0), w = n('<div class="' + O + '-left"></div>').get(0), C = n('<div class="' + O + '-right"></div>').get(0), this["marginT" + o] = g, this["marginB" + o] = m, this["marginL" + o] = v, this["marginR" + o] = y, this["padT" + o] = b, this["padB" + o] = x, this["padL" + o] = w, this["padR" + o] = C, M.appendChild(g), M.appendChild(m), M.appendChild(v), M.appendChild(y), E.appendChild(b), E.appendChild(x), E.appendChild(w), E.appendChild(C), p.appendChild(M), p.appendChild(E), this[d] = "1" } var N = u.marginLeft.replace("px", ""), D = parseInt(u.marginTop.replace("px", "")), I = parseInt(u.marginBottom.replace("px", "")), _ = g.style, F = m.style, $ = v.style, z = y.style, H = b.style, R = x.style, V = w.style, j = C.style, B = parseInt(c.left); _.height = u.marginTop, _.width = u.width, _.top = c.top - u.marginTop.replace("px", "") + "px", _.left = B + "px", F.height = u.marginBottom, F.width = u.width, F.top = c.top + c.height + "px", F.left = B + "px"; var W = c.height + D + I + "px", U = c.top - D + "px"; $.height = W, $.width = u.marginLeft, $.top = U, $.left = B - N + "px", z.height = W, z.width = u.marginRight, z.top = U, z.left = B + c.width + "px"; var q = parseInt(u.paddingTop.replace("px", "")); H.height = u.paddingTop, H.width = u.width, H.top = c.top + "px", H.left = B + "px"; var K = parseInt(u.paddingBottom.replace("px", "")); R.height = u.paddingBottom, R.width = u.width, R.top = c.top + c.height - K + "px", R.left = B + "px"; var G = c.height - K - q + "px", Y = c.top + q + "px"; V.height = G, V.width = u.paddingLeft, V.top = Y, V.left = c.left + "px"; var X = parseInt(u.paddingRight.replace("px", "")); j.height = G, j.width = u.paddingRight, j.top = Y, j.left = c.left + c.width - X + "px" } }, stop: function (t, e, n) { var i = n || {}, r = i.state || "", o = this.getOffsetMethod(r); t.Canvas[o]().style.display = "none" } } }).call(e, n(0)) }, function (t, e, n) { "use strict"; t.exports = { run: function (t) { var e = t.getSelected(), n = e && e.collection; n && n.parent && t.select(n.parent) } } }, function (t, e, n) { "use strict"; t.exports = { isEnabled: function () { var t = document; return t.fullscreenElement || t.webkitFullscreenElement || t.mozFullScreenElement ? 1 : 0 }, enable: function (t) { var e = ""; return t.requestFullscreen ? t.requestFullscreen() : t.webkitRequestFullscreen ? (e = "webkit", t.webkitRequestFullscreen()) : t.mozRequestFullScreen ? (e = "moz", t.mozRequestFullScreen()) : t.msRequestFullscreen ? t.msRequestFullscreen() : console.warn("Fullscreen not supported"), e }, disable: function () { var t = document; t.exitFullscreen ? t.exitFullscreen() : t.webkitExitFullscreen ? t.webkitExitFullscreen() : t.mozCancelFullScreen ? t.mozCancelFullScreen() : t.msExitFullscreen && t.msExitFullscreen() }, fsChanged: function (t, e) { var n = (document, (t || "") + "fullscreenchange"); this.isEnabled() || (this.stop(null, this.sender), document.removeEventListener(n, this.fsChanged)) }, run: function (t, e) { this.sender = e; var n = this.enable(t.getContainer()); this.fsChanged = this.fsChanged.bind(this, n), document.addEventListener(n + "fullscreenchange", this.fsChanged), t && t.trigger("change:canvasOffset") }, stop: function (t, e) { e && e.set && e.set("active", !1), this.disable(), t && t.trigger("change:canvasOffset") } } }, function (t, e, n) { "use strict"; (function (e) { t.exports = { getPanels: function (t) { return this.panels || (this.panels = t.Panels.getPanelsEl()), this.panels }, tglPointers: function (t, n) { var i = t.Canvas.getBody().querySelectorAll("." + this.ppfx + "no-pointer"); e.each(i, function (t) { t.style.pointerEvents = n ? "" : "all" }) }, run: function (t, e) { e && e.set && e.set("active", !1), t.stopCommand("sw-visibility"), t.getModel().stopDefault(); var n = this, i = this.getPanels(t), r = t.Canvas.getElement(), o = t.getEl(), s = t.Config.stylePrefix; this.helper || (this.helper = document.createElement("span"), this.helper.className = s + "off-prv fa fa-eye-slash", o.appendChild(this.helper), this.helper.onclick = function () { n.stop(t) }), this.helper.style.display = "inline-block", this.tglPointers(t), i.style.display = "none"; var a = r.style; a.width = "100%", a.height = "100%", a.top = "0", a.left = "0", a.padding = "0", a.margin = "0", t.trigger("change:canvasOffset") }, stop: function (t, e) { var n = this.getPanels(t); t.runCommand("sw-visibility"), t.getModel().runDefault(), n.style.display = "block", t.Canvas.getElement().setAttribute("style", ""), this.helper && (this.helper.style.display = "none"), t.trigger("change:canvasOffset"), this.tglPointers(t, 1) } } }).call(e, n(1)) }, function (t, e, n) { "use strict"; t.exports = { run: function (t, e, n) { var i = n || {}, r = i.el || "", o = t.Canvas, s = this.canvasResizer, a = i.options || {}, l = o.getCanvasView(); return a.ratioDefault = 1, a.appendTo = o.getResizerEl(), a.prefix = t.getConfig().stylePrefix, a.posFetcher = l.getElementPos.bind(l), a.mousePosFetcher = o.getMouseRelativePos, s && !i.forceNew || (this.canvasResizer = t.Utils.Resizer.init(a), s = this.canvasResizer), s.setOptions(a), s.focus(r), s }, stop: function () { var t = this.canvasResizer; t && t.blur() } } }, function (t, e, n) { "use strict"; t.exports = { run: function (t, e, n) { var i = n && n.el || "", r = t.Canvas, o = this.dragger, s = n.options || {}, a = r.getCanvasView(); return s.prefix = t.getConfig().stylePrefix, s.mousePosFetcher = r.getMouseRelativePos, s.posFetcher = a.getElementPos.bind(a), o || (o = t.Utils.Dragger.init(s), this.dragger = o), o.setOptions(s), o.focus(i), s.event && o.start(s.event), o }, stop: function () { this.canvasResizer && this.canvasResizer.blur() } } }, function (t, e, n) { "use strict"; t.exports = function () { var t, e, i, r = {}, o = n(201), s = n(202), a = n(204), l = n(205), c = []; return { name: "BlockManager", init: function (n) { r = n || {}; var u = r.em; for (var h in o) h in r || (r[h] = o[h]); return t = new s([]), e = new s([]), c = new a, i = new l({ collection: e, categories: c }, r), t.listenTo(t, "add", function (t) { e.add(t), u && u.trigger("block:add", t) }), t.listenTo(t, "remove", function (t) { e.remove(t), u && u.trigger("block:remove", t) }), t.listenTo(t, "reset", function (t) { e.reset(t.models) }), this }, getConfig: function () { return r }, onLoad: function () { var t = this.getAll(); !t.length && t.reset(r.blocks) }, add: function (e, n) { var i = n || {}; return i.id = e, t.add(i) }, get: function (e) { return t.get(e) }, getAll: function () { return t }, getAllVisible: function () { return e }, remove: function (e) { return t.remove(e) }, getCategories: function () { return c }, getContainer: function () { return i.el }, render: function (t) { var e = t || this.getAll().models; i.rendered || (i.render(), i.rendered = 1), i.collection.reset(e) } } } }, function (t, e, n) { "use strict"; t.exports = { blocks: [], appendTo: "" } }, function (t, e, n) { "use strict"; var i = n(0), r = n(203); t.exports = i.Collection.extend({ model: r }) }, function (t, e, n) { "use strict"; var i = n(0), r = n(55); t.exports = i.Model.extend({ defaults: { label: "", content: "", category: "", attributes: {} }, initialize: function () { var t = (arguments.length > 0 && void 0 !== arguments[0] && arguments[0], this.get("category")); if (t && "string" == typeof t) { new r({ id: t, label: t }) } } }) }, function (t, e, n) { "use strict"; var i = n(0); t.exports = i.Collection.extend({ model: n(55) }) }, function (t, e, n) { "use strict"; (function (e) { var i = n(0), r = n(206), o = n(207); t.exports = i.View.extend({ initialize: function (t, n) { e.bindAll(this, "getSorter", "onDrag", "onDrop"), this.config = n || {}, this.categories = t.categories || "", this.renderedCategories = []; var i = this.config.pStylePrefix || ""; this.ppfx = i, this.noCatClass = i + "blocks-no-cat", this.blockContClass = i + "blocks-c", this.catsClass = i + "block-categories"; var r = this.collection; this.listenTo(r, "add", this.addTo), this.listenTo(r, "reset", this.render), this.em = this.config.em, this.tac = "test-tac", this.grabbingCls = this.ppfx + "grabbing", this.em && (this.config.getSorter = this.getSorter, this.canvas = this.em.get("Canvas")) }, getSorter: function () { if (this.em) { if (!this.sorter) { var t = this.em.get("Utils"), e = this.canvas; this.sorter = new t.Sorter({ container: e.getBody(), placer: e.getPlacerEl(), containerSel: "*", itemSel: "*", pfx: this.ppfx, onStart: this.onDrag, onEndMove: this.onDrop, onMove: this.onMove, document: e.getFrameEl().contentDocument, direction: "a", wmargin: 1, nested: 1, em: this.em, canvasRelative: 1 }) } return this.sorter } }, onDrag: function (t) { this.em.stopDefault(), this.em.trigger("block:drag:start", t) }, onMove: function (t) { this.em.trigger("block:drag:move", t) }, onDrop: function (t) { var e = this.em; e.runDefault(), t && t.get && (t.get("activeOnRender") && (t.trigger("active"), t.set("activeOnRender", 0)), e.initChildrenComp(t), e.trigger("block:drag:stop", t)) }, addTo: function (t) { this.add(t) }, add: function (t, e) { var n = e || null, i = new r({ model: t, attributes: t.get("attributes") }, this.config), s = i.render().el, a = t.get("category"); if (a && this.categories) { "string" == typeof a && (a = { id: a, label: a }); var l = this.categories.add(a), c = l.get("id"), u = this.renderedCategories[c], h = this.getCategoriesEl(); return t.set("category", l), !u && h && (u = new o({ model: l }, this.config).render(), this.renderedCategories[c] = u, h.appendChild(u.el)), void (u && u.append(s)) } n ? n.appendChild(s) : this.append(s) }, getCategoriesEl: function () { return this.catsEl || (this.catsEl = this.el.querySelector("." + this.catsClass)), this.catsEl }, getBlocksEl: function () { return this.blocksEl || (this.blocksEl = this.el.querySelector("." + this.noCatClass + " ." + this.blockContClass)), this.blocksEl }, append: function (t) { var e = this.getBlocksEl(); e && e.appendChild(t) }, render: function () { var t = this, e = document.createDocumentFragment(); return this.catsEl = null, this.blocksEl = null, this.renderedCategories = [], this.el.innerHTML = '\n      <div class="' + this.catsClass + '"></div>\n      <div class="' + this.noCatClass + '">\n        <div class="' + this.blockContClass + '"></div>\n      </div>\n    ', this.collection.each(function (n) { return t.add(n, e) }), this.append(e), this.$el.addClass(this.blockContClass + "s"), this } }) }).call(e, n(1)) }, function (t, e, n) { "use strict"; (function (e) { var i = n(2); t.exports = e.View.extend({ events: { mousedown: "startDrag" }, initialize: function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; this.config = e, this.endDrag = this.endDrag.bind(this), this.ppfx = e.pStylePrefix || "", this.listenTo(this.model, "destroy remove", this.remove) }, startDrag: function (t) { if (0 === t.button && this.config.getSorter) { this.config.em.refreshCanvas(); var e = this.config.getSorter(); e.setDragHelper(this.el, t), e.startSort(this.el), e.setDropContent(this.model.get("content")), (0, i.on)(document, "mouseup", this.endDrag) } }, endDrag: function (t) { (0, i.off)(document, "mouseup", this.endDrag); var e = this.config.getSorter(); e.moved = 0, e.endMove() }, render: function () { var t = this.el, e = this.ppfx + "block"; return t.className += " " + e, t.innerHTML = '<div class="' + e + '-label">' + this.model.get("label") + "</div>", this } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; (function (e) { var i = n(0); t.exports = i.View.extend({ template: e.template('\n  <div class="<%= pfx %>title">\n    <i class="<%= pfx %>caret-icon"></i>\n    <%= label %>\n  </div>\n  <div class="<%= pfx %>blocks-c"></div>\n  '), events: {}, initialize: function () { var t = (arguments.length > 0 && void 0 !== arguments[0] && arguments[0], arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}); this.config = t; var e = this.config.pStylePrefix || ""; this.pfx = e, this.caretR = "fa fa-caret-right", this.caretD = "fa fa-caret-down", this.iconClass = e + "caret-icon", this.activeClass = e + "open", this.className = e + "block-category", this.events["click ." + e + "title"] = "toggle", this.listenTo(this.model, "change:open", this.updateVisibility), this.delegateEvents() }, updateVisibility: function () { this.model.get("open") ? this.open() : this.close() }, open: function () { this.el.className = this.className + " " + this.activeClass, this.getIconEl().className = this.iconClass + " " + this.caretD, this.getBlocksEl().style.display = "" }, close: function () { this.el.className = this.className, this.getIconEl().className = this.iconClass + " " + this.caretR, this.getBlocksEl().style.display = "none" }, toggle: function () { var t = this.model; t.set("open", !t.get("open")) }, getIconEl: function () { return this.iconEl || (this.iconEl = this.el.querySelector("." + this.iconClass)), this.iconEl }, getBlocksEl: function () { return this.blocksEl || (this.blocksEl = this.el.querySelector("." + this.pfx + "blocks-c")), this.blocksEl }, append: function (t) { this.getBlocksEl().appendChild(t) }, render: function () { return this.el.innerHTML = this.template({ pfx: this.pfx, label: this.model.get("label") }), this.el.className = this.className, this.updateVisibility(), this } }) }).call(e, n(1)) }, function (t, e, n) {
        var i, r, o;/*!
 * Backbone.Undo.js v0.2
 * 
 * Copyright (c)2013 Oliver Sartun
 * Released under the MIT License
 *
 * Documentation and full license available at
 * https://github.com/osartun/Backbone.Undo.js
 */
        !function (s) { r = [n(1), n(209)], i = s, void 0 !== (o = "function" == typeof i ? i.apply(e, r) : i) && (t.exports = o) }(function (t, e) { function n(t, e, n) { return n.length <= 4 ? t.call(e, n[0], n[1], n[2], n[3]) : t.apply(e, n) } function i(t, e) { return f.call(t, e) } function r(e, n) { return null != e && (t.isArray(n) || (n = i(arguments, 1)), t.all(n, function (t) { return t in e })) } function o() { this.registeredObjects = [], this.cidIndexes = [] } function s(e, n, i, r) { for (var o, s = 0, a = n.length; s < a; s++)if (o = n[s]) { if ("on" === e) { if (!r.objectRegistry.register(o)) continue } else if (!r.objectRegistry.unregister(o)) continue; t.isFunction(o[e]) && o[e]("all", i, r) } } function a(e, n) { var i = n.type, r = n.undoTypes, o = !r[i] || r[i][e]; t.isFunction(o) && o(n.object, n.before, n.after, n.options) } function l(e, n, i, r, o) { if (!(i.isCurrentlyUndoRedoing || "undo" === e && -1 === i.pointer || "redo" === e && i.pointer === i.length - 1)) { i.isCurrentlyUndoRedoing = !0; var s, a, l = "undo" === e; for (o ? a = l && i.pointer === i.length - 1 || !l && -1 === i.pointer ? t.clone(i.models) : f.apply(i.models, l ? [0, i.pointer] : [i.pointer, i.length - 1]) : (s = i.at(l ? i.pointer : i.pointer + 1), a = r ? i.where({ magicFusionIndex: s.get("magicFusionIndex") }) : [s]), i.pointer += (l ? -1 : 1) * a.length; s = l ? a.pop() : a.shift();)s[e](); i.isCurrentlyUndoRedoing = !1, n.trigger(e, n) } } function c(t, e) { var i = t.condition, r = typeof i; return "function" === r ? !!n(i, t, e) : "boolean" !== r || i } function u(t, e, i, o) { if (t.track && !t.isCurrentlyUndoRedoing && e in o && c(o[e], i)) { var s, a = n(o[e].on, o[e], i); if (r(a, "object", "before", "after")) { if (a.type = e, a.magicFusionIndex = p(), a.undoTypes = o, t.pointer < t.length - 1) for (var s = t.length - t.pointer - 1; s--;)t.pop(); t.pointer = t.length, t.add(a), t.length > t.maximumStackLength && (t.shift(), t.pointer--) } } } function h() { } function d(e, n, i, o) { if ("object" == typeof n) return t.each(n, function (t, n) { 2 === e ? d(e, t, i, o) : d(e, n, t, i) }); switch (e) { case 0: r(i, "undo", "redo", "on") && t.all(t.pick(i, "undo", "redo", "on"), t.isFunction) && (o[n] = i); break; case 1: o[n] && t.isObject(i) && (o[n] = t.extend({}, o[n], i)); break; case 2: delete o[n] }return this } var f = Array.prototype.slice, p = function () { function e() { i++ , n = !0, t.defer(function () { n = !1 }) } var n = !1, i = -1; return function () { return n || e(), i } }(); o.prototype = { isRegistered: function (e) { return e && e.cid ? this.registeredObjects[e.cid] : t.contains(this.registeredObjects, e) }, register: function (t) { return !this.isRegistered(t) && (t && t.cid ? (this.registeredObjects[t.cid] = t, this.cidIndexes.push(t.cid)) : this.registeredObjects.push(t), !0) }, unregister: function (e) { if (this.isRegistered(e)) { if (e && e.cid) delete this.registeredObjects[e.cid], this.cidIndexes.splice(t.indexOf(this.cidIndexes, e.cid), 1); else { var n = t.indexOf(this.registeredObjects, e); this.registeredObjects.splice(n, 1) } return !0 } return !1 }, get: function () { return t.map(this.cidIndexes, function (t) { return this.registeredObjects[t] }, this).concat(this.registeredObjects) } }; var g = { add: { undo: function (t, e, n, i) { t.remove(n, i) }, redo: function (t, e, n, i) { i.index && (i.at = i.index), t.add(n, i) }, on: function (e, n, i) { return { object: n, before: void 0, after: e, options: t.clone(i) } } }, remove: { undo: function (t, e, n, i) { "index" in i && (i.at = i.index), t.add(e, i) }, redo: function (t, e, n, i) { t.remove(e, i) }, on: function (e, n, i) { return { object: n, before: e, after: void 0, options: t.clone(i) } } }, change: { undo: function (e, n, i, r) { t.isEmpty(n) ? t.each(t.keys(i), e.unset, e) : (e.set(n), r && r.unsetData && r.unsetData.before && r.unsetData.before.length && t.each(r.unsetData.before, e.unset, e)) }, redo: function (e, n, i, r) { t.isEmpty(i) ? t.each(t.keys(n), e.unset, e) : (e.set(i), r && r.unsetData && r.unsetData.after && r.unsetData.after.length && t.each(r.unsetData.after, e.unset, e)) }, on: function (e, n) { var i = e.changedAttributes(), r = t.keys(i), o = t.pick(e.previousAttributes(), r), s = t.keys(o), a = (n || (n = {})).unsetData = { after: [], before: [] }; return r.length != s.length && (r.length > s.length ? t.each(r, function (t) { t in o || a.before.push(t) }, this) : t.each(s, function (t) { t in i || a.after.push(t) })), { object: e, before: o, after: i, options: t.clone(n) } } }, reset: { undo: function (t, e, n) { t.reset(e) }, redo: function (t, e, n) { t.reset(n) }, on: function (e, n) { return { object: e, before: n.previousModels, after: t.clone(e.models) } } } }; h.prototype = g; var m = e.Model.extend({ defaults: { type: null, object: null, before: null, after: null, magicFusionIndex: null }, undo: function (t) { a("undo", this.attributes) }, redo: function (t) { a("redo", this.attributes) } }), v = e.Collection.extend({ model: m, pointer: -1, track: !1, isCurrentlyUndoRedoing: !1, maximumStackLength: 1 / 0, setMaxLength: function (t) { this.maximumStackLength = t } }), y = e.Model.extend({ defaults: { maximumStackLength: 1 / 0, track: !1 }, initialize: function (e) { this.stack = new v, this.objectRegistry = new o, this.undoTypes = new h, this.stack.setMaxLength(this.get("maximumStackLength")), this.on("change:maximumStackLength", function (t, e) { this.stack.setMaxLength(e) }, this), e && e.track && this.startTracking(), e && e.register && (t.isArray(e.register) || t.isArguments(e.register) ? n(this.register, this, e.register) : this.register(e.register)) }, startTracking: function () { this.set("track", !0), this.stack.track = !0 }, stopTracking: function () { this.set("track", !1), this.stack.track = !1 }, isTracking: function () { return this.get("track") }, _addToStack: function (t) { u(this.stack, t, i(arguments, 1), this.undoTypes) }, register: function () { s("on", arguments, this._addToStack, this) }, unregister: function () { s("off", arguments, this._addToStack, this) }, unregisterAll: function () { n(this.unregister, this, this.objectRegistry.get()) }, undo: function (t) { l("undo", this, this.stack, t) }, undoAll: function () { l("undo", this, this.stack, !1, !0) }, redo: function (t) { l("redo", this, this.stack, t) }, redoAll: function () { l("redo", this, this.stack, !1, !0) }, isAvailable: function (t) { var e = this.stack, n = e.length; switch (t) { case "undo": return n > 0 && e.pointer > -1; case "redo": return n > 0 && e.pointer < n - 1; default: return !1 } }, merge: function (e) { for (var n, r = t.isArray(e) ? e : i(arguments); n = r.pop();)n instanceof y && n.stack instanceof v && (n.stack = this.stack) }, addUndoType: function (t, e) { d(0, t, e, this.undoTypes) }, changeUndoType: function (t, e) { d(1, t, e, this.undoTypes) }, removeUndoType: function (t) { d(2, t, void 0, this.undoTypes) }, clear: function () { this.stack.reset(), this.stack.pointer = -1 } }); return t.extend(y, { defaults: function (e) { t.extend(y.prototype.defaults, e) }, addUndoType: function (t, e) { d(0, t, e, g) }, changeUndoType: function (t, e) { d(1, t, e, g) }, removeUndoType: function (t) { d(2, t, void 0, g) } }), e.UndoManager = y })
    }, function (t, e, n) { (function (i) { var r, o; !function (s) { var a = "object" == typeof self && self.self == self && self || "object" == typeof i && i.global == i && i; r = [n(1), n(8), e], void 0 !== (o = function (t, e, n) { a.Backbone = s(a, n, t, e) }.apply(e, r)) && (t.exports = o) }(function (t, e, n, i) { var r = t.Backbone, o = [].slice; e.VERSION = "1.2.1", e.$ = i, e.noConflict = function () { return t.Backbone = r, this }, e.emulateHTTP = !1, e.emulateJSON = !1; var s = function (t, e, i) { switch (t) { case 1: return function () { return n[e](this[i]) }; case 2: return function (t) { return n[e](this[i], t) }; case 3: return function (t, r) { return n[e](this[i], t, r) }; case 4: return function (t, r, o) { return n[e](this[i], t, r, o) }; default: return function () { var t = o.call(arguments); return t.unshift(this[i]), n[e].apply(n, t) } } }, a = function (t, e, i) { n.each(e, function (e, r) { n[r] && (t.prototype[r] = s(e, r, i)) }) }, l = e.Events = {}, c = /\s+/, u = function (t, e, i, r, o) { var s, a = 0; if (i && "object" == typeof i) { void 0 !== r && "context" in o && void 0 === o.context && (o.context = r); for (s = n.keys(i); a < s.length; a++)e = t(e, s[a], i[s[a]], o) } else if (i && c.test(i)) for (s = i.split(c); a < s.length; a++)e = t(e, s[a], r, o); else e = t(e, i, r, o); return e }; l.on = function (t, e, n) { return h(this, t, e, n) }; var h = function (t, e, n, i, r) { if (t._events = u(d, t._events || {}, e, n, { context: i, ctx: t, listening: r }), r) { (t._listeners || (t._listeners = {}))[r.id] = r } return t }; l.listenTo = function (t, e, i) { if (!t) return this; var r = t._listenId || (t._listenId = n.uniqueId("l")), o = this._listeningTo || (this._listeningTo = {}), s = o[r]; if (!s) { var a = this._listenId || (this._listenId = n.uniqueId("l")); s = o[r] = { obj: t, objId: r, id: a, listeningTo: o, count: 0 } } return h(t, e, i, this, s), this }; var d = function (t, e, n, i) { if (n) { var r = t[e] || (t[e] = []), o = i.context, s = i.ctx, a = i.listening; a && a.count++ , r.push({ callback: n, context: o, ctx: o || s, listening: a }) } return t }; l.off = function (t, e, n) { return this._events ? (this._events = u(f, this._events, t, e, { context: n, listeners: this._listeners }), this) : this }, l.stopListening = function (t, e, i) { var r = this._listeningTo; if (!r) return this; for (var o = t ? [t._listenId] : n.keys(r), s = 0; s < o.length; s++) { var a = r[o[s]]; if (!a) break; a.obj.off(e, i, this) } return n.isEmpty(r) && (this._listeningTo = void 0), this }; var f = function (t, e, i, r) { if (t) { var o, s = 0, a = r.context, l = r.listeners; if (e || i || a) { for (var c = e ? [e] : n.keys(t); s < c.length; s++) { e = c[s]; var u = t[e]; if (!u) break; for (var h = [], d = 0; d < u.length; d++) { var f = u[d]; i && i !== f.callback && i !== f.callback._callback || a && a !== f.context ? h.push(f) : (o = f.listening) && 0 == --o.count && (delete l[o.id], delete o.listeningTo[o.objId]) } h.length ? t[e] = h : delete t[e] } return n.size(t) ? t : void 0 } for (var p = n.keys(l); s < p.length; s++)o = l[p[s]], delete l[o.id], delete o.listeningTo[o.objId] } }; l.once = function (t, e, i) { var r = u(p, {}, t, e, n.bind(this.off, this)); return this.on(r, void 0, i) }, l.listenToOnce = function (t, e, i) { var r = u(p, {}, e, i, n.bind(this.stopListening, this, t)); return this.listenTo(t, r) }; var p = function (t, e, i, r) { if (i) { var o = t[e] = n.once(function () { r(e, o), i.apply(this, arguments) }); o._callback = i } return t }; l.trigger = function (t) { if (!this._events) return this; for (var e = Math.max(0, arguments.length - 1), n = Array(e), i = 0; i < e; i++)n[i] = arguments[i + 1]; return u(g, this._events, t, void 0, n), this }; var g = function (t, e, n, i) { if (t) { var r = t[e], o = t.all; r && o && (o = o.slice()), r && m(r, i), o && m(o, [e].concat(i)) } return t }, m = function (t, e) { var n, i = -1, r = t.length, o = e[0], s = e[1], a = e[2]; switch (e.length) { case 0: for (; ++i < r;)(n = t[i]).callback.call(n.ctx); return; case 1: for (; ++i < r;)(n = t[i]).callback.call(n.ctx, o); return; case 2: for (; ++i < r;)(n = t[i]).callback.call(n.ctx, o, s); return; case 3: for (; ++i < r;)(n = t[i]).callback.call(n.ctx, o, s, a); return; default: for (; ++i < r;)(n = t[i]).callback.apply(n.ctx, e); return } }; l.bind = l.on, l.unbind = l.off, n.extend(e, l); var v = e.Model = function (t, e) { var i = t || {}; e || (e = {}), this.cid = n.uniqueId(this.cidPrefix), this.attributes = {}, e.collection && (this.collection = e.collection), e.parse && (i = this.parse(i, e) || {}), i = n.defaults({}, i, n.result(this, "defaults")), this.set(i, e), this.changed = {}, this.initialize.apply(this, arguments) }; n.extend(v.prototype, l, { changed: null, validationError: null, idAttribute: "id", cidPrefix: "c", initialize: function () { }, toJSON: function (t) { return n.clone(this.attributes) }, sync: function () { return e.sync.apply(this, arguments) }, get: function (t) { return this.attributes[t] }, escape: function (t) { return n.escape(this.get(t)) }, has: function (t) { return null != this.get(t) }, matches: function (t) { return !!n.iteratee(t, this)(this.attributes) }, set: function (t, e, i) { if (null == t) return this; var r; if ("object" == typeof t ? (r = t, i = e) : (r = {})[t] = e, i || (i = {}), !this._validate(r, i)) return !1; var o = i.unset, s = i.silent, a = [], l = this._changing; this._changing = !0, l || (this._previousAttributes = n.clone(this.attributes), this.changed = {}); var c = this.attributes, u = this.changed, h = this._previousAttributes; this.idAttribute in r && (this.id = r[this.idAttribute]); for (var d in r) e = r[d], n.isEqual(c[d], e) || a.push(d), n.isEqual(h[d], e) ? delete u[d] : u[d] = e, o ? delete c[d] : c[d] = e; if (!s) { a.length && (this._pending = i); for (var f = 0; f < a.length; f++)this.trigger("change:" + a[f], this, c[a[f]], i) } if (l) return this; if (!s) for (; this._pending;)i = this._pending, this._pending = !1, this.trigger("change", this, i); return this._pending = !1, this._changing = !1, this }, unset: function (t, e) { return this.set(t, void 0, n.extend({}, e, { unset: !0 })) }, clear: function (t) { var e = {}; for (var i in this.attributes) e[i] = void 0; return this.set(e, n.extend({}, t, { unset: !0 })) }, hasChanged: function (t) { return null == t ? !n.isEmpty(this.changed) : n.has(this.changed, t) }, changedAttributes: function (t) { if (!t) return !!this.hasChanged() && n.clone(this.changed); var e = this._changing ? this._previousAttributes : this.attributes, i = {}; for (var r in t) { var o = t[r]; n.isEqual(e[r], o) || (i[r] = o) } return !!n.size(i) && i }, previous: function (t) { return null != t && this._previousAttributes ? this._previousAttributes[t] : null }, previousAttributes: function () { return n.clone(this._previousAttributes) }, fetch: function (t) { t = n.extend({ parse: !0 }, t); var e = this, i = t.success; return t.success = function (n) { var r = t.parse ? e.parse(n, t) : n; if (!e.set(r, t)) return !1; i && i.call(t.context, e, n, t), e.trigger("sync", e, n, t) }, $(this, t), this.sync("read", this, t) }, save: function (t, e, i) { var r; null == t || "object" == typeof t ? (r = t, i = e) : (r = {})[t] = e, i = n.extend({ validate: !0, parse: !0 }, i); var o = i.wait; if (r && !o) { if (!this.set(r, i)) return !1 } else if (!this._validate(r, i)) return !1; var s = this, a = i.success, l = this.attributes; i.success = function (t) { s.attributes = l; var e = i.parse ? s.parse(t, i) : t; if (o && (e = n.extend({}, r, e)), e && !s.set(e, i)) return !1; a && a.call(i.context, s, t, i), s.trigger("sync", s, t, i) }, $(this, i), r && o && (this.attributes = n.extend({}, l, r)); var c = this.isNew() ? "create" : i.patch ? "patch" : "update"; "patch" !== c || i.attrs || (i.attrs = r); var u = this.sync(c, this, i); return this.attributes = l, u }, destroy: function (t) { t = t ? n.clone(t) : {}; var e = this, i = t.success, r = t.wait, o = function () { e.stopListening(), e.trigger("destroy", e, e.collection, t) }; t.success = function (n) { r && o(), i && i.call(t.context, e, n, t), e.isNew() || e.trigger("sync", e, n, t) }; var s = !1; return this.isNew() ? n.defer(t.success) : ($(this, t), s = this.sync("delete", this, t)), r || o(), s }, url: function () { var t = n.result(this, "urlRoot") || n.result(this.collection, "url") || F(); if (this.isNew()) return t; var e = this.get(this.idAttribute); return t.replace(/[^\/]$/, "$&/") + encodeURIComponent(e) }, parse: function (t, e) { return t }, clone: function () { return new this.constructor(this.attributes) }, isNew: function () { return !this.has(this.idAttribute) }, isValid: function (t) { return this._validate({}, n.defaults({ validate: !0 }, t)) }, _validate: function (t, e) { if (!e.validate || !this.validate) return !0; t = n.extend({}, this.attributes, t); var i = this.validationError = this.validate(t, e) || null; return !i || (this.trigger("invalid", this, i, n.extend(e, { validationError: i })), !1) } }), a(v, { keys: 1, values: 1, pairs: 1, invert: 1, pick: 0, omit: 0, chain: 1, isEmpty: 1 }, "attributes"); var y = e.Collection = function (t, e) { e || (e = {}), e.model && (this.model = e.model), void 0 !== e.comparator && (this.comparator = e.comparator), this._reset(), this.initialize.apply(this, arguments), t && this.reset(t, n.extend({ silent: !0 }, e)) }, b = { add: !0, remove: !0, merge: !0 }, x = { add: !0, remove: !1 }; n.extend(y.prototype, l, { model: v, initialize: function () { }, toJSON: function (t) { return this.map(function (e) { return e.toJSON(t) }) }, sync: function () { return e.sync.apply(this, arguments) }, add: function (t, e) { return this.set(t, n.extend({ merge: !1 }, e, x)) }, remove: function (t, e) { e = n.extend({}, e); var i = !n.isArray(t); t = i ? [t] : n.clone(t); var r = this._removeModels(t, e); return !e.silent && r && this.trigger("update", this, e), i ? r[0] : r }, set: function (t, e) { e = n.defaults({}, e, b), e.parse && !this._isModel(t) && (t = this.parse(t, e)); var i = !n.isArray(t); t = i ? t ? [t] : [] : t.slice(); var r, o, s, a, l, c = e.at; null != c && (c = +c), c < 0 && (c += this.length + 1); for (var u = this.comparator && null == c && !1 !== e.sort, h = n.isString(this.comparator) ? this.comparator : null, d = [], f = [], p = {}, g = e.add, m = e.merge, v = e.remove, y = !(u || !g || !v) && [], x = !1, w = 0; w < t.length; w++) { if (s = t[w], a = this.get(s)) v && (p[a.cid] = !0), m && s !== a && (s = this._isModel(s) ? s.attributes : s, e.parse && (s = a.parse(s, e)), a.set(s, e), u && !l && a.hasChanged(h) && (l = !0)), t[w] = a; else if (g) { if (!(o = t[w] = this._prepareModel(s, e))) continue; d.push(o), this._addReference(o, e) } o = a || o, o && (r = this.modelId(o.attributes), !y || !o.isNew() && p[r] || (y.push(o), x = x || !this.models[w] || o.cid !== this.models[w].cid), p[r] = !0) } if (v) { for (var w = 0; w < this.length; w++)p[(o = this.models[w]).cid] || f.push(o); f.length && this._removeModels(f, e) } if (d.length || x) if (u && (l = !0), this.length += d.length, null != c) for (var w = 0; w < d.length; w++)this.models.splice(c + w, 0, d[w]); else { y && (this.models.length = 0); for (var C = y || d, w = 0; w < C.length; w++)this.models.push(C[w]) } if (l && this.sort({ silent: !0 }), !e.silent) { for (var k = null != c ? n.clone(e) : e, w = 0; w < d.length; w++)null != c && (k.index = c + w), (o = d[w]).trigger("add", o, this, k); (l || x) && this.trigger("sort", this, e), (d.length || f.length) && this.trigger("update", this, e) } return i ? t[0] : t }, reset: function (t, e) { e = e ? n.clone(e) : {}; for (var i = 0; i < this.models.length; i++)this._removeReference(this.models[i], e); return e.previousModels = this.models, this._reset(), t = this.add(t, n.extend({ silent: !0 }, e)), e.silent || this.trigger("reset", this, e), t }, push: function (t, e) { return this.add(t, n.extend({ at: this.length }, e)) }, pop: function (t) { var e = this.at(this.length - 1); return this.remove(e, t) }, unshift: function (t, e) { return this.add(t, n.extend({ at: 0 }, e)) }, shift: function (t) { var e = this.at(0); return this.remove(e, t) }, slice: function () { return o.apply(this.models, arguments) }, get: function (t) { if (null != t) { var e = this.modelId(this._isModel(t) ? t.attributes : t); return this._byId[t] || this._byId[e] || this._byId[t.cid] } }, at: function (t) { return t < 0 && (t += this.length), this.models[t] }, where: function (t, e) { var i = n.matches(t); return this[e ? "find" : "filter"](function (t) { return i(t.attributes) }) }, findWhere: function (t) { return this.where(t, !0) }, sort: function (t) { if (!this.comparator) throw new Error("Cannot sort a set without a comparator"); return t || (t = {}), n.isString(this.comparator) || 1 === this.comparator.length ? this.models = this.sortBy(this.comparator, this) : this.models.sort(n.bind(this.comparator, this)), t.silent || this.trigger("sort", this, t), this }, pluck: function (t) { return n.invoke(this.models, "get", t) }, fetch: function (t) { t = n.extend({ parse: !0 }, t); var e = t.success, i = this; return t.success = function (n) { var r = t.reset ? "reset" : "set"; i[r](n, t), e && e.call(t.context, i, n, t), i.trigger("sync", i, n, t) }, $(this, t), this.sync("read", this, t) }, create: function (t, e) { e = e ? n.clone(e) : {}; var i = e.wait; if (!(t = this._prepareModel(t, e))) return !1; i || this.add(t, e); var r = this, o = e.success; return e.success = function (t, e, n) { i && r.add(t, n), o && o.call(n.context, t, e, n) }, t.save(null, e), t }, parse: function (t, e) { return t }, clone: function () { return new this.constructor(this.models, { model: this.model, comparator: this.comparator }) }, modelId: function (t) { return t[this.model.prototype.idAttribute || "id"] }, _reset: function () { this.length = 0, this.models = [], this._byId = {} }, _prepareModel: function (t, e) { if (this._isModel(t)) return t.collection || (t.collection = this), t; e = e ? n.clone(e) : {}, e.collection = this; var i = new this.model(t, e); return i.validationError ? (this.trigger("invalid", this, i.validationError, e), !1) : i }, _removeModels: function (t, e) { for (var n = [], i = 0; i < t.length; i++) { var r = this.get(t[i]); if (r) { var o = this.indexOf(r); this.models.splice(o, 1), this.length-- , e.silent || (e.index = o, r.trigger("remove", r, this, e)), n.push(r), this._removeReference(r, e) } } return !!n.length && n }, _isModel: function (t) { return t instanceof v }, _addReference: function (t, e) { this._byId[t.cid] = t; var n = this.modelId(t.attributes); null != n && (this._byId[n] = t), t.on("all", this._onModelEvent, this) }, _removeReference: function (t, e) { delete this._byId[t.cid]; var n = this.modelId(t.attributes); null != n && delete this._byId[n], this === t.collection && delete t.collection, t.off("all", this._onModelEvent, this) }, _onModelEvent: function (t, e, n, i) { if ("add" !== t && "remove" !== t || n === this) { if ("destroy" === t && this.remove(e, i), "change" === t) { var r = this.modelId(e.previousAttributes()), o = this.modelId(e.attributes); r !== o && (null != r && delete this._byId[r], null != o && (this._byId[o] = e)) } this.trigger.apply(this, arguments) } } }), a(y, { forEach: 3, each: 3, map: 3, collect: 3, reduce: 4, foldl: 4, inject: 4, reduceRight: 4, foldr: 4, find: 3, detect: 3, filter: 3, select: 3, reject: 3, every: 3, all: 3, some: 3, any: 3, include: 2, contains: 2, invoke: 0, max: 3, min: 3, toArray: 1, size: 1, first: 3, head: 3, take: 3, initial: 3, rest: 3, tail: 3, drop: 3, last: 3, without: 0, difference: 0, indexOf: 3, shuffle: 1, lastIndexOf: 3, isEmpty: 1, chain: 1, sample: 3, partition: 3 }, "models"); var w = ["groupBy", "countBy", "sortBy", "indexBy"]; n.each(w, function (t) { n[t] && (y.prototype[t] = function (e, i) { var r = n.isFunction(e) ? e : function (t) { return t.get(e) }; return n[t](this.models, r, i) }) }); var C = e.View = function (t) { this.cid = n.uniqueId("view"), n.extend(this, n.pick(t, S)), this._ensureElement(), this.initialize.apply(this, arguments) }, k = /^(\S+)\s*(.*)$/, S = ["model", "collection", "el", "id", "attributes", "className", "tagName", "events"]; n.extend(C.prototype, l, { tagName: "div", $: function (t) { return this.$el.find(t) }, initialize: function () { }, render: function () { return this }, remove: function () { return this._removeElement(), this.stopListening(), this }, _removeElement: function () { this.$el.remove() }, setElement: function (t) { return this.undelegateEvents(), this._setElement(t), this.delegateEvents(), this }, _setElement: function (t) { this.$el = t instanceof e.$ ? t : e.$(t), this.el = this.$el[0] }, delegateEvents: function (t) { if (t || (t = n.result(this, "events")), !t) return this; this.undelegateEvents(); for (var e in t) { var i = t[e]; if (n.isFunction(i) || (i = this[i]), i) { var r = e.match(k); this.delegate(r[1], r[2], n.bind(i, this)) } } return this }, delegate: function (t, e, n) { return this.$el.on(t + ".delegateEvents" + this.cid, e, n), this }, undelegateEvents: function () { return this.$el && this.$el.off(".delegateEvents" + this.cid), this }, undelegate: function (t, e, n) { return this.$el.off(t + ".delegateEvents" + this.cid, e, n), this }, _createElement: function (t) { return document.createElement(t) }, _ensureElement: function () { if (this.el) this.setElement(n.result(this, "el")); else { var t = n.extend({}, n.result(this, "attributes")); this.id && (t.id = n.result(this, "id")), this.className && (t.class = n.result(this, "className")), this.setElement(this._createElement(n.result(this, "tagName"))), this._setAttributes(t) } }, _setAttributes: function (t) { this.$el.attr(t) } }), e.sync = function (t, i, r) { var o = T[t]; n.defaults(r || (r = {}), { emulateHTTP: e.emulateHTTP, emulateJSON: e.emulateJSON }); var s = { type: o, dataType: "json" }; if (r.url || (s.url = n.result(i, "url") || F()), null != r.data || !i || "create" !== t && "update" !== t && "patch" !== t || (s.contentType = "application/json", s.data = JSON.stringify(r.attrs || i.toJSON(r))), r.emulateJSON && (s.contentType = "application/x-www-form-urlencoded", s.data = s.data ? { model: s.data } : {}), r.emulateHTTP && ("PUT" === o || "DELETE" === o || "PATCH" === o)) { s.type = "POST", r.emulateJSON && (s.data._method = o); var a = r.beforeSend; r.beforeSend = function (t) { if (t.setRequestHeader("X-HTTP-Method-Override", o), a) return a.apply(this, arguments) } } "GET" === s.type || r.emulateJSON || (s.processData = !1); var l = r.error; r.error = function (t, e, n) { r.textStatus = e, r.errorThrown = n, l && l.call(r.context, t, e, n) }; var c = r.xhr = e.ajax(n.extend(s, r)); return i.trigger("request", i, c, r), c }; var T = { create: "POST", update: "PUT", patch: "PATCH", delete: "DELETE", read: "GET" }; e.ajax = function () { return e.$.ajax.apply(e.$, arguments) }; var M = e.Router = function (t) { t || (t = {}), t.routes && (this.routes = t.routes), this._bindRoutes(), this.initialize.apply(this, arguments) }, E = /\((.*?)\)/g, P = /(\(\?)?:\w+/g, A = /\*\w+/g, L = /[\-{}\[\]+?.,\\\^$|#\s]/g; n.extend(M.prototype, l, { initialize: function () { }, route: function (t, i, r) { n.isRegExp(t) || (t = this._routeToRegExp(t)), n.isFunction(i) && (r = i, i = ""), r || (r = this[i]); var o = this; return e.history.route(t, function (n) { var s = o._extractParameters(t, n); !1 !== o.execute(r, s, i) && (o.trigger.apply(o, ["route:" + i].concat(s)), o.trigger("route", i, s), e.history.trigger("route", o, i, s)) }), this }, execute: function (t, e, n) { t && t.apply(this, e) }, navigate: function (t, n) { return e.history.navigate(t, n), this }, _bindRoutes: function () { if (this.routes) { this.routes = n.result(this, "routes"); for (var t, e = n.keys(this.routes); null != (t = e.pop());)this.route(t, this.routes[t]) } }, _routeToRegExp: function (t) { return t = t.replace(L, "\\$&").replace(E, "(?:$1)?").replace(P, function (t, e) { return e ? t : "([^/?]+)" }).replace(A, "([^?]*?)"), new RegExp("^" + t + "(?:\\?([\\s\\S]*))?$") }, _extractParameters: function (t, e) { var i = t.exec(e).slice(1); return n.map(i, function (t, e) { return e === i.length - 1 ? t || null : t ? decodeURIComponent(t) : null }) } }); var O = e.History = function () { this.handlers = [], n.bindAll(this, "checkUrl"), "undefined" != typeof window && (this.location = window.location, this.history = window.history) }, N = /^[#\/]|\s+$/g, D = /^\/+|\/+$/g, I = /#.*$/; O.started = !1, n.extend(O.prototype, l, { interval: 50, atRoot: function () { return this.location.pathname.replace(/[^\/]$/, "$&/") === this.root && !this.getSearch() }, matchRoot: function () { return this.decodeFragment(this.location.pathname).slice(0, this.root.length - 1) + "/" === this.root }, decodeFragment: function (t) { return decodeURI(t.replace(/%25/g, "%2525")) }, getSearch: function () { var t = this.location.href.replace(/#.*/, "").match(/\?.+/); return t ? t[0] : "" }, getHash: function (t) { var e = (t || this).location.href.match(/#(.*)$/); return e ? e[1] : "" }, getPath: function () { var t = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1); return "/" === t.charAt(0) ? t.slice(1) : t }, getFragment: function (t) { return null == t && (t = this._usePushState || !this._wantsHashChange ? this.getPath() : this.getHash()), t.replace(N, "") }, start: function (t) { if (O.started) throw new Error("Backbone.history has already been started"); if (O.started = !0, this.options = n.extend({ root: "/" }, this.options, t), this.root = this.options.root, this._wantsHashChange = !1 !== this.options.hashChange, this._hasHashChange = "onhashchange" in window, this._useHashChange = this._wantsHashChange && this._hasHashChange, this._wantsPushState = !!this.options.pushState, this._hasPushState = !(!this.history || !this.history.pushState), this._usePushState = this._wantsPushState && this._hasPushState, this.fragment = this.getFragment(), this.root = ("/" + this.root + "/").replace(D, "/"), this._wantsHashChange && this._wantsPushState) { if (!this._hasPushState && !this.atRoot()) { var e = this.root.slice(0, -1) || "/"; return this.location.replace(e + "#" + this.getPath()), !0 } this._hasPushState && this.atRoot() && this.navigate(this.getHash(), { replace: !0 }) } if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) { this.iframe = document.createElement("iframe"), this.iframe.src = "javascript:0", this.iframe.style.display = "none", this.iframe.tabIndex = -1; var i = document.body, r = i.insertBefore(this.iframe, i.firstChild).contentWindow; r.document.open(), r.document.close(), r.location.hash = "#" + this.fragment } var o = window.addEventListener || function (t, e) { return attachEvent("on" + t, e) }; if (this._usePushState ? o("popstate", this.checkUrl, !1) : this._useHashChange && !this.iframe ? o("hashchange", this.checkUrl, !1) : this._wantsHashChange && (this._checkUrlInterval = setInterval(this.checkUrl, this.interval)), !this.options.silent) return this.loadUrl() }, stop: function () { var t = window.removeEventListener || function (t, e) { return detachEvent("on" + t, e) }; this._usePushState ? t("popstate", this.checkUrl, !1) : this._useHashChange && !this.iframe && t("hashchange", this.checkUrl, !1), this.iframe && (document.body.removeChild(this.iframe), this.iframe = null), this._checkUrlInterval && clearInterval(this._checkUrlInterval), O.started = !1 }, route: function (t, e) { this.handlers.unshift({ route: t, callback: e }) }, checkUrl: function (t) { var e = this.getFragment(); if (e === this.fragment && this.iframe && (e = this.getHash(this.iframe.contentWindow)), e === this.fragment) return !1; this.iframe && this.navigate(e), this.loadUrl() }, loadUrl: function (t) { return !!this.matchRoot() && (t = this.fragment = this.getFragment(t), n.any(this.handlers, function (e) { if (e.route.test(t)) return e.callback(t), !0 })) }, navigate: function (t, e) { if (!O.started) return !1; e && !0 !== e || (e = { trigger: !!e }), t = this.getFragment(t || ""); var n = this.root; "" !== t && "?" !== t.charAt(0) || (n = n.slice(0, -1) || "/"); var i = n + t; if (t = this.decodeFragment(t.replace(I, "")), this.fragment !== t) { if (this.fragment = t, this._usePushState) this.history[e.replace ? "replaceState" : "pushState"]({}, document.title, i); else { if (!this._wantsHashChange) return this.location.assign(i); if (this._updateHash(this.location, t, e.replace), this.iframe && t !== this.getHash(this.iframe.contentWindow)) { var r = this.iframe.contentWindow; e.replace || (r.document.open(), r.document.close()), this._updateHash(r.location, t, e.replace) } } return e.trigger ? this.loadUrl(t) : void 0 } }, _updateHash: function (t, e, n) { if (n) { var i = t.href.replace(/(javascript:|#).*$/, ""); t.replace(i + "#" + e) } else t.hash = "#" + e } }), e.history = new O; var _ = function (t, e) { var i, r = this; i = t && n.has(t, "constructor") ? t.constructor : function () { return r.apply(this, arguments) }, n.extend(i, r, e); var o = function () { this.constructor = i }; return o.prototype = r.prototype, i.prototype = new o, t && n.extend(i.prototype, t), i.__super__ = r.prototype, i }; v.extend = y.extend = M.extend = C.extend = O.extend = _; var F = function () { throw new Error('A "url" property or function must be specified') }, $ = function (t, e) { var n = e.error; e.error = function (i) { n && n.call(e.context, t, i, e), t.trigger("error", t, i, e) } }; return e }) }).call(e, n(15)) }, function (t, e, n) { "use strict"; t.exports = function (t) { var e = t.$, n = t.Backbone; if (n) { var i = n.View.prototype, r = {}; i.eventNsMap = r, i.delegate = function (t, e, n) { var i = ".delegateEvents" + this.cid; this.$el.on(t, e, n); var o = r[i]; return o || (o = [], r[i] = o), o.push({ eventName: t, selector: e, listener: n }), this }, i.undelegateEvents = function () { var t = this, e = ".delegateEvents" + this.cid; if (this.$el) { var n = r[e]; n && n.forEach(function (e) { var n = e.eventName; e.selector, e.listener; t.$el.off(n) }) } return this }, i.undelegate = function (t, e, n) { var i = this, o = ".delegateEvents" + this.cid, s = r[o]; return s && s.forEach(function (n) { var r = n.eventName, o = n.selector; n.listener; r == t && o == e && i.$el.off(r) }), this } } if (e && "jQuery" !== e.prototype.constructor.name) { var o = e.fn, s = e.prototype.on, a = e.prototype.off, l = e.prototype.trigger, c = e.prototype.offset, u = function (t) { return t.split(/[,\s]+/g) }, h = function (t) { return t.split(".") }; o.on = function (t, e, n, i) { var r = this; if ("string" == typeof t) { var o = u(t); if (1 == o.length) { t = o[0]; var a = h(t); if (0 !== t.indexOf(".") && (t = a[0]), a = a.slice(1), a.length) { this.data("_cashNs"); this.data("_cashNs", a) } return s.call(this, t, e, n, i) } return o.forEach(function (t) { return r.on(t, e, n, i) }), this } return s.call(this, t, e, n, i) }, o.off = function (t, e) { var n = this; if ("string" == typeof t) { var i = u(t); if (1 == i.length) { t = i[0]; var r = h(t); return 0 !== t.indexOf(".") && (t = r[0]), r = r.slice(1), r.length, a.call(this, t, e) } return i.forEach(function (t) { return n.off(t, e) }), this } return a.call(this, t, e) }, o.trigger = function (t, n) { var i = this; if (t instanceof e.Event) return this.trigger(t.type, n); if ("string" == typeof t) { var r = u(t); if (1 == r.length) { t = r[0]; var o = h(t); return 0 !== t.indexOf(".") && (t = o[0]), o = o.slice(1), o.length, l.call(this, t, n) } return r.forEach(function (t) { return i.trigger(t, n) }), this } return l.call(this, t, n) }, o.hide = function () { return this.css("display", "none") }, o.show = function () { return this.css("display", "block") }, o.focus = function () { var t = this.get(0); return t && t.focus(), this }, o.remove = function () { return this.each(function (t) { return t.parentNode && t.parentNode.removeChild(t) }) }, o.bind = function (t, e) { return this.on(t, e) }, o.unbind = function (t, e) { return this.off(t, e) }, o.click = function (t) { return t ? this.on("click", t) : this.trigger("click") }, o.change = function (t) { return t ? this.on("change", t) : this.trigger("change") }, o.keydown = function (t) { return t ? this.on("keydown", t) : this.trigger("keydown") }, o.delegate = function (t, e, n, i) { return i || (i = n), this.on(e, t, function (t) { t.data = n, i(t) }) }, o.scrollLeft = function () { var t = this.get(0); t = 9 == t.nodeType ? t.defaultView : t; var e = t instanceof Window ? t : null; return e ? e.pageXOffset : t.scrollLeft || 0 }, o.scrollTop = function () { var t = this.get(0); t = 9 == t.nodeType ? t.defaultView : t; var e = t instanceof Window ? t : null; return e ? e.pageYOffset : t.scrollTop || 0 }, o.offset = function (t) { var e = void 0, n = void 0; return t && (e = t.top, n = t.left), void 0 !== e && this.css("top", e + "px"), void 0 !== n && this.css("left", n + "px"), c.call(this) }, e.map = function (t, e) { for (var n = [], i = 0; i < t.length; i++)n.push(e(t[i], i)); return n }; var d = Array.prototype.indexOf; e.inArray = function (t, e, n) { return null == e ? -1 : d.call(e, t, n) }, e.Event = function (t, n) { if (!(this instanceof e.Event)) return new e.Event(t, n); this.type = t, this.isDefaultPrevented = function () { return !1 } } } } }, function (t, e, n) { "use strict"; (function (e) { var n = e.$; t.exports = e.View.extend({ initialize: function () { var t = this, e = this.model; e.view = this, this.conf = e.config, this.pn = e.get("Panels"), e.on("loaded", function () { t.pn.active(), t.pn.disableButtons(), e.runDefault(), setTimeout(function () { return e.trigger("load") }, 0) }) }, render: function () { var t = this.model, e = this.$el, i = this.conf, r = n(i.el || "body " + i.container), o = i.stylePrefix; return e.empty(), i.width && r.css("width", i.width), i.height && r.css("height", i.height), e.append(t.get("Canvas").render()), e.append(this.pn.render()), e.attr("class", o + "editor"), r.addClass(o + "editor-cont").empty().append(e), this } }) }).call(e, n(0)) }, function (t, e, n) { "use strict"; t.exports = function (t) { var e = t || {}, i = n(213); for (var r in i) r in e || (e[r] = i[r]); var o = {}; return { add: function (t, e) { return o[t] ? o[t] : (o[t] = e, e) }, get: function (t) { return o[t] }, getAll: function () { return o } } } }, function (t, e, n) { "use strict"; t.exports = { plugins: [] } }])
});
/*! grapesjs-preset-newsletter - 0.2.15 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports["grapesjs-preset-newsletter"]=e():t["grapesjs-preset-newsletter"]=e()}(this,function(){return function(t){function e(n){if(r[n])return r[n].exports;var i=r[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,e),i.l=!0,i.exports}var r={};return e.m=t,e.c=r,e.d=function(t,r,n){e.o(t,r)||Object.defineProperty(t,r,{configurable:!1,enumerable:!0,get:n})},e.n=function(t){var r=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(r,"a",r),r},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=46)}([function(t,e){var r;r=function(){return this}();try{r=r||Function("return this")()||(0,eval)("this")}catch(t){"object"==typeof window&&(r=window)}t.exports=r},function(t,e){"function"==typeof Object.create?t.exports=function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})}:t.exports=function(t,e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}},function(t,e,r){"use strict";function n(t){if(!(this instanceof n))return new n(t);c.call(this,t),l.call(this,t),t&&!1===t.readable&&(this.readable=!1),t&&!1===t.writable&&(this.writable=!1),this.allowHalfOpen=!0,t&&!1===t.allowHalfOpen&&(this.allowHalfOpen=!1),this.once("end",i)}function i(){this.allowHalfOpen||this._writableState.ended||a(o,this)}function o(t){t.end()}var a=r(14),s=Object.keys||function(t){var e=[];for(var r in t)e.push(r);return e};t.exports=n;var u=r(9);u.inherits=r(1);var c=r(36),l=r(21);u.inherits(n,c);for(var f=s(l.prototype),h=0;h<f.length;h++){var p=f[h];n.prototype[p]||(n.prototype[p]=l.prototype[p])}Object.defineProperty(n.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed&&this._writableState.destroyed)},set:function(t){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=t,this._writableState.destroyed=t)}}),n.prototype._destroy=function(t,e){this.push(null),this.end(),a(e,t)}},function(t,e,r){function n(e,r){return delete t.exports[e],t.exports[e]=r,r}var i=r(30),o=r(56);t.exports={Parser:i,Tokenizer:r(31),ElementType:r(7),DomHandler:o,get FeedHandler(){return n("FeedHandler",r(58))},get Stream(){return n("Stream",r(59))},get WritableStream(){return n("WritableStream",r(35))},get ProxyHandler(){return n("ProxyHandler",r(72))},get DomUtils(){return n("DomUtils",r(4))},get CollectingHandler(){return n("CollectingHandler",r(83))},DefaultHandler:o,get RssHandler(){return n("RssHandler",this.FeedHandler)},parseDOM:function(t,e){var r=new o(e);return new i(r,e).end(t),r.dom},parseFeed:function(e,r){var n=new t.exports.FeedHandler(r);return new i(n,r).end(e),n.dom},createDomStream:function(t,e,r){var n=new o(t,e,r);return new i(n,e)},EVENTS:{attribute:2,cdatastart:0,cdataend:0,text:1,processinginstruction:2,comment:1,commentend:0,closetag:1,opentag:2,opentagname:1,error:1,end:0}}},function(t,e,r){var n=t.exports;[r(73),r(78),r(79),r(80),r(81),r(82)].forEach(function(t){Object.keys(t).forEach(function(e){n[e]=t[e].bind(n)})})},function(t,e){t.exports=function(t){return t.webpackPolyfill||(t.deprecate=function(){},t.paths=[],t.children||(t.children=[]),Object.defineProperty(t,"loaded",{enumerable:!0,get:function(){return t.l}}),Object.defineProperty(t,"id",{enumerable:!0,get:function(){return t.i}}),t.webpackPolyfill=1),t}},function(t,e,r){"use strict";(function(t){function n(){return o.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function i(t,e){if(n()<e)throw new RangeError("Invalid typed array length");return o.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(e),t.__proto__=o.prototype):(null===t&&(t=new o(e)),t.length=e),t}function o(t,e,r){if(!(o.TYPED_ARRAY_SUPPORT||this instanceof o))return new o(t,e,r);if("number"==typeof t){if("string"==typeof e)throw new Error("If encoding is specified then the first argument must be a string");return c(this,t)}return a(this,t,e,r)}function a(t,e,r,n){if("number"==typeof e)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer?h(t,e,r,n):"string"==typeof e?l(t,e,r):p(t,e)}function s(t){if("number"!=typeof t)throw new TypeError('"size" argument must be a number');if(t<0)throw new RangeError('"size" argument must not be negative')}function u(t,e,r,n){return s(e),e<=0?i(t,e):void 0!==r?"string"==typeof n?i(t,e).fill(r,n):i(t,e).fill(r):i(t,e)}function c(t,e){if(s(e),t=i(t,e<0?0:0|d(e)),!o.TYPED_ARRAY_SUPPORT)for(var r=0;r<e;++r)t[r]=0;return t}function l(t,e,r){if("string"==typeof r&&""!==r||(r="utf8"),!o.isEncoding(r))throw new TypeError('"encoding" must be a valid string encoding');var n=0|v(e,r);t=i(t,n);var a=t.write(e,r);return a!==n&&(t=t.slice(0,a)),t}function f(t,e){var r=e.length<0?0:0|d(e.length);t=i(t,r);for(var n=0;n<r;n+=1)t[n]=255&e[n];return t}function h(t,e,r,n){if(e.byteLength,r<0||e.byteLength<r)throw new RangeError("'offset' is out of bounds");if(e.byteLength<r+(n||0))throw new RangeError("'length' is out of bounds");return e=void 0===r&&void 0===n?new Uint8Array(e):void 0===n?new Uint8Array(e,r):new Uint8Array(e,r,n),o.TYPED_ARRAY_SUPPORT?(t=e,t.__proto__=o.prototype):t=f(t,e),t}function p(t,e){if(o.isBuffer(e)){var r=0|d(e.length);return t=i(t,r),0===t.length?t:(e.copy(t,0,0,r),t)}if(e){if("undefined"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer||"length"in e)return"number"!=typeof e.length||J(e.length)?i(t,0):f(t,e);if("Buffer"===e.type&&Z(e.data))return f(t,e.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}function d(t){if(t>=n())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+n().toString(16)+" bytes");return 0|t}function g(t){return+t!=t&&(t=0),o.alloc(+t)}function v(t,e){if(o.isBuffer(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var r=t.length;if(0===r)return 0;for(var n=!1;;)switch(e){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return z(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return G(t).length;default:if(n)return z(t).length;e=(""+e).toLowerCase(),n=!0}}function y(t,e,r){var n=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if(r>>>=0,e>>>=0,r<=e)return"";for(t||(t="utf8");;)switch(t){case"hex":return B(this,e,r);case"utf8":case"utf-8":return T(this,e,r);case"ascii":return L(this,e,r);case"latin1":case"binary":return C(this,e,r);case"base64":return E(this,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return D(this,e,r);default:if(n)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),n=!0}}function b(t,e,r){var n=t[e];t[e]=t[r],t[r]=n}function m(t,e,r,n,i){if(0===t.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=i?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(i)return-1;r=t.length-1}else if(r<0){if(!i)return-1;r=0}if("string"==typeof e&&(e=o.from(e,n)),o.isBuffer(e))return 0===e.length?-1:_(t,e,r,n,i);if("number"==typeof e)return e&=255,o.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):_(t,[e],r,n,i);throw new TypeError("val must be string, number or Buffer")}function _(t,e,r,n,i){function o(t,e){return 1===a?t[e]:t.readUInt16BE(e*a)}var a=1,s=t.length,u=e.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(t.length<2||e.length<2)return-1;a=2,s/=2,u/=2,r/=2}var c;if(i){var l=-1;for(c=r;c<s;c++)if(o(t,c)===o(e,-1===l?0:c-l)){if(-1===l&&(l=c),c-l+1===u)return l*a}else-1!==l&&(c-=c-l),l=-1}else for(r+u>s&&(r=s-u),c=r;c>=0;c--){for(var f=!0,h=0;h<u;h++)if(o(t,c+h)!==o(e,h)){f=!1;break}if(f)return c}return-1}function w(t,e,r,n){r=Number(r)||0;var i=t.length-r;n?(n=Number(n))>i&&(n=i):n=i;var o=e.length;if(o%2!=0)throw new TypeError("Invalid hex string");n>o/2&&(n=o/2);for(var a=0;a<n;++a){var s=parseInt(e.substr(2*a,2),16);if(isNaN(s))return a;t[r+a]=s}return a}function x(t,e,r,n){return Y(z(e,t.length-r),t,r,n)}function S(t,e,r,n){return Y(H(e),t,r,n)}function j(t,e,r,n){return S(t,e,r,n)}function k(t,e,r,n){return Y(G(e),t,r,n)}function A(t,e,r,n){return Y(W(e,t.length-r),t,r,n)}function E(t,e,r){return 0===e&&r===t.length?Q.fromByteArray(t):Q.fromByteArray(t.slice(e,r))}function T(t,e,r){r=Math.min(t.length,r);for(var n=[],i=e;i<r;){var o=t[i],a=null,s=o>239?4:o>223?3:o>191?2:1;if(i+s<=r){var u,c,l,f;switch(s){case 1:o<128&&(a=o);break;case 2:u=t[i+1],128==(192&u)&&(f=(31&o)<<6|63&u)>127&&(a=f);break;case 3:u=t[i+1],c=t[i+2],128==(192&u)&&128==(192&c)&&(f=(15&o)<<12|(63&u)<<6|63&c)>2047&&(f<55296||f>57343)&&(a=f);break;case 4:u=t[i+1],c=t[i+2],l=t[i+3],128==(192&u)&&128==(192&c)&&128==(192&l)&&(f=(15&o)<<18|(63&u)<<12|(63&c)<<6|63&l)>65535&&f<1114112&&(a=f)}}null===a?(a=65533,s=1):a>65535&&(a-=65536,n.push(a>>>10&1023|55296),a=56320|1023&a),n.push(a),i+=s}return O(n)}function O(t){var e=t.length;if(e<=K)return String.fromCharCode.apply(String,t);for(var r="",n=0;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=K));return r}function L(t,e,r){var n="";r=Math.min(t.length,r);for(var i=e;i<r;++i)n+=String.fromCharCode(127&t[i]);return n}function C(t,e,r){var n="";r=Math.min(t.length,r);for(var i=e;i<r;++i)n+=String.fromCharCode(t[i]);return n}function B(t,e,r){var n=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>n)&&(r=n);for(var i="",o=e;o<r;++o)i+=$(t[o]);return i}function D(t,e,r){for(var n=t.slice(e,r),i="",o=0;o<n.length;o+=2)i+=String.fromCharCode(n[o]+256*n[o+1]);return i}function R(t,e,r){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+e>r)throw new RangeError("Trying to access beyond buffer length")}function P(t,e,r,n,i,a){if(!o.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(e>i||e<a)throw new RangeError('"value" argument is out of bounds');if(r+n>t.length)throw new RangeError("Index out of range")}function q(t,e,r,n){e<0&&(e=65535+e+1);for(var i=0,o=Math.min(t.length-r,2);i<o;++i)t[r+i]=(e&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function M(t,e,r,n){e<0&&(e=4294967295+e+1);for(var i=0,o=Math.min(t.length-r,4);i<o;++i)t[r+i]=e>>>8*(n?i:3-i)&255}function I(t,e,r,n,i,o){if(r+n>t.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function N(t,e,r,n,i){return i||I(t,e,r,4,3.4028234663852886e38,-3.4028234663852886e38),X.write(t,e,r,n,23,4),r+4}function U(t,e,r,n,i){return i||I(t,e,r,8,1.7976931348623157e308,-1.7976931348623157e308),X.write(t,e,r,n,52,8),r+8}function F(t){if(t=V(t).replace(tt,""),t.length<2)return"";for(;t.length%4!=0;)t+="=";return t}function V(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")}function $(t){return t<16?"0"+t.toString(16):t.toString(16)}function z(t,e){e=e||1/0;for(var r,n=t.length,i=null,o=[],a=0;a<n;++a){if((r=t.charCodeAt(a))>55295&&r<57344){if(!i){if(r>56319){(e-=3)>-1&&o.push(239,191,189);continue}if(a+1===n){(e-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(e-=3)>-1&&o.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(e-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((e-=1)<0)break;o.push(r)}else if(r<2048){if((e-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(r<65536){if((e-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function H(t){for(var e=[],r=0;r<t.length;++r)e.push(255&t.charCodeAt(r));return e}function W(t,e){for(var r,n,i,o=[],a=0;a<t.length&&!((e-=2)<0);++a)r=t.charCodeAt(a),n=r>>8,i=r%256,o.push(i),o.push(n);return o}function G(t){return Q.toByteArray(F(t))}function Y(t,e,r,n){for(var i=0;i<n&&!(i+r>=e.length||i>=t.length);++i)e[i+r]=t[i];return i}function J(t){return t!==t}/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var Q=r(53),X=r(54),Z=r(29);e.Buffer=o,e.SlowBuffer=g,e.INSPECT_MAX_BYTES=50,o.TYPED_ARRAY_SUPPORT=void 0!==t.TYPED_ARRAY_SUPPORT?t.TYPED_ARRAY_SUPPORT:function(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()&&"function"==typeof t.subarray&&0===t.subarray(1,1).byteLength}catch(t){return!1}}(),e.kMaxLength=n(),o.poolSize=8192,o._augment=function(t){return t.__proto__=o.prototype,t},o.from=function(t,e,r){return a(null,t,e,r)},o.TYPED_ARRAY_SUPPORT&&(o.prototype.__proto__=Uint8Array.prototype,o.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&o[Symbol.species]===o&&Object.defineProperty(o,Symbol.species,{value:null,configurable:!0})),o.alloc=function(t,e,r){return u(null,t,e,r)},o.allocUnsafe=function(t){return c(null,t)},o.allocUnsafeSlow=function(t){return c(null,t)},o.isBuffer=function(t){return!(null==t||!t._isBuffer)},o.compare=function(t,e){if(!o.isBuffer(t)||!o.isBuffer(e))throw new TypeError("Arguments must be Buffers");if(t===e)return 0;for(var r=t.length,n=e.length,i=0,a=Math.min(r,n);i<a;++i)if(t[i]!==e[i]){r=t[i],n=e[i];break}return r<n?-1:n<r?1:0},o.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},o.concat=function(t,e){if(!Z(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return o.alloc(0);var r;if(void 0===e)for(e=0,r=0;r<t.length;++r)e+=t[r].length;var n=o.allocUnsafe(e),i=0;for(r=0;r<t.length;++r){var a=t[r];if(!o.isBuffer(a))throw new TypeError('"list" argument must be an Array of Buffers');a.copy(n,i),i+=a.length}return n},o.byteLength=v,o.prototype._isBuffer=!0,o.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var e=0;e<t;e+=2)b(this,e,e+1);return this},o.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var e=0;e<t;e+=4)b(this,e,e+3),b(this,e+1,e+2);return this},o.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var e=0;e<t;e+=8)b(this,e,e+7),b(this,e+1,e+6),b(this,e+2,e+5),b(this,e+3,e+4);return this},o.prototype.toString=function(){var t=0|this.length;return 0===t?"":0===arguments.length?T(this,0,t):y.apply(this,arguments)},o.prototype.equals=function(t){if(!o.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===o.compare(this,t)},o.prototype.inspect=function(){var t="",r=e.INSPECT_MAX_BYTES;return this.length>0&&(t=this.toString("hex",0,r).match(/.{2}/g).join(" "),this.length>r&&(t+=" ... ")),"<Buffer "+t+">"},o.prototype.compare=function(t,e,r,n,i){if(!o.isBuffer(t))throw new TypeError("Argument must be a Buffer");if(void 0===e&&(e=0),void 0===r&&(r=t?t.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),e<0||r>t.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&e>=r)return 0;if(n>=i)return-1;if(e>=r)return 1;if(e>>>=0,r>>>=0,n>>>=0,i>>>=0,this===t)return 0;for(var a=i-n,s=r-e,u=Math.min(a,s),c=this.slice(n,i),l=t.slice(e,r),f=0;f<u;++f)if(c[f]!==l[f]){a=c[f],s=l[f];break}return a<s?-1:s<a?1:0},o.prototype.includes=function(t,e,r){return-1!==this.indexOf(t,e,r)},o.prototype.indexOf=function(t,e,r){return m(this,t,e,r,!0)},o.prototype.lastIndexOf=function(t,e,r){return m(this,t,e,r,!1)},o.prototype.write=function(t,e,r,n){if(void 0===e)n="utf8",r=this.length,e=0;else if(void 0===r&&"string"==typeof e)n=e,r=this.length,e=0;else{if(!isFinite(e))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");e|=0,isFinite(r)?(r|=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}var i=this.length-e;if((void 0===r||r>i)&&(r=i),t.length>0&&(r<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var o=!1;;)switch(n){case"hex":return w(this,t,e,r);case"utf8":case"utf-8":return x(this,t,e,r);case"ascii":return S(this,t,e,r);case"latin1":case"binary":return j(this,t,e,r);case"base64":return k(this,t,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return A(this,t,e,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}},o.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var K=4096;o.prototype.slice=function(t,e){var r=this.length;t=~~t,e=void 0===e?r:~~e,t<0?(t+=r)<0&&(t=0):t>r&&(t=r),e<0?(e+=r)<0&&(e=0):e>r&&(e=r),e<t&&(e=t);var n;if(o.TYPED_ARRAY_SUPPORT)n=this.subarray(t,e),n.__proto__=o.prototype;else{var i=e-t;n=new o(i,void 0);for(var a=0;a<i;++a)n[a]=this[a+t]}return n},o.prototype.readUIntLE=function(t,e,r){t|=0,e|=0,r||R(t,e,this.length);for(var n=this[t],i=1,o=0;++o<e&&(i*=256);)n+=this[t+o]*i;return n},o.prototype.readUIntBE=function(t,e,r){t|=0,e|=0,r||R(t,e,this.length);for(var n=this[t+--e],i=1;e>0&&(i*=256);)n+=this[t+--e]*i;return n},o.prototype.readUInt8=function(t,e){return e||R(t,1,this.length),this[t]},o.prototype.readUInt16LE=function(t,e){return e||R(t,2,this.length),this[t]|this[t+1]<<8},o.prototype.readUInt16BE=function(t,e){return e||R(t,2,this.length),this[t]<<8|this[t+1]},o.prototype.readUInt32LE=function(t,e){return e||R(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},o.prototype.readUInt32BE=function(t,e){return e||R(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},o.prototype.readIntLE=function(t,e,r){t|=0,e|=0,r||R(t,e,this.length);for(var n=this[t],i=1,o=0;++o<e&&(i*=256);)n+=this[t+o]*i;return i*=128,n>=i&&(n-=Math.pow(2,8*e)),n},o.prototype.readIntBE=function(t,e,r){t|=0,e|=0,r||R(t,e,this.length);for(var n=e,i=1,o=this[t+--n];n>0&&(i*=256);)o+=this[t+--n]*i;return i*=128,o>=i&&(o-=Math.pow(2,8*e)),o},o.prototype.readInt8=function(t,e){return e||R(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},o.prototype.readInt16LE=function(t,e){e||R(t,2,this.length);var r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},o.prototype.readInt16BE=function(t,e){e||R(t,2,this.length);var r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},o.prototype.readInt32LE=function(t,e){return e||R(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},o.prototype.readInt32BE=function(t,e){return e||R(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},o.prototype.readFloatLE=function(t,e){return e||R(t,4,this.length),X.read(this,t,!0,23,4)},o.prototype.readFloatBE=function(t,e){return e||R(t,4,this.length),X.read(this,t,!1,23,4)},o.prototype.readDoubleLE=function(t,e){return e||R(t,8,this.length),X.read(this,t,!0,52,8)},o.prototype.readDoubleBE=function(t,e){return e||R(t,8,this.length),X.read(this,t,!1,52,8)},o.prototype.writeUIntLE=function(t,e,r,n){if(t=+t,e|=0,r|=0,!n){P(this,t,e,r,Math.pow(2,8*r)-1,0)}var i=1,o=0;for(this[e]=255&t;++o<r&&(i*=256);)this[e+o]=t/i&255;return e+r},o.prototype.writeUIntBE=function(t,e,r,n){if(t=+t,e|=0,r|=0,!n){P(this,t,e,r,Math.pow(2,8*r)-1,0)}var i=r-1,o=1;for(this[e+i]=255&t;--i>=0&&(o*=256);)this[e+i]=t/o&255;return e+r},o.prototype.writeUInt8=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,1,255,0),o.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[e]=255&t,e+1},o.prototype.writeUInt16LE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,2,65535,0),o.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):q(this,t,e,!0),e+2},o.prototype.writeUInt16BE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,2,65535,0),o.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):q(this,t,e,!1),e+2},o.prototype.writeUInt32LE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,4,4294967295,0),o.TYPED_ARRAY_SUPPORT?(this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t):M(this,t,e,!0),e+4},o.prototype.writeUInt32BE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,4,4294967295,0),o.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):M(this,t,e,!1),e+4},o.prototype.writeIntLE=function(t,e,r,n){if(t=+t,e|=0,!n){var i=Math.pow(2,8*r-1);P(this,t,e,r,i-1,-i)}var o=0,a=1,s=0;for(this[e]=255&t;++o<r&&(a*=256);)t<0&&0===s&&0!==this[e+o-1]&&(s=1),this[e+o]=(t/a>>0)-s&255;return e+r},o.prototype.writeIntBE=function(t,e,r,n){if(t=+t,e|=0,!n){var i=Math.pow(2,8*r-1);P(this,t,e,r,i-1,-i)}var o=r-1,a=1,s=0;for(this[e+o]=255&t;--o>=0&&(a*=256);)t<0&&0===s&&0!==this[e+o+1]&&(s=1),this[e+o]=(t/a>>0)-s&255;return e+r},o.prototype.writeInt8=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,1,127,-128),o.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[e]=255&t,e+1},o.prototype.writeInt16LE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,2,32767,-32768),o.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):q(this,t,e,!0),e+2},o.prototype.writeInt16BE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,2,32767,-32768),o.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):q(this,t,e,!1),e+2},o.prototype.writeInt32LE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,4,2147483647,-2147483648),o.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24):M(this,t,e,!0),e+4},o.prototype.writeInt32BE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),o.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):M(this,t,e,!1),e+4},o.prototype.writeFloatLE=function(t,e,r){return N(this,t,e,!0,r)},o.prototype.writeFloatBE=function(t,e,r){return N(this,t,e,!1,r)},o.prototype.writeDoubleLE=function(t,e,r){return U(this,t,e,!0,r)},o.prototype.writeDoubleBE=function(t,e,r){return U(this,t,e,!1,r)},o.prototype.copy=function(t,e,r,n){if(r||(r=0),n||0===n||(n=this.length),e>=t.length&&(e=t.length),e||(e=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),t.length-e<n-r&&(n=t.length-e+r);var i,a=n-r;if(this===t&&r<e&&e<n)for(i=a-1;i>=0;--i)t[i+e]=this[i+r];else if(a<1e3||!o.TYPED_ARRAY_SUPPORT)for(i=0;i<a;++i)t[i+e]=this[i+r];else Uint8Array.prototype.set.call(t,this.subarray(r,r+a),e);return a},o.prototype.fill=function(t,e,r,n){if("string"==typeof t){if("string"==typeof e?(n=e,e=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),1===t.length){var i=t.charCodeAt(0);i<256&&(t=i)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!o.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<r)throw new RangeError("Out of range index");if(r<=e)return this;e>>>=0,r=void 0===r?this.length:r>>>0,t||(t=0);var a;if("number"==typeof t)for(a=e;a<r;++a)this[a]=t;else{var s=o.isBuffer(t)?t:z(new o(t,n).toString()),u=s.length;for(a=0;a<r-e;++a)this[a+e]=s[a%u]}return this};var tt=/[^+\/0-9A-Za-z-_]/g}).call(e,r(0))},function(t,e){t.exports={Text:"text",Directive:"directive",Comment:"comment",Script:"script",Style:"style",Tag:"tag",CDATA:"cdata",Doctype:"doctype",isTag:function(t){return"tag"===t.type||"script"===t.type||"style"===t.type}}},function(t,e){function r(){throw new Error("setTimeout has not been defined")}function n(){throw new Error("clearTimeout has not been defined")}function i(t){if(l===setTimeout)return setTimeout(t,0);if((l===r||!l)&&setTimeout)return l=setTimeout,setTimeout(t,0);try{return l(t,0)}catch(e){try{return l.call(null,t,0)}catch(e){return l.call(this,t,0)}}}function o(t){if(f===clearTimeout)return clearTimeout(t);if((f===n||!f)&&clearTimeout)return f=clearTimeout,clearTimeout(t);try{return f(t)}catch(e){try{return f.call(null,t)}catch(e){return f.call(this,t)}}}function a(){g&&p&&(g=!1,p.length?d=p.concat(d):v=-1,d.length&&s())}function s(){if(!g){var t=i(a);g=!0;for(var e=d.length;e;){for(p=d,d=[];++v<e;)p&&p[v].run();v=-1,e=d.length}p=null,g=!1,o(t)}}function u(t,e){this.fun=t,this.array=e}function c(){}var l,f,h=t.exports={};!function(){try{l="function"==typeof setTimeout?setTimeout:r}catch(t){l=r}try{f="function"==typeof clearTimeout?clearTimeout:n}catch(t){f=n}}();var p,d=[],g=!1,v=-1;h.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];d.push(new u(t,e)),1!==d.length||g||i(s)},u.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=c,h.addListener=c,h.once=c,h.off=c,h.removeListener=c,h.removeAllListeners=c,h.emit=c,h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,e,r){(function(t){function r(t){return Array.isArray?Array.isArray(t):"[object Array]"===v(t)}function n(t){return"boolean"==typeof t}function i(t){return null===t}function o(t){return null==t}function a(t){return"number"==typeof t}function s(t){return"string"==typeof t}function u(t){return"symbol"==typeof t}function c(t){return void 0===t}function l(t){return"[object RegExp]"===v(t)}function f(t){return"object"==typeof t&&null!==t}function h(t){return"[object Date]"===v(t)}function p(t){return"[object Error]"===v(t)||t instanceof Error}function d(t){return"function"==typeof t}function g(t){return null===t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||"symbol"==typeof t||void 0===t}function v(t){return Object.prototype.toString.call(t)}e.isArray=r,e.isBoolean=n,e.isNull=i,e.isNullOrUndefined=o,e.isNumber=a,e.isString=s,e.isSymbol=u,e.isUndefined=c,e.isRegExp=l,e.isObject=f,e.isDate=h,e.isError=p,e.isFunction=d,e.isPrimitive=g,e.isBuffer=t.isBuffer}).call(e,r(6).Buffer)},function(t,e,r){var n=r(12),i=r(23),o={tag:!0,script:!0,style:!0};e.isTag=function(t){return t.type&&(t=t.type),o[t]||!1},e.camelCase=function(t){return t.replace(/[_.-](\w|$)/g,function(t,e){return e.toUpperCase()})},e.cssCase=function(t){return t.replace(/[A-Z]/g,"-$&").toLowerCase()},e.domEach=function(t,e){for(var r=0,n=t.length;r<n&&!1!==e.call(t,r,t[r]);)++r;return t},e.cloneDom=function(t,e){return n(i(t,e),e).children};var a=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/;e.isHtml=function(t){if("<"===t.charAt(0)&&">"===t.charAt(t.length-1)&&t.length>=3)return!0;var e=a.exec(t);return!(!e||!e[1])}},function(t,e){t.exports={trueFunc:function(){return!0},falseFunc:function(){return!1}}},function(t,e,r){(function(n){var i=r(3);e=t.exports=function(t,r){var n=e.evaluate(t,r),i=e.evaluate("<root></root>",r)[0];return i.type="root",e.update(n,i),i},e.evaluate=function(t,e){return"string"==typeof t||n.isBuffer(t)?i.parseDOM(t,e):t},e.update=function(t,e){Array.isArray(t)||(t=[t]),e?e.children=t:e=null;for(var r=0;r<t.length;r++){var n=t[r],i=n.parent||n.root,o=i&&i.children;o&&o!==t&&(o.splice(o.indexOf(n),1),n.prev&&(n.prev.next=n.next),n.next&&(n.next.prev=n.prev)),e?(n.prev=t[r-1]||null,n.next=t[r+1]||null):n.prev=n.next=null,e&&"root"===e.type?(n.root=e,n.parent=null):(n.root=null,n.parent=e)}return e}}).call(e,r(6).Buffer)},function(t,e){function r(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0}function n(t){return"function"==typeof t}function i(t){return"number"==typeof t}function o(t){return"object"==typeof t&&null!==t}function a(t){return void 0===t}t.exports=r,r.EventEmitter=r,r.prototype._events=void 0,r.prototype._maxListeners=void 0,r.defaultMaxListeners=10,r.prototype.setMaxListeners=function(t){if(!i(t)||t<0||isNaN(t))throw TypeError("n must be a positive number");return this._maxListeners=t,this},r.prototype.emit=function(t){var e,r,i,s,u,c;if(this._events||(this._events={}),"error"===t&&(!this._events.error||o(this._events.error)&&!this._events.error.length)){if((e=arguments[1])instanceof Error)throw e;var l=new Error('Uncaught, unspecified "error" event. ('+e+")");throw l.context=e,l}if(r=this._events[t],a(r))return!1;if(n(r))switch(arguments.length){case 1:r.call(this);break;case 2:r.call(this,arguments[1]);break;case 3:r.call(this,arguments[1],arguments[2]);break;default:s=Array.prototype.slice.call(arguments,1),r.apply(this,s)}else if(o(r))for(s=Array.prototype.slice.call(arguments,1),c=r.slice(),i=c.length,u=0;u<i;u++)c[u].apply(this,s);return!0},r.prototype.addListener=function(t,e){var i;if(!n(e))throw TypeError("listener must be a function");return this._events||(this._events={}),this._events.newListener&&this.emit("newListener",t,n(e.listener)?e.listener:e),this._events[t]?o(this._events[t])?this._events[t].push(e):this._events[t]=[this._events[t],e]:this._events[t]=e,o(this._events[t])&&!this._events[t].warned&&(i=a(this._maxListeners)?r.defaultMaxListeners:this._maxListeners)&&i>0&&this._events[t].length>i&&(this._events[t].warned=!0,console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",this._events[t].length),"function"==typeof console.trace&&console.trace()),this},r.prototype.on=r.prototype.addListener,r.prototype.once=function(t,e){function r(){this.removeListener(t,r),i||(i=!0,e.apply(this,arguments))}if(!n(e))throw TypeError("listener must be a function");var i=!1;return r.listener=e,this.on(t,r),this},r.prototype.removeListener=function(t,e){var r,i,a,s;if(!n(e))throw TypeError("listener must be a function");if(!this._events||!this._events[t])return this;if(r=this._events[t],a=r.length,i=-1,r===e||n(r.listener)&&r.listener===e)delete this._events[t],this._events.removeListener&&this.emit("removeListener",t,e);else if(o(r)){for(s=a;s-- >0;)if(r[s]===e||r[s].listener&&r[s].listener===e){i=s;break}if(i<0)return this;1===r.length?(r.length=0,delete this._events[t]):r.splice(i,1),this._events.removeListener&&this.emit("removeListener",t,e)}return this},r.prototype.removeAllListeners=function(t){var e,r;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[t]&&delete this._events[t],this;if(0===arguments.length){for(e in this._events)"removeListener"!==e&&this.removeAllListeners(e);return this.removeAllListeners("removeListener"),this._events={},this}if(r=this._events[t],n(r))this.removeListener(t,r);else if(r)for(;r.length;)this.removeListener(t,r[r.length-1]);return delete this._events[t],this},r.prototype.listeners=function(t){return this._events&&this._events[t]?n(this._events[t])?[this._events[t]]:this._events[t].slice():[]},r.prototype.listenerCount=function(t){if(this._events){var e=this._events[t];if(n(e))return 1;if(e)return e.length}return 0},r.listenerCount=function(t,e){return t.listenerCount(e)}},function(t,e,r){"use strict";(function(e){function r(t,r,n,i){if("function"!=typeof t)throw new TypeError('"callback" argument must be a function');var o,a,s=arguments.length;switch(s){case 0:case 1:return e.nextTick(t);case 2:return e.nextTick(function(){t.call(null,r)});case 3:return e.nextTick(function(){t.call(null,r,n)});case 4:return e.nextTick(function(){t.call(null,r,n,i)});default:for(o=new Array(s-1),a=0;a<o.length;)o[a++]=arguments[a];return e.nextTick(function(){t.apply(null,o)})}}!e.version||0===e.version.indexOf("v0.")||0===e.version.indexOf("v1.")&&0!==e.version.indexOf("v1.8.")?t.exports=r:t.exports=e.nextTick}).call(e,r(8))},function(t,e){function r(t,e){for(var r=-1,n=t?t.length:0;++r<n&&!1!==e(t[r],r,t););return t}function n(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}function i(t,e){var r=C(t)||l(t)?n(t.length,String):[],i=r.length,o=!!i;for(var a in t)!e&&!k.call(t,a)||o&&("length"==a||s(a,i))||r.push(a);return r}function o(t,e){return t&&L(t,e,y)}function a(t){if(!u(t))return T(t);var e=[];for(var r in Object(t))k.call(t,r)&&"constructor"!=r&&e.push(r);return e}function s(t,e){return!!(e=null==e?m:e)&&("number"==typeof t||S.test(t))&&t>-1&&t%1==0&&t<e}function u(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||j)}function c(t,e){return(C(t)?r:O)(t,"function"==typeof e?e:b)}function l(t){return h(t)&&k.call(t,"callee")&&(!E.call(t,"callee")||A.call(t)==_)}function f(t){return null!=t&&d(t.length)&&!p(t)}function h(t){return v(t)&&f(t)}function p(t){var e=g(t)?A.call(t):"";return e==w||e==x}function d(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=m}function g(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function v(t){return!!t&&"object"==typeof t}function y(t){return f(t)?i(t):a(t)}function b(t){return t}var m=9007199254740991,_="[object Arguments]",w="[object Function]",x="[object GeneratorFunction]",S=/^(?:0|[1-9]\d*)$/,j=Object.prototype,k=j.hasOwnProperty,A=j.toString,E=j.propertyIsEnumerable,T=function(t,e){return function(r){return t(e(r))}}(Object.keys,Object),O=function(t,e){return function(r,n){if(null==r)return r;if(!f(r))return t(r,n);for(var i=r.length,o=e?i:-1,a=Object(r);(e?o--:++o<i)&&!1!==n(a[o],o,a););return r}}(o),L=function(t){return function(e,r,n){for(var i=-1,o=Object(e),a=n(e),s=a.length;s--;){var u=a[t?s:++i];if(!1===r(o[u],u,o))break}return e}}(),C=Array.isArray;t.exports=c},function(t,e,r){var n=r(12),i=r(10).isHtml,o={extend:r(40),bind:r(24),forEach:r(15),defaults:r(41)},a=[r(84),r(94),r(98),r(100),r(102)],s=t.exports=function(t,e,r,a){return this instanceof s?(this.options=o.defaults(a||{},this.options),t?(r&&("string"==typeof r&&(r=n(r,this.options)),this._root=s.call(this,r)),t.cheerio?t:(u(t)&&(t=[t]),Array.isArray(t)?(o.forEach(t,o.bind(function(t,e){this[e]=t},this)),this.length=t.length,this):"string"==typeof t&&i(t)?s.call(this,n(t,this.options).children):(e?"string"==typeof e?i(e)?(e=n(e,this.options),e=s.call(this,e)):(t=[e,t].join(" "),e=this._root):e.cheerio||(e=s.call(this,e)):e=this._root,e?e.find(t):this))):this):new s(t,e,r,a)};o.extend(s,r(25)),s.prototype.cheerio="[cheerio object]",s.prototype.options={withDomLvl1:!0,normalizeWhitespace:!1,xmlMode:!1,decodeEntities:!0},s.prototype.length=0,s.prototype.splice=Array.prototype.splice,s.prototype._make=function(t,e){var r=new this.constructor(t,e,this._root,this.options);return r.prevObject=this,r},s.prototype.toArray=function(){return this.get()},a.forEach(function(t){o.extend(s.prototype,t)});var u=function(t){return t.name||"text"===t.type||"comment"===t.type}},function(t,e){t.exports={Aacute:"",aacute:"",Abreve:"",abreve:"",ac:"",acd:"",acE:"",Acirc:"",acirc:"",acute:"",Acy:"",acy:"",AElig:"",aelig:"",af:"",Afr:"",afr:"",Agrave:"",agrave:" ",alefsym:"",aleph:"",Alpha:"",alpha:"",Amacr:"",amacr:"",amalg:"",amp:"&",AMP:"&",andand:"",And:"",and:"",andd:"",andslope:"",andv:"",ang:" ",ange:"",angle:" ",angmsdaa:"",angmsdab:"",angmsdac:"",angmsdad:"",angmsdae:"",angmsdaf:"",angmsdag:"",angmsdah:"",angmsd:"",angrt:"",angrtvb:"",angrtvbd:"",angsph:"",angst:"",angzarr:"",Aogon:"",aogon:"",Aopf:"",aopf:"",apacir:"",ap:"",apE:"",ape:"",apid:"",apos:"'",ApplyFunction:"",approx:"",approxeq:"",Aring:"",aring:"",Ascr:"",ascr:"",Assign:"",ast:"*",asymp:"",asympeq:"",Atilde:"",atilde:"",Auml:"",auml:"",awconint:"",awint:"",backcong:"",backepsilon:"",backprime:"",backsim:"",backsimeq:"",Backslash:"",Barv:"",barvee:"",barwed:"",Barwed:"",barwedge:"",bbrk:"",bbrktbrk:"",bcong:"",Bcy:"",bcy:"",bdquo:"",becaus:"",because:"",Because:"",bemptyv:"",bepsi:"",bernou:"",Bernoullis:"",Beta:"",beta:"",beth:"",between:"",Bfr:"",bfr:"",bigcap:"",bigcirc:"",bigcup:"",bigodot:"",bigoplus:"",bigotimes:"",bigsqcup:"",bigstar:"",bigtriangledown:"",bigtriangleup:"",biguplus:"",bigvee:"",bigwedge:"",bkarow:"",blacklozenge:"",blacksquare:"",blacktriangle:"",blacktriangledown:"",blacktriangleleft:"",blacktriangleright:"",blank:"",blk12:"",blk14:"",blk34:"",block:"",bne:"=",bnequiv:"",bNot:"",bnot:"",Bopf:"",bopf:"",bot:"",bottom:"",bowtie:"",boxbox:"",boxdl:"",boxdL:"",boxDl:"",boxDL:"",boxdr:"",boxdR:"",boxDr:"",boxDR:"",boxh:"",boxH:"",boxhd:"",boxHd:"",boxhD:"",boxHD:"",boxhu:"",boxHu:"",boxhU:"",boxHU:"",boxminus:"",boxplus:"",boxtimes:" ",boxul:"",boxuL:"",boxUl:"",boxUL:"",boxur:"",boxuR:"",boxUr:"",boxUR:"",boxv:"",boxV:"",boxvh:"",boxvH:"",boxVh:"",boxVH:"",boxvl:"",boxvL:"",boxVl:"",boxVL:"",boxvr:"",boxvR:"",boxVr:"",boxVR:" ",bprime:"",breve:"",Breve:"",brvbar:"",bscr:"",Bscr:"",bsemi:"",bsim:"",bsime:"",bsolb:"",bsol:"\\",bsolhsub:"",bull:"",bullet:"",bump:"",bumpE:"",bumpe:"",Bumpeq:"",bumpeq:"",Cacute:"",cacute:"",capand:"",capbrcup:"",capcap:"",cap:"",Cap:"",capcup:"",capdot:"",CapitalDifferentialD:"",caps:"",caret:"",caron:"",Cayleys:"",ccaps:"",Ccaron:"",ccaron:"",Ccedil:"",ccedil:"",Ccirc:"",ccirc:"",Cconint:"",ccups:"",ccupssm:"",Cdot:"",cdot:"",cedil:"",Cedilla:"",cemptyv:"",cent:"",centerdot:"",CenterDot:"",cfr:" ",Cfr:"",CHcy:"",chcy:"",check:"",checkmark:"",Chi:"",chi:"",circ:"",circeq:"",circlearrowleft:"",circlearrowright:"",circledast:"",circledcirc:"",circleddash:"",CircleDot:"",circledR:"",circledS:"",CircleMinus:"",CirclePlus:"",CircleTimes:"",cir:"",cirE:"",cire:"",cirfnint:"",cirmid:"",cirscir:"",ClockwiseContourIntegral:"",CloseCurlyDoubleQuote:"",CloseCurlyQuote:"",clubs:"",clubsuit:"",colon:":",Colon:"",Colone:"",colone:"",coloneq:"",comma:",",commat:"@",comp:"",compfn:"",complement:"",complexes:"",cong:"",congdot:"",Congruent:"",conint:"",Conint:"",ContourIntegral:"",copf:"",Copf:"",coprod:"",Coproduct:"",copy:"",COPY:"",copysr:"",CounterClockwiseContourIntegral:"",crarr:"",cross:"",Cross:"",Cscr:"",cscr:"",csub:"",csube:"",csup:"",csupe:"",ctdot:"",cudarrl:"",cudarrr:"",cuepr:"",cuesc:"",cularr:"",cularrp:"",cupbrcap:"",cupcap:"",CupCap:"",cup:"",Cup:"",cupcup:"",cupdot:"",cupor:"",cups:"",curarr:"",curarrm:"",curlyeqprec:"",curlyeqsucc:"",curlyvee:"",curlywedge:"",curren:"",curvearrowleft:"",curvearrowright:"",cuvee:"",cuwed:"",cwconint:"",cwint:"",cylcty:"",dagger:" ",Dagger:"",daleth:"",darr:"",Darr:"",dArr:"",dash:"",Dashv:"",dashv:"",dbkarow:"",dblac:"",Dcaron:"",dcaron:"",Dcy:"",dcy:"",ddagger:"",ddarr:"",DD:"",dd:"",DDotrahd:"",ddotseq:"",deg:"",Del:"",Delta:"",delta:"",demptyv:"",dfisht:"",Dfr:"",dfr:"",dHar:"",dharl:"",dharr:"",DiacriticalAcute:"",DiacriticalDot:"",DiacriticalDoubleAcute:"",DiacriticalGrave:"`",DiacriticalTilde:"",diam:"",diamond:"",Diamond:"",diamondsuit:"",diams:"",die:"",DifferentialD:"",digamma:"",disin:"",div:"",divide:"",divideontimes:"",divonx:"",DJcy:"",djcy:"",dlcorn:"",dlcrop:"",dollar:"$",Dopf:"",dopf:"",Dot:"",dot:"",DotDot:"",doteq:"",doteqdot:"",DotEqual:"",dotminus:"",dotplus:"",dotsquare:"",doublebarwedge:"",DoubleContourIntegral:"",DoubleDot:"",DoubleDownArrow:"",DoubleLeftArrow:"",DoubleLeftRightArrow:"",DoubleLeftTee:"",DoubleLongLeftArrow:"",DoubleLongLeftRightArrow:"",DoubleLongRightArrow:"",DoubleRightArrow:"",DoubleRightTee:"",DoubleUpArrow:"",DoubleUpDownArrow:"",DoubleVerticalBar:"",DownArrowBar:"",downarrow:"",DownArrow:"",Downarrow:"",DownArrowUpArrow:"",DownBreve:"",downdownarrows:"",downharpoonleft:"",downharpoonright:"",DownLeftRightVector:"",DownLeftTeeVector:"",DownLeftVectorBar:"",DownLeftVector:"",DownRightTeeVector:"",DownRightVectorBar:"",DownRightVector:"",DownTeeArrow:"",DownTee:"",drbkarow:"",drcorn:"",drcrop:"",Dscr:"",dscr:"",DScy:"",dscy:"",dsol:"",Dstrok:"",dstrok:"",dtdot:"",dtri:"",dtrif:"",duarr:"",duhar:"",dwangle:"",DZcy:"",dzcy:"",dzigrarr:"",Eacute:"",eacute:"",easter:"",Ecaron:"",ecaron:"",Ecirc:"",ecirc:"",ecir:"",ecolon:"",Ecy:"",ecy:"",eDDot:"",Edot:"",edot:"",eDot:"",ee:"",efDot:"",Efr:"",efr:"",eg:"",Egrave:"",egrave:"",egs:"",egsdot:"",el:"",Element:"",elinters:"",ell:"",els:"",elsdot:"",Emacr:"",emacr:"",empty:"",emptyset:"",EmptySmallSquare:"",emptyv:"",EmptyVerySmallSquare:"",emsp13:"",emsp14:"",emsp:"",ENG:"",eng:"",ensp:"",Eogon:"",eogon:"",Eopf:"",eopf:"",epar:"",eparsl:"",eplus:"",epsi:"",Epsilon:"",epsilon:"",epsiv:"",eqcirc:"",eqcolon:"",eqsim:"",eqslantgtr:"",eqslantless:"",Equal:"",equals:"=",EqualTilde:"",equest:"",Equilibrium:"",equiv:"",equivDD:"",eqvparsl:"",erarr:"",erDot:"",escr:"",Escr:"",esdot:"",Esim:"",esim:"",Eta:"",eta:"",ETH:"",eth:"",Euml:"",euml:"",euro:"",excl:"!",exist:"",Exists:"",expectation:"",exponentiale:"",ExponentialE:"",fallingdotseq:"",Fcy:"",fcy:"",female:"",ffilig:"",fflig:"",ffllig:"",Ffr:"",ffr:"",filig:"",FilledSmallSquare:"",FilledVerySmallSquare:"",fjlig:"fj",flat:"",fllig:"",fltns:"",fnof:"",Fopf:"",fopf:"",forall:"",ForAll:"",fork:"",forkv:"",Fouriertrf:"",fpartint:"",frac12:"",frac13:"",frac14:"",frac15:"",frac16:"",frac18:"",frac23:"",frac25:"",frac34:"",frac35:"",frac38:"",frac45:"",frac56:"",frac58:"",frac78:"",frasl:"",frown:"",fscr:"",Fscr:"",gacute:"",Gamma:"",gamma:"",Gammad:"",gammad:"",gap:"",Gbreve:"",gbreve:"",Gcedil:"",Gcirc:"",gcirc:"",Gcy:"",gcy:"",Gdot:" ",gdot:"",ge:"",gE:"",gEl:"",gel:"",geq:"",geqq:"",geqslant:"",gescc:"",ges:"",gesdot:"",gesdoto:"",gesdotol:"",gesl:"",gesles:"",Gfr:"",gfr:"",gg:"",Gg:"",ggg:"",gimel:"",GJcy:"",gjcy:"",gla:"",gl:"",glE:"",glj:"",gnap:"",gnapprox:"",gne:"",gnE:"",gneq:"",gneqq:"",gnsim:"",Gopf:"",gopf:"",grave:"`",GreaterEqual:"",GreaterEqualLess:"",GreaterFullEqual:"",GreaterGreater:"",GreaterLess:"",GreaterSlantEqual:"",GreaterTilde:"",Gscr:"",gscr:"",gsim:"",gsime:"",gsiml:"",gtcc:"",gtcir:"",gt:">",GT:">",Gt:"",gtdot:"",gtlPar:"",gtquest:"",gtrapprox:"",gtrarr:"",gtrdot:"",gtreqless:"",gtreqqless:"",gtrless:"",gtrsim:"",gvertneqq:"",gvnE:"",Hacek:"",hairsp:"",half:"",hamilt:"",HARDcy:"",hardcy:"",harrcir:"",harr:"",hArr:"",harrw:"",Hat:"^",hbar:"",Hcirc:"",hcirc:"",hearts:"",heartsuit:"",hellip:"",hercon:"",hfr:"",Hfr:"",HilbertSpace:"",hksearow:"",hkswarow:"",hoarr:"",homtht:"",hookleftarrow:"",hookrightarrow:"",hopf:"",Hopf:"",horbar:"",HorizontalLine:"",hscr:"",Hscr:"",hslash:"",Hstrok:"",hstrok:"",HumpDownHump:"",HumpEqual:"",hybull:"",hyphen:"",Iacute:"",iacute:"",ic:"",Icirc:"",icirc:"",Icy:"",icy:"",Idot:"",IEcy:"",iecy:"",iexcl:"",iff:"",ifr:"",Ifr:"",Igrave:"",igrave:"",ii:"",iiiint:"",iiint:"",iinfin:"",iiota:"",IJlig:"",ijlig:"",Imacr:"",imacr:"",image:"",ImaginaryI:"",imagline:"",imagpart:"",imath:"",Im:"",imof:"",imped:"",Implies:"",incare:"",in:"",infin:"",infintie:"",inodot:"",intcal:"",int:"",Int:"",integers:"",Integral:"",intercal:"",Intersection:"",intlarhk:"",intprod:"",InvisibleComma:"",InvisibleTimes:"",IOcy:"",iocy:"",Iogon:"",iogon:"",Iopf:"",iopf:"",Iota:"",iota:"",iprod:"",iquest:"",iscr:"",Iscr:"",isin:"",isindot:"",isinE:"",isins:"",isinsv:"",isinv:"",it:"",Itilde:"",itilde:"",Iukcy:"",iukcy:"",Iuml:"",iuml:"",Jcirc:"",jcirc:"",Jcy:"",jcy:"",Jfr:"",jfr:"",jmath:"",Jopf:"",jopf:"",Jscr:"",jscr:"",Jsercy:"",jsercy:"",Jukcy:"",jukcy:"",Kappa:"",kappa:"",kappav:"",Kcedil:"",kcedil:"",Kcy:"",kcy:"",Kfr:"",kfr:"",kgreen:"",KHcy:"",khcy:"",KJcy:"",kjcy:"",Kopf:"",kopf:"",Kscr:"",kscr:"",lAarr:"",Lacute:"",lacute:"",laemptyv:"",lagran:"",Lambda:"",lambda:"",lang:"",Lang:"",langd:"",langle:"",lap:"",Laplacetrf:"",laquo:"",larrb:"",larrbfs:"",larr:"",Larr:"",lArr:"",larrfs:"",larrhk:"",larrlp:"",larrpl:"",larrsim:"",larrtl:"",latail:"",lAtail:"",lat:"",late:"",lates:"",lbarr:"",lBarr:"",lbbrk:"",lbrace:"{",lbrack:"[",lbrke:"",lbrksld:"",lbrkslu:"",Lcaron:"",lcaron:"",Lcedil:"",lcedil:"",lceil:"",lcub:"{",Lcy:"",lcy:"",ldca:"",ldquo:"",ldquor:"",ldrdhar:"",ldrushar:"",ldsh:"",le:"",lE:"",LeftAngleBracket:"",LeftArrowBar:"",leftarrow:"",LeftArrow:"",Leftarrow:"",LeftArrowRightArrow:"",leftarrowtail:"",LeftCeiling:"",LeftDoubleBracket:"",LeftDownTeeVector:"",LeftDownVectorBar:"",LeftDownVector:"",LeftFloor:"",leftharpoondown:"",leftharpoonup:"",leftleftarrows:"",leftrightarrow:"",LeftRightArrow:"",Leftrightarrow:"",leftrightarrows:"",leftrightharpoons:"",leftrightsquigarrow:"",LeftRightVector:"",LeftTeeArrow:"",LeftTee:"",LeftTeeVector:"",leftthreetimes:"",LeftTriangleBar:"",LeftTriangle:"",LeftTriangleEqual:"",LeftUpDownVector:"",LeftUpTeeVector:" ",LeftUpVectorBar:"",LeftUpVector:"",LeftVectorBar:"",LeftVector:"",lEg:"",leg:"",leq:"",leqq:"",leqslant:"",lescc:"",les:"",lesdot:"",lesdoto:"",lesdotor:"",lesg:"",lesges:"",lessapprox:"",lessdot:"",lesseqgtr:"",lesseqqgtr:"",LessEqualGreater:"",LessFullEqual:"",LessGreater:"",lessgtr:"",LessLess:"",lesssim:"",LessSlantEqual:"",LessTilde:"",lfisht:"",lfloor:"",Lfr:"",lfr:"",lg:"",lgE:"",lHar:"",lhard:"",lharu:"",lharul:"",lhblk:"",LJcy:"",ljcy:"",llarr:"",ll:"",Ll:"",llcorner:"",Lleftarrow:"",llhard:"",lltri:"",Lmidot:"",lmidot:"",lmoustache:"",lmoust:"",lnap:"",lnapprox:"",lne:"",lnE:"",lneq:"",lneqq:"",lnsim:"",loang:"",loarr:"",lobrk:"",longleftarrow:"",LongLeftArrow:"",Longleftarrow:"",longleftrightarrow:"",LongLeftRightArrow:"",Longleftrightarrow:"",longmapsto:"",longrightarrow:"",LongRightArrow:"",Longrightarrow:"",looparrowleft:"",looparrowright:"",lopar:"",Lopf:"",lopf:"",loplus:"",lotimes:"",lowast:"",lowbar:"_",LowerLeftArrow:"",LowerRightArrow:"",loz:"",lozenge:"",lozf:"",lpar:"(",lparlt:"",lrarr:"",lrcorner:"",lrhar:"",lrhard:"",lrm:"",lrtri:"",lsaquo:"",lscr:"",Lscr:"",lsh:"",Lsh:"",lsim:"",lsime:"",lsimg:"",lsqb:"[",lsquo:"",lsquor:"",Lstrok:"",lstrok:"",ltcc:"",ltcir:"",lt:"<",LT:"<",Lt:"",ltdot:"",lthree:"",ltimes:"",ltlarr:"",ltquest:"",ltri:"",ltrie:"",ltrif:"",ltrPar:"",lurdshar:"",luruhar:"",lvertneqq:"",lvnE:"",macr:"",male:"",malt:" ",maltese:" ",Map:"",map:"",mapsto:"",mapstodown:"",mapstoleft:"",mapstoup:"",marker:"",mcomma:"",Mcy:"",mcy:"",mdash:"",mDDot:"",measuredangle:"",MediumSpace:"",Mellintrf:"",Mfr:"",mfr:"",mho:"",micro:"",midast:"*",midcir:"",mid:"",middot:"",minusb:"",minus:"",minusd:"",minusdu:"",MinusPlus:"",mlcp:"",mldr:"",mnplus:"",models:"",Mopf:"",mopf:"",mp:"",mscr:"",Mscr:"",mstpos:"",Mu:"",mu:"",multimap:"",mumap:"",nabla:"",Nacute:"",nacute:"",nang:" ",nap:"",napE:"",napid:"",napos:"",napprox:"",natural:"",naturals:"",natur:"",nbsp:" ",nbump:"",nbumpe:"",ncap:"",Ncaron:"",ncaron:"",Ncedil:"",ncedil:"",ncong:"",ncongdot:"",ncup:"",Ncy:"",ncy:"",ndash:"",nearhk:"",nearr:"",neArr:"",nearrow:"",ne:" ",nedot:"",NegativeMediumSpace:"",NegativeThickSpace:"",NegativeThinSpace:"",NegativeVeryThinSpace:"",nequiv:"",nesear:"",nesim:"",NestedGreaterGreater:"",NestedLessLess:"",NewLine:"\n",nexist:"",nexists:"",Nfr:"",nfr:"",ngE:"",nge:"",ngeq:"",ngeqq:"",ngeqslant:"",nges:"",nGg:"",ngsim:"",nGt:"",ngt:"",ngtr:"",nGtv:"",nharr:"",nhArr:"",nhpar:"",ni:"",nis:"",nisd:"",niv:"",NJcy:"",njcy:"",nlarr:"",nlArr:"",nldr:"",nlE:"",nle:"",nleftarrow:"",nLeftarrow:"",nleftrightarrow:"",nLeftrightarrow:"",nleq:"",nleqq:"",nleqslant:"",nles:"",nless:"",nLl:"",nlsim:"",nLt:"",nlt:"",nltri:"",nltrie:"",nLtv:"",nmid:"",NoBreak:" ",NonBreakingSpace:" ",nopf:"",Nopf:"",Not:"",not:"",NotCongruent:"",NotCupCap:"",NotDoubleVerticalBar:"",NotElement:"",NotEqual:" ",NotEqualTilde:"",NotExists:"",NotGreater:"",NotGreaterEqual:"",NotGreaterFullEqual:"",NotGreaterGreater:"",NotGreaterLess:"",NotGreaterSlantEqual:"",NotGreaterTilde:"",NotHumpDownHump:"",NotHumpEqual:"",notin:"",notindot:"",notinE:"",notinva:"",notinvb:"",notinvc:"",NotLeftTriangleBar:"",NotLeftTriangle:"",NotLeftTriangleEqual:"",NotLess:"",NotLessEqual:"",NotLessGreater:"",NotLessLess:"",NotLessSlantEqual:"",NotLessTilde:"",NotNestedGreaterGreater:"",NotNestedLessLess:"",notni:"",notniva:"",notnivb:"",notnivc:"",NotPrecedes:"",NotPrecedesEqual:"",NotPrecedesSlantEqual:" ",NotReverseElement:"",NotRightTriangleBar:"",NotRightTriangle:"",NotRightTriangleEqual:"",NotSquareSubset:"",NotSquareSubsetEqual:"",NotSquareSuperset:"",NotSquareSupersetEqual:"",NotSubset:"",NotSubsetEqual:"",NotSucceeds:"",NotSucceedsEqual:"",NotSucceedsSlantEqual:"",NotSucceedsTilde:"",NotSuperset:"",NotSupersetEqual:"",NotTilde:"",NotTildeEqual:"",NotTildeFullEqual:"",NotTildeTilde:"",NotVerticalBar:"",nparallel:"",npar:"",nparsl:"",npart:"",npolint:"",npr:"",nprcue:" ",nprec:"",npreceq:"",npre:"",nrarrc:"",nrarr:"",nrArr:"",nrarrw:"",nrightarrow:"",nRightarrow:"",nrtri:"",nrtrie:"",nsc:"",nsccue:"",nsce:"",Nscr:"",nscr:"",nshortmid:"",nshortparallel:"",nsim:"",nsime:"",nsimeq:"",nsmid:"",nspar:"",nsqsube:"",nsqsupe:"",nsub:"",nsubE:"",nsube:"",nsubset:"",nsubseteq:"",nsubseteqq:"",nsucc:"",nsucceq:"",nsup:"",nsupE:"",nsupe:"",nsupset:"",nsupseteq:"",nsupseteqq:"",ntgl:"",Ntilde:"",ntilde:"",ntlg:"",ntriangleleft:"",ntrianglelefteq:"",ntriangleright:"",ntrianglerighteq:"",Nu:"",nu:"",num:"#",numero:"",numsp:"",nvap:"",nvdash:"",nvDash:"",nVdash:"",nVDash:"",nvge:"",nvgt:">",nvHarr:"",nvinfin:"",nvlArr:"",nvle:"",nvlt:"<",nvltrie:"",nvrArr:"",nvrtrie:"",nvsim:"",nwarhk:"",nwarr:"",nwArr:"",nwarrow:"",nwnear:"",Oacute:"",oacute:"",oast:"",Ocirc:"",ocirc:"",ocir:"",Ocy:"",ocy:"",odash:"",Odblac:"",odblac:"",odiv:"",odot:"",odsold:"",OElig:"",oelig:"",ofcir:"",Ofr:"",ofr:"",ogon:"",Ograve:"",ograve:"",ogt:"",ohbar:"",ohm:"",oint:"",olarr:"",olcir:"",olcross:"",oline:"",olt:"",Omacr:"",omacr:"",Omega:"",omega:"",Omicron:"",omicron:"",omid:"",ominus:"",Oopf:"",oopf:" ",opar:"",OpenCurlyDoubleQuote:"",OpenCurlyQuote:"",operp:"",oplus:"",orarr:"",Or:"",or:"",ord:"",order:"",orderof:"",ordf:"",ordm:"",origof:"",oror:"",orslope:"",orv:"",oS:"",Oscr:"",oscr:"",Oslash:"",oslash:"",osol:"",Otilde:"",otilde:"",otimesas:"",Otimes:"",otimes:"",Ouml:"",ouml:"",ovbar:"",OverBar:"",OverBrace:"",OverBracket:"",OverParenthesis:"",para:"",parallel:"",par:"",parsim:"",parsl:"",part:"",PartialD:"",Pcy:"",pcy:"",percnt:"%",period:".",permil:"",perp:"",pertenk:"",Pfr:"",pfr:"",Phi:"",phi:"",phiv:"",phmmat:"",phone:"",Pi:" ",pi:"",pitchfork:"",piv:"",planck:"",planckh:"",plankv:"",plusacir:"",plusb:"",pluscir:"",plus:"+",plusdo:"",plusdu:"",pluse:"",PlusMinus:"",plusmn:"",plussim:"",plustwo:"",pm:"",Poincareplane:"",pointint:"",popf:"",Popf:"",pound:"",prap:"",Pr:"",pr:"",prcue:"",precapprox:"",prec:"",preccurlyeq:"",Precedes:"",PrecedesEqual:"",PrecedesSlantEqual:"",PrecedesTilde:"",preceq:"",precnapprox:"",precneqq:"",precnsim:"",pre:"",prE:"",precsim:"",prime:"",Prime:"",primes:"",prnap:"",prnE:"",prnsim:"",prod:"",Product:"",profalar:"",profline:"",profsurf:"",prop:"",Proportional:"",Proportion:"",propto:"",prsim:"",prurel:"",Pscr:"",pscr:"",Psi:"",psi:"",puncsp:"",Qfr:"",qfr:"",qint:"",qopf:"",Qopf:"",qprime:"",Qscr:"",qscr:"",quaternions:"",quatint:"",quest:"?",questeq:"",quot:'"',QUOT:'"',rAarr:"",race:"",Racute:"",racute:"",radic:"",raemptyv:"",rang:"",Rang:"",rangd:"",range:"",rangle:"",raquo:"",rarrap:"",rarrb:"",rarrbfs:" ",rarrc:"",rarr:"",Rarr:" ",rArr:"",rarrfs:"",rarrhk:"",rarrlp:"",rarrpl:"",rarrsim:"",Rarrtl:"",rarrtl:"",rarrw:"",ratail:"",rAtail:"",ratio:"",rationals:"",rbarr:"",rBarr:"",RBarr:"",rbbrk:"",rbrace:"}",rbrack:"]",rbrke:"",rbrksld:"",rbrkslu:"",Rcaron:"",rcaron:"",Rcedil:"",rcedil:"",rceil:"",rcub:"}",Rcy:" ",rcy:"",rdca:"",rdldhar:"",rdquo:"",rdquor:"",rdsh:"",real:"",realine:"",realpart:"",reals:"",Re:"",rect:"",reg:"",REG:"",ReverseElement:"",ReverseEquilibrium:"",ReverseUpEquilibrium:"",rfisht:"",rfloor:"",rfr:"",Rfr:"",rHar:"",rhard:"",rharu:"",rharul:"",Rho:"",rho:"",rhov:"",RightAngleBracket:"",RightArrowBar:"",rightarrow:"",RightArrow:"",Rightarrow:"",RightArrowLeftArrow:"",rightarrowtail:"",RightCeiling:"",RightDoubleBracket:"",RightDownTeeVector:"",RightDownVectorBar:"",RightDownVector:"",RightFloor:"",rightharpoondown:"",rightharpoonup:"",rightleftarrows:"",rightleftharpoons:"",rightrightarrows:"",rightsquigarrow:"",RightTeeArrow:"",RightTee:"",RightTeeVector:"",rightthreetimes:"",RightTriangleBar:"",RightTriangle:"",RightTriangleEqual:"",RightUpDownVector:"",RightUpTeeVector:"",RightUpVectorBar:"",RightUpVector:"",RightVectorBar:"",RightVector:"",ring:"",risingdotseq:"",rlarr:"",rlhar:"",rlm:"",rmoustache:"",rmoust:"",rnmid:"",roang:"",roarr:"",robrk:"",ropar:"",ropf:"",Ropf:"",roplus:"",rotimes:"",RoundImplies:"",rpar:")",rpargt:"",rppolint:"",rrarr:"",Rrightarrow:"",rsaquo:"",rscr:"",Rscr:"",rsh:"",Rsh:"",rsqb:"]",rsquo:"",rsquor:"",rthree:"",rtimes:"",rtri:"",rtrie:"",rtrif:"",rtriltri:"",RuleDelayed:"",ruluhar:"",rx:"",Sacute:"",sacute:"",sbquo:"",scap:"",Scaron:" ",scaron:"",Sc:"",sc:"",sccue:"",sce:"",scE:"",Scedil:"",scedil:"",Scirc:"",scirc:"",scnap:"",scnE:"",scnsim:"",scpolint:"",scsim:"",Scy:"",scy:"",sdotb:"",sdot:"",sdote:"",searhk:"",searr:"",seArr:"",searrow:"",sect:"",semi:";",seswar:"",setminus:"",setmn:"",sext:"",Sfr:"",sfr:"",sfrown:"",sharp:"",SHCHcy:"",shchcy:"",SHcy:"",shcy:"",ShortDownArrow:"",ShortLeftArrow:"",shortmid:"",shortparallel:"",ShortRightArrow:"",ShortUpArrow:"",shy:"",Sigma:"",sigma:"",sigmaf:"",sigmav:"",sim:"",simdot:"",sime:"",simeq:"",simg:"",simgE:" ",siml:"",simlE:"",simne:"",simplus:"",simrarr:"",slarr:"",SmallCircle:"",smallsetminus:"",smashp:"",smeparsl:"",smid:"",smile:"",smt:"",smte:"",smtes:"",SOFTcy:"",softcy:"",solbar:"",solb:"",sol:"/",Sopf:"",sopf:"",spades:" ",spadesuit:" ",spar:"",sqcap:"",sqcaps:"",sqcup:"",sqcups:"",Sqrt:"",sqsub:"",sqsube:"",sqsubset:"",sqsubseteq:"",sqsup:"",sqsupe:"",sqsupset:"",sqsupseteq:"",square:"",Square:"",SquareIntersection:"",SquareSubset:"",SquareSubsetEqual:"",SquareSuperset:"",SquareSupersetEqual:"",SquareUnion:"",squarf:"",squ:"",squf:"",srarr:"",Sscr:"",sscr:"",ssetmn:"",ssmile:"",sstarf:"",Star:"",star:"",starf:"",straightepsilon:"",straightphi:"",strns:"",sub:"",Sub:"",subdot:"",subE:"",sube:"",subedot:"",submult:"",subnE:"",subne:"",subplus:"",subrarr:"",subset:"",Subset:"",subseteq:"",subseteqq:"",SubsetEqual:"",subsetneq:"",subsetneqq:"",subsim:"",subsub:"",subsup:"",succapprox:"",succ:"",succcurlyeq:"",Succeeds:"",SucceedsEqual:"",SucceedsSlantEqual:"",SucceedsTilde:"",succeq:"",succnapprox:"",succneqq:"",succnsim:"",succsim:"",SuchThat:"",sum:"",Sum:"",sung:"",sup1:"",sup2:"",sup3:"",sup:"",Sup:"",supdot:"",supdsub:"",supE:"",supe:"",supedot:"",Superset:"",SupersetEqual:"",suphsol:"",suphsub:"",suplarr:"",supmult:"",supnE:"",supne:"",supplus:"",supset:"",Supset:"",supseteq:"",supseteqq:"",supsetneq:"",supsetneqq:"",supsim:"",supsub:"",supsup:"",swarhk:"",swarr:"",swArr:"",swarrow:"",swnwar:"",szlig:"",Tab:"\t",target:"",Tau:"",tau:"",tbrk:"",Tcaron:"",tcaron:"",Tcedil:"",tcedil:"",Tcy:"",tcy:"",tdot:"",telrec:"",Tfr:"",tfr:"",there4:"",therefore:"",Therefore:"",Theta:"",theta:"",thetasym:"",thetav:"",thickapprox:"",thicksim:"",ThickSpace:"",ThinSpace:"",thinsp:"",thkap:"",thksim:"",THORN:"",thorn:"",tilde:"",Tilde:"",TildeEqual:"",TildeFullEqual:"",TildeTilde:"",timesbar:"",timesb:" ",times:"",timesd:"",tint:"",toea:"",topbot:"",topcir:"",top:"",Topf:"",topf:"",topfork:"",tosa:"",tprime:"",trade:"",TRADE:"",triangle:"",triangledown:"",triangleleft:"",trianglelefteq:"",triangleq:"",triangleright:"",trianglerighteq:"",tridot:"",trie:"",triminus:"",TripleDot:"",triplus:"",trisb:"",tritime:"",trpezium:"",Tscr:"",tscr:"",TScy:"",tscy:"",TSHcy:"",tshcy:"",Tstrok:"",tstrok:"",twixt:"",twoheadleftarrow:"",twoheadrightarrow:" ",Uacute:"",uacute:"",uarr:"",Uarr:"",uArr:"",Uarrocir:"",Ubrcy:"",ubrcy:"",Ubreve:"",ubreve:"",Ucirc:"",ucirc:"",Ucy:"",ucy:"",udarr:"",Udblac:"",udblac:"",udhar:"",ufisht:"",Ufr:"",ufr:"",Ugrave:"",ugrave:"",uHar:"",uharl:"",uharr:"",uhblk:"",ulcorn:"",ulcorner:"",ulcrop:"",ultri:"",Umacr:"",umacr:"",uml:"",UnderBar:"_",UnderBrace:"",UnderBracket:"",UnderParenthesis:"",Union:"",UnionPlus:"",Uogon:"",uogon:"",Uopf:"",uopf:"",UpArrowBar:"",uparrow:"",UpArrow:"",Uparrow:"",UpArrowDownArrow:"",updownarrow:"",UpDownArrow:"",Updownarrow:"",UpEquilibrium:"",upharpoonleft:"",upharpoonright:"",uplus:"",UpperLeftArrow:"",UpperRightArrow:"",upsi:"",Upsi:"",upsih:"",Upsilon:"",upsilon:"",UpTeeArrow:"",UpTee:"",upuparrows:"",urcorn:"",urcorner:"",urcrop:"",Uring:"",uring:"",urtri:"",Uscr:"",uscr:"",utdot:"",Utilde:"",utilde:"",utri:"",utrif:"",uuarr:"",Uuml:"",uuml:"",uwangle:"",vangrt:"",varepsilon:"",varkappa:"",varnothing:"",varphi:"",varpi:"",varpropto:"",varr:"",vArr:"",varrho:"",varsigma:"",varsubsetneq:"",varsubsetneqq:"",varsupsetneq:"",varsupsetneqq:"",vartheta:"",vartriangleleft:"",vartriangleright:"",vBar:"",Vbar:"",vBarv:"",Vcy:"",vcy:"",vdash:"",vDash:"",Vdash:"",VDash:"",Vdashl:"",veebar:"",vee:"",Vee:"",veeeq:"",vellip:"",verbar:"|",Verbar:"",vert:"|",Vert:"",VerticalBar:"",VerticalLine:"|",VerticalSeparator:"",VerticalTilde:"",VeryThinSpace:"",Vfr:"",vfr:"",vltri:"",vnsub:"",vnsup:"",Vopf:"",vopf:"",vprop:"",vrtri:"",Vscr:"",vscr:"",vsubnE:"",vsubne:"",vsupnE:"",vsupne:"",Vvdash:"",vzigzag:"",Wcirc:"",wcirc:"",wedbar:"",wedge:"",Wedge:"",wedgeq:"",weierp:"",Wfr:"",wfr:"",Wopf:"",wopf:"",wp:"",wr:"",wreath:"",Wscr:"",wscr:"",xcap:"",xcirc:"",xcup:"",xdtri:"",Xfr:"",xfr:"",xharr:"",xhArr:"",Xi:"",xi:"",xlarr:"",xlArr:"",xmap:"",xnis:"",xodot:"",Xopf:"",xopf:"",xoplus:"",xotime:"",xrarr:"",xrArr:"",Xscr:"",xscr:"",xsqcup:"",xuplus:"",xutri:"",xvee:"",xwedge:"",Yacute:"",yacute:"",YAcy:"",yacy:"",Ycirc:"",ycirc:"",Ycy:"",ycy:"",yen:"",Yfr:"",yfr:"",YIcy:"",yicy:"",Yopf:"",yopf:"",Yscr:"",yscr:"",YUcy:"",yucy:"",yuml:"",Yuml:"",Zacute:"",zacute:"",Zcaron:"",zcaron:"",Zcy:"",zcy:"",Zdot:"",zdot:"",zeetrf:"",ZeroWidthSpace:"",Zeta:"",zeta:"",zfr:"",Zfr:"",ZHcy:"",zhcy:"",zigrarr:"",zopf:"",Zopf:"",Zscr:"",zscr:"",zwj:"",zwnj:""}},function(t,e){t.exports={amp:"&",apos:"'",gt:">",lt:"<",quot:'"'}},function(t,e,r){e=t.exports=r(36),e.Stream=e,e.Readable=e,e.Writable=r(21),e.Duplex=r(2),e.Transform=r(39),e.PassThrough=r(66)},function(t,e,r){function n(t,e){for(var r in t)e[r]=t[r]}function i(t,e,r){return a(t,e,r)}var o=r(6),a=o.Buffer;a.from&&a.alloc&&a.allocUnsafe&&a.allocUnsafeSlow?t.exports=o:(n(o,e),e.Buffer=i),n(a,i),i.from=function(t,e,r){if("number"==typeof t)throw new TypeError("Argument must not be a number");return a(t,e,r)},i.alloc=function(t,e,r){if("number"!=typeof t)throw new TypeError("Argument must be a number");var n=a(t);return void 0!==e?"string"==typeof r?n.fill(e,r):n.fill(e):n.fill(0),n},i.allocUnsafe=function(t){if("number"!=typeof t)throw new TypeError("Argument must be a number");return a(t)},i.allocUnsafeSlow=function(t){if("number"!=typeof t)throw new TypeError("Argument must be a number");return o.SlowBuffer(t)}},function(t,e,r){"use strict";(function(e,n,i){function o(t){var e=this;this.next=null,this.entry=null,this.finish=function(){E(e,t)}}function a(t){return R.from(t)}function s(t){return R.isBuffer(t)||t instanceof P}function u(){}function c(t,e){O=O||r(2),t=t||{},this.objectMode=!!t.objectMode,e instanceof O&&(this.objectMode=this.objectMode||!!t.writableObjectMode);var n=t.highWaterMark,i=this.objectMode?16:16384;this.highWaterMark=n||0===n?n:i,this.highWaterMark=Math.floor(this.highWaterMark),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var a=!1===t.decodeStrings;this.decodeStrings=!a,this.defaultEncoding=t.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(t){b(e,t)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.bufferedRequestCount=0,this.corkedRequestsFree=new o(this)}function l(t){if(O=O||r(2),!(M.call(l,this)||this instanceof O))return new l(t);this._writableState=new c(t,this),this.writable=!0,t&&("function"==typeof t.write&&(this._write=t.write),"function"==typeof t.writev&&(this._writev=t.writev),"function"==typeof t.destroy&&(this._destroy=t.destroy),"function"==typeof t.final&&(this._final=t.final)),D.call(this)}function f(t,e){var r=new Error("write after end");t.emit("error",r),T(e,r)}function h(t,e,r,n){var i=!0,o=!1;return null===r?o=new TypeError("May not write null values to stream"):"string"==typeof r||void 0===r||e.objectMode||(o=new TypeError("Invalid non-string/buffer chunk")),o&&(t.emit("error",o),T(n,o),i=!1),i}function p(t,e,r){return t.objectMode||!1===t.decodeStrings||"string"!=typeof e||(e=R.from(e,r)),e}function d(t,e,r,n,i,o){if(!r){var a=p(e,n,i);n!==a&&(r=!0,i="buffer",n=a)}var s=e.objectMode?1:n.length;e.length+=s;var u=e.length<e.highWaterMark;if(u||(e.needDrain=!0),e.writing||e.corked){var c=e.lastBufferedRequest;e.lastBufferedRequest={chunk:n,encoding:i,isBuf:r,callback:o,next:null},c?c.next=e.lastBufferedRequest:e.bufferedRequest=e.lastBufferedRequest,e.bufferedRequestCount+=1}else g(t,e,!1,s,n,i,o);return u}function g(t,e,r,n,i,o,a){e.writelen=n,e.writecb=a,e.writing=!0,e.sync=!0,r?t._writev(i,e.onwrite):t._write(i,o,e.onwrite),e.sync=!1}function v(t,e,r,n,i){--e.pendingcb,r?(T(i,n),T(k,t,e),t._writableState.errorEmitted=!0,t.emit("error",n)):(i(n),t._writableState.errorEmitted=!0,t.emit("error",n),k(t,e))}function y(t){t.writing=!1,t.writecb=null,t.length-=t.writelen,t.writelen=0}function b(t,e){var r=t._writableState,n=r.sync,i=r.writecb;if(y(r),e)v(t,r,n,e,i);else{var o=x(r);o||r.corked||r.bufferProcessing||!r.bufferedRequest||w(t,r),n?L(m,t,r,o,i):m(t,r,o,i)}}function m(t,e,r,n){r||_(t,e),e.pendingcb--,n(),k(t,e)}function _(t,e){0===e.length&&e.needDrain&&(e.needDrain=!1,t.emit("drain"))}function w(t,e){e.bufferProcessing=!0;var r=e.bufferedRequest;if(t._writev&&r&&r.next){var n=e.bufferedRequestCount,i=new Array(n),a=e.corkedRequestsFree;a.entry=r;for(var s=0,u=!0;r;)i[s]=r,r.isBuf||(u=!1),r=r.next,s+=1;i.allBuffers=u,g(t,e,!0,e.length,i,"",a.finish),e.pendingcb++,e.lastBufferedRequest=null,a.next?(e.corkedRequestsFree=a.next,a.next=null):e.corkedRequestsFree=new o(e)}else{for(;r;){var c=r.chunk,l=r.encoding,f=r.callback;if(g(t,e,!1,e.objectMode?1:c.length,c,l,f),r=r.next,e.writing)break}null===r&&(e.lastBufferedRequest=null)}e.bufferedRequestCount=0,e.bufferedRequest=r,e.bufferProcessing=!1}function x(t){return t.ending&&0===t.length&&null===t.bufferedRequest&&!t.finished&&!t.writing}function S(t,e){t._final(function(r){e.pendingcb--,r&&t.emit("error",r),e.prefinished=!0,t.emit("prefinish"),k(t,e)})}function j(t,e){e.prefinished||e.finalCalled||("function"==typeof t._final?(e.pendingcb++,e.finalCalled=!0,T(S,t,e)):(e.prefinished=!0,t.emit("prefinish")))}function k(t,e){var r=x(e);return r&&(j(t,e),0===e.pendingcb&&(e.finished=!0,t.emit("finish"))),r}function A(t,e,r){e.ending=!0,k(t,e),r&&(e.finished?T(r):t.once("finish",r)),e.ended=!0,t.writable=!1}function E(t,e,r){var n=t.entry;for(t.entry=null;n;){var i=n.callback;e.pendingcb--,i(r),n=n.next}e.corkedRequestsFree?e.corkedRequestsFree.next=t:e.corkedRequestsFree=t}var T=r(14);t.exports=l;var O,L=!e.browser&&["v0.10","v0.9."].indexOf(e.version.slice(0,5))>-1?n:T;l.WritableState=c;var C=r(9);C.inherits=r(1);var B={deprecate:r(65)},D=r(37),R=r(20).Buffer,P=i.Uint8Array||function(){},q=r(38);C.inherits(l,D),c.prototype.getBuffer=function(){for(var t=this.bufferedRequest,e=[];t;)e.push(t),t=t.next;return e},function(){try{Object.defineProperty(c.prototype,"buffer",{get:B.deprecate(function(){return this.getBuffer()},"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(t){}}();var M;"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(M=Function.prototype[Symbol.hasInstance],Object.defineProperty(l,Symbol.hasInstance,{value:function(t){return!!M.call(this,t)||t&&t._writableState instanceof c}})):M=function(t){return t instanceof this},l.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe, not readable"))},l.prototype.write=function(t,e,r){var n=this._writableState,i=!1,o=s(t)&&!n.objectMode;return o&&!R.isBuffer(t)&&(t=a(t)),"function"==typeof e&&(r=e,e=null),o?e="buffer":e||(e=n.defaultEncoding),"function"!=typeof r&&(r=u),n.ended?f(this,r):(o||h(this,n,t,r))&&(n.pendingcb++,i=d(this,n,o,t,e,r)),i},l.prototype.cork=function(){this._writableState.corked++},l.prototype.uncork=function(){var t=this._writableState;t.corked&&(t.corked--,t.writing||t.corked||t.finished||t.bufferProcessing||!t.bufferedRequest||w(this,t))},l.prototype.setDefaultEncoding=function(t){if("string"==typeof t&&(t=t.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((t+"").toLowerCase())>-1))throw new TypeError("Unknown encoding: "+t);return this._writableState.defaultEncoding=t,this},l.prototype._write=function(t,e,r){r(new Error("_write() is not implemented"))},l.prototype._writev=null,l.prototype.end=function(t,e,r){var n=this._writableState;"function"==typeof t?(r=t,t=null,e=null):"function"==typeof e&&(r=e,e=null),null!==t&&void 0!==t&&this.write(t,e),n.corked&&(n.corked=1,this.uncork()),n.ending||n.finished||A(this,n,r)},Object.defineProperty(l.prototype,"destroyed",{get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(t){this._writableState&&(this._writableState.destroyed=t)}}),l.prototype.destroy=q.destroy,l.prototype._undestroy=q.undestroy,l.prototype._destroy=function(t,e){this.end(),e(t)}}).call(e,r(8),r(63).setImmediate,r(0))},function(t,e,r){function n(t){if(t&&!u(t))throw new Error("Unknown encoding: "+t)}function i(t){return t.toString(this.encoding)}function o(t){this.charReceived=t.length%2,this.charLength=this.charReceived?2:0}function a(t){this.charReceived=t.length%3,this.charLength=this.charReceived?3:0}var s=r(6).Buffer,u=s.isEncoding||function(t){switch(t&&t.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}},c=e.StringDecoder=function(t){switch(this.encoding=(t||"utf8").toLowerCase().replace(/[-_]/,""),n(t),this.encoding){case"utf8":this.surrogateSize=3;break;case"ucs2":case"utf16le":this.surrogateSize=2,this.detectIncompleteChar=o;break;case"base64":this.surrogateSize=3,this.detectIncompleteChar=a;break;default:return void(this.write=i)}this.charBuffer=new s(6),this.charReceived=0,this.charLength=0};c.prototype.write=function(t){for(var e="";this.charLength;){var r=t.length>=this.charLength-this.charReceived?this.charLength-this.charReceived:t.length;if(t.copy(this.charBuffer,this.charReceived,0,r),this.charReceived+=r,this.charReceived<this.charLength)return"";t=t.slice(r,t.length),e=this.charBuffer.slice(0,this.charLength).toString(this.encoding);var n=e.charCodeAt(e.length-1);if(!(n>=55296&&n<=56319)){if(this.charReceived=this.charLength=0,0===t.length)return e;break}this.charLength+=this.surrogateSize,e=""}this.detectIncompleteChar(t);var i=t.length;this.charLength&&(t.copy(this.charBuffer,0,t.length-this.charReceived,i),i-=this.charReceived),e+=t.toString(this.encoding,0,i);var i=e.length-1,n=e.charCodeAt(i);if(n>=55296&&n<=56319){var o=this.surrogateSize;return this.charLength+=o,this.charReceived+=o,this.charBuffer.copy(this.charBuffer,o,0,o),t.copy(this.charBuffer,0,0,o),e.substring(0,i)}return e},c.prototype.detectIncompleteChar=function(t){for(var e=t.length>=3?3:t.length;e>0;e--){var r=t[t.length-e];if(1==e&&r>>5==6){this.charLength=2;break}if(e<=2&&r>>4==14){this.charLength=3;break}if(e<=3&&r>>3==30){this.charLength=4;break}}this.charReceived=e},c.prototype.end=function(t){var e="";if(t&&t.length&&(e=this.write(t)),this.charReceived){var r=this.charReceived,n=this.charBuffer,i=this.encoding;e+=n.slice(0,r).toString(i)}return e}},function(t,e,r){function n(t,e){if(t){var r,n="";for(var i in t)r=t[i],n&&(n+=" "),!r&&f[i]?n+=i:n+=i+'="'+(e.decodeEntities?l.encodeXML(r):r)+'"';return n}}function i(t,e){"svg"===t.name&&(e={decodeEntities:e.decodeEntities,xmlMode:!0});var r="<"+t.name,i=n(t.attribs,e);return i&&(r+=" "+i),!e.xmlMode||t.children&&0!==t.children.length?(r+=">",t.children&&(r+=d(t.children,e)),p[t.name]&&!e.xmlMode||(r+="</"+t.name+">")):r+="/>",r}function o(t){return"<"+t.data+">"}function a(t,e){var r=t.data||"";return!e.decodeEntities||t.parent&&t.parent.name in h||(r=l.encodeXML(r)),r}function s(t){return"<![CDATA["+t.children[0].data+"]]>"}function u(t){return"\x3c!--"+t.data+"--\x3e"}var c=r(74),l=r(75),f={__proto__:null,allowfullscreen:!0,async:!0,autofocus:!0,autoplay:!0,checked:!0,controls:!0,default:!0,defer:!0,disabled:!0,hidden:!0,ismap:!0,loop:!0,multiple:!0,muted:!0,open:!0,readonly:!0,required:!0,reversed:!0,scoped:!0,seamless:!0,selected:!0,typemustmatch:!0},h={__proto__:null,style:!0,script:!0,xmp:!0,iframe:!0,noembed:!0,noframes:!0,plaintext:!0,noscript:!0},p={__proto__:null,area:!0,base:!0,basefont:!0,br:!0,col:!0,command:!0,embed:!0,frame:!0,hr:!0,img:!0,input:!0,isindex:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0},d=t.exports=function(t,e){Array.isArray(t)||t.cheerio||(t=[t]),e=e||{};for(var r="",n=0;n<t.length;n++){var l=t[n];"root"===l.type?r+=d(l.children,e):c.isTag(l)?r+=i(l,e):l.type===c.Directive?r+=o(l):l.type===c.Comment?r+=u(l):l.type===c.CDATA?r+=s(l):r+=a(l,e)}return r}},function(t,e,r){(function(e){function r(t,e,r){switch(r.length){case 0:return t.call(e);case 1:return t.call(e,r[0]);case 2:return t.call(e,r[0],r[1]);case 3:return t.call(e,r[0],r[1],r[2])}return t.apply(e,r)}function n(t,e){for(var r=-1,n=t?t.length:0;++r<n&&!1!==e(t[r],r,t););return t}function i(t,e){return!!(t?t.length:0)&&a(t,e,0)>-1}function o(t,e,r,n){for(var i=t.length,o=r+(n?1:-1);n?o--:++o<i;)if(e(t[o],o,t))return o;return-1}function a(t,e,r){if(e!==e)return o(t,s,r);for(var n=r-1,i=t.length;++n<i;)if(t[n]===e)return n;return-1}function s(t){return t!==t}function u(t,e){for(var r=t.length,n=0;r--;)t[r]===e&&n++;return n}function c(t,e){return null==t?void 0:t[e]}function l(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"")}catch(t){}return e}function f(t,e){for(var r=-1,n=t.length,i=0,o=[];++r<n;){var a=t[r];a!==e&&a!==$||(t[r]=$,o[i++]=r)}return o}function h(t){return R(t)?Ot(t):{}}function p(t){return!(!R(t)||O(t))&&(D(t)||l(t)?Tt:dt).test(C(t))}function d(t,e,r,n){for(var i=-1,o=t.length,a=r.length,s=-1,u=e.length,c=Lt(o-a,0),l=Array(u+c),f=!n;++s<u;)l[s]=e[s];for(;++i<a;)(f||i<o)&&(l[r[i]]=t[i]);for(;c--;)l[s++]=t[i++];return l}function g(t,e,r,n){for(var i=-1,o=t.length,a=-1,s=r.length,u=-1,c=e.length,l=Lt(o-s,0),f=Array(l+c),h=!n;++i<l;)f[i]=t[i];for(var p=i;++u<c;)f[p+u]=e[u];for(;++a<s;)(h||i<o)&&(f[p+r[a]]=t[i++]);return f}function v(t,e){var r=-1,n=t.length;for(e||(e=Array(n));++r<n;)e[r]=t[r];return e}function y(t,e,r){function n(){return(this&&this!==_t&&this instanceof n?o:t).apply(i?r:this,arguments)}var i=e&z,o=b(t);return n}function b(t){return function(){var e=arguments;switch(e.length){case 0:return new t;case 1:return new t(e[0]);case 2:return new t(e[0],e[1]);case 3:return new t(e[0],e[1],e[2]);case 4:return new t(e[0],e[1],e[2],e[3]);case 5:return new t(e[0],e[1],e[2],e[3],e[4]);case 6:return new t(e[0],e[1],e[2],e[3],e[4],e[5]);case 7:return new t(e[0],e[1],e[2],e[3],e[4],e[5],e[6])}var r=h(t.prototype),n=t.apply(r,e);return R(n)?n:r}}function m(t,e,n){function i(){for(var a=arguments.length,s=Array(a),u=a,c=j(i);u--;)s[u]=arguments[u];var l=a<3&&s[0]!==c&&s[a-1]!==c?[]:f(s,c);return(a-=l.length)<n?x(t,e,_,i.placeholder,void 0,s,l,void 0,void 0,n-a):r(this&&this!==_t&&this instanceof i?o:t,this,s)}var o=b(t);return i}function _(t,e,r,n,i,o,a,s,c,l){function h(){for(var k=arguments.length,A=Array(k),E=k;E--;)A[E]=arguments[E];if(m)var T=j(h),O=u(A,T);if(n&&(A=d(A,n,i,m)),o&&(A=g(A,o,a,m)),k-=O,m&&k<l){var C=f(A,T);return x(t,e,_,h.placeholder,r,A,C,s,c,l-k)}var B=v?r:this,D=y?B[t]:t;return k=A.length,s?A=L(A,s):w&&k>1&&A.reverse(),p&&c<k&&(A.length=c),this&&this!==_t&&this instanceof h&&(D=S||b(D)),D.apply(B,A)}var p=e&X,v=e&z,y=e&H,m=e&(G|Y),w=e&Z,S=y?void 0:b(t);return h}function w(t,e,n,i){function o(){for(var e=-1,u=arguments.length,c=-1,l=i.length,f=Array(l+u),h=this&&this!==_t&&this instanceof o?s:t;++c<l;)f[c]=i[c];for(;u--;)f[c++]=arguments[++e];return r(h,a?n:this,f)}var a=e&z,s=b(t);return o}function x(t,e,r,n,i,o,a,s,u,c){var l=e&G,f=l?a:void 0,h=l?void 0:a,p=l?o:void 0,d=l?void 0:o;e|=l?J:Q,(e&=~(l?Q:J))&W||(e&=~(z|H));var g=r(t,e,i,p,f,d,h,s,u,c);return g.placeholder=n,Dt(g,t,e)}function S(t,e,r,n,i,o,a,s){var u=e&H;if(!u&&"function"!=typeof t)throw new TypeError(V);var c=n?n.length:0;if(c||(e&=~(J|Q),n=i=void 0),a=void 0===a?a:Lt(I(a),0),s=void 0===s?s:I(s),c-=i?i.length:0,e&Q){var l=n,f=i;n=i=void 0}var h=[t,e,r,n,i,l,f,o,a,s];if(t=h[0],e=h[1],r=h[2],n=h[3],i=h[4],s=h[9]=null==h[9]?u?0:t.length:Lt(h[9]-c,0),!s&&e&(G|Y)&&(e&=~(G|Y)),e&&e!=z)p=e==G||e==Y?m(t,e,s):e!=J&&e!=(z|J)||i.length?_.apply(void 0,h):w(t,e,r,n);else var p=y(t,e,r);return Dt(p,t,e)}function j(t){return t.placeholder}function k(t,e){var r=c(t,e);return p(r)?r:void 0}function A(t){var e=t.match(lt);return e?e[1].split(ft):[]}function E(t,e){var r=e.length,n=r-1;return e[n]=(r>1?"& ":"")+e[n],e=e.join(r>2?", ":" "),t.replace(ct,"{\n/* [wrapped with "+e+"] */\n")}function T(t,e){return!!(e=null==e?tt:e)&&("number"==typeof t||vt.test(t))&&t>-1&&t%1==0&&t<e}function O(t){return!!jt&&jt in t}function L(t,e){for(var r=t.length,n=Ct(e.length,r),i=v(t);n--;){var o=e[n];t[n]=T(o,r)?i[o]:void 0}return t}function C(t){if(null!=t){try{return kt.call(t)}catch(t){}try{return t+""}catch(t){}}return""}function B(t,e){return n(nt,function(r){var n="_."+r[0];e&r[1]&&!i(t,n)&&t.push(n)}),t.sort()}function D(t){var e=R(t)?Et.call(t):"";return e==it||e==ot}function R(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function P(t){return!!t&&"object"==typeof t}function q(t){return"symbol"==typeof t||P(t)&&Et.call(t)==at}function M(t){if(!t)return 0===t?t:0;if((t=N(t))===K||t===-K){return(t<0?-1:1)*et}return t===t?t:0}function I(t){var e=M(t),r=e%1;return e===e?r?e-r:e:0}function N(t){if("number"==typeof t)return t;if(q(t))return rt;if(R(t)){var e="function"==typeof t.valueOf?t.valueOf():t;t=R(e)?e+"":e}if("string"!=typeof t)return 0===t?t:+t;t=t.replace(ut,"");var r=pt.test(t);return r||gt.test(t)?yt(t.slice(2),r?2:8):ht.test(t)?rt:+t}function U(t){return function(){return t}}function F(t){return t}var V="Expected a function",$="__lodash_placeholder__",z=1,H=2,W=4,G=8,Y=16,J=32,Q=64,X=128,Z=512,K=1/0,tt=9007199254740991,et=1.7976931348623157e308,rt=NaN,nt=[["ary",X],["bind",z],["bindKey",H],["curry",G],["curryRight",Y],["flip",Z],["partial",J],["partialRight",Q],["rearg",256]],it="[object Function]",ot="[object GeneratorFunction]",at="[object Symbol]",st=/[\\^$.*+?()[\]{}|]/g,ut=/^\s+|\s+$/g,ct=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,lt=/\{\n\/\* \[wrapped with (.+)\] \*/,ft=/,? & /,ht=/^[-+]0x[0-9a-f]+$/i,pt=/^0b[01]+$/i,dt=/^\[object .+?Constructor\]$/,gt=/^0o[0-7]+$/i,vt=/^(?:0|[1-9]\d*)$/,yt=parseInt,bt="object"==typeof e&&e&&e.Object===Object&&e,mt="object"==typeof self&&self&&self.Object===Object&&self,_t=bt||mt||Function("return this")(),wt=Function.prototype,xt=Object.prototype,St=_t["__core-js_shared__"],jt=function(){var t=/[^.]+$/.exec(St&&St.keys&&St.keys.IE_PROTO||"");return t?"Symbol(src)_1."+t:""}(),kt=wt.toString,At=xt.hasOwnProperty,Et=xt.toString,Tt=RegExp("^"+kt.call(At).replace(st,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Ot=Object.create,Lt=Math.max,Ct=Math.min,Bt=function(){var t=k(Object,"defineProperty"),e=k.name;return e&&e.length>2?t:void 0}(),Dt=Bt?function(t,e,r){var n=e+"";return Bt(t,"toString",{configurable:!0,enumerable:!1,value:U(E(n,B(A(n),r)))})}:F,Rt=function(t,e){return e=Lt(void 0===e?t.length-1:e,0),function(){for(var n=arguments,i=-1,o=Lt(n.length-e,0),a=Array(o);++i<o;)a[i]=n[e+i];i=-1;for(var s=Array(e+1);++i<e;)s[i]=n[i];return s[e]=a,r(t,this,s)}}(function(t,e,r){var n=z;if(r.length){var i=f(r,j(Rt));n|=J}return S(t,n,e,r,i)});Rt.placeholder={},t.exports=Rt}).call(e,r(0))},function(t,e,r){function n(t,e,r){if(e)"string"==typeof e&&(e=o(e,t._root,r));else{if(!t._root||!t._root.children)return"";e=t._root.children}return i(e,r)}var i=r(23),o=r(42),a=r(12),s={merge:r(92),defaults:r(41)};e.load=function(t,n){var i=r(16);n=s.defaults(n||{},i.prototype.options);var o=a(t,n),u=function(t,e,r,a){return this instanceof u?(a=s.defaults(a||{},n),i.call(this,t,e,r||o,a)):new u(t,e,r,a)};return u.prototype=Object.create(i.prototype),u.prototype.constructor=u,u.fn=u.prototype,u.prototype._originalRoot=o,s.merge(u,e),u._root=o,u._options=n,u},e.html=function(t,e){var i=r(16);return"[object Object]"!==Object.prototype.toString.call(t)||e||"length"in t||"type"in t||(e=t,t=void 0),e=s.defaults(e||{},this._options,i.prototype.options),n(this,t,e)},e.xml=function(t){return n(this,t,s.defaults({xmlMode:!0},this._options))},e.text=function(t){t||(t=this.root());for(var r,n="",i=t.length,o=0;o<i;o++)r=t[o],"text"===r.type?n+=r.data:r.children&&"comment"!==r.type&&(n+=e.text(r.children));return n},e.parseHTML=function(t,e,r){var n;return t&&"string"==typeof t?("boolean"==typeof e&&(r=e),n=this.load(t),r||n("script").remove(),n.root()[0].children.slice()):null},e.root=function(){return this(this._root)},e.contains=function(t,e){if(e===t)return!1;for(;e&&e!==e.parent;)if((e=e.parent)===t)return!0;return!1}},function(t,e,r){function n(t){for(var e=0;t&&e<t.length;e++)if(u(t[e]))return t[e]}function i(t,e){var r={name:t,value:e};return function(t){return y(t,r)}}function o(t){return function(e){return!!l(e)&&t(e)}}function a(t,e,r){if(null===r){if(t.length>1&&"scope"!==e)throw new SyntaxError("pseudo-selector :"+e+" requires an argument")}else if(1===t.length)throw new SyntaxError("pseudo-selector :"+e+" doesn't have any arguments")}var s=r(4),u=s.isTag,c=s.getText,l=s.getParent,f=s.getChildren,h=s.getSiblings,p=s.hasAttrib,d=s.getName,g=s.getAttributeValue,v=r(85),y=r(43).rules.equals,b=r(11),m=b.trueFunc,_=b.falseFunc,w={contains:function(t,e){return function(r){return t(r)&&c(r).indexOf(e)>=0}},icontains:function(t,e){var r=e.toLowerCase();return function(e){return t(e)&&c(e).toLowerCase().indexOf(r)>=0}},"nth-child":function(t,e){var r=v(e);return r===_?r:r===m?o(t):function(e){for(var n=h(e),i=0,o=0;i<n.length;i++)if(u(n[i])){if(n[i]===e)break;o++}return r(o)&&t(e)}},"nth-last-child":function(t,e){var r=v(e);return r===_?r:r===m?o(t):function(e){for(var n=h(e),i=0,o=n.length-1;o>=0;o--)if(u(n[o])){if(n[o]===e)break;i++}return r(i)&&t(e)}},"nth-of-type":function(t,e){var r=v(e);return r===_?r:r===m?o(t):function(e){for(var n=h(e),i=0,o=0;o<n.length;o++)if(u(n[o])){if(n[o]===e)break;d(n[o])===d(e)&&i++}return r(i)&&t(e)}},"nth-last-of-type":function(t,e){var r=v(e);return r===_?r:r===m?o(t):function(e){for(var n=h(e),i=0,o=n.length-1;o>=0;o--)if(u(n[o])){if(n[o]===e)break;d(n[o])===d(e)&&i++}return r(i)&&t(e)}},root:function(t){return function(e){return!l(e)&&t(e)}},scope:function(t,e,r,n){return n&&0!==n.length?1===n.length?function(e){return n[0]===e&&t(e)}:function(e){return n.indexOf(e)>=0&&t(e)}:w.root(t)},checkbox:i("type","checkbox"),file:i("type","file"),password:i("type","password"),radio:i("type","radio"),reset:i("type","reset"),image:i("type","image"),submit:i("type","submit")},x={empty:function(t){return!f(t).some(function(t){return u(t)||"text"===t.type})},"first-child":function(t){return n(h(t))===t},"last-child":function(t){for(var e=h(t),r=e.length-1;r>=0;r--){if(e[r]===t)return!0;if(u(e[r]))break}return!1},"first-of-type":function(t){for(var e=h(t),r=0;r<e.length;r++)if(u(e[r])){if(e[r]===t)return!0;if(d(e[r])===d(t))break}return!1},"last-of-type":function(t){for(var e=h(t),r=e.length-1;r>=0;r--)if(u(e[r])){if(e[r]===t)return!0;if(d(e[r])===d(t))break}return!1},"only-of-type":function(t){for(var e=h(t),r=0,n=e.length;r<n;r++)if(u(e[r])){if(e[r]===t)continue;if(d(e[r])===d(t))return!1}return!0},"only-child":function(t){for(var e=h(t),r=0;r<e.length;r++)if(u(e[r])&&e[r]!==t)return!1;return!0},link:function(t){return p(t,"href")},visited:_,selected:function(t){if(p(t,"selected"))return!0;if("option"!==d(t))return!1;var e=l(t);if(!e||"select"!==d(e)||p(e,"multiple"))return!1;for(var r=f(e),n=!1,i=0;i<r.length;i++)if(u(r[i]))if(r[i]===t)n=!0;else{if(!n)return!1;if(p(r[i],"selected"))return!1}return n},disabled:function(t){return p(t,"disabled")},enabled:function(t){return!p(t,"disabled")},checked:function(t){return p(t,"checked")||x.selected(t)},required:function(t){return p(t,"required")},optional:function(t){return!p(t,"required")},parent:function(t){return!x.empty(t)},header:function(t){var e=d(t);return"h1"===e||"h2"===e||"h3"===e||"h4"===e||"h5"===e||"h6"===e},button:function(t){var e=d(t);return"button"===e||"input"===e&&"button"===g(t,"type")},input:function(t){var e=d(t);return"input"===e||"textarea"===e||"select"===e||"button"===e},text:function(t){var e;return"input"===d(t)&&(!(e=g(t,"type"))||"text"===e.toLowerCase())}},S=/^(?:(?:nth|last|first|only)-(?:child|of-type)|root|empty|(?:en|dis)abled|checked|not)$/;t.exports={compile:function(t,e,r,n){var i=e.name,o=e.data;if(r&&r.strict&&!S.test(i))throw SyntaxError(":"+i+" isn't part of CSS3");if("function"==typeof w[i])return a(w[i],i,o),w[i](t,o,r,n);if("function"==typeof x[i]){var s=x[i];return a(s,i,o),t===m?s:function(e){return s(e,o)&&t(e)}}throw new SyntaxError("unmatched pseudo-class :"+i)},filters:w,pseudos:x}},function(t,e,r){"use strict";var n=r(105),i={}.hasOwnProperty,o=r(108),a=r(110);e.Selector=o,e.Property=a,/**
 * Returns an array of the selectors.
 *
 * @license Sizzle CSS Selector Engine - MIT
 * @param {String} selectorText from mensch
 * @api public
 */
e.extract=function(t){for(var e=0,r=[],n="",i=0,o=t.length;i<o;i++){var a=t.charAt(i);e?("]"!==a&&")"!==a||e--,n+=a):","===a?(r.push(n),n=""):("["!==a&&"("!==a||e++,(n.length||","!==a&&"\n"!==a&&" "!==a)&&(n+=a))}return n.length&&r.push(n),r},e.parseCSS=function(t){for(var e=n.parse(t,{position:!0,comments:!0}),r=void 0!==e.stylesheet&&e.stylesheet.rules?e.stylesheet.rules:[],i=[],o=0,a=r.length;o<a;o++)if("rule"==r[o].type)for(var s=r[o],u=s.selectors,c=0,l=u.length;c<l;c++)i.push([u[c],s.declarations]);return i},e.getPreservedText=function(t,e){for(var r=n.parse(t,{position:!0,comments:!0}),i=void 0!==r.stylesheet&&r.stylesheet.rules?r.stylesheet.rules:[],o=[],a=i.length-1;a>=0;a--)(e.fontFaces&&"font-face"===i[a].type||e.mediaQueries&&"media"===i[a].type)&&o.unshift(n.stringify({stylesheet:{rules:[i[a]]}},{comments:!1,indentation:"  "})),i[a].position.start;return 0!==o.length&&"\n"+o.join("\n")+"\n"},e.normalizeLineEndings=function(t){return t.replace(/\r\n/g,"\n").replace(/\n/g,"\r\n")},e.compareFunc=function(t,e){for(var r=Math.min(t.length,e.length),n=0;n<r;n++)if(t[n]!==e[n])return t[n]>e[n]?1:-1;return t.length-e.length},e.compare=function(t,r){return 1==e.compareFunc(t,r)?t:r},e.extend=function(t,e){for(var r in e)i.call(e,r)&&(t[r]=e[r]);return t},e.getDefaultOptions=function(t){var r=e.extend({extraCss:"",insertPreservedExtraCss:!0,applyStyleTags:!0,removeStyleTags:!0,preserveMediaQueries:!0,preserveFontFaces:!0,applyWidthAttributes:!0,applyHeightAttributes:!0,applyAttributesTableElements:!0,url:""},t);return r.webResources=r.webResources||{},r}},function(t,e,r){(function(r){function n(t){return i.bind(null,t)}function i(t){var e=[].slice.call(arguments,1);e.unshift("["+t+"]"),r.stderr.write(e.join(" ")+"\n")}e=t.exports=n}).call(e,r(8))},function(t,e){var r={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==r.call(t)}},function(t,e,r){function n(t,e){this._options=e||{},this._cbs=t||{},this._tagname="",this._attribname="",this._attribvalue="",this._attribs=null,this._stack=[],this.startIndex=0,this.endIndex=null,this._lowerCaseTagNames="lowerCaseTags"in this._options?!!this._options.lowerCaseTags:!this._options.xmlMode,this._lowerCaseAttributeNames="lowerCaseAttributeNames"in this._options?!!this._options.lowerCaseAttributeNames:!this._options.xmlMode,this._options.Tokenizer&&(i=this._options.Tokenizer),this._tokenizer=new i(this._options,this),this._cbs.onparserinit&&this._cbs.onparserinit(this)}var i=r(31),o={input:!0,option:!0,optgroup:!0,select:!0,button:!0,datalist:!0,textarea:!0},a={tr:{tr:!0,th:!0,td:!0},th:{th:!0},td:{thead:!0,th:!0,td:!0},body:{head:!0,link:!0,script:!0},li:{li:!0},p:{p:!0},h1:{p:!0},h2:{p:!0},h3:{p:!0},h4:{p:!0},h5:{p:!0},h6:{p:!0},select:o,input:o,output:o,button:o,datalist:o,textarea:o,option:{option:!0},optgroup:{optgroup:!0}},s={__proto__:null,area:!0,base:!0,basefont:!0,br:!0,col:!0,command:!0,embed:!0,frame:!0,hr:!0,img:!0,input:!0,isindex:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0,path:!0,circle:!0,ellipse:!0,line:!0,rect:!0,use:!0,stop:!0,polyline:!0,polygon:!0},u=/\s|\//;r(1)(n,r(13).EventEmitter),n.prototype._updatePosition=function(t){null===this.endIndex?this._tokenizer._sectionStart<=t?this.startIndex=0:this.startIndex=this._tokenizer._sectionStart-t:this.startIndex=this.endIndex+1,this.endIndex=this._tokenizer.getAbsoluteIndex()},n.prototype.ontext=function(t){this._updatePosition(1),this.endIndex--,this._cbs.ontext&&this._cbs.ontext(t)},n.prototype.onopentagname=function(t){if(this._lowerCaseTagNames&&(t=t.toLowerCase()),this._tagname=t,!this._options.xmlMode&&t in a)for(var e;(e=this._stack[this._stack.length-1])in a[t];this.onclosetag(e));!this._options.xmlMode&&t in s||this._stack.push(t),this._cbs.onopentagname&&this._cbs.onopentagname(t),this._cbs.onopentag&&(this._attribs={})},n.prototype.onopentagend=function(){this._updatePosition(1),this._attribs&&(this._cbs.onopentag&&this._cbs.onopentag(this._tagname,this._attribs),this._attribs=null),!this._options.xmlMode&&this._cbs.onclosetag&&this._tagname in s&&this._cbs.onclosetag(this._tagname),this._tagname=""},n.prototype.onclosetag=function(t){if(this._updatePosition(1),this._lowerCaseTagNames&&(t=t.toLowerCase()),!this._stack.length||t in s&&!this._options.xmlMode)this._options.xmlMode||"br"!==t&&"p"!==t||(this.onopentagname(t),this._closeCurrentTag());else{var e=this._stack.lastIndexOf(t);if(-1!==e)if(this._cbs.onclosetag)for(e=this._stack.length-e;e--;)this._cbs.onclosetag(this._stack.pop());else this._stack.length=e;else"p"!==t||this._options.xmlMode||(this.onopentagname(t),this._closeCurrentTag())}},n.prototype.onselfclosingtag=function(){this._options.xmlMode||this._options.recognizeSelfClosing?this._closeCurrentTag():this.onopentagend()},n.prototype._closeCurrentTag=function(){var t=this._tagname;this.onopentagend(),this._stack[this._stack.length-1]===t&&(this._cbs.onclosetag&&this._cbs.onclosetag(t),this._stack.pop())},n.prototype.onattribname=function(t){this._lowerCaseAttributeNames&&(t=t.toLowerCase()),this._attribname=t},n.prototype.onattribdata=function(t){this._attribvalue+=t},n.prototype.onattribend=function(){this._cbs.onattribute&&this._cbs.onattribute(this._attribname,this._attribvalue),this._attribs&&!Object.prototype.hasOwnProperty.call(this._attribs,this._attribname)&&(this._attribs[this._attribname]=this._attribvalue),this._attribname="",this._attribvalue=""},n.prototype._getInstructionName=function(t){var e=t.search(u),r=e<0?t:t.substr(0,e);return this._lowerCaseTagNames&&(r=r.toLowerCase()),r},n.prototype.ondeclaration=function(t){if(this._cbs.onprocessinginstruction){var e=this._getInstructionName(t);this._cbs.onprocessinginstruction("!"+e,"!"+t)}},n.prototype.onprocessinginstruction=function(t){if(this._cbs.onprocessinginstruction){var e=this._getInstructionName(t);this._cbs.onprocessinginstruction("?"+e,"?"+t)}},n.prototype.oncomment=function(t){this._updatePosition(4),this._cbs.oncomment&&this._cbs.oncomment(t),this._cbs.oncommentend&&this._cbs.oncommentend()},n.prototype.oncdata=function(t){this._updatePosition(1),this._options.xmlMode||this._options.recognizeCDATA?(this._cbs.oncdatastart&&this._cbs.oncdatastart(),this._cbs.ontext&&this._cbs.ontext(t),this._cbs.oncdataend&&this._cbs.oncdataend()):this.oncomment("[CDATA["+t+"]]")},n.prototype.onerror=function(t){this._cbs.onerror&&this._cbs.onerror(t)},n.prototype.onend=function(){if(this._cbs.onclosetag)for(var t=this._stack.length;t>0;this._cbs.onclosetag(this._stack[--t]));this._cbs.onend&&this._cbs.onend()},n.prototype.reset=function(){this._cbs.onreset&&this._cbs.onreset(),this._tokenizer.reset(),this._tagname="",this._attribname="",this._attribs=null,this._stack=[],this._cbs.onparserinit&&this._cbs.onparserinit(this)},n.prototype.parseComplete=function(t){this.reset(),this.end(t)},n.prototype.write=function(t){this._tokenizer.write(t)},n.prototype.end=function(t){this._tokenizer.end(t)},n.prototype.pause=function(){this._tokenizer.pause()},n.prototype.resume=function(){this._tokenizer.resume()},n.prototype.parseChunk=n.prototype.write,n.prototype.done=n.prototype.end,t.exports=n},function(t,e,r){function n(t){return" "===t||"\n"===t||"\t"===t||"\f"===t||"\r"===t}function i(t,e,r){var n=t.toLowerCase();return t===n?function(t){t===n?this._state=e:(this._state=r,this._index--)}:function(i){i===n||i===t?this._state=e:(this._state=r,this._index--)}}function o(t,e){var r=t.toLowerCase();return function(n){n===r||n===t?this._state=e:(this._state=d,this._index--)}}function a(t,e){this._state=h,this._buffer="",this._sectionStart=0,this._index=0,this._bufferOffset=0,this._baseState=h,this._special=dt,this._cbs=e,this._running=!0,this._ended=!1,this._xmlMode=!(!t||!t.xmlMode),this._decodeEntities=!(!t||!t.decodeEntities)}t.exports=a;var s=r(32),u=r(17),c=r(33),l=r(18),f=0,h=f++,p=f++,d=f++,g=f++,v=f++,y=f++,b=f++,m=f++,_=f++,w=f++,x=f++,S=f++,j=f++,k=f++,A=f++,E=f++,T=f++,O=f++,L=f++,C=f++,B=f++,D=f++,R=f++,P=f++,q=f++,M=f++,I=f++,N=f++,U=f++,F=f++,V=f++,$=f++,z=f++,H=f++,W=f++,G=f++,Y=f++,J=f++,Q=f++,X=f++,Z=f++,K=f++,tt=f++,et=f++,rt=f++,nt=f++,it=f++,ot=f++,at=f++,st=f++,ut=f++,ct=f++,lt=f++,ft=f++,ht=f++,pt=0,dt=pt++,gt=pt++,vt=pt++;a.prototype._stateText=function(t){"<"===t?(this._index>this._sectionStart&&this._cbs.ontext(this._getSection()),this._state=p,this._sectionStart=this._index):this._decodeEntities&&this._special===dt&&"&"===t&&(this._index>this._sectionStart&&this._cbs.ontext(this._getSection()),this._baseState=h,this._state=ut,this._sectionStart=this._index)},a.prototype._stateBeforeTagName=function(t){"/"===t?this._state=v:"<"===t?(this._cbs.ontext(this._getSection()),this._sectionStart=this._index):">"===t||this._special!==dt||n(t)?this._state=h:"!"===t?(this._state=A,this._sectionStart=this._index+1):"?"===t?(this._state=T,this._sectionStart=this._index+1):(this._state=this._xmlMode||"s"!==t&&"S"!==t?d:V,this._sectionStart=this._index)},a.prototype._stateInTagName=function(t){("/"===t||">"===t||n(t))&&(this._emitToken("onopentagname"),this._state=m,this._index--)},a.prototype._stateBeforeCloseingTagName=function(t){n(t)||(">"===t?this._state=h:this._special!==dt?"s"===t||"S"===t?this._state=$:(this._state=h,this._index--):(this._state=y,this._sectionStart=this._index))},a.prototype._stateInCloseingTagName=function(t){(">"===t||n(t))&&(this._emitToken("onclosetag"),this._state=b,this._index--)},a.prototype._stateAfterCloseingTagName=function(t){">"===t&&(this._state=h,this._sectionStart=this._index+1)},a.prototype._stateBeforeAttributeName=function(t){">"===t?(this._cbs.onopentagend(),this._state=h,this._sectionStart=this._index+1):"/"===t?this._state=g:n(t)||(this._state=_,this._sectionStart=this._index)},a.prototype._stateInSelfClosingTag=function(t){">"===t?(this._cbs.onselfclosingtag(),this._state=h,this._sectionStart=this._index+1):n(t)||(this._state=m,this._index--)},a.prototype._stateInAttributeName=function(t){("="===t||"/"===t||">"===t||n(t))&&(this._cbs.onattribname(this._getSection()),this._sectionStart=-1,this._state=w,this._index--)},a.prototype._stateAfterAttributeName=function(t){"="===t?this._state=x:"/"===t||">"===t?(this._cbs.onattribend(),this._state=m,this._index--):n(t)||(this._cbs.onattribend(),this._state=_,this._sectionStart=this._index)},a.prototype._stateBeforeAttributeValue=function(t){'"'===t?(this._state=S,this._sectionStart=this._index+1):"'"===t?(this._state=j,this._sectionStart=this._index+1):n(t)||(this._state=k,this._sectionStart=this._index,this._index--)},a.prototype._stateInAttributeValueDoubleQuotes=function(t){'"'===t?(this._emitToken("onattribdata"),this._cbs.onattribend(),this._state=m):this._decodeEntities&&"&"===t&&(this._emitToken("onattribdata"),this._baseState=this._state,this._state=ut,this._sectionStart=this._index)},a.prototype._stateInAttributeValueSingleQuotes=function(t){"'"===t?(this._emitToken("onattribdata"),this._cbs.onattribend(),this._state=m):this._decodeEntities&&"&"===t&&(this._emitToken("onattribdata"),this._baseState=this._state,this._state=ut,this._sectionStart=this._index)},a.prototype._stateInAttributeValueNoQuotes=function(t){n(t)||">"===t?(this._emitToken("onattribdata"),this._cbs.onattribend(),this._state=m,this._index--):this._decodeEntities&&"&"===t&&(this._emitToken("onattribdata"),this._baseState=this._state,this._state=ut,this._sectionStart=this._index)},a.prototype._stateBeforeDeclaration=function(t){this._state="["===t?D:"-"===t?O:E},a.prototype._stateInDeclaration=function(t){">"===t&&(this._cbs.ondeclaration(this._getSection()),this._state=h,this._sectionStart=this._index+1)},a.prototype._stateInProcessingInstruction=function(t){">"===t&&(this._cbs.onprocessinginstruction(this._getSection()),this._state=h,this._sectionStart=this._index+1)},a.prototype._stateBeforeComment=function(t){"-"===t?(this._state=L,this._sectionStart=this._index+1):this._state=E},a.prototype._stateInComment=function(t){"-"===t&&(this._state=C)},a.prototype._stateAfterComment1=function(t){this._state="-"===t?B:L},a.prototype._stateAfterComment2=function(t){">"===t?(this._cbs.oncomment(this._buffer.substring(this._sectionStart,this._index-2)),this._state=h,this._sectionStart=this._index+1):"-"!==t&&(this._state=L)},a.prototype._stateBeforeCdata1=i("C",R,E),a.prototype._stateBeforeCdata2=i("D",P,E),a.prototype._stateBeforeCdata3=i("A",q,E),a.prototype._stateBeforeCdata4=i("T",M,E),a.prototype._stateBeforeCdata5=i("A",I,E),a.prototype._stateBeforeCdata6=function(t){"["===t?(this._state=N,this._sectionStart=this._index+1):(this._state=E,this._index--)},a.prototype._stateInCdata=function(t){"]"===t&&(this._state=U)},a.prototype._stateAfterCdata1=function(t,e){return function(r){r===t&&(this._state=e)}}("]",F),a.prototype._stateAfterCdata2=function(t){">"===t?(this._cbs.oncdata(this._buffer.substring(this._sectionStart,this._index-2)),this._state=h,this._sectionStart=this._index+1):"]"!==t&&(this._state=N)},a.prototype._stateBeforeSpecial=function(t){"c"===t||"C"===t?this._state=z:"t"===t||"T"===t?this._state=tt:(this._state=d,this._index--)},a.prototype._stateBeforeSpecialEnd=function(t){this._special!==gt||"c"!==t&&"C"!==t?this._special!==vt||"t"!==t&&"T"!==t?this._state=h:this._state=it:this._state=J},a.prototype._stateBeforeScript1=o("R",H),a.prototype._stateBeforeScript2=o("I",W),a.prototype._stateBeforeScript3=o("P",G),a.prototype._stateBeforeScript4=o("T",Y),a.prototype._stateBeforeScript5=function(t){("/"===t||">"===t||n(t))&&(this._special=gt),this._state=d,this._index--},a.prototype._stateAfterScript1=i("R",Q,h),a.prototype._stateAfterScript2=i("I",X,h),a.prototype._stateAfterScript3=i("P",Z,h),a.prototype._stateAfterScript4=i("T",K,h),a.prototype._stateAfterScript5=function(t){">"===t||n(t)?(this._special=dt,this._state=y,this._sectionStart=this._index-6,this._index--):this._state=h},a.prototype._stateBeforeStyle1=o("Y",et),a.prototype._stateBeforeStyle2=o("L",rt),a.prototype._stateBeforeStyle3=o("E",nt),a.prototype._stateBeforeStyle4=function(t){("/"===t||">"===t||n(t))&&(this._special=vt),this._state=d,this._index--},a.prototype._stateAfterStyle1=i("Y",ot,h),a.prototype._stateAfterStyle2=i("L",at,h),a.prototype._stateAfterStyle3=i("E",st,h),a.prototype._stateAfterStyle4=function(t){">"===t||n(t)?(this._special=dt,this._state=y,this._sectionStart=this._index-5,this._index--):this._state=h},a.prototype._stateBeforeEntity=i("#",ct,lt),a.prototype._stateBeforeNumericEntity=i("X",ht,ft),a.prototype._parseNamedEntityStrict=function(){if(this._sectionStart+1<this._index){var t=this._buffer.substring(this._sectionStart+1,this._index),e=this._xmlMode?l:u;e.hasOwnProperty(t)&&(this._emitPartial(e[t]),this._sectionStart=this._index+1)}},a.prototype._parseLegacyEntity=function(){var t=this._sectionStart+1,e=this._index-t;for(e>6&&(e=6);e>=2;){var r=this._buffer.substr(t,e);if(c.hasOwnProperty(r))return this._emitPartial(c[r]),void(this._sectionStart+=e+1);e--}},a.prototype._stateInNamedEntity=function(t){";"===t?(this._parseNamedEntityStrict(),this._sectionStart+1<this._index&&!this._xmlMode&&this._parseLegacyEntity(),this._state=this._baseState):(t<"a"||t>"z")&&(t<"A"||t>"Z")&&(t<"0"||t>"9")&&(this._xmlMode||this._sectionStart+1===this._index||(this._baseState!==h?"="!==t&&this._parseNamedEntityStrict():this._parseLegacyEntity()),this._state=this._baseState,this._index--)},a.prototype._decodeNumericEntity=function(t,e){var r=this._sectionStart+t;if(r!==this._index){var n=this._buffer.substring(r,this._index),i=parseInt(n,e);this._emitPartial(s(i)),this._sectionStart=this._index}else this._sectionStart--;this._state=this._baseState},a.prototype._stateInNumericEntity=function(t){";"===t?(this._decodeNumericEntity(2,10),this._sectionStart++):(t<"0"||t>"9")&&(this._xmlMode?this._state=this._baseState:this._decodeNumericEntity(2,10),this._index--)},a.prototype._stateInHexEntity=function(t){";"===t?(this._decodeNumericEntity(3,16),this._sectionStart++):(t<"a"||t>"f")&&(t<"A"||t>"F")&&(t<"0"||t>"9")&&(this._xmlMode?this._state=this._baseState:this._decodeNumericEntity(3,16),this._index--)},a.prototype._cleanup=function(){this._sectionStart<0?(this._buffer="",this._bufferOffset+=this._index,this._index=0):this._running&&(this._state===h?(this._sectionStart!==this._index&&this._cbs.ontext(this._buffer.substr(this._sectionStart)),this._buffer="",this._bufferOffset+=this._index,this._index=0):this._sectionStart===this._index?(this._buffer="",this._bufferOffset+=this._index,this._index=0):(this._buffer=this._buffer.substr(this._sectionStart),this._index-=this._sectionStart,this._bufferOffset+=this._sectionStart),this._sectionStart=0)},a.prototype.write=function(t){this._ended&&this._cbs.onerror(Error(".write() after done!")),this._buffer+=t,this._parse()},a.prototype._parse=function(){for(;this._index<this._buffer.length&&this._running;){var t=this._buffer.charAt(this._index);this._state===h?this._stateText(t):this._state===p?this._stateBeforeTagName(t):this._state===d?this._stateInTagName(t):this._state===v?this._stateBeforeCloseingTagName(t):this._state===y?this._stateInCloseingTagName(t):this._state===b?this._stateAfterCloseingTagName(t):this._state===g?this._stateInSelfClosingTag(t):this._state===m?this._stateBeforeAttributeName(t):this._state===_?this._stateInAttributeName(t):this._state===w?this._stateAfterAttributeName(t):this._state===x?this._stateBeforeAttributeValue(t):this._state===S?this._stateInAttributeValueDoubleQuotes(t):this._state===j?this._stateInAttributeValueSingleQuotes(t):this._state===k?this._stateInAttributeValueNoQuotes(t):this._state===A?this._stateBeforeDeclaration(t):this._state===E?this._stateInDeclaration(t):this._state===T?this._stateInProcessingInstruction(t):this._state===O?this._stateBeforeComment(t):this._state===L?this._stateInComment(t):this._state===C?this._stateAfterComment1(t):this._state===B?this._stateAfterComment2(t):this._state===D?this._stateBeforeCdata1(t):this._state===R?this._stateBeforeCdata2(t):this._state===P?this._stateBeforeCdata3(t):this._state===q?this._stateBeforeCdata4(t):this._state===M?this._stateBeforeCdata5(t):this._state===I?this._stateBeforeCdata6(t):this._state===N?this._stateInCdata(t):this._state===U?this._stateAfterCdata1(t):this._state===F?this._stateAfterCdata2(t):this._state===V?this._stateBeforeSpecial(t):this._state===$?this._stateBeforeSpecialEnd(t):this._state===z?this._stateBeforeScript1(t):this._state===H?this._stateBeforeScript2(t):this._state===W?this._stateBeforeScript3(t):this._state===G?this._stateBeforeScript4(t):this._state===Y?this._stateBeforeScript5(t):this._state===J?this._stateAfterScript1(t):this._state===Q?this._stateAfterScript2(t):this._state===X?this._stateAfterScript3(t):this._state===Z?this._stateAfterScript4(t):this._state===K?this._stateAfterScript5(t):this._state===tt?this._stateBeforeStyle1(t):this._state===et?this._stateBeforeStyle2(t):this._state===rt?this._stateBeforeStyle3(t):this._state===nt?this._stateBeforeStyle4(t):this._state===it?this._stateAfterStyle1(t):this._state===ot?this._stateAfterStyle2(t):this._state===at?this._stateAfterStyle3(t):this._state===st?this._stateAfterStyle4(t):this._state===ut?this._stateBeforeEntity(t):this._state===ct?this._stateBeforeNumericEntity(t):this._state===lt?this._stateInNamedEntity(t):this._state===ft?this._stateInNumericEntity(t):this._state===ht?this._stateInHexEntity(t):this._cbs.onerror(Error("unknown _state"),this._state),this._index++}this._cleanup()},a.prototype.pause=function(){this._running=!1},a.prototype.resume=function(){this._running=!0,this._index<this._buffer.length&&this._parse(),this._ended&&this._finish()},a.prototype.end=function(t){this._ended&&this._cbs.onerror(Error(".end() after done!")),t&&this.write(t),this._ended=!0,this._running&&this._finish()},a.prototype._finish=function(){this._sectionStart<this._index&&this._handleTrailingData(),this._cbs.onend()},a.prototype._handleTrailingData=function(){var t=this._buffer.substr(this._sectionStart);this._state===N||this._state===U||this._state===F?this._cbs.oncdata(t):this._state===L||this._state===C||this._state===B?this._cbs.oncomment(t):this._state!==lt||this._xmlMode?this._state!==ft||this._xmlMode?this._state!==ht||this._xmlMode?this._state!==d&&this._state!==m&&this._state!==x&&this._state!==w&&this._state!==_&&this._state!==j&&this._state!==S&&this._state!==k&&this._state!==y&&this._cbs.ontext(t):(this._decodeNumericEntity(3,16),this._sectionStart<this._index&&(this._state=this._baseState,this._handleTrailingData())):(this._decodeNumericEntity(2,10),this._sectionStart<this._index&&(this._state=this._baseState,this._handleTrailingData())):(this._parseLegacyEntity(),this._sectionStart<this._index&&(this._state=this._baseState,this._handleTrailingData()))},a.prototype.reset=function(){a.call(this,{xmlMode:this._xmlMode,decodeEntities:this._decodeEntities},this._cbs)},a.prototype.getAbsoluteIndex=function(){return this._bufferOffset+this._index},a.prototype._getSection=function(){return this._buffer.substring(this._sectionStart,this._index)},a.prototype._emitToken=function(t){this._cbs[t](this._getSection()),this._sectionStart=-1},a.prototype._emitPartial=function(t){this._baseState!==h?this._cbs.onattribdata(t):this._cbs.ontext(t)}},function(t,e,r){function n(t){if(t>=55296&&t<=57343||t>1114111)return"";t in i&&(t=i[t]);var e="";return t>65535&&(t-=65536,e+=String.fromCharCode(t>>>10&1023|55296),t=56320|1023&t),e+=String.fromCharCode(t)}var i=r(55);t.exports=n},function(t,e){t.exports={Aacute:"",aacute:"",Acirc:"",acirc:"",acute:"",AElig:"",aelig:"",Agrave:"",agrave:" ",amp:"&",AMP:"&",Aring:"",aring:"",Atilde:"",atilde:"",Auml:"",auml:"",brvbar:"",Ccedil:"",ccedil:"",cedil:"",cent:"",copy:"",COPY:"",curren:"",deg:"",divide:"",Eacute:"",eacute:"",Ecirc:"",ecirc:"",Egrave:"",egrave:"",ETH:"",eth:"",Euml:"",euml:"",frac12:"",frac14:"",frac34:"",gt:">",GT:">",Iacute:"",iacute:"",Icirc:"",icirc:"",iexcl:"",Igrave:"",igrave:"",iquest:"",Iuml:"",iuml:"",laquo:"",lt:"<",LT:"<",macr:"",micro:"",middot:"",nbsp:" ",not:"",Ntilde:"",ntilde:"",Oacute:"",oacute:"",Ocirc:"",ocirc:"",Ograve:"",ograve:"",ordf:"",ordm:"",Oslash:"",oslash:"",Otilde:"",otilde:"",Ouml:"",ouml:"",para:"",plusmn:"",pound:"",quot:'"',QUOT:'"',raquo:"",reg:"",REG:"",sect:"",shy:"",sup1:"",sup2:"",sup3:"",szlig:"",THORN:"",thorn:"",times:"",Uacute:"",uacute:"",Ucirc:"",ucirc:"",Ugrave:"",ugrave:"",uml:"",Uuml:"",uuml:"",Yacute:"",yacute:"",yen:"",yuml:""}},function(t,e){var r=t.exports={get firstChild(){var t=this.children;return t&&t[0]||null},get lastChild(){var t=this.children;return t&&t[t.length-1]||null},get nodeType(){return i[this.type]||i.element}},n={tagName:"name",childNodes:"children",parentNode:"parent",previousSibling:"prev",nextSibling:"next",nodeValue:"data"},i={element:1,text:3,cdata:4,comment:8};Object.keys(n).forEach(function(t){var e=n[t];Object.defineProperty(r,t,{get:function(){return this[e]||null},set:function(t){return this[e]=t,t}})})},function(t,e,r){function n(t,e){var r=this._parser=new i(t,e),n=this._decoder=new a;o.call(this,{decodeStrings:!1}),this.once("finish",function(){r.end(n.end())})}t.exports=n;var i=r(30),o=r(60).Writable||r(71).Writable,a=r(22).StringDecoder,s=r(6).Buffer;r(1)(n,o),o.prototype._write=function(t,e,r){t instanceof s&&(t=this._decoder.write(t)),this._parser.write(t),r()}},function(t,e,r){"use strict";(function(e,n){function i(t){return M.from(t)}function o(t){return M.isBuffer(t)||t instanceof I}function a(t,e,r){if("function"==typeof t.prependListener)return t.prependListener(e,r);t._events&&t._events[e]?R(t._events[e])?t._events[e].unshift(r):t._events[e]=[r,t._events[e]]:t.on(e,r)}function s(t,e){D=D||r(2),t=t||{},this.objectMode=!!t.objectMode,e instanceof D&&(this.objectMode=this.objectMode||!!t.readableObjectMode);var n=t.highWaterMark,i=this.objectMode?16:16384;this.highWaterMark=n||0===n?n:i,this.highWaterMark=Math.floor(this.highWaterMark),this.buffer=new $,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.destroyed=!1,this.defaultEncoding=t.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,t.encoding&&(V||(V=r(22).StringDecoder),this.decoder=new V(t.encoding),this.encoding=t.encoding)}function u(t){if(D=D||r(2),!(this instanceof u))return new u(t);this._readableState=new s(t,this),this.readable=!0,t&&("function"==typeof t.read&&(this._read=t.read),"function"==typeof t.destroy&&(this._destroy=t.destroy)),q.call(this)}function c(t,e,r,n,o){var a=t._readableState;if(null===e)a.reading=!1,g(t,a);else{var s;o||(s=f(a,e)),s?t.emit("error",s):a.objectMode||e&&e.length>0?("string"==typeof e||a.objectMode||Object.getPrototypeOf(e)===M.prototype||(e=i(e)),n?a.endEmitted?t.emit("error",new Error("stream.unshift() after end event")):l(t,a,e,!0):a.ended?t.emit("error",new Error("stream.push() after EOF")):(a.reading=!1,a.decoder&&!r?(e=a.decoder.write(e),a.objectMode||0!==e.length?l(t,a,e,!1):b(t,a)):l(t,a,e,!1))):n||(a.reading=!1)}return h(a)}function l(t,e,r,n){e.flowing&&0===e.length&&!e.sync?(t.emit("data",r),t.read(0)):(e.length+=e.objectMode?1:r.length,n?e.buffer.unshift(r):e.buffer.push(r),e.needReadable&&v(t)),b(t,e)}function f(t,e){var r;return o(e)||"string"==typeof e||void 0===e||t.objectMode||(r=new TypeError("Invalid non-string/buffer chunk")),r}function h(t){return!t.ended&&(t.needReadable||t.length<t.highWaterMark||0===t.length)}function p(t){return t>=W?t=W:(t--,t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,t|=t>>>16,t++),t}function d(t,e){return t<=0||0===e.length&&e.ended?0:e.objectMode?1:t!==t?e.flowing&&e.length?e.buffer.head.data.length:e.length:(t>e.highWaterMark&&(e.highWaterMark=p(t)),t<=e.length?t:e.ended?e.length:(e.needReadable=!0,0))}function g(t,e){if(!e.ended){if(e.decoder){var r=e.decoder.end();r&&r.length&&(e.buffer.push(r),e.length+=e.objectMode?1:r.length)}e.ended=!0,v(t)}}function v(t){var e=t._readableState;e.needReadable=!1,e.emittedReadable||(F("emitReadable",e.flowing),e.emittedReadable=!0,e.sync?B(y,t):y(t))}function y(t){F("emit readable"),t.emit("readable"),j(t)}function b(t,e){e.readingMore||(e.readingMore=!0,B(m,t,e))}function m(t,e){for(var r=e.length;!e.reading&&!e.flowing&&!e.ended&&e.length<e.highWaterMark&&(F("maybeReadMore read 0"),t.read(0),r!==e.length);)r=e.length;e.readingMore=!1}function _(t){return function(){var e=t._readableState;F("pipeOnDrain",e.awaitDrain),e.awaitDrain&&e.awaitDrain--,0===e.awaitDrain&&P(t,"data")&&(e.flowing=!0,j(t))}}function w(t){F("readable nexttick read 0"),t.read(0)}function x(t,e){e.resumeScheduled||(e.resumeScheduled=!0,B(S,t,e))}function S(t,e){e.reading||(F("resume read 0"),t.read(0)),e.resumeScheduled=!1,e.awaitDrain=0,t.emit("resume"),j(t),e.flowing&&!e.reading&&t.read(0)}function j(t){var e=t._readableState;for(F("flow",e.flowing);e.flowing&&null!==t.read(););}function k(t,e){if(0===e.length)return null;var r;return e.objectMode?r=e.buffer.shift():!t||t>=e.length?(r=e.decoder?e.buffer.join(""):1===e.buffer.length?e.buffer.head.data:e.buffer.concat(e.length),e.buffer.clear()):r=A(t,e.buffer,e.decoder),r}function A(t,e,r){var n;return t<e.head.data.length?(n=e.head.data.slice(0,t),e.head.data=e.head.data.slice(t)):n=t===e.head.data.length?e.shift():r?E(t,e):T(t,e),n}function E(t,e){var r=e.head,n=1,i=r.data;for(t-=i.length;r=r.next;){var o=r.data,a=t>o.length?o.length:t;if(a===o.length?i+=o:i+=o.slice(0,t),0===(t-=a)){a===o.length?(++n,r.next?e.head=r.next:e.head=e.tail=null):(e.head=r,r.data=o.slice(a));break}++n}return e.length-=n,i}function T(t,e){var r=M.allocUnsafe(t),n=e.head,i=1;for(n.data.copy(r),t-=n.data.length;n=n.next;){var o=n.data,a=t>o.length?o.length:t;if(o.copy(r,r.length-t,0,a),0===(t-=a)){a===o.length?(++i,n.next?e.head=n.next:e.head=e.tail=null):(e.head=n,n.data=o.slice(a));break}++i}return e.length-=i,r}function O(t){var e=t._readableState;if(e.length>0)throw new Error('"endReadable()" called on non-empty stream');e.endEmitted||(e.ended=!0,B(L,e,t))}function L(t,e){t.endEmitted||0!==t.length||(t.endEmitted=!0,e.readable=!1,e.emit("end"))}function C(t,e){for(var r=0,n=t.length;r<n;r++)if(t[r]===e)return r;return-1}var B=r(14);t.exports=u;var D,R=r(29);u.ReadableState=s;var P=(r(13).EventEmitter,function(t,e){return t.listeners(e).length}),q=r(37),M=r(20).Buffer,I=e.Uint8Array||function(){},N=r(9);N.inherits=r(1);var U=r(61),F=void 0;F=U&&U.debuglog?U.debuglog("stream"):function(){};var V,$=r(62),z=r(38);N.inherits(u,q);var H=["error","close","destroy","pause","resume"];Object.defineProperty(u.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(t){this._readableState&&(this._readableState.destroyed=t)}}),u.prototype.destroy=z.destroy,u.prototype._undestroy=z.undestroy,u.prototype._destroy=function(t,e){this.push(null),e(t)},u.prototype.push=function(t,e){var r,n=this._readableState;return n.objectMode?r=!0:"string"==typeof t&&(e=e||n.defaultEncoding,e!==n.encoding&&(t=M.from(t,e),e=""),r=!0),c(this,t,e,!1,r)},u.prototype.unshift=function(t){return c(this,t,null,!0,!1)},u.prototype.isPaused=function(){return!1===this._readableState.flowing},u.prototype.setEncoding=function(t){return V||(V=r(22).StringDecoder),this._readableState.decoder=new V(t),this._readableState.encoding=t,this};var W=8388608;u.prototype.read=function(t){F("read",t),t=parseInt(t,10);var e=this._readableState,r=t;if(0!==t&&(e.emittedReadable=!1),0===t&&e.needReadable&&(e.length>=e.highWaterMark||e.ended))return F("read: emitReadable",e.length,e.ended),0===e.length&&e.ended?O(this):v(this),null;if(0===(t=d(t,e))&&e.ended)return 0===e.length&&O(this),null;var n=e.needReadable;F("need readable",n),(0===e.length||e.length-t<e.highWaterMark)&&(n=!0,F("length less than watermark",n)),e.ended||e.reading?(n=!1,F("reading or ended",n)):n&&(F("do read"),e.reading=!0,e.sync=!0,0===e.length&&(e.needReadable=!0),this._read(e.highWaterMark),e.sync=!1,e.reading||(t=d(r,e)));var i;return i=t>0?k(t,e):null,null===i?(e.needReadable=!0,t=0):e.length-=t,0===e.length&&(e.ended||(e.needReadable=!0),r!==t&&e.ended&&O(this)),null!==i&&this.emit("data",i),i},u.prototype._read=function(t){this.emit("error",new Error("_read() is not implemented"))},u.prototype.pipe=function(t,e){function r(t,e){F("onunpipe"),t===h&&e&&!1===e.hasUnpiped&&(e.hasUnpiped=!0,o())}function i(){F("onend"),t.end()}function o(){F("cleanup"),t.removeListener("close",c),t.removeListener("finish",l),t.removeListener("drain",v),t.removeListener("error",u),t.removeListener("unpipe",r),h.removeListener("end",i),h.removeListener("end",f),h.removeListener("data",s),y=!0,!p.awaitDrain||t._writableState&&!t._writableState.needDrain||v()}function s(e){F("ondata"),b=!1,!1!==t.write(e)||b||((1===p.pipesCount&&p.pipes===t||p.pipesCount>1&&-1!==C(p.pipes,t))&&!y&&(F("false write response, pause",h._readableState.awaitDrain),h._readableState.awaitDrain++,b=!0),h.pause())}function u(e){F("onerror",e),f(),t.removeListener("error",u),0===P(t,"error")&&t.emit("error",e)}function c(){t.removeListener("finish",l),f()}function l(){F("onfinish"),t.removeListener("close",c),f()}function f(){F("unpipe"),h.unpipe(t)}var h=this,p=this._readableState;switch(p.pipesCount){case 0:p.pipes=t;break;case 1:p.pipes=[p.pipes,t];break;default:p.pipes.push(t)}p.pipesCount+=1,F("pipe count=%d opts=%j",p.pipesCount,e);var d=(!e||!1!==e.end)&&t!==n.stdout&&t!==n.stderr,g=d?i:f;p.endEmitted?B(g):h.once("end",g),t.on("unpipe",r);var v=_(h);t.on("drain",v);var y=!1,b=!1;return h.on("data",s),a(t,"error",u),t.once("close",c),t.once("finish",l),t.emit("pipe",h),p.flowing||(F("pipe resume"),h.resume()),t},u.prototype.unpipe=function(t){var e=this._readableState,r={hasUnpiped:!1};if(0===e.pipesCount)return this;if(1===e.pipesCount)return t&&t!==e.pipes?this:(t||(t=e.pipes),e.pipes=null,e.pipesCount=0,e.flowing=!1,t&&t.emit("unpipe",this,r),this);if(!t){var n=e.pipes,i=e.pipesCount;e.pipes=null,e.pipesCount=0,e.flowing=!1;for(var o=0;o<i;o++)n[o].emit("unpipe",this,r);return this}var a=C(e.pipes,t);return-1===a?this:(e.pipes.splice(a,1),e.pipesCount-=1,1===e.pipesCount&&(e.pipes=e.pipes[0]),t.emit("unpipe",this,r),this)},u.prototype.on=function(t,e){var r=q.prototype.on.call(this,t,e);if("data"===t)!1!==this._readableState.flowing&&this.resume();else if("readable"===t){var n=this._readableState;n.endEmitted||n.readableListening||(n.readableListening=n.needReadable=!0,n.emittedReadable=!1,n.reading?n.length&&v(this):B(w,this))}return r},u.prototype.addListener=u.prototype.on,u.prototype.resume=function(){var t=this._readableState;return t.flowing||(F("resume"),t.flowing=!0,x(this,t)),this},u.prototype.pause=function(){return F("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(F("pause"),this._readableState.flowing=!1,this.emit("pause")),this},u.prototype.wrap=function(t){var e=this._readableState,r=!1,n=this;t.on("end",function(){if(F("wrapped end"),e.decoder&&!e.ended){var t=e.decoder.end();t&&t.length&&n.push(t)}n.push(null)}),t.on("data",function(i){if(F("wrapped data"),e.decoder&&(i=e.decoder.write(i)),(!e.objectMode||null!==i&&void 0!==i)&&(e.objectMode||i&&i.length)){n.push(i)||(r=!0,t.pause())}});for(var i in t)void 0===this[i]&&"function"==typeof t[i]&&(this[i]=function(e){return function(){return t[e].apply(t,arguments)}}(i));for(var o=0;o<H.length;o++)t.on(H[o],n.emit.bind(n,H[o]));return n._read=function(e){F("wrapped _read",e),r&&(r=!1,t.resume())},n},u._fromList=k}).call(e,r(0),r(8))},function(t,e,r){t.exports=r(13).EventEmitter},function(t,e,r){"use strict";function n(t,e){var r=this,n=this._readableState&&this._readableState.destroyed,i=this._writableState&&this._writableState.destroyed;if(n||i)return void(e?e(t):!t||this._writableState&&this._writableState.errorEmitted||a(o,this,t));this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(t||null,function(t){!e&&t?(a(o,r,t),r._writableState&&(r._writableState.errorEmitted=!0)):e&&e(t)})}function i(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)}function o(t,e){t.emit("error",e)}var a=r(14);t.exports={destroy:n,undestroy:i}},function(t,e,r){"use strict";function n(t){this.afterTransform=function(e,r){return i(t,e,r)},this.needTransform=!1,this.transforming=!1,this.writecb=null,this.writechunk=null,this.writeencoding=null}function i(t,e,r){var n=t._transformState;n.transforming=!1;var i=n.writecb;if(!i)return t.emit("error",new Error("write callback called multiple times"));n.writechunk=null,n.writecb=null,null!==r&&void 0!==r&&t.push(r),i(e);var o=t._readableState;o.reading=!1,(o.needReadable||o.length<o.highWaterMark)&&t._read(o.highWaterMark)}function o(t){if(!(this instanceof o))return new o(t);s.call(this,t),this._transformState=new n(this);var e=this;this._readableState.needReadable=!0,this._readableState.sync=!1,t&&("function"==typeof t.transform&&(this._transform=t.transform),"function"==typeof t.flush&&(this._flush=t.flush)),this.once("prefinish",function(){"function"==typeof this._flush?this._flush(function(t,r){a(e,t,r)}):a(e)})}function a(t,e,r){if(e)return t.emit("error",e);null!==r&&void 0!==r&&t.push(r);var n=t._writableState,i=t._transformState;if(n.length)throw new Error("Calling transform done when ws.length != 0");if(i.transforming)throw new Error("Calling transform done when still transforming");return t.push(null)}t.exports=o;var s=r(2),u=r(9);u.inherits=r(1),u.inherits(o,s),o.prototype.push=function(t,e){return this._transformState.needTransform=!1,s.prototype.push.call(this,t,e)},o.prototype._transform=function(t,e,r){throw new Error("_transform() is not implemented")},o.prototype._write=function(t,e,r){var n=this._transformState;if(n.writecb=r,n.writechunk=t,n.writeencoding=e,!n.transforming){var i=this._readableState;(n.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}},o.prototype._read=function(t){var e=this._transformState;null!==e.writechunk&&e.writecb&&!e.transforming?(e.transforming=!0,this._transform(e.writechunk,e.writeencoding,e.afterTransform)):e.needTransform=!0},o.prototype._destroy=function(t,e){var r=this;s.prototype._destroy.call(this,t,function(t){e(t),r.emit("close")})}},function(t,e){function r(t,e,r){switch(r.length){case 0:return t.call(e);case 1:return t.call(e,r[0]);case 2:return t.call(e,r[0],r[1]);case 3:return t.call(e,r[0],r[1],r[2])}return t.apply(e,r)}function n(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}function i(t,e){var r=B(t)||d(t)?n(t.length,String):[],i=r.length,o=!!i;for(var a in t)!e&&!T.call(t,a)||o&&("length"==a||c(a,i))||r.push(a);return r}function o(t,e,r){var n=t[e];T.call(t,e)&&p(n,r)&&(void 0!==r||e in t)||(t[e]=r)}function a(t){if(!m(t))return h(t);var e=f(t),r=[];for(var n in t)("constructor"!=n||!e&&T.call(t,n))&&r.push(n);return r}function s(t,e){return e=C(void 0===e?t.length-1:e,0),function(){for(var n=arguments,i=-1,o=C(n.length-e,0),a=Array(o);++i<o;)a[i]=n[e+i];i=-1;for(var s=Array(e+1);++i<e;)s[i]=n[i];return s[e]=a,r(t,this,s)}}function u(t,e,r,n){r||(r={});for(var i=-1,a=e.length;++i<a;){var s=e[i],u=n?n(r[s],t[s],s,r,t):void 0;o(r,s,void 0===u?t[s]:u)}return r}function c(t,e){return!!(e=null==e?x:e)&&("number"==typeof t||A.test(t))&&t>-1&&t%1==0&&t<e}function l(t,e,r){if(!m(r))return!1;var n=typeof e;return!!("number"==n?g(r)&&c(e,r.length):"string"==n&&e in r)&&p(r[e],t)}function f(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||E)}function h(t){var e=[];if(null!=t)for(var r in Object(t))e.push(r);return e}function p(t,e){return t===e||t!==t&&e!==e}function d(t){return v(t)&&T.call(t,"callee")&&(!L.call(t,"callee")||O.call(t)==S)}function g(t){return null!=t&&b(t.length)&&!y(t)}function v(t){return _(t)&&g(t)}function y(t){var e=m(t)?O.call(t):"";return e==j||e==k}function b(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=x}function m(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function _(t){return!!t&&"object"==typeof t}function w(t){return g(t)?i(t,!0):a(t)}var x=9007199254740991,S="[object Arguments]",j="[object Function]",k="[object GeneratorFunction]",A=/^(?:0|[1-9]\d*)$/,E=Object.prototype,T=E.hasOwnProperty,O=E.toString,L=E.propertyIsEnumerable,C=Math.max,B=Array.isArray,D=function(t){return s(function(e,r){var n=-1,i=r.length,o=i>1?r[i-1]:void 0,a=i>2?r[2]:void 0;for(o=t.length>3&&"function"==typeof o?(i--,o):void 0,a&&l(r[0],r[1],a)&&(o=i<3?void 0:o,i=1),e=Object(e);++n<i;){var s=r[n];s&&t(e,s,n,o)}return e})}(function(t,e){u(e,w(e),t)});t.exports=D},function(t,e){function r(t,e,r){switch(r.length){case 0:return t.call(e);case 1:return t.call(e,r[0]);case 2:return t.call(e,r[0],r[1]);case 3:return t.call(e,r[0],r[1],r[2])}return t.apply(e,r)}function n(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}function i(t,e){var r=D(t)||g(t)?n(t.length,String):[],i=r.length,o=!!i;for(var a in t)!e&&!O.call(t,a)||o&&("length"==a||l(a,i))||r.push(a);return r}function o(t,e,r,n){return void 0===t||d(t,T[r])&&!O.call(n,r)?e:t}function a(t,e,r){var n=t[e];O.call(t,e)&&d(n,r)&&(void 0!==r||e in t)||(t[e]=r)}function s(t){if(!_(t))return p(t);var e=h(t),r=[];for(var n in t)("constructor"!=n||!e&&O.call(t,n))&&r.push(n);return r}function u(t,e){return e=B(void 0===e?t.length-1:e,0),function(){for(var n=arguments,i=-1,o=B(n.length-e,0),a=Array(o);++i<o;)a[i]=n[e+i];i=-1;for(var s=Array(e+1);++i<e;)s[i]=n[i];return s[e]=a,r(t,this,s)}}function c(t,e,r,n){r||(r={});for(var i=-1,o=e.length;++i<o;){var s=e[i],u=n?n(r[s],t[s],s,r,t):void 0;a(r,s,void 0===u?t[s]:u)}return r}function l(t,e){return!!(e=null==e?S:e)&&("number"==typeof t||E.test(t))&&t>-1&&t%1==0&&t<e}function f(t,e,r){if(!_(r))return!1;var n=typeof e;return!!("number"==n?v(r)&&l(e,r.length):"string"==n&&e in r)&&d(r[e],t)}function h(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||T)}function p(t){var e=[];if(null!=t)for(var r in Object(t))e.push(r);return e}function d(t,e){return t===e||t!==t&&e!==e}function g(t){return y(t)&&O.call(t,"callee")&&(!C.call(t,"callee")||L.call(t)==j)}function v(t){return null!=t&&m(t.length)&&!b(t)}function y(t){return w(t)&&v(t)}function b(t){var e=_(t)?L.call(t):"";return e==k||e==A}function m(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=S}function _(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function w(t){return!!t&&"object"==typeof t}function x(t){return v(t)?i(t,!0):s(t)}var S=9007199254740991,j="[object Arguments]",k="[object Function]",A="[object GeneratorFunction]",E=/^(?:0|[1-9]\d*)$/,T=Object.prototype,O=T.hasOwnProperty,L=T.toString,C=T.propertyIsEnumerable,B=Math.max,D=Array.isArray,R=function(t){return u(function(e,r){var n=-1,i=r.length,o=i>1?r[i-1]:void 0,a=i>2?r[2]:void 0;for(o=t.length>3&&"function"==typeof o?(i--,o):void 0,a&&f(r[0],r[1],a)&&(o=i<3?void 0:o,i=1),e=Object(e);++n<i;){var s=r[n];s&&t(e,s,n,o)}return e})}(function(t,e,r,n){c(e,x(e),t,n)}),P=u(function(t){return t.push(void 0,o),r(R,void 0,t)});t.exports=P},function(t,e,r){"use strict";function n(t){return function(e,r,n){return"function"!=typeof e&&(e=d(e,n,r)),r=Array.isArray(r)?f(r):l(r),t(e,r)}}function i(t,e,r){return("function"==typeof e?e:p(e,r))(t)}function o(t,e,r){return v(t,e,r)}t.exports=o;var a=r(26),s=r(4),u=s.findOne,c=s.findAll,l=s.getChildren,f=s.removeSubsets,h=r(11).falseFunc,p=r(88),d=p.compileUnsafe,g=p.compileToken,v=n(function(t,e){return t!==h&&e&&0!==e.length?c(t,e):[]}),y=n(function(t,e){return t!==h&&e&&0!==e.length?u(t,e):null});o.compile=p,o.filters=a.filters,o.pseudos=a.pseudos,o.selectAll=v,o.selectOne=y,o.is=i,o.parse=p,o.iterate=v,o._compileUnsafe=d,o._compileToken=g},function(t,e,r){var n=r(4),i=n.hasAttrib,o=n.getAttributeValue,a=r(11).falseFunc,s=/[-[\]{}()*+?.,\\^$|#\s]/g,u={__proto__:null,equals:function(t,e){var r=e.name,n=e.value;return e.ignoreCase?(n=n.toLowerCase(),function(e){var i=o(e,r);return null!=i&&i.toLowerCase()===n&&t(e)}):function(e){return o(e,r)===n&&t(e)}},hyphen:function(t,e){var r=e.name,n=e.value,i=n.length;return e.ignoreCase?(n=n.toLowerCase(),function(e){var a=o(e,r);return null!=a&&(a.length===i||"-"===a.charAt(i))&&a.substr(0,i).toLowerCase()===n&&t(e)}):function(e){var a=o(e,r);return null!=a&&a.substr(0,i)===n&&(a.length===i||"-"===a.charAt(i))&&t(e)}},element:function(t,e){var r=e.name,n=e.value;if(/\s/.test(n))return a;n=n.replace(s,"\\$&");var i="(?:^|\\s)"+n+"(?:$|\\s)",u=e.ignoreCase?"i":"",c=new RegExp(i,u);return function(e){var n=o(e,r);return null!=n&&c.test(n)&&t(e)}},exists:function(t,e){var r=e.name;return function(e){return i(e,r)&&t(e)}},start:function(t,e){var r=e.name,n=e.value,i=n.length;return 0===i?a:e.ignoreCase?(n=n.toLowerCase(),function(e){var a=o(e,r);return null!=a&&a.substr(0,i).toLowerCase()===n&&t(e)}):function(e){var a=o(e,r);return null!=a&&a.substr(0,i)===n&&t(e)}},end:function(t,e){var r=e.name,n=e.value,i=-n.length;return 0===i?a:e.ignoreCase?(n=n.toLowerCase(),function(e){var a=o(e,r);return null!=a&&a.substr(i).toLowerCase()===n&&t(e)}):function(e){var a=o(e,r);return null!=a&&a.substr(i)===n&&t(e)}},any:function(t,e){var r=e.name,n=e.value;if(""===n)return a;if(e.ignoreCase){var i=new RegExp(n.replace(s,"\\$&"),"i");return function(e){var n=o(e,r);return null!=n&&i.test(n)&&t(e)}}return function(e){var i=o(e,r);return null!=i&&i.indexOf(n)>=0&&t(e)}},not:function(t,e){var r=e.name,n=e.value;return""===n?function(e){return!!o(e,r)&&t(e)}:e.ignoreCase?(n=n.toLowerCase(),function(e){var i=o(e,r);return null!=i&&i.toLowerCase()!==n&&t(e)}):function(e){return o(e,r)!==n&&t(e)}}};t.exports={compile:function(t,e,r){if(r&&r.strict&&(e.ignoreCase||"not"===e.action))throw SyntaxError("Unsupported attribute selector");return u[e.action](t,e)},rules:u}},function(t,e){t.exports={universal:50,tag:30,attribute:1,pseudo:0,descendant:-1,child:-1,parent:-1,sibling:-1,adjacent:-1}},function(t,e,r){function n(t){function e(t){return t?w[w.length-1-t]:_}function r(t){return t===n(1)}function n(e){return t[y+(e||1)]}function s(){var t=w.pop();return _=w[w.length-1],t}function u(t){return _=t,w.push(_),w.length}function c(t){var e=_;return w[w.length-1]=_=t,e}function l(e){if(1==(e||1))"\n"==t[y]?(m++,v=1):v++,y++;else{var r=t.slice(y,y+e).split("\n");r.length>1&&(m+=r.length-1,v=1),v+=r[r.length-1].length,y+=e}}function f(){x.end={line:m,col:v},i&&a("addToken:",JSON.stringify(x,null,2)),S.push(x),g="",x={}}function h(t){x={type:t,start:{line:m,col:v}}}var p,d,g="",v=0,y=-1,b=0,m=1,_="before-selector",w=[_],x={},S=[],j=["media","keyframes",{name:"-webkit-keyframes",type:"keyframes",prefix:"-webkit-"},{name:"-moz-keyframes",type:"keyframes",prefix:"-moz-"},{name:"-ms-keyframes",type:"keyframes",prefix:"-ms-"},{name:"-o-keyframes",type:"keyframes",prefix:"-o-"},"font-face",{name:"import",state:"before-at-value"},{name:"charset",state:"before-at-value"},"supports","viewport",{name:"namespace",state:"before-at-value"},"document",{name:"-moz-document",type:"document",prefix:"-moz-"},"page"];for(o&&(p=Date.now());d=function(){return l(),t[y]}();)switch(i&&a(d,e()),d){case" ":switch(e()){case"selector":case"value":case"value-paren":case"at-group":case"at-value":case"comment":case"double-string":case"single-string":g+=d}break;case"\n":case"\t":case"\r":case"\f":switch(e()){case"value":case"value-paren":case"at-group":case"comment":case"single-string":case"double-string":case"selector":g+=d;break;case"at-value":"\n"===d&&(x.value=g.trim(),f(),s())}break;case":":switch(e()){case"name":x.name=g.trim(),g="",c("before-value");break;case"before-selector":g+=d,h("selector"),u("selector");break;case"before-value":c("value"),g+=d;break;default:g+=d}break;case";":switch(e()){case"name":case"before-value":case"value":g.trim().length>0&&(x.value=g.trim(),f()),c("before-name");break;case"value-paren":g+=d;break;case"at-value":x.value=g.trim(),f(),s();break;case"before-name":break;default:g+=d}break;case"{":switch(e()){case"selector":if("\\"===n(-1)){g+=d;break}x.text=g.trim(),f(),c("before-name"),b+=1;break;case"at-group":switch(x.name=g.trim(),x.type){case"font-face":case"viewport":case"page":u("before-name");break;default:u("before-selector")}f(),b+=1;break;case"name":case"at-rule":x.name=g.trim(),f(),u("before-name"),b+=1;break;case"comment":case"double-string":case"single-string":g+=d;break;case"before-value":c("value"),g+=d}break;case"}":switch(e()){case"before-name":case"name":case"before-value":case"value":g&&(x.value=g.trim()),x.name&&x.value&&f(),h("end"),f(),s(),"at-group"===e()&&(h("at-group-end"),f(),s()),b>0&&(b-=1);break;case"at-group":case"before-selector":case"selector":if("\\"===n(-1)){g+=d;break}b>0&&"at-group"===e(1)&&(h("at-group-end"),f()),b>1&&s(),b>0&&(b-=1);break;case"double-string":case"single-string":case"comment":g+=d}break;case'"':case"'":switch(e()){case"double-string":'"'===d&&"\\"!==n(-1)&&s();break;case"single-string":"'"===d&&"\\"!==n(-1)&&s();break;case"before-at-value":c("at-value"),u('"'===d?"double-string":"single-string");break;case"before-value":c("value"),u('"'===d?"double-string":"single-string");break;case"comment":break;default:"\\"!==n(-1)&&u('"'===d?"double-string":"single-string")}g+=d;break;case"/":switch(e()){case"comment":case"double-string":case"single-string":g+=d;break;case"before-value":case"selector":case"name":case"value":if(r("*")){var k=function(e){var r=t.slice(y).indexOf(e);return r>0&&r}("*/");k&&l(k+1)}else"before-value"==e()&&c("value"),g+=d;break;default:r("*")?(h("comment"),u("comment"),l()):g+=d}break;case"*":switch(e()){case"comment":r("/")?(x.text=g,l(),f(),s()):g+=d;break;case"before-selector":g+=d,h("selector"),u("selector");break;case"before-value":c("value"),g+=d;break;default:g+=d}break;case"@":switch(e()){case"comment":case"double-string":case"single-string":g+=d;break;case"before-value":c("value"),g+=d;break;default:for(var A,E,T=!1,O=0,L=j.length;!T&&O<L;++O)E=j[O],A=E.name||E,function(e){var r=y+1;return e===t.slice(r,r+e.length)}(A)&&(T=!0,h(A),u(E.state||"at-group"),l(A.length),E.prefix&&(x.prefix=E.prefix),E.type&&(x.type=E.type));T||(g+=d)}break;case"(":switch(e()){case"value":u("value-paren");break;case"before-value":c("value")}g+=d;break;case")":switch(e()){case"value-paren":s();break;case"before-value":c("value")}g+=d;break;default:switch(e()){case"before-selector":h("selector"),u("selector");break;case"before-name":h("property"),c("name");break;case"before-value":c("value");break;case"before-at-value":c("at-value")}g+=d}return o&&a("ran in",Date.now()-p+"ms"),S}var i=!1,o=!1,a=r(28)("lex");t.exports=n},function(t,e,r){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default=grapesjs.plugins.add("gjs-preset-newsletter",function(t,e){var n=e||{},i=t.getConfig(),o=i.stylePrefix,a={editor:t,pfx:o||"",cmdOpenImport:"gjs-open-import-template",cmdTglImages:"gjs-toggle-images",cmtTglImagesLabel:"Toggle Images",cmdBtnMoveLabel:"Move",cmdBtnUndoLabel:"Undo",cmdBtnRedoLabel:"Redo",cmdBtnDesktopLabel:"Desktop",cmdBtnTabletLabel:"Tablet",cmdBtnMobileLabel:"Mobile",modalTitleImport:"Import template",modalTitleExport:"Export template",modalLabelImport:"",modalLabelExport:"",modalBtnImport:"Import",codeViewerTheme:"hopscotch",openBlocksBtnTitle:n.openBlocksBtnTitle||"",openLayersBtnTitle:n.openLayersBtnTitle||"",openSmBtnTitle:n.openSmBtnTitle||"",openTmBtnTitle:n.openTmBtnTitle||"",expTplBtnTitle:n.expTplBtnTitle||"View Code",fullScrBtnTitle:n.fullScrBtnTitle||"FullScreen",swichtVwBtnTitle:n.swichtVwBtnTitle||"View Components",categoryLabel:n.categoryLabel||"",importPlaceholder:"",defaultTemplate:"",inlineCss:1,cellStyle:{padding:0,margin:0,"vertical-align":"top"},tableStyle:{height:"150px",margin:"0 auto 10px auto",padding:"5px 5px 5px 5px",width:"100%"},sect100BlkLabel:"1 Section",sect50BlkLabel:"1/2 Section",sect30BlkLabel:"1/3 Section",sect37BlkLabel:"3/7 Section",buttonBlkLabel:"Button",dividerBlkLabel:"Divider",textBlkLabel:"Text",textSectionBlkLabel:"Text Section",imageBlkLabel:"Image",quoteBlkLabel:"Quote",linkBlkLabel:"Link",linkBlockBlkLabel:"Link Block",gridItemsBlkLabel:"Grid Items",listItemsBlkLabel:"List Items",assetsModalTitle:n.assetsModalTitle||"Select image",styleManagerSectors:[{name:"Dimension",open:!1,buildProps:["width","height","max-width","min-height","margin","padding"],properties:[{property:"margin",properties:[{name:"Top",property:"margin-top"},{name:"Left",property:"margin-left"},{name:"Right",property:"margin-right"},{name:"Bottom",property:"margin-bottom"}]},{property:"padding",properties:[{name:"Top",property:"padding-top"},{name:"Right",property:"padding-right"},{name:"Bottom",property:"padding-bottom"},{name:"Left",property:"padding-left"}]}]},{name:"Typography",open:!1,buildProps:["font-family","font-size","font-weight","letter-spacing","color","line-height","text-align","text-decoration","font-style","vertical-align","text-shadow"],properties:[{name:"Font",property:"font-family"},{name:"Weight",property:"font-weight"},{name:"Font color",property:"color"},{property:"text-align",type:"radio",defaults:"left",list:[{value:"left",name:"Left",className:"fa fa-align-left"},{value:"center",name:"Center",className:"fa fa-align-center"},{value:"right",name:"Right",className:"fa fa-align-right"},{value:"justify",name:"Justify",className:"fa fa-align-justify"}]},{property:"text-decoration",type:"radio",defaults:"none",list:[{value:"none",name:"None",className:"fa fa-times"},{value:"underline",name:"underline",className:"fa fa-underline"},{value:"line-through",name:"Line-through",className:"fa fa-strikethrough"}]},{property:"font-style",type:"radio",defaults:"normal",list:[{value:"normal",name:"Normal",className:"fa fa-font"},{value:"italic",name:"Italic",className:"fa fa-italic"}]},{property:"vertical-align",type:"select",defaults:"baseline",list:[{value:"baseline"},{value:"top"},{value:"middle"},{value:"bottom"}]},{property:"text-shadow",properties:[{name:"X position",property:"text-shadow-h"},{name:"Y position",property:"text-shadow-v"},{name:"Blur",property:"text-shadow-blur"},{name:"Color",property:"text-shadow-color"}]}]},{name:"Decorations",open:!1,buildProps:["background-color","border-collapse","border-radius","border","background"],properties:[{property:"background-color",name:"Background"},{property:"border-radius",properties:[{name:"Top",property:"border-top-left-radius"},{name:"Right",property:"border-top-right-radius"},{name:"Bottom",property:"border-bottom-left-radius"},{name:"Left",property:"border-bottom-right-radius"}]},{property:"border-collapse",type:"radio",defaults:"separate",list:[{value:"separate",name:"No"},{value:"collapse",name:"Yes"}]},{property:"border",properties:[{name:"Width",property:"border-width",defaults:"0"},{name:"Style",property:"border-style"},{name:"Color",property:"border-color"}]},{property:"background",properties:[{name:"Image",property:"background-image"},{name:"Repeat",property:"background-repeat"},{name:"Position",property:"background-position"},{name:"Attachment",property:"background-attachment"},{name:"Size",property:"background-size"}]}]}]};i.devicePreviewMode=1;for(var s in a)s in n||(n[s]=a[s]);r(47)(n),r(113)(n),r(114)(n),r(115)(n),!t.getHtml()&&n.defaultTemplate&&(t.setComponents(n.defaultTemplate),t.editor.initChildrenComp(t.DomComponents.getWrapper())),t.on("change:selectedComponent",function(){var e=t.Panels.getButton("views","open-layers");if((!e||!e.get("active"))&&t.editor.get("selectedComponent")){var r=t.Panels.getButton("views","open-sm");r.set("attributes",{title:a.openSmBtnTitle}),r&&r.set("active",1)}}),t.on("run:open-assets",function(){t.Modal.setTitle(a.assetsModalTitle)}),t.on("load",function(){t.Panels.getButton("options","export-template").set("attributes",{title:a.expTplBtnTitle}),t.Panels.getButton("options","fullscreen").set("attributes",{title:a.fullScrBtnTitle}),t.Panels.getButton("options","sw-visibility").set("attributes",{title:a.swichtVwBtnTitle}),t.Panels.getButton("views","open-sm").set("attributes",{title:a.openSmBtnTitle}),t.Panels.getButton("views","open-tm").set("attributes",{title:a.openTmBtnTitle}),t.Panels.getButton("views","open-layers").set("attributes",{title:a.openLayersBtnTitle});var e=t.Panels.getButton("views","open-blocks");e.set("attributes",{title:a.openBlocksBtnTitle}),e&&e.set("active",1)})})},function(t,e,r){"use strict";var n;void 0!==(n=function(){return function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=t.editor,n=e.Commands,i=r(48),o=r(49),a=r(112);n.add(t.cmdOpenImport,i(t)),n.add(t.cmdTglImages,a(t)),e.on("load",function(){n.add("export-template",o(t))}),n.add("undo",{run:function(t,e){e.set("active",0),t.UndoManager.undo(1)}}),n.add("redo",{run:function(t,e){e.set("active",0),t.UndoManager.redo(1)}}),n.add("set-device-desktop",{run:function(t){t.setDevice("Desktop")}}),n.add("set-device-tablet",{run:function(t){t.setDevice("Tablet")}}),n.add("set-device-mobile",{run:function(t){t.setDevice("Mobile portrait")}})}}.call(e,r,e,t))&&(t.exports=n)},function(t,e,r){"use strict";var n;void 0!==(n=function(){return function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=t.editor,r=e&&e.CodeManager.getViewer("CodeMirror").clone(),n=document.createElement("button"),i=document.createElement("div"),o=t.pfx||"";return n.innerHTML=t.modalBtnImport,n.className=o+"btn-prim "+o+"btn-import",n.onclick=function(){var t=r.editor.getValue();e.DomComponents.getWrapper().set("content",""),e.setComponents(t),e.Modal.close()},r.set({codeName:"htmlmixed",theme:t.codeViewerTheme,readOnly:0}),{run:function(e,a){var s=e.Modal,u=(s.getContentEl(),r.editor);if(s.setTitle(t.modalTitleImport),!u){var c=document.createElement("textarea");if(t.modalLabelImport){var l=document.createElement("div");l.className=o+"import-label",l.innerHTML=t.modalLabelImport,i.appendChild(l)}i.appendChild(c),i.appendChild(n),r.init(c),u=r.editor}s.setContent(""),s.setContent(i),r.setContent(t.importPlaceholder||""),s.open(),u.refresh(),a&&a.set("active",0)}}}}.call(e,r,e,t))&&(t.exports=n)},function(t,e,r){"use strict";var n;void 0!==(n=function(){var t=r(50);return function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.editor,n=r&&r.CodeManager.getViewer("CodeMirror").clone(),i=document.createElement("div"),o=e.pfx||"",a=r.Commands;return n.set({codeName:"htmlmixed",theme:e.codeViewerTheme}),a.add(o+"get-inlined-html",{run:function(e){var r=e.getHtml()+"<style>"+e.getCss()+"</style>";return t(r)}}),{run:function(r,a){var s=r.Modal,u=(s.getContentEl(),n.editor);if(s.setTitle(e.modalTitleExport),!u){var c=document.createElement("textarea");if(e.modalLabelExport){var l=document.createElement("div");l.className=o+"export-label",l.innerHTML=e.modalLabelExport,i.appendChild(l)}i.appendChild(c),n.init(c),u=n.editor,u.setOption("lineWrapping",1)}s.setContent(i);var f=r.getHtml()+"<style>"+r.getCss()+"</style>";n.setContent(e.inlineCss?t(f):f),s.open(),u.refresh(),a&&a.set&&a.set("active",0)}}}}.call(e,r,e,t))&&(t.exports=n)},function(t,e,r){"use strict";var n=r(51),i=r(111),o=i(function(t,e){return n(t,{xmlMode:e&&e.xmlMode},a,[e])}),a=function(t,e){return o.juiceDocument(t,e)};o.inlineContent=function(t,e,r){return n(t,{xmlMode:r&&r.xmlMode},o.inlineDocument,[e,r])},t.exports=o},function(t,e,r){"use strict";var n=r(52),i=r(27),o=function(t,e){return e=i.extend({decodeEntities:!1},e||{}),t=u(t),n.load(t,e)},a=function(e){var r=t.exports.codeBlocks;return Object.keys(r).forEach(function(t){var n=new RegExp(r[t].start+"((.|\\s)*?)"+r[t].end,"g");e=e.replace(n,function(e,n){return"\x3c!--"+t+" "+r[t].start+n+r[t].end+" --\x3e"})}),e},s=function(e){var r=t.exports.codeBlocks;return Object.keys(r).forEach(function(t){var n=new RegExp("\x3c!--"+t+" "+r[t].start+"((.|\\s)*?)"+r[t].end+" --\x3e","g");e=e.replace(n,function(e,n){return r[t].start+n+r[t].end})}),e},u=function(t){return a(t)},c=function(t){return s(t)};t.exports=function(t,e,r,n){var i=o(t,e),a=[i];a.push.apply(a,n);var s=r.apply(void 0,a)||i;return e&&e.xmlMode?s.xml():c(s.html())},t.exports.codeBlocks={EJS:{start:"<%",end:"%>"},HBS:{start:"{{",end:"}}"}}},function(t,e,r){e=t.exports=r(16),e.version=r(104).version},function(t,e,r){"use strict";function n(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");return"="===t[e-2]?2:"="===t[e-1]?1:0}function i(t){return 3*t.length/4-n(t)}function o(t){var e,r,i,o,a,s,u=t.length;a=n(t),s=new f(3*u/4-a),i=a>0?u-4:u;var c=0;for(e=0,r=0;e<i;e+=4,r+=3)o=l[t.charCodeAt(e)]<<18|l[t.charCodeAt(e+1)]<<12|l[t.charCodeAt(e+2)]<<6|l[t.charCodeAt(e+3)],s[c++]=o>>16&255,s[c++]=o>>8&255,s[c++]=255&o;return 2===a?(o=l[t.charCodeAt(e)]<<2|l[t.charCodeAt(e+1)]>>4,s[c++]=255&o):1===a&&(o=l[t.charCodeAt(e)]<<10|l[t.charCodeAt(e+1)]<<4|l[t.charCodeAt(e+2)]>>2,s[c++]=o>>8&255,s[c++]=255&o),s}function a(t){return c[t>>18&63]+c[t>>12&63]+c[t>>6&63]+c[63&t]}function s(t,e,r){for(var n,i=[],o=e;o<r;o+=3)n=(t[o]<<16)+(t[o+1]<<8)+t[o+2],i.push(a(n));return i.join("")}function u(t){for(var e,r=t.length,n=r%3,i="",o=[],a=0,u=r-n;a<u;a+=16383)o.push(s(t,a,a+16383>u?u:a+16383));return 1===n?(e=t[r-1],i+=c[e>>2],i+=c[e<<4&63],i+="=="):2===n&&(e=(t[r-2]<<8)+t[r-1],i+=c[e>>10],i+=c[e>>4&63],i+=c[e<<2&63],i+="="),o.push(i),o.join("")}e.byteLength=i,e.toByteArray=o,e.fromByteArray=u;for(var c=[],l=[],f="undefined"!=typeof Uint8Array?Uint8Array:Array,h="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",p=0,d=h.length;p<d;++p)c[p]=h[p],l[h.charCodeAt(p)]=p;l["-".charCodeAt(0)]=62,l["_".charCodeAt(0)]=63},function(t,e){e.read=function(t,e,r,n,i){var o,a,s=8*i-n-1,u=(1<<s)-1,c=u>>1,l=-7,f=r?i-1:0,h=r?-1:1,p=t[e+f];for(f+=h,o=p&(1<<-l)-1,p>>=-l,l+=s;l>0;o=256*o+t[e+f],f+=h,l-=8);for(a=o&(1<<-l)-1,o>>=-l,l+=n;l>0;a=256*a+t[e+f],f+=h,l-=8);if(0===o)o=1-c;else{if(o===u)return a?NaN:1/0*(p?-1:1);a+=Math.pow(2,n),o-=c}return(p?-1:1)*a*Math.pow(2,o-n)},e.write=function(t,e,r,n,i,o){var a,s,u,c=8*o-i-1,l=(1<<c)-1,f=l>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,p=n?0:o-1,d=n?1:-1,g=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,a=l):(a=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-a))<1&&(a--,u*=2),e+=a+f>=1?h/u:h*Math.pow(2,1-f),e*u>=2&&(a++,u/=2),a+f>=l?(s=0,a=l):a+f>=1?(s=(e*u-1)*Math.pow(2,i),a+=f):(s=e*Math.pow(2,f-1)*Math.pow(2,i),a=0));i>=8;t[r+p]=255&s,p+=d,s/=256,i-=8);for(a=a<<i|s,c+=i;c>0;t[r+p]=255&a,p+=d,a/=256,c-=8);t[r+p-d]|=128*g}},function(t,e){t.exports={0:65533,128:8364,130:8218,131:402,132:8222,133:8230,134:8224,135:8225,136:710,137:8240,138:352,139:8249,140:338,142:381,145:8216,146:8217,147:8220,148:8221,149:8226,150:8211,151:8212,152:732,153:8482,154:353,155:8250,156:339,158:382,159:376}},function(t,e,r){function n(t,e,r){"object"==typeof t?(r=e,e=t,t=null):"function"==typeof e&&(r=e,e=u),this._callback=t,this._options=e||u,this._elementCB=r,this.dom=[],this._done=!1,this._tagStack=[],this._parser=this._parser||null}var i=r(7),o=/\s+/g,a=r(34),s=r(57),u={normalizeWhitespace:!1,withStartIndices:!1};n.prototype.onparserinit=function(t){this._parser=t},n.prototype.onreset=function(){n.call(this,this._callback,this._options,this._elementCB)},n.prototype.onend=function(){this._done||(this._done=!0,this._parser=null,this._handleCallback(null))},n.prototype._handleCallback=n.prototype.onerror=function(t){if("function"==typeof this._callback)this._callback(t,this.dom);else if(t)throw t},n.prototype.onclosetag=function(){var t=this._tagStack.pop();this._elementCB&&this._elementCB(t)},n.prototype._addDomElement=function(t){var e=this._tagStack[this._tagStack.length-1],r=e?e.children:this.dom,n=r[r.length-1];t.next=null,this._options.withStartIndices&&(t.startIndex=this._parser.startIndex),this._options.withDomLvl1&&(t.__proto__="tag"===t.type?s:a),n?(t.prev=n,n.next=t):t.prev=null,r.push(t),t.parent=e||null},n.prototype.onopentag=function(t,e){var r={type:"script"===t?i.Script:"style"===t?i.Style:i.Tag,name:t,attribs:e,children:[]};this._addDomElement(r),this._tagStack.push(r)},n.prototype.ontext=function(t){var e,r=this._options.normalizeWhitespace||this._options.ignoreWhitespace;!this._tagStack.length&&this.dom.length&&(e=this.dom[this.dom.length-1]).type===i.Text?r?e.data=(e.data+t).replace(o," "):e.data+=t:this._tagStack.length&&(e=this._tagStack[this._tagStack.length-1])&&(e=e.children[e.children.length-1])&&e.type===i.Text?r?e.data=(e.data+t).replace(o," "):e.data+=t:(r&&(t=t.replace(o," ")),this._addDomElement({data:t,type:i.Text}))},n.prototype.oncomment=function(t){var e=this._tagStack[this._tagStack.length-1];if(e&&e.type===i.Comment)return void(e.data+=t);var r={data:t,type:i.Comment};this._addDomElement(r),this._tagStack.push(r)},n.prototype.oncdatastart=function(){var t={children:[{data:"",type:i.Text}],type:i.CDATA};this._addDomElement(t),this._tagStack.push(t)},n.prototype.oncommentend=n.prototype.oncdataend=function(){this._tagStack.pop()},n.prototype.onprocessinginstruction=function(t,e){this._addDomElement({name:t,data:e,type:i.Directive})},t.exports=n},function(t,e,r){var n=r(34),i=t.exports=Object.create(n),o={tagName:"name"};Object.keys(o).forEach(function(t){var e=o[t];Object.defineProperty(i,t,{get:function(){return this[e]||null},set:function(t){return this[e]=t,t}})})},function(t,e,r){function n(t,e){this.init(t,e)}function i(t,e){return l.getElementsByTagName(t,e,!0)}function o(t,e){return l.getElementsByTagName(t,e,!0,1)[0]}function a(t,e,r){return l.getText(l.getElementsByTagName(t,e,r,1)).trim()}function s(t,e,r,n,i){var o=a(r,n,i);o&&(t[e]=o)}var u=r(3),c=u.DomHandler,l=u.DomUtils;r(1)(n,c),n.prototype.init=c;var f=function(t){return"rss"===t||"feed"===t||"rdf:RDF"===t};n.prototype.onend=function(){var t,e,r={},n=o(f,this.dom);n&&("feed"===n.name?(e=n.children,r.type="atom",s(r,"id","id",e),s(r,"title","title",e),(t=o("link",e))&&(t=t.attribs)&&(t=t.href)&&(r.link=t),s(r,"description","subtitle",e),(t=a("updated",e))&&(r.updated=new Date(t)),s(r,"author","email",e,!0),r.items=i("entry",e).map(function(t){var e,r={};return t=t.children,s(r,"id","id",t),s(r,"title","title",t),(e=o("link",t))&&(e=e.attribs)&&(e=e.href)&&(r.link=e),(e=a("summary",t)||a("content",t))&&(r.description=e),(e=a("updated",t))&&(r.pubDate=new Date(e)),r})):(e=o("channel",n.children).children,r.type=n.name.substr(0,3),r.id="",s(r,"title","title",e),s(r,"link","link",e),s(r,"description","description",e),(t=a("lastBuildDate",e))&&(r.updated=new Date(t)),s(r,"author","managingEditor",e,!0),r.items=i("item",n.children).map(function(t){var e,r={};return t=t.children,s(r,"id","guid",t),s(r,"title","title",t),s(r,"link","link",t),s(r,"description","description",t),(e=a("pubDate",t))&&(r.pubDate=new Date(e)),r}))),this.dom=r,c.prototype._handleCallback.call(this,n?null:Error("couldn't find root of feed"))},t.exports=n},function(t,e,r){function n(t){o.call(this,new i(this),t)}function i(t){this.scope=t}t.exports=n;var o=r(35);r(1)(n,o),n.prototype.readable=!0;var a=r(3).EVENTS;Object.keys(a).forEach(function(t){if(0===a[t])i.prototype["on"+t]=function(){this.scope.emit(t)};else if(1===a[t])i.prototype["on"+t]=function(e){this.scope.emit(t,e)};else{if(2!==a[t])throw Error("wrong number of arguments!");i.prototype["on"+t]=function(e,r){this.scope.emit(t,e,r)}}})},function(t,e,r){function n(){i.call(this)}t.exports=n;var i=r(13).EventEmitter;r(1)(n,i),n.Readable=r(19),n.Writable=r(67),n.Duplex=r(68),n.Transform=r(69),n.PassThrough=r(70),n.Stream=n,n.prototype.pipe=function(t,e){function r(e){t.writable&&!1===t.write(e)&&c.pause&&c.pause()}function n(){c.readable&&c.resume&&c.resume()}function o(){l||(l=!0,t.end())}function a(){l||(l=!0,"function"==typeof t.destroy&&t.destroy())}function s(t){if(u(),0===i.listenerCount(this,"error"))throw t}function u(){c.removeListener("data",r),t.removeListener("drain",n),c.removeListener("end",o),c.removeListener("close",a),c.removeListener("error",s),t.removeListener("error",s),c.removeListener("end",u),c.removeListener("close",u),t.removeListener("close",u)}var c=this;c.on("data",r),t.on("drain",n),t._isStdio||e&&!1===e.end||(c.on("end",o),c.on("close",a));var l=!1;return c.on("error",s),t.on("error",s),c.on("end",u),c.on("close",u),t.on("close",u),t.emit("pipe",c),t}},function(t,e){},function(t,e,r){"use strict";function n(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e,r){t.copy(e,r)}var o=r(20).Buffer;t.exports=function(){function t(){n(this,t),this.head=null,this.tail=null,this.length=0}return t.prototype.push=function(t){var e={data:t,next:null};this.length>0?this.tail.next=e:this.head=e,this.tail=e,++this.length},t.prototype.unshift=function(t){var e={data:t,next:this.head};0===this.length&&(this.tail=e),this.head=e,++this.length},t.prototype.shift=function(){if(0!==this.length){var t=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,t}},t.prototype.clear=function(){this.head=this.tail=null,this.length=0},t.prototype.join=function(t){if(0===this.length)return"";for(var e=this.head,r=""+e.data;e=e.next;)r+=t+e.data;return r},t.prototype.concat=function(t){if(0===this.length)return o.alloc(0);if(1===this.length)return this.head.data;for(var e=o.allocUnsafe(t>>>0),r=this.head,n=0;r;)i(r.data,e,n),n+=r.data.length,r=r.next;return e},t}()},function(t,e,r){function n(t,e){this._id=t,this._clearFn=e}var i=Function.prototype.apply;e.setTimeout=function(){return new n(i.call(setTimeout,window,arguments),clearTimeout)},e.setInterval=function(){return new n(i.call(setInterval,window,arguments),clearInterval)},e.clearTimeout=e.clearInterval=function(t){t&&t.close()},n.prototype.unref=n.prototype.ref=function(){},n.prototype.close=function(){this._clearFn.call(window,this._id)},e.enroll=function(t,e){clearTimeout(t._idleTimeoutId),t._idleTimeout=e},e.unenroll=function(t){clearTimeout(t._idleTimeoutId),t._idleTimeout=-1},e._unrefActive=e.active=function(t){clearTimeout(t._idleTimeoutId);var e=t._idleTimeout;e>=0&&(t._idleTimeoutId=setTimeout(function(){t._onTimeout&&t._onTimeout()},e))},r(64),e.setImmediate=setImmediate,e.clearImmediate=clearImmediate},function(t,e,r){(function(t,e){!function(t,r){"use strict";function n(t){"function"!=typeof t&&(t=new Function(""+t));for(var e=new Array(arguments.length-1),r=0;r<e.length;r++)e[r]=arguments[r+1];var n={callback:t,args:e};return c[u]=n,s(u),u++}function i(t){delete c[t]}function o(t){var e=t.callback,n=t.args;switch(n.length){case 0:e();break;case 1:e(n[0]);break;case 2:e(n[0],n[1]);break;case 3:e(n[0],n[1],n[2]);break;default:e.apply(r,n)}}function a(t){if(l)setTimeout(a,0,t);else{var e=c[t];if(e){l=!0;try{o(e)}finally{i(t),l=!1}}}}if(!t.setImmediate){var s,u=1,c={},l=!1,f=t.document,h=Object.getPrototypeOf&&Object.getPrototypeOf(t);h=h&&h.setTimeout?h:t,"[object process]"==={}.toString.call(t.process)?function(){s=function(t){e.nextTick(function(){a(t)})}}():function(){if(t.postMessage&&!t.importScripts){var e=!0,r=t.onmessage;return t.onmessage=function(){e=!1},t.postMessage("","*"),t.onmessage=r,e}}()?function(){var e="setImmediate$"+Math.random()+"$",r=function(r){r.source===t&&"string"==typeof r.data&&0===r.data.indexOf(e)&&a(+r.data.slice(e.length))};t.addEventListener?t.addEventListener("message",r,!1):t.attachEvent("onmessage",r),s=function(r){t.postMessage(e+r,"*")}}():t.MessageChannel?function(){var t=new MessageChannel;t.port1.onmessage=function(t){a(t.data)},s=function(e){t.port2.postMessage(e)}}():f&&"onreadystatechange"in f.createElement("script")?function(){var t=f.documentElement;s=function(e){var r=f.createElement("script");r.onreadystatechange=function(){a(e),r.onreadystatechange=null,t.removeChild(r),r=null},t.appendChild(r)}}():function(){s=function(t){setTimeout(a,0,t)}}(),h.setImmediate=n,h.clearImmediate=i}}("undefined"==typeof self?void 0===t?this:t:self)}).call(e,r(0),r(8))},function(t,e,r){(function(e){function r(t,e){function r(){if(!i){if(n("throwDeprecation"))throw new Error(e);n("traceDeprecation")?console.trace(e):console.warn(e),i=!0}return t.apply(this,arguments)}if(n("noDeprecation"))return t;var i=!1;return r}function n(t){try{if(!e.localStorage)return!1}catch(t){return!1}var r=e.localStorage[t];return null!=r&&"true"===String(r).toLowerCase()}t.exports=r}).call(e,r(0))},function(t,e,r){"use strict";function n(t){if(!(this instanceof n))return new n(t);i.call(this,t)}t.exports=n;var i=r(39),o=r(9);o.inherits=r(1),o.inherits(n,i),n.prototype._transform=function(t,e,r){r(null,t)}},function(t,e,r){t.exports=r(21)},function(t,e,r){t.exports=r(2)},function(t,e,r){t.exports=r(19).Transform},function(t,e,r){t.exports=r(19).PassThrough},function(t,e){},function(t,e,r){function n(t){this._cbs=t||{}}t.exports=n;var i=r(3).EVENTS;Object.keys(i).forEach(function(t){if(0===i[t])t="on"+t,n.prototype[t]=function(){this._cbs[t]&&this._cbs[t]()};else if(1===i[t])t="on"+t,n.prototype[t]=function(e){this._cbs[t]&&this._cbs[t](e)};else{if(2!==i[t])throw Error("wrong number of arguments");t="on"+t,n.prototype[t]=function(e,r){this._cbs[t]&&this._cbs[t](e,r)}}})},function(t,e,r){function n(t,e){return t.children?t.children.map(function(t){return a(t,e)}).join(""):""}function i(t){return Array.isArray(t)?t.map(i).join(""):s(t)||t.type===o.CDATA?i(t.children):t.type===o.Text?t.data:""}var o=r(7),a=r(23),s=o.isTag;t.exports={getInnerHTML:n,getOuterHTML:a,getText:i}},function(t,e){t.exports={Text:"text",Directive:"directive",Comment:"comment",Script:"script",Style:"style",Tag:"tag",CDATA:"cdata",isTag:function(t){return"tag"===t.type||"script"===t.type||"style"===t.type}}},function(t,e,r){var n=r(76),i=r(77);e.decode=function(t,e){return(!e||e<=0?i.XML:i.HTML)(t)},e.decodeStrict=function(t,e){return(!e||e<=0?i.XML:i.HTMLStrict)(t)},e.encode=function(t,e){return(!e||e<=0?n.XML:n.HTML)(t)},e.encodeXML=n.XML,e.encodeHTML4=e.encodeHTML5=e.encodeHTML=n.HTML,e.decodeXML=e.decodeXMLStrict=i.XML,e.decodeHTML4=e.decodeHTML5=e.decodeHTML=i.HTML,e.decodeHTML4Strict=e.decodeHTML5Strict=e.decodeHTMLStrict=i.HTMLStrict,e.escape=n.escape},function(t,e,r){function n(t){return Object.keys(t).sort().reduce(function(e,r){return e[t[r]]="&"+r+";",e},{})}function i(t){var e=[],r=[];return Object.keys(t).forEach(function(t){1===t.length?e.push("\\"+t):r.push(t)}),r.unshift("["+e.join("")+"]"),new RegExp(r.join("|"),"g")}function o(t){return"&#x"+t.charCodeAt(0).toString(16).toUpperCase()+";"}function a(t){return"&#x"+(1024*(t.charCodeAt(0)-55296)+t.charCodeAt(1)-56320+65536).toString(16).toUpperCase()+";"}function s(t,e){function r(e){return t[e]}return function(t){return t.replace(e,r).replace(d,a).replace(p,o)}}function u(t){return t.replace(g,o).replace(d,a).replace(p,o)}var c=n(r(18)),l=i(c);e.XML=s(c,l);var f=n(r(17)),h=i(f);e.HTML=s(f,h);var p=/[^\0-\x7F]/g,d=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,g=i(c);e.escape=u},function(t,e,r){function n(t){var e=Object.keys(t).join("|"),r=o(t);e+="|#[xX][\\da-fA-F]+|#\\d+";var n=new RegExp("&(?:"+e+");","g");return function(t){return String(t).replace(n,r)}}function i(t,e){return t<e?1:-1}function o(t){return function(e){return"#"===e.charAt(1)?c("X"===e.charAt(2)||"x"===e.charAt(2)?parseInt(e.substr(3),16):parseInt(e.substr(2),10)):t[e.slice(1,-1)]}}var a=r(17),s=r(33),u=r(18),c=r(32),l=n(u),f=n(a),h=function(){function t(t){return";"!==t.substr(-1)&&(t+=";"),l(t)}for(var e=Object.keys(s).sort(i),r=Object.keys(a).sort(i),n=0,u=0;n<r.length;n++)e[u]===r[n]?(r[n]+=";?",u++):r[n]+=";";var c=new RegExp("&(?:"+r.join("|")+"|#[xX][\\da-fA-F]+;?|#\\d+;?)","g"),l=o(a);return function(e){return String(e).replace(c,t)}}();t.exports={XML:l,HTML:h,HTMLStrict:f}},function(t,e){var r=e.getChildren=function(t){return t.children},n=e.getParent=function(t){return t.parent};e.getSiblings=function(t){var e=n(t);return e?r(e):[t]},e.getAttributeValue=function(t,e){return t.attribs&&t.attribs[e]},e.hasAttrib=function(t,e){return!!t.attribs&&hasOwnProperty.call(t.attribs,e)},e.getName=function(t){return t.name}},function(t,e){e.removeElement=function(t){if(t.prev&&(t.prev.next=t.next),t.next&&(t.next.prev=t.prev),t.parent){var e=t.parent.children;e.splice(e.lastIndexOf(t),1)}},e.replaceElement=function(t,e){var r=e.prev=t.prev;r&&(r.next=e);var n=e.next=t.next;n&&(n.prev=e);var i=e.parent=t.parent;if(i){var o=i.children;o[o.lastIndexOf(t)]=e}},e.appendChild=function(t,e){if(e.parent=t,1!==t.children.push(e)){var r=t.children[t.children.length-2];r.next=e,e.prev=r,e.next=null}},e.append=function(t,e){var r=t.parent,n=t.next;if(e.next=n,e.prev=t,t.next=e,e.parent=r,n){if(n.prev=e,r){var i=r.children;i.splice(i.lastIndexOf(n),0,e)}}else r&&r.children.push(e)},e.prepend=function(t,e){var r=t.parent;if(r){var n=r.children;n.splice(n.lastIndexOf(t),0,e)}t.prev&&(t.prev.next=e),e.parent=r,e.prev=t.prev,e.next=t,t.prev=e}},function(t,e,r){function n(t,e,r,n){return Array.isArray(e)||(e=[e]),"number"==typeof n&&isFinite(n)||(n=1/0),i(t,e,!1!==r,n)}function i(t,e,r,n){for(var o,a=[],s=0,u=e.length;s<u&&!(t(e[s])&&(a.push(e[s]),--n<=0))&&(o=e[s].children,!(r&&o&&o.length>0&&(o=i(t,o,r,n),a=a.concat(o),(n-=o.length)<=0)));s++);return a}function o(t,e){for(var r=0,n=e.length;r<n;r++)if(t(e[r]))return e[r];return null}function a(t,e){for(var r=null,n=0,i=e.length;n<i&&!r;n++)c(e[n])&&(t(e[n])?r=e[n]:e[n].children.length>0&&(r=a(t,e[n].children)));return r}function s(t,e){for(var r=0,n=e.length;r<n;r++)if(c(e[r])&&(t(e[r])||e[r].children.length>0&&s(t,e[r].children)))return!0;return!1}function u(t,e){for(var r=[],n=0,i=e.length;n<i;n++)c(e[n])&&(t(e[n])&&r.push(e[n]),e[n].children.length>0&&(r=r.concat(u(t,e[n].children))));return r}var c=r(7).isTag;t.exports={filter:n,find:i,findOneChild:o,findOne:a,existsOne:s,findAll:u}},function(t,e,r){function n(t,e){return"function"==typeof e?function(r){return r.attribs&&e(r.attribs[t])}:function(r){return r.attribs&&r.attribs[t]===e}}function i(t,e){return function(r){return t(r)||e(r)}}var o=r(7),a=e.isTag=o.isTag;e.testElement=function(t,e){for(var r in t)if(t.hasOwnProperty(r)){if("tag_name"===r){if(!a(e)||!t.tag_name(e.name))return!1}else if("tag_type"===r){if(!t.tag_type(e.type))return!1}else if("tag_contains"===r){if(a(e)||!t.tag_contains(e.data))return!1}else if(!e.attribs||!t[r](e.attribs[r]))return!1}else;return!0};var s={tag_name:function(t){return"function"==typeof t?function(e){return a(e)&&t(e.name)}:"*"===t?a:function(e){return a(e)&&e.name===t}},tag_type:function(t){return"function"==typeof t?function(e){return t(e.type)}:function(e){return e.type===t}},tag_contains:function(t){return"function"==typeof t?function(e){return!a(e)&&t(e.data)}:function(e){return!a(e)&&e.data===t}}};e.getElements=function(t,e,r,o){var a=Object.keys(t).map(function(e){var r=t[e];return e in s?s[e](r):n(e,r)});return 0===a.length?[]:this.filter(a.reduce(i),e,r,o)},e.getElementById=function(t,e,r){return Array.isArray(e)||(e=[e]),this.findOne(n("id",t),e,!1!==r)},e.getElementsByTagName=function(t,e,r,n){return this.filter(s.tag_name(t),e,r,n)},e.getElementsByTagType=function(t,e,r,n){return this.filter(s.tag_type(t),e,r,n)}},function(t,e){e.removeSubsets=function(t){for(var e,r,n,i=t.length;--i>-1;){for(e=r=t[i],t[i]=null,n=!0;r;){if(t.indexOf(r)>-1){n=!1,t.splice(i,1);break}r=r.parent}n&&(t[i]=e)}return t};var r={DISCONNECTED:1,PRECEDING:2,FOLLOWING:4,CONTAINS:8,CONTAINED_BY:16},n=e.compareDocumentPosition=function(t,e){var n,i,o,a,s,u,c=[],l=[];if(t===e)return 0;for(n=t;n;)c.unshift(n),n=n.parent;for(n=e;n;)l.unshift(n),n=n.parent;for(u=0;c[u]===l[u];)u++;return 0===u?r.DISCONNECTED:(i=c[u-1],o=i.children,a=c[u],s=l[u],o.indexOf(a)>o.indexOf(s)?i===e?r.FOLLOWING|r.CONTAINED_BY:r.FOLLOWING:i===t?r.PRECEDING|r.CONTAINS:r.PRECEDING)};e.uniqueSort=function(t){var e,i,o=t.length;for(t=t.slice();--o>-1;)e=t[o],(i=t.indexOf(e))>-1&&i<o&&t.splice(o,1);return t.sort(function(t,e){var i=n(t,e);return i&r.PRECEDING?-1:i&r.FOLLOWING?1:0}),t}},function(t,e,r){function n(t){this._cbs=t||{},this.events=[]}t.exports=n;var i=r(3).EVENTS;Object.keys(i).forEach(function(t){if(0===i[t])t="on"+t,n.prototype[t]=function(){this.events.push([t]),this._cbs[t]&&this._cbs[t]()};else if(1===i[t])t="on"+t,n.prototype[t]=function(e){this.events.push([t,e]),this._cbs[t]&&this._cbs[t](e)};else{if(2!==i[t])throw Error("wrong number of arguments");t="on"+t,n.prototype[t]=function(e,r){this.events.push([t,e,r]),this._cbs[t]&&this._cbs[t](e,r)}}}),n.prototype.onreset=function(){this.events=[],this._cbs.onreset&&this._cbs.onreset()},n.prototype.restart=function(){this._cbs.onreset&&this._cbs.onreset();for(var t=0,e=this.events.length;t<e;t++)if(this._cbs[this.events[t][0]]){var r=this.events[t].length;1===r?this._cbs[this.events[t][0]]():2===r?this._cbs[this.events[t][0]](this.events[t][1]):this._cbs[this.events[t][0]](this.events[t][1],this.events[t][2])}}},function(t,e,r){var n=r(25),i=r(10),o=i.isTag,a=i.domEach,s=Object.prototype.hasOwnProperty,u=i.camelCase,c=i.cssCase,l=/\s+/,f={forEach:r(15),extend:r(40),some:r(93)},h={null:null,true:!0,false:!1},p=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,d=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,g=function(t,e){if(t&&o(t))return t.attribs||(t.attribs={}),e?s.call(t.attribs,e)?p.test(e)?e:t.attribs[e]:"option"===t.name&&"value"===e?n.text(t.children):"input"!==t.name||"radio"!==t.attribs.type&&"checkbox"!==t.attribs.type||"value"!==e?void 0:"on":t.attribs},v=function(t,e,r){null===r?w(t,e):t.attribs[e]=r+""};e.attr=function(t,e){return"object"==typeof t||void 0!==e?"function"==typeof e?a(this,function(r,n){v(n,t,e.call(n,r,n.attribs[t]))}):a(this,function(r,n){o(n)&&("object"==typeof t?f.forEach(t,function(t,e){v(n,e,t)}):v(n,t,e))}):g(this[0],t)};var y=function(t,e){if(t&&o(t))return t.hasOwnProperty(e)?t[e]:p.test(e)?void 0!==g(t,e):g(t,e)},b=function(t,e,r){t[e]=p.test(e)?!!r:r};e.prop=function(t,e){var r,n=0;if("string"==typeof t&&void 0===e){switch(t){case"style":r=this.css(),f.forEach(r,function(t,e){r[n++]=e}),r.length=n;break;case"tagName":case"nodeName":r=this[0].name.toUpperCase();break;default:r=y(this[0],t)}return r}if("object"==typeof t||void 0!==e)return"function"==typeof e?a(this,function(r,n){b(n,t,e.call(n,r,y(n,t)))}):a(this,function(r,n){o(n)&&("object"==typeof t?f.forEach(t,function(t,e){b(n,e,t)}):b(n,t,e))})};var m=function(t,e,r){if(t.data||(t.data={}),"object"==typeof e)return f.extend(t.data,e);"string"==typeof e&&void 0!==r?t.data[e]=r:"object"==typeof e&&f.extend(t.data,e)},_=function(t,e){var r,n,i,o,a,l,f,p=1===arguments.length;for(p?(r=Object.keys(t.attribs).filter(function(t){return"data-"===t.slice(0,"data-".length)}),i=r.map(function(t){return u(t.slice("data-".length))})):(r=["data-"+c(e)],i=[e]),l=0,f=r.length;l<f;++l)if(n=r[l],o=i[l],s.call(t.attribs,n)){if(a=t.attribs[n],s.call(h,a))a=h[a];else if(a===String(Number(a)))a=Number(a);else if(d.test(a))try{a=JSON.parse(a)}catch(t){}t.data[o]=a}return p?t.data:a};e.data=function(t,e){var r=this[0];if(r&&o(r))return r.data||(r.data={}),t?"object"==typeof t||void 0!==e?(a(this,function(r,n){m(n,t,e)}),this):s.call(r.data,t)?r.data[t]:_(r,t):_(r)},e.val=function(t){var e=0===arguments.length,r=this[0];if(r)switch(r.name){case"textarea":return this.text(t);case"input":switch(this.attr("type")){case"radio":return e?this.attr("value"):(this.attr("value",t),this);default:return this.attr("value",t)}return;case"select":var n,i=this.find("option:selected");if(void 0===i)return;if(!e){if(!this.attr().hasOwnProperty("multiple")&&"object"==typeof t)return this;"object"!=typeof t&&(t=[t]),this.find("option").removeAttr("selected");for(var o=0;o<t.length;o++)this.find('option[value="'+t[o]+'"]').attr("selected","");return this}return n=i.attr("value"),this.attr().hasOwnProperty("multiple")&&(n=[],a(i,function(t,e){n.push(g(e,"value"))})),n;case"option":return e?this.attr("value"):(this.attr("value",t),this)}};var w=function(t,e){t.attribs&&s.call(t.attribs,e)&&delete t.attribs[e]};e.removeAttr=function(t){return a(this,function(e,r){w(r,t)}),this},e.hasClass=function(t){return f.some(this,function(e){var r,n=e.attribs,i=n&&n.class,o=-1;if(i)for(;(o=i.indexOf(t,o+1))>-1;)if(r=o+t.length,(0===o||l.test(i[o-1]))&&(r===i.length||l.test(i[r])))return!0})},e.addClass=function(t){if("function"==typeof t)return a(this,function(r,n){var i=n.attribs.class||"";e.addClass.call([n],t.call(n,r,i))});if(!t||"string"!=typeof t)return this;for(var r=t.split(l),n=this.length,i=0;i<n;i++)if(o(this[i])){var s,u,c=g(this[i],"class");if(c){u=" "+c+" ",s=r.length;for(var f=0;f<s;f++){var h=r[f]+" ";u.indexOf(" "+h)<0&&(u+=h)}v(this[i],"class",u.trim())}else v(this[i],"class",r.join(" ").trim())}return this};var x=function(t){return t?t.trim().split(l):[]};e.removeClass=function(t){var r,n,i;return"function"==typeof t?a(this,function(r,n){e.removeClass.call([n],t.call(n,r,n.attribs.class||""))}):(r=x(t),n=r.length,i=0===arguments.length,a(this,function(t,e){if(o(e))if(i)e.attribs.class="";else{for(var a,s,u=x(e.attribs.class),c=0;c<n;c++)(a=u.indexOf(r[c]))>=0&&(u.splice(a,1),s=!0,c--);s&&(e.attribs.class=u.join(" "))}}))},e.toggleClass=function(t,r){if("function"==typeof t)return a(this,function(n,i){e.toggleClass.call([i],t.call(i,n,i.attribs.class||"",r),r)});if(!t||"string"!=typeof t)return this;for(var n,i,s=t.split(l),u=s.length,c="boolean"==typeof r?r?1:-1:0,f=this.length,h=0;h<f;h++)if(o(this[h])){n=x(this[h].attribs.class);for(var p=0;p<u;p++)i=n.indexOf(s[p]),c>=0&&i<0?n.push(s[p]):c<=0&&i>=0&&n.splice(i,1);this[h].attribs.class=n.join(" ")}return this},e.is=function(t){return!!t&&this.filter(t).length>0}},function(t,e,r){var n=r(86),i=r(87);t.exports=function(t){return i(n(t))},t.exports.parse=n,t.exports.compile=i},function(t,e){function r(t){if("even"===(t=t.trim().toLowerCase()))return[2,0];if("odd"===t)return[2,1];var e=t.match(n);if(!e)throw new SyntaxError("n-th rule couldn't be parsed ('"+t+"')");var r;return e[1]?(r=parseInt(e[1],10),isNaN(r)&&(r="-"===e[1].charAt(0)?-1:1)):r=0,[r,e[3]?parseInt((e[2]||"")+e[3],10):0]}t.exports=r;var n=/^([+\-]?\d*n)?\s*(?:([+\-]?)\s*(\d+))?$/},function(t,e,r){function n(t){var e=t[0],r=t[1]-1;if(r<0&&e<=0)return a;if(-1===e)return function(t){return t<=r};if(0===e)return function(t){return t===r};if(1===e)return r<0?o:function(t){return t>=r};var n=r%e;return n<0&&(n+=e),e>1?function(t){return t>=r&&t%e===n}:(e*=-1,function(t){return t<=r&&t%e===n})}t.exports=n;var i=r(11),o=i.trueFunc,a=i.falseFunc},function(t,e,r){function n(t,e,r){return i(o(t,e,r))}function i(t){return function(e){return g(e)&&t(e)}}function o(t,e,r){return u(p(t,e),e,r)}function a(t){return"pseudo"===t.type&&("scope"===t.name||Array.isArray(t.data)&&t.data.some(function(t){return t.some(a)}))}function s(t,e){var r=!!e&&!!e.length&&e.every(function(t){return t===j||!!k(t)});t.forEach(function(t){if(t.length>0&&c(t[0])&&"descendant"!==t[0].type);else{if(!r||a(t))return;t.unshift(x)}t.unshift(S)})}function u(t,e,r){t=t.filter(function(t){return t.length>0}),t.forEach(y);var n=Array.isArray(r);return r=e&&e.context||r,r&&!n&&(r=[r]),s(t,r),t.map(function(t){return l(t,e,r,n)}).reduce(f,_)}function c(t){return w[t.type]<0}function l(t,e,r,n){var i=n&&"scope"===t[0].name&&"descendant"===t[1].type;return t.reduce(function(t,n,o){return t===_?t:v[n.type](t,n,e,r,i&&1===o)},e&&e.rootFunc||m)}function f(t,e){return e===_||t===m?t:t===_||e===m?e:function(r){return t(r)||e(r)}}function h(t){return t.some(c)}t.exports=n,t.exports.compileUnsafe=o,t.exports.compileToken=u;var p=r(89),d=r(4),g=d.isTag,v=r(90),y=r(91),b=r(11),m=b.trueFunc,_=b.falseFunc,w=r(44),x={type:"descendant"},S={type:"pseudo",name:"scope"},j={},k=d.getParent,A=r(26),E=A.filters,T=d.existsOne,g=d.isTag,O=d.getChildren;E.not=function(t,e,r,n){var i={xmlMode:!(!r||!r.xmlMode),strict:!(!r||!r.strict)};if(i.strict&&(e.length>1||e.some(h)))throw new SyntaxError("complex selectors in :not aren't allowed in strict mode");var o=u(e,i,n);return o===_?t:o===m?_:function(e){return!o(e)&&t(e)}},E.has=function(t,e,r){var n={xmlMode:!(!r||!r.xmlMode),strict:!(!r||!r.strict)},o=e.some(h)?[j]:null,a=u(e,n,o);return a===_?_:a===m?function(e){return O(e).some(g)&&t(e)}:(a=i(a),o?function(e){return t(e)&&(o[0]=e,T(a,O(e)))}:function(e){return t(e)&&T(a,O(e))})},E.matches=function(t,e,r,n){return u(e,{xmlMode:!(!r||!r.xmlMode),strict:!(!r||!r.strict),rootFunc:t},n)}},function(t,e,r){"use strict";function n(t,e,r){var n="0x"+e-65536;return n!==n||r?e:n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320)}function i(t){return t.replace(l,n)}function o(t){return" "===t||"\n"===t||"\t"===t||"\f"===t||"\r"===t}function a(t,e){var r=[];if(""!==(t=s(r,t+"",e)))throw new SyntaxError("Unmatched selector: "+t);return r}function s(t,e,r){function n(){var t=e.match(c)[0];return e=e.substr(t.length),i(t)}function a(t){for(;o(e.charAt(t));)t++;e=e.substr(t)}var l,b,m,_,w=[],x=!1;for(a(0);""!==e;)if(b=e.charAt(0),o(b))x=!0,a(1);else if(b in p)w.push({type:p[b]}),x=!1,a(1);else if(","===b){if(0===w.length)throw new SyntaxError("empty sub-selector");t.push(w),w=[],x=!1,a(1)}else if(x&&(w.length>0&&w.push({type:"descendant"}),x=!1),"*"===b)e=e.substr(1),w.push({type:"universal"});else if(b in d)e=e.substr(1),w.push({type:"attribute",name:d[b][0],action:d[b][1],value:n(),ignoreCase:!1});else if("["===b){if(e=e.substr(1),!(l=e.match(f)))throw new SyntaxError("Malformed attribute selector: "+e);e=e.substr(l[0].length),m=i(l[1]),r&&("lowerCaseAttributeNames"in r?!r.lowerCaseAttributeNames:r.xmlMode)||(m=m.toLowerCase()),w.push({type:"attribute",name:m,action:h[l[2]],value:i(l[4]||l[5]||""),ignoreCase:!!l[6]})}else if(":"===b){if(":"===e.charAt(1)){e=e.substr(2),w.push({type:"pseudo-element",name:n().toLowerCase()});continue}if(e=e.substr(1),m=n().toLowerCase(),l=null,"("===e.charAt(0))if(m in g){_=e.charAt(1);var S=_ in y;if(e=e.substr(S+1),l=[],e=s(l,e,r),S){if(e.charAt(0)!==_)throw new SyntaxError("unmatched quotes in :"+m);e=e.substr(1)}if(")"!==e.charAt(0))throw new SyntaxError("missing closing parenthesis in :"+m+" "+e);e=e.substr(1)}else{for(var j=1,k=1;k>0&&j<e.length;j++)"("===e.charAt(j)?k++:")"===e.charAt(j)&&k--;if(k)throw new SyntaxError("parenthesis not matched");l=e.substr(1,j-2),e=e.substr(j),m in v&&(_=l.charAt(0),_===l.slice(-1)&&_ in y&&(l=l.slice(1,-1)),l=i(l))}w.push({type:"pseudo",name:m,data:l})}else{if(!c.test(e))return w.length&&"descendant"===w[w.length-1].type&&w.pop(),u(t,w),e;m=n(),r&&("lowerCaseTags"in r?!r.lowerCaseTags:r.xmlMode)||(m=m.toLowerCase()),w.push({type:"tag",name:m})}return u(t,w),e}function u(t,e){if(t.length>0&&0===e.length)throw new SyntaxError("empty sub-selector");t.push(e)}t.exports=a;var c=/^(?:\\.|[\w\-\u00c0-\uFFFF])+/,l=/\\([\da-f]{1,6}\s?|(\s)|.)/gi,f=/^\s*((?:\\.|[\w\u00c0-\uFFFF\-])+)\s*(?:(\S?)=\s*(?:(['"])(.*?)\3|(#?(?:\\.|[\w\u00c0-\uFFFF\-])*)|)|)\s*(i)?\]/,h={__proto__:null,undefined:"exists","":"equals","~":"element","^":"start",$:"end","*":"any","!":"not","|":"hyphen"},p={__proto__:null,">":"child","<":"parent","~":"sibling","+":"adjacent"},d={__proto__:null,"#":["id","equals"],".":["class","element"]},g={__proto__:null,has:!0,not:!0,matches:!0},v={__proto__:null,contains:!0,icontains:!0},y={__proto__:null,'"':!0,"'":!0}},function(t,e,r){var n=r(4),i=n.isTag,o=n.getParent,a=n.getChildren,s=n.getSiblings,u=n.getName;t.exports={__proto__:null,attribute:r(43).compile,pseudo:r(26).compile,tag:function(t,e){var r=e.name;return function(e){return u(e)===r&&t(e)}},descendant:function(t,e,r,n,i){return function(e){if(i&&t(e))return!0;for(var r=!1;!r&&(e=o(e));)r=t(e);return r}},parent:function(t,e,r){function n(e){return i(e)&&t(e)}if(r&&r.strict)throw SyntaxError("Parent selector isn't part of CSS3");return function(t){return a(t).some(n)}},child:function(t){return function(e){var r=o(e);return!!r&&t(r)}},sibling:function(t){return function(e){for(var r=s(e),n=0;n<r.length;n++)if(i(r[n])){if(r[n]===e)break;if(t(r[n]))return!0}return!1}},adjacent:function(t){return function(e){for(var r,n=s(e),o=0;o<n.length;o++)if(i(n[o])){if(n[o]===e)break;r=n[o]}return!!r&&t(r)}},universal:function(t){return t}}},function(t,e,r){function n(t){for(var e=t.map(i),r=1;r<t.length;r++){var n=e[r];if(!(n<0))for(var o=r-1;o>=0&&n<e[o];o--){var a=t[o+1];t[o+1]=t[o],t[o]=a,e[o+1]=e[o],e[o]=n}}}function i(t){var e=o[t.type];if(e===o.attribute)e=a[t.action],e===a.equals&&"id"===t.name&&(e=9),t.ignoreCase&&(e>>=1);else if(e===o.pseudo)if(t.data)if("has"===t.name||"contains"===t.name)e=0;else if("matches"===t.name||"not"===t.name){e=0;for(var r=0;r<t.data.length;r++)if(1===t.data[r].length){var n=i(t.data[r][0]);if(0===n){e=0;break}n>e&&(e=n)}t.data.length>1&&e>0&&(e-=1)}else e=1;else e=3;return e}t.exports=n;var o=r(44),a={__proto__:null,exists:10,equals:8,not:7,start:6,end:6,any:5,hyphen:4,element:4}},function(t,e,r){(function(t,r){function n(t,e){return t.set(e[0],e[1]),t}function i(t,e){return t.add(e),t}function o(t,e,r){switch(r.length){case 0:return t.call(e);case 1:return t.call(e,r[0]);case 2:return t.call(e,r[0],r[1]);case 3:return t.call(e,r[0],r[1],r[2])}return t.apply(e,r)}function a(t,e){for(var r=-1,n=t?t.length:0;++r<n&&!1!==e(t[r],r,t););return t}function s(t,e){for(var r=-1,n=e.length,i=t.length;++r<n;)t[i+r]=e[r];return t}function u(t,e,r,n){var i=-1,o=t?t.length:0;for(n&&o&&(r=t[++i]);++i<o;)r=e(r,t[i],i,t);return r}function c(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}function l(t,e){return null==t?void 0:t[e]}function f(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"")}catch(t){}return e}function h(t){var e=-1,r=Array(t.size);return t.forEach(function(t,n){r[++e]=[n,t]}),r}function p(t,e){return function(r){return t(e(r))}}function d(t){var e=-1,r=Array(t.size);return t.forEach(function(t){r[++e]=t}),r}function g(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function v(){this.__data__=Ke?Ke(null):{}}function y(t){return this.has(t)&&delete this.__data__[t]}function b(t){var e=this.__data__;if(Ke){var r=e[t];return r===Ut?void 0:r}return De.call(e,t)?e[t]:void 0}function m(t){var e=this.__data__;return Ke?void 0!==e[t]:De.call(e,t)}function _(t,e){return this.__data__[t]=Ke&&void 0===e?Ut:e,this}function w(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function x(){this.__data__=[]}function S(t){var e=this.__data__,r=V(e,t);return!(r<0)&&(r==e.length-1?e.pop():$e.call(e,r,1),!0)}function j(t){var e=this.__data__,r=V(e,t);return r<0?void 0:e[r][1]}function k(t){return V(this.__data__,t)>-1}function A(t,e){var r=this.__data__,n=V(r,t);return n<0?r.push([t,e]):r[n][1]=e,this}function E(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function T(){this.__data__={hash:new g,map:new(Je||w),string:new g}}function O(t){return pt(this,t).delete(t)}function L(t){return pt(this,t).get(t)}function C(t){return pt(this,t).has(t)}function B(t,e){return pt(this,t).set(t,e),this}function D(t){this.__data__=new w(t)}function R(){this.__data__=new w}function P(t){return this.__data__.delete(t)}function q(t){return this.__data__.get(t)}function M(t){return this.__data__.has(t)}function I(t,e){var r=this.__data__;if(r instanceof w){var n=r.__data__;if(!Je||n.length<Nt-1)return n.push([t,e]),this;r=this.__data__=new E(n)}return r.set(t,e),this}function N(t,e){var r=cr(t)||At(t)?c(t.length,String):[],n=r.length,i=!!n;for(var o in t)!e&&!De.call(t,o)||i&&("length"==o||bt(o,n))||r.push(o);return r}function U(t,e,r){(void 0===r||kt(t[e],r))&&("number"!=typeof e||void 0!==r||e in t)||(t[e]=r)}function F(t,e,r){var n=t[e];De.call(t,e)&&kt(n,r)&&(void 0!==r||e in t)||(t[e]=r)}function V(t,e){for(var r=t.length;r--;)if(kt(t[r][0],e))return r;return-1}function $(t,e){return t&&lt(e,Pt(e),t)}function z(t,e,r,n,i,o,s){var u;if(n&&(u=o?n(t,i,o,s):n(t)),void 0!==u)return u;if(!Ct(t))return t;var c=cr(t);if(c){if(u=gt(t),!e)return ct(t,u)}else{var l=ur(t),h=l==Ht||l==Wt;if(lr(t))return et(t,e);if(l==Jt||l==Vt||h&&!o){if(f(t))return o?t:{};if(u=vt(h?{}:t),!e)return ft(t,$(u,t))}else{if(!ye[l])return o?t:{};u=yt(t,l,z,e)}}s||(s=new D);var p=s.get(t);if(p)return p;if(s.set(t,u),!c)var d=r?ht(t):Pt(t);return a(d||t,function(i,o){d&&(o=i,i=t[o]),F(u,o,z(i,e,r,n,o,t,s))}),u}function H(t){return Ct(t)?Fe(t):{}}function W(t,e,r){var n=e(t);return cr(t)?n:s(n,r(t))}function G(t){return Pe.call(t)}function Y(t){return!(!Ct(t)||wt(t))&&(Ot(t)||f(t)?qe:de).test(jt(t))}function J(t){return Bt(t)&&Lt(t.length)&&!!ve[Pe.call(t)]}function Q(t){if(!xt(t))return We(t);var e=[];for(var r in Object(t))De.call(t,r)&&"constructor"!=r&&e.push(r);return e}function X(t){if(!Ct(t))return St(t);var e=xt(t),r=[];for(var n in t)("constructor"!=n||!e&&De.call(t,n))&&r.push(n);return r}function Z(t,e,r,n,i){if(t!==e){if(!cr(e)&&!fr(e))var o=X(e);a(o||e,function(a,s){if(o&&(s=a,a=e[s]),Ct(a))i||(i=new D),K(t,e,s,r,Z,n,i);else{var u=n?n(t[s],a,s+"",t,e,i):void 0;void 0===u&&(u=a),U(t,s,u)}})}}function K(t,e,r,n,i,o,a){var s=t[r],u=e[r],c=a.get(u);if(c)return void U(t,r,c);var l=o?o(s,u,r+"",t,e,a):void 0,f=void 0===l;f&&(l=u,cr(u)||fr(u)?cr(s)?l=s:Tt(s)?l=ct(s):(f=!1,l=z(u,!0)):Dt(u)||At(u)?At(s)?l=Rt(s):!Ct(s)||n&&Ot(s)?(f=!1,l=z(u,!0)):l=s:f=!1),f&&(a.set(u,l),i(l,u,n,o,a),a.delete(u)),U(t,r,l)}function tt(t,e){return e=Ge(void 0===e?t.length-1:e,0),function(){for(var r=arguments,n=-1,i=Ge(r.length-e,0),a=Array(i);++n<i;)a[n]=r[e+n];n=-1;for(var s=Array(e+1);++n<e;)s[n]=r[n];return s[e]=a,o(t,this,s)}}function et(t,e){if(e)return t.slice();var r=new t.constructor(t.length);return t.copy(r),r}function rt(t){var e=new t.constructor(t.byteLength);return new Ne(e).set(new Ne(t)),e}function nt(t,e){var r=e?rt(t.buffer):t.buffer;return new t.constructor(r,t.byteOffset,t.byteLength)}function it(t,e,r){return u(e?r(h(t),!0):h(t),n,new t.constructor)}function ot(t){var e=new t.constructor(t.source,pe.exec(t));return e.lastIndex=t.lastIndex,e}function at(t,e,r){return u(e?r(d(t),!0):d(t),i,new t.constructor)}function st(t){return ar?Object(ar.call(t)):{}}function ut(t,e){var r=e?rt(t.buffer):t.buffer;return new t.constructor(r,t.byteOffset,t.length)}function ct(t,e){var r=-1,n=t.length;for(e||(e=Array(n));++r<n;)e[r]=t[r];return e}function lt(t,e,r,n){r||(r={});for(var i=-1,o=e.length;++i<o;){var a=e[i],s=n?n(r[a],t[a],a,r,t):void 0;F(r,a,void 0===s?t[a]:s)}return r}function ft(t,e){return lt(t,sr(t),e)}function ht(t){return W(t,Pt,sr)}function pt(t,e){var r=t.__data__;return _t(e)?r["string"==typeof e?"string":"hash"]:r.map}function dt(t,e){var r=l(t,e);return Y(r)?r:void 0}function gt(t){var e=t.length,r=t.constructor(e);return e&&"string"==typeof t[0]&&De.call(t,"index")&&(r.index=t.index,r.input=t.input),r}function vt(t){return"function"!=typeof t.constructor||xt(t)?{}:H(Ue(t))}function yt(t,e,r,n){var i=t.constructor;switch(e){case ee:return rt(t);case $t:case zt:return new i(+t);case re:return nt(t,n);case ne:case ie:case oe:case ae:case se:case ue:case ce:case le:case fe:return ut(t,n);case Gt:return it(t,n,r);case Yt:case Zt:return new i(t);case Qt:return ot(t);case Xt:return at(t,n,r);case Kt:return st(t)}}function bt(t,e){return!!(e=null==e?Ft:e)&&("number"==typeof t||ge.test(t))&&t>-1&&t%1==0&&t<e}function mt(t,e,r){if(!Ct(r))return!1;var n=typeof e;return!!("number"==n?Et(r)&&bt(e,r.length):"string"==n&&e in r)&&kt(r[e],t)}function _t(t){var e=typeof t;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t}function wt(t){return!!Ce&&Ce in t}function xt(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||Oe)}function St(t){var e=[];if(null!=t)for(var r in Object(t))e.push(r);return e}function jt(t){if(null!=t){try{return Be.call(t)}catch(t){}try{return t+""}catch(t){}}return""}function kt(t,e){return t===e||t!==t&&e!==e}function At(t){return Tt(t)&&De.call(t,"callee")&&(!Ve.call(t,"callee")||Pe.call(t)==Vt)}function Et(t){return null!=t&&Lt(t.length)&&!Ot(t)}function Tt(t){return Bt(t)&&Et(t)}function Ot(t){var e=Ct(t)?Pe.call(t):"";return e==Ht||e==Wt}function Lt(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=Ft}function Ct(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function Bt(t){return!!t&&"object"==typeof t}function Dt(t){if(!Bt(t)||Pe.call(t)!=Jt||f(t))return!1;var e=Ue(t);if(null===e)return!0;var r=De.call(e,"constructor")&&e.constructor;return"function"==typeof r&&r instanceof r&&Be.call(r)==Re}function Rt(t){return lt(t,qt(t))}function Pt(t){return Et(t)?N(t):Q(t)}function qt(t){return Et(t)?N(t,!0):X(t)}function Mt(){return[]}function It(){return!1}var Nt=200,Ut="__lodash_hash_undefined__",Ft=9007199254740991,Vt="[object Arguments]",$t="[object Boolean]",zt="[object Date]",Ht="[object Function]",Wt="[object GeneratorFunction]",Gt="[object Map]",Yt="[object Number]",Jt="[object Object]",Qt="[object RegExp]",Xt="[object Set]",Zt="[object String]",Kt="[object Symbol]",te="[object WeakMap]",ee="[object ArrayBuffer]",re="[object DataView]",ne="[object Float32Array]",ie="[object Float64Array]",oe="[object Int8Array]",ae="[object Int16Array]",se="[object Int32Array]",ue="[object Uint8Array]",ce="[object Uint8ClampedArray]",le="[object Uint16Array]",fe="[object Uint32Array]",he=/[\\^$.*+?()[\]{}|]/g,pe=/\w*$/,de=/^\[object .+?Constructor\]$/,ge=/^(?:0|[1-9]\d*)$/,ve={};ve[ne]=ve[ie]=ve[oe]=ve[ae]=ve[se]=ve[ue]=ve[ce]=ve[le]=ve[fe]=!0,ve[Vt]=ve["[object Array]"]=ve[ee]=ve[$t]=ve[re]=ve[zt]=ve["[object Error]"]=ve[Ht]=ve[Gt]=ve[Yt]=ve[Jt]=ve[Qt]=ve[Xt]=ve[Zt]=ve[te]=!1;var ye={};ye[Vt]=ye["[object Array]"]=ye[ee]=ye[re]=ye[$t]=ye[zt]=ye[ne]=ye[ie]=ye[oe]=ye[ae]=ye[se]=ye[Gt]=ye[Yt]=ye[Jt]=ye[Qt]=ye[Xt]=ye[Zt]=ye[Kt]=ye[ue]=ye[ce]=ye[le]=ye[fe]=!0,ye["[object Error]"]=ye[Ht]=ye[te]=!1;var be="object"==typeof t&&t&&t.Object===Object&&t,me="object"==typeof self&&self&&self.Object===Object&&self,_e=be||me||Function("return this")(),we="object"==typeof e&&e&&!e.nodeType&&e,xe=we&&"object"==typeof r&&r&&!r.nodeType&&r,Se=xe&&xe.exports===we,je=Se&&be.process,ke=function(){try{return je&&je.binding("util")}catch(t){}}(),Ae=ke&&ke.isTypedArray,Ee=Array.prototype,Te=Function.prototype,Oe=Object.prototype,Le=_e["__core-js_shared__"],Ce=function(){var t=/[^.]+$/.exec(Le&&Le.keys&&Le.keys.IE_PROTO||"");return t?"Symbol(src)_1."+t:""}(),Be=Te.toString,De=Oe.hasOwnProperty,Re=Be.call(Object),Pe=Oe.toString,qe=RegExp("^"+Be.call(De).replace(he,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Me=Se?_e.Buffer:void 0,Ie=_e.Symbol,Ne=_e.Uint8Array,Ue=p(Object.getPrototypeOf,Object),Fe=Object.create,Ve=Oe.propertyIsEnumerable,$e=Ee.splice,ze=Object.getOwnPropertySymbols,He=Me?Me.isBuffer:void 0,We=p(Object.keys,Object),Ge=Math.max,Ye=dt(_e,"DataView"),Je=dt(_e,"Map"),Qe=dt(_e,"Promise"),Xe=dt(_e,"Set"),Ze=dt(_e,"WeakMap"),Ke=dt(Object,"create"),tr=jt(Ye),er=jt(Je),rr=jt(Qe),nr=jt(Xe),ir=jt(Ze),or=Ie?Ie.prototype:void 0,ar=or?or.valueOf:void 0;g.prototype.clear=v,g.prototype.delete=y,g.prototype.get=b,g.prototype.has=m,g.prototype.set=_,w.prototype.clear=x,w.prototype.delete=S,w.prototype.get=j,w.prototype.has=k,w.prototype.set=A,E.prototype.clear=T,E.prototype.delete=O,E.prototype.get=L,E.prototype.has=C,E.prototype.set=B,D.prototype.clear=R,D.prototype.delete=P,D.prototype.get=q,D.prototype.has=M,D.prototype.set=I;var sr=ze?p(ze,Object):Mt,ur=G;(Ye&&ur(new Ye(new ArrayBuffer(1)))!=re||Je&&ur(new Je)!=Gt||Qe&&"[object Promise]"!=ur(Qe.resolve())||Xe&&ur(new Xe)!=Xt||Ze&&ur(new Ze)!=te)&&(ur=function(t){var e=Pe.call(t),r=e==Jt?t.constructor:void 0,n=r?jt(r):void 0;if(n)switch(n){case tr:return re;case er:return Gt;case rr:return"[object Promise]";case nr:return Xt;case ir:return te}return e});var cr=Array.isArray,lr=He||It,fr=Ae?function(t){return function(e){return t(e)}}(Ae):J,hr=function(t){return tt(function(e,r){var n=-1,i=r.length,o=i>1?r[i-1]:void 0,a=i>2?r[2]:void 0;for(o=t.length>3&&"function"==typeof o?(i--,o):void 0,a&&mt(r[0],r[1],a)&&(o=i<3?void 0:o,i=1),e=Object(e);++n<i;){var s=r[n];s&&t(e,s,n,o)}return e})}(function(t,e,r){Z(t,e,r)});r.exports=hr}).call(e,r(0),r(5)(t))},function(t,e,r){(function(t,r){function n(t,e){for(var r=-1,n=t?t.length:0;++r<n;)if(e(t[r],r,t))return!0;return!1}function i(t){return function(e){return null==e?void 0:e[t]}}function o(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}function a(t,e){return null==t?void 0:t[e]}function s(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"")}catch(t){}return e}function u(t){var e=-1,r=Array(t.size);return t.forEach(function(t,n){r[++e]=[n,t]}),r}function c(t){var e=-1,r=Array(t.size);return t.forEach(function(t){r[++e]=t}),r}function l(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function f(){this.__data__=Ve?Ve(null):{}}function h(t){return this.has(t)&&delete this.__data__[t]}function p(t){var e=this.__data__;if(Ve){var r=e[t];return r===It?void 0:r}return Oe.call(e,t)?e[t]:void 0}function d(t){var e=this.__data__;return Ve?void 0!==e[t]:Oe.call(e,t)}function g(t,e){return this.__data__[t]=Ve&&void 0===e?It:e,this}function v(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function y(){this.__data__=[]}function b(t){var e=this.__data__,r=I(e,t);return!(r<0)&&(r==e.length-1?e.pop():Pe.call(e,r,1),!0)}function m(t){var e=this.__data__,r=I(e,t);return r<0?void 0:e[r][1]}function _(t){return I(this.__data__,t)>-1}function w(t,e){var r=this.__data__,n=I(r,t);return n<0?r.push([t,e]):r[n][1]=e,this}function x(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function S(){this.__data__={hash:new l,map:new(Ie||v),string:new l}}function j(t){return ot(this,t).delete(t)}function k(t){return ot(this,t).get(t)}function A(t){return ot(this,t).has(t)}function E(t,e){return ot(this,t).set(t,e),this}function T(t){var e=-1,r=t?t.length:0;for(this.__data__=new x;++e<r;)this.add(t[e])}function O(t){return this.__data__.set(t,It),this}function L(t){return this.__data__.has(t)}function C(t){this.__data__=new v(t)}function B(){this.__data__=new v}function D(t){return this.__data__.delete(t)}function R(t){return this.__data__.get(t)}function P(t){return this.__data__.has(t)}function q(t,e){var r=this.__data__;if(r instanceof v){var n=r.__data__;if(!Ie||n.length<qt-1)return n.push([t,e]),this;r=this.__data__=new x(n)}return r.set(t,e),this}function M(t,e){var r=er(t)||xt(t)?o(t.length,String):[],n=r.length,i=!!n;for(var a in t)!e&&!Oe.call(t,a)||i&&("length"==a||ct(a,n))||r.push(a);return r}function I(t,e){for(var r=t.length;r--;)if(wt(t[r][0],e))return r;return-1}function N(t,e){return t&&Ze(t,e,Dt)}function U(t,e){e=ft(e,t)?[e]:et(e);for(var r=0,n=e.length;null!=t&&r<n;)t=t[yt(e[r++])];return r&&r==n?t:void 0}function F(t){return Le.call(t)}function V(t,e){return null!=t&&e in Object(t)}function $(t,e,r,n,i){return t===e||(null==t||null==e||!Et(t)&&!Tt(e)?t!==t&&e!==e:z(t,e,$,r,n,i))}function z(t,e,r,n,i,o){var a=er(t),u=er(e),c=zt,l=zt;a||(c=Ke(t),c=c==$t?Zt:c),u||(l=Ke(e),l=l==$t?Zt:l);var f=c==Zt&&!s(t),h=l==Zt&&!s(e),p=c==l;if(p&&!f)return o||(o=new C),a||rr(t)?rt(t,e,r,n,i,o):nt(t,e,c,r,n,i,o);if(!(i&Ut)){var d=f&&Oe.call(t,"__wrapped__"),g=h&&Oe.call(e,"__wrapped__");if(d||g){var v=d?t.value():t,y=g?e.value():e;return o||(o=new C),r(v,y,n,i,o)}}return!!p&&(o||(o=new C),it(t,e,r,n,i,o))}function H(t,e,r,n){var i=r.length,o=i,a=!n;if(null==t)return!o;for(t=Object(t);i--;){var s=r[i];if(a&&s[2]?s[1]!==t[s[0]]:!(s[0]in t))return!1}for(;++i<o;){s=r[i];var u=s[0],c=t[u],l=s[1];if(a&&s[2]){if(void 0===c&&!(u in t))return!1}else{var f=new C;if(n)var h=n(c,l,u,t,e,f);if(!(void 0===h?$(l,c,n,Nt|Ut,f):h))return!1}}return!0}function W(t){return!(!Et(t)||pt(t))&&(kt(t)||s(t)?Ce:fe).test(bt(t))}function G(t){return Tt(t)&&At(t.length)&&!!pe[Le.call(t)]}function Y(t){return"function"==typeof t?t:null==t?Rt:"object"==typeof t?er(t)?X(t[0],t[1]):Q(t):Pt(t)}function J(t){if(!dt(t))return qe(t);var e=[];for(var r in Object(t))Oe.call(t,r)&&"constructor"!=r&&e.push(r);return e}function Q(t){var e=at(t);return 1==e.length&&e[0][2]?vt(e[0][0],e[0][1]):function(r){return r===t||H(r,t,e)}}function X(t,e){return ft(t)&&gt(e)?vt(yt(t),e):function(r){var n=Ct(r,t);return void 0===n&&n===e?Bt(r,t):$(e,n,void 0,Nt|Ut)}}function Z(t){return function(e){return U(e,t)}}function K(t,e){var r;return Xe(t,function(t,n,i){return!(r=e(t,n,i))}),!!r}function tt(t){if("string"==typeof t)return t;if(Ot(t))return Qe?Qe.call(t):"";var e=t+"";return"0"==e&&1/t==-Ft?"-0":e}function et(t){return er(t)?t:tr(t)}function rt(t,e,r,i,o,a){var s=o&Ut,u=t.length,c=e.length;if(u!=c&&!(s&&c>u))return!1;var l=a.get(t);if(l&&a.get(e))return l==e;var f=-1,h=!0,p=o&Nt?new T:void 0;for(a.set(t,e),a.set(e,t);++f<u;){var d=t[f],g=e[f];if(i)var v=s?i(g,d,f,e,t,a):i(d,g,f,t,e,a);if(void 0!==v){if(v)continue;h=!1;break}if(p){if(!n(e,function(t,e){if(!p.has(e)&&(d===t||r(d,t,i,o,a)))return p.add(e)})){h=!1;break}}else if(d!==g&&!r(d,g,i,o,a)){h=!1;break}}return a.delete(t),a.delete(e),h}function nt(t,e,r,n,i,o,a){switch(r){case ie:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return!1;t=t.buffer,e=e.buffer;case ne:return!(t.byteLength!=e.byteLength||!n(new De(t),new De(e)));case Ht:case Wt:case Xt:return wt(+t,+e);case Gt:return t.name==e.name&&t.message==e.message;case Kt:case ee:return t==e+"";case Qt:var s=u;case te:var l=o&Ut;if(s||(s=c),t.size!=e.size&&!l)return!1;var f=a.get(t);if(f)return f==e;o|=Nt,a.set(t,e);var h=rt(s(t),s(e),n,i,o,a);return a.delete(t),h;case re:if(Je)return Je.call(t)==Je.call(e)}return!1}function it(t,e,r,n,i,o){var a=i&Ut,s=Dt(t),u=s.length;if(u!=Dt(e).length&&!a)return!1;for(var c=u;c--;){var l=s[c];if(!(a?l in e:Oe.call(e,l)))return!1}var f=o.get(t);if(f&&o.get(e))return f==e;var h=!0;o.set(t,e),o.set(e,t);for(var p=a;++c<u;){l=s[c];var d=t[l],g=e[l];if(n)var v=a?n(g,d,l,e,t,o):n(d,g,l,t,e,o);if(!(void 0===v?d===g||r(d,g,n,i,o):v)){h=!1;break}p||(p="constructor"==l)}if(h&&!p){var y=t.constructor,b=e.constructor;y!=b&&"constructor"in t&&"constructor"in e&&!("function"==typeof y&&y instanceof y&&"function"==typeof b&&b instanceof b)&&(h=!1)}return o.delete(t),o.delete(e),h}function ot(t,e){var r=t.__data__;return ht(e)?r["string"==typeof e?"string":"hash"]:r.map}function at(t){for(var e=Dt(t),r=e.length;r--;){var n=e[r],i=t[n];e[r]=[n,i,gt(i)]}return e}function st(t,e){var r=a(t,e);return W(r)?r:void 0}function ut(t,e,r){e=ft(e,t)?[e]:et(e);for(var n,i=-1,o=e.length;++i<o;){var a=yt(e[i]);if(!(n=null!=t&&r(t,a)))break;t=t[a]}if(n)return n;var o=t?t.length:0;return!!o&&At(o)&&ct(a,o)&&(er(t)||xt(t))}function ct(t,e){return!!(e=null==e?Vt:e)&&("number"==typeof t||he.test(t))&&t>-1&&t%1==0&&t<e}function lt(t,e,r){if(!Et(r))return!1;var n=typeof e;return!!("number"==n?St(r)&&ct(e,r.length):"string"==n&&e in r)&&wt(r[e],t)}function ft(t,e){if(er(t))return!1;var r=typeof t;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=t&&!Ot(t))||(ae.test(t)||!oe.test(t)||null!=e&&t in Object(e))}function ht(t){var e=typeof t;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t}function pt(t){return!!Ee&&Ee in t}function dt(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||ke)}function gt(t){return t===t&&!Et(t)}function vt(t,e){return function(r){return null!=r&&(r[t]===e&&(void 0!==e||t in Object(r)))}}function yt(t){if("string"==typeof t||Ot(t))return t;var e=t+"";return"0"==e&&1/t==-Ft?"-0":e}function bt(t){if(null!=t){try{return Te.call(t)}catch(t){}try{return t+""}catch(t){}}return""}function mt(t,e,r){var i=er(t)?n:K;return r&&lt(t,e,r)&&(e=void 0),i(t,Y(e,3))}function _t(t,e){if("function"!=typeof t||e&&"function"!=typeof e)throw new TypeError(Mt);var r=function(){var n=arguments,i=e?e.apply(this,n):n[0],o=r.cache;if(o.has(i))return o.get(i);var a=t.apply(this,n);return r.cache=o.set(i,a),a};return r.cache=new(_t.Cache||x),r}function wt(t,e){return t===e||t!==t&&e!==e}function xt(t){return jt(t)&&Oe.call(t,"callee")&&(!Re.call(t,"callee")||Le.call(t)==$t)}function St(t){return null!=t&&At(t.length)&&!kt(t)}function jt(t){return Tt(t)&&St(t)}function kt(t){var e=Et(t)?Le.call(t):"";return e==Yt||e==Jt}function At(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=Vt}function Et(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function Tt(t){return!!t&&"object"==typeof t}function Ot(t){return"symbol"==typeof t||Tt(t)&&Le.call(t)==re}function Lt(t){return null==t?"":tt(t)}function Ct(t,e,r){var n=null==t?void 0:U(t,e);return void 0===n?r:n}function Bt(t,e){return null!=t&&ut(t,e,V)}function Dt(t){return St(t)?M(t):J(t)}function Rt(t){return t}function Pt(t){return ft(t)?i(yt(t)):Z(t)}var qt=200,Mt="Expected a function",It="__lodash_hash_undefined__",Nt=1,Ut=2,Ft=1/0,Vt=9007199254740991,$t="[object Arguments]",zt="[object Array]",Ht="[object Boolean]",Wt="[object Date]",Gt="[object Error]",Yt="[object Function]",Jt="[object GeneratorFunction]",Qt="[object Map]",Xt="[object Number]",Zt="[object Object]",Kt="[object RegExp]",te="[object Set]",ee="[object String]",re="[object Symbol]",ne="[object ArrayBuffer]",ie="[object DataView]",oe=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,ae=/^\w*$/,se=/^\./,ue=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,ce=/[\\^$.*+?()[\]{}|]/g,le=/\\(\\)?/g,fe=/^\[object .+?Constructor\]$/,he=/^(?:0|[1-9]\d*)$/,pe={};pe["[object Float32Array]"]=pe["[object Float64Array]"]=pe["[object Int8Array]"]=pe["[object Int16Array]"]=pe["[object Int32Array]"]=pe["[object Uint8Array]"]=pe["[object Uint8ClampedArray]"]=pe["[object Uint16Array]"]=pe["[object Uint32Array]"]=!0,pe[$t]=pe[zt]=pe[ne]=pe[Ht]=pe[ie]=pe[Wt]=pe[Gt]=pe[Yt]=pe[Qt]=pe[Xt]=pe[Zt]=pe[Kt]=pe[te]=pe[ee]=pe["[object WeakMap]"]=!1;var de="object"==typeof t&&t&&t.Object===Object&&t,ge="object"==typeof self&&self&&self.Object===Object&&self,ve=de||ge||Function("return this")(),ye="object"==typeof e&&e&&!e.nodeType&&e,be=ye&&"object"==typeof r&&r&&!r.nodeType&&r,me=be&&be.exports===ye,_e=me&&de.process,we=function(){try{return _e&&_e.binding("util")}catch(t){}}(),xe=we&&we.isTypedArray,Se=Array.prototype,je=Function.prototype,ke=Object.prototype,Ae=ve["__core-js_shared__"],Ee=function(){var t=/[^.]+$/.exec(Ae&&Ae.keys&&Ae.keys.IE_PROTO||"");return t?"Symbol(src)_1."+t:""}(),Te=je.toString,Oe=ke.hasOwnProperty,Le=ke.toString,Ce=RegExp("^"+Te.call(Oe).replace(ce,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Be=ve.Symbol,De=ve.Uint8Array,Re=ke.propertyIsEnumerable,Pe=Se.splice,qe=function(t,e){return function(r){return t(e(r))}}(Object.keys,Object),Me=st(ve,"DataView"),Ie=st(ve,"Map"),Ne=st(ve,"Promise"),Ue=st(ve,"Set"),Fe=st(ve,"WeakMap"),Ve=st(Object,"create"),$e=bt(Me),ze=bt(Ie),He=bt(Ne),We=bt(Ue),Ge=bt(Fe),Ye=Be?Be.prototype:void 0,Je=Ye?Ye.valueOf:void 0,Qe=Ye?Ye.toString:void 0;l.prototype.clear=f,l.prototype.delete=h,l.prototype.get=p,l.prototype.has=d,l.prototype.set=g,v.prototype.clear=y,v.prototype.delete=b,v.prototype.get=m,v.prototype.has=_,v.prototype.set=w,x.prototype.clear=S,x.prototype.delete=j,x.prototype.get=k,x.prototype.has=A,x.prototype.set=E,T.prototype.add=T.prototype.push=O,T.prototype.has=L,C.prototype.clear=B,C.prototype.delete=D,C.prototype.get=R,C.prototype.has=P,C.prototype.set=q;var Xe=function(t,e){return function(r,n){if(null==r)return r;if(!St(r))return t(r,n);for(var i=r.length,o=e?i:-1,a=Object(r);(e?o--:++o<i)&&!1!==n(a[o],o,a););return r}}(N),Ze=function(t){return function(e,r,n){for(var i=-1,o=Object(e),a=n(e),s=a.length;s--;){var u=a[t?s:++i];if(!1===r(o[u],u,o))break}return e}}(),Ke=F;(Me&&Ke(new Me(new ArrayBuffer(1)))!=ie||Ie&&Ke(new Ie)!=Qt||Ne&&"[object Promise]"!=Ke(Ne.resolve())||Ue&&Ke(new Ue)!=te||Fe&&"[object WeakMap]"!=Ke(new Fe))&&(Ke=function(t){var e=Le.call(t),r=e==Zt?t.constructor:void 0,n=r?bt(r):void 0;if(n)switch(n){case $e:return ie;case ze:return Qt;case He:return"[object Promise]";case We:return te;case Ge:return"[object WeakMap]"}return e});var tr=_t(function(t){t=Lt(t);var e=[];return se.test(t)&&e.push(""),t.replace(ue,function(t,r,n,i){e.push(n?i.replace(le,"$1"):r||t)}),e});_t.Cache=x;var er=Array.isArray,rr=xe?function(t){return function(e){return t(e)}}(xe):G;r.exports=mt}).call(e,r(0),r(5)(t))},function(t,e,r){function n(t,r,n,i){for(var o=[];r&&o.length<i;)n&&!e.filter.call([r],n,t).length||o.push(r),r=r.parent;return o}var i=r(42),o=r(10),a=o.domEach,s=r(3).DomUtils.uniqueSort,u=o.isTag,c={bind:r(24),forEach:r(15),reject:r(95),filter:r(96),reduce:r(97)};e.find=function(t){var e,r=c.reduce(this,function(t,e){return t.concat(c.filter(e.children,u))},[]),n=this.constructor.contains;if(t&&"string"!=typeof t)return e=t.cheerio?t.get():[t],this._make(e.filter(function(t){var e,r;for(e=0,r=this.length;e<r;++e)if(n(this[e],t))return!0},this));var o={__proto__:this.options,context:this.toArray()};return this._make(i(t,r,o))},e.parent=function(t){var r=[];return a(this,function(t,e){var n=e.parent;n&&r.indexOf(n)<0&&r.push(n)}),arguments.length&&(r=e.filter.call(r,t,this)),this._make(r)},e.parents=function(t){var e=[];return this.get().reverse().forEach(function(r){n(this,r.parent,t,1/0).forEach(function(t){-1===e.indexOf(t)&&e.push(t)})},this),this._make(e)},e.parentsUntil=function(t,e){var r,n,o=[];return"string"==typeof t?r=i(t,this.parents().toArray(),this.options)[0]:t&&t.cheerio?n=t.toArray():t&&(r=t),this.toArray().reverse().forEach(function(t){for(;(t=t.parent)&&(r&&t!==r||n&&-1===n.indexOf(t)||!r&&!n);)u(t)&&-1===o.indexOf(t)&&o.push(t)},this),this._make(e?i(e,o,this.options):o)},e.closest=function(t){var e=[];return t?(a(this,function(r,i){var o=n(this,i,t,1)[0];o&&e.indexOf(o)<0&&e.push(o)}.bind(this)),this._make(e)):this._make(e)},e.next=function(t){if(!this[0])return this;var r=[];return c.forEach(this,function(t){for(;t=t.next;)if(u(t))return void r.push(t)}),t?e.filter.call(r,t,this):this._make(r)},e.nextAll=function(t){if(!this[0])return this;var r=[];return c.forEach(this,function(t){for(;t=t.next;)u(t)&&-1===r.indexOf(t)&&r.push(t)}),t?e.filter.call(r,t,this):this._make(r)},e.nextUntil=function(t,r){if(!this[0])return this;var n,o,a=[];return"string"==typeof t?n=i(t,this.nextAll().get(),this.options)[0]:t&&t.cheerio?o=t.get():t&&(n=t),c.forEach(this,function(t){for(;(t=t.next)&&(n&&t!==n||o&&-1===o.indexOf(t)||!n&&!o);)u(t)&&-1===a.indexOf(t)&&a.push(t)}),r?e.filter.call(a,r,this):this._make(a)},e.prev=function(t){if(!this[0])return this;var r=[];return c.forEach(this,function(t){for(;t=t.prev;)if(u(t))return void r.push(t)}),t?e.filter.call(r,t,this):this._make(r)},e.prevAll=function(t){if(!this[0])return this;var r=[];return c.forEach(this,function(t){for(;t=t.prev;)u(t)&&-1===r.indexOf(t)&&r.push(t)}),t?e.filter.call(r,t,this):this._make(r)},e.prevUntil=function(t,r){if(!this[0])return this;var n,o,a=[];return"string"==typeof t?n=i(t,this.prevAll().get(),this.options)[0]:t&&t.cheerio?o=t.get():t&&(n=t),c.forEach(this,function(t){for(;(t=t.prev)&&(n&&t!==n||o&&-1===o.indexOf(t)||!n&&!o);)u(t)&&-1===a.indexOf(t)&&a.push(t)}),r?e.filter.call(a,r,this):this._make(a)},e.siblings=function(t){var r=this.parent(),n=c.filter(r?r.children():this.siblingsAndMe(),c.bind(function(t){return u(t)&&!this.is(t)},this));return void 0!==t?e.filter.call(n,t,this):this._make(n)},e.children=function(t){var r=c.reduce(this,function(t,e){return t.concat(c.filter(e.children,u))},[]);return void 0===t?this._make(r):e.filter.call(r,t,this)},e.contents=function(){return this._make(c.reduce(this,function(t,e){return t.push.apply(t,e.children),t},[]))},e.each=function(t){for(var e=0,r=this.length;e<r&&!1!==t.call(this[e],e,this[e]);)++e;return this},e.map=function(t){return this._make(c.reduce(this,function(e,r,n){var i=t.call(r,n,r);return null==i?e:e.concat(i)},[]))};var l=function(t){return function(e,r){var n;return r=r||this,n="string"==typeof e?i.compile(e,r.options):"function"==typeof e?function(t,r){return e.call(t,r,t)}:e.cheerio?e.is.bind(e):function(t){return e===t},r._make(t(this,n))}};e.filter=l(c.filter),e.not=l(c.reject),e.has=function(t){var r=this;return e.filter.call(this,function(){return r._make(this).find(t).length>0})},e.first=function(){return this.length>1?this._make(this[0]):this},e.last=function(){return this.length>1?this._make(this[this.length-1]):this},e.eq=function(t){return 0===(t=+t)&&this.length<=1?this:(t<0&&(t=this.length+t),this[t]?this._make(this[t]):this._make([]))},e.get=function(t){return null==t?Array.prototype.slice.call(this):this[t<0?this.length+t:t]},e.index=function(t){var e,r;return 0===arguments.length?(e=this.parent().children(),r=this[0]):"string"==typeof t?(e=this._make(t),r=this[0]):(e=this,r=t.cheerio?t[0]:t),e.get().indexOf(r)},e.slice=function(){return this._make([].slice.apply(this,arguments))},e.end=function(){return this.prevObject||this._make([])},e.add=function(t,e){for(var r=this._make(t,e),n=s(r.get().concat(this.get())),i=0;i<n.length;++i)r[i]=n[i];return r.length=n.length,r},e.addBack=function(t){return this.add(arguments.length?this.prevObject.filter(t):this.prevObject)}},function(t,e,r){(function(t,r){function n(t,e){for(var r=-1,n=t?t.length:0,i=0,o=[];++r<n;){var a=t[r];e(a,r,t)&&(o[i++]=a)}return o}function i(t,e){for(var r=-1,n=t?t.length:0;++r<n;)if(e(t[r],r,t))return!0;return!1}function o(t){return function(e){return null==e?void 0:e[t]}}function a(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}function s(t,e){return null==t?void 0:t[e]}function u(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"")}catch(t){}return e}function c(t){var e=-1,r=Array(t.size);return t.forEach(function(t,n){r[++e]=[n,t]}),r}function l(t){var e=-1,r=Array(t.size);return t.forEach(function(t){r[++e]=t}),r}function f(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function h(){this.__data__=$e?$e(null):{}}function p(t){return this.has(t)&&delete this.__data__[t]}function d(t){var e=this.__data__;if($e){var r=e[t];return r===Nt?void 0:r}return Le.call(e,t)?e[t]:void 0}function g(t){var e=this.__data__;return $e?void 0!==e[t]:Le.call(e,t)}function v(t,e){return this.__data__[t]=$e&&void 0===e?Nt:e,this}function y(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function b(){this.__data__=[]}function m(t){var e=this.__data__,r=N(e,t);return!(r<0)&&(r==e.length-1?e.pop():qe.call(e,r,1),!0)}function _(t){var e=this.__data__,r=N(e,t);return r<0?void 0:e[r][1]}function w(t){return N(this.__data__,t)>-1}function x(t,e){var r=this.__data__,n=N(r,t);return n<0?r.push([t,e]):r[n][1]=e,this}function S(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function j(){this.__data__={hash:new f,map:new(Ne||y),string:new f}}function k(t){return at(this,t).delete(t)}function A(t){return at(this,t).get(t)}function E(t){return at(this,t).has(t)}function T(t,e){return at(this,t).set(t,e),this}function O(t){var e=-1,r=t?t.length:0;for(this.__data__=new S;++e<r;)this.add(t[e])}function L(t){return this.__data__.set(t,Nt),this}function C(t){return this.__data__.has(t)}function B(t){this.__data__=new y(t)}function D(){this.__data__=new y}function R(t){return this.__data__.delete(t)}function P(t){return this.__data__.get(t)}function q(t){return this.__data__.has(t)}function M(t,e){var r=this.__data__;if(r instanceof y){var n=r.__data__;if(!Ne||n.length<Mt-1)return n.push([t,e]),this;r=this.__data__=new S(n)}return r.set(t,e),this}function I(t,e){var r=rr(t)||St(t)?a(t.length,String):[],n=r.length,i=!!n;for(var o in t)!e&&!Le.call(t,o)||i&&("length"==o||lt(o,n))||r.push(o);return r}function N(t,e){for(var r=t.length;r--;)if(xt(t[r][0],e))return r;return-1}function U(t,e){var r=[];return Ze(t,function(t,n,i){e(t,n,i)&&r.push(t)}),r}function F(t,e){return t&&Ke(t,e,Rt)}function V(t,e){e=ft(e,t)?[e]:rt(e);for(var r=0,n=e.length;null!=t&&r<n;)t=t[yt(e[r++])];return r&&r==n?t:void 0}function $(t){return Ce.call(t)}function z(t,e){return null!=t&&e in Object(t)}function H(t,e,r,n,i){return t===e||(null==t||null==e||!Tt(t)&&!Ot(e)?t!==t&&e!==e:W(t,e,H,r,n,i))}function W(t,e,r,n,i,o){var a=rr(t),s=rr(e),c=Ht,l=Ht;a||(c=tr(t),c=c==zt?Kt:c),s||(l=tr(e),l=l==zt?Kt:l);var f=c==Kt&&!u(t),h=l==Kt&&!u(e),p=c==l;if(p&&!f)return o||(o=new B),a||nr(t)?nt(t,e,r,n,i,o):it(t,e,c,r,n,i,o);if(!(i&Ft)){var d=f&&Le.call(t,"__wrapped__"),g=h&&Le.call(e,"__wrapped__");if(d||g){var v=d?t.value():t,y=g?e.value():e;return o||(o=new B),r(v,y,n,i,o)}}return!!p&&(o||(o=new B),ot(t,e,r,n,i,o))}function G(t,e,r,n){var i=r.length,o=i,a=!n;if(null==t)return!o;for(t=Object(t);i--;){var s=r[i];if(a&&s[2]?s[1]!==t[s[0]]:!(s[0]in t))return!1}for(;++i<o;){s=r[i];var u=s[0],c=t[u],l=s[1];if(a&&s[2]){if(void 0===c&&!(u in t))return!1}else{var f=new B;if(n)var h=n(c,l,u,t,e,f);if(!(void 0===h?H(l,c,n,Ut|Ft,f):h))return!1}}return!0}function Y(t){return!(!Tt(t)||pt(t))&&(At(t)||u(t)?Be:he).test(bt(t))}function J(t){return Ot(t)&&Et(t.length)&&!!de[Ce.call(t)]}function Q(t){return"function"==typeof t?t:null==t?Pt:"object"==typeof t?rr(t)?K(t[0],t[1]):Z(t):qt(t)}function X(t){if(!dt(t))return Me(t);var e=[];for(var r in Object(t))Le.call(t,r)&&"constructor"!=r&&e.push(r);return e}function Z(t){var e=st(t);return 1==e.length&&e[0][2]?vt(e[0][0],e[0][1]):function(r){return r===t||G(r,t,e)}}function K(t,e){return ft(t)&&gt(e)?vt(yt(t),e):function(r){var n=Bt(r,t);return void 0===n&&n===e?Dt(r,t):H(e,n,void 0,Ut|Ft)}}function tt(t){return function(e){return V(e,t)}}function et(t){if("string"==typeof t)return t;if(Lt(t))return Xe?Xe.call(t):"";var e=t+"";return"0"==e&&1/t==-Vt?"-0":e}function rt(t){return rr(t)?t:er(t)}function nt(t,e,r,n,o,a){var s=o&Ft,u=t.length,c=e.length;if(u!=c&&!(s&&c>u))return!1;var l=a.get(t);if(l&&a.get(e))return l==e;var f=-1,h=!0,p=o&Ut?new O:void 0;for(a.set(t,e),a.set(e,t);++f<u;){var d=t[f],g=e[f];if(n)var v=s?n(g,d,f,e,t,a):n(d,g,f,t,e,a);if(void 0!==v){if(v)continue;h=!1;break}if(p){if(!i(e,function(t,e){if(!p.has(e)&&(d===t||r(d,t,n,o,a)))return p.add(e)})){h=!1;break}}else if(d!==g&&!r(d,g,n,o,a)){h=!1;break}}return a.delete(t),a.delete(e),h}function it(t,e,r,n,i,o,a){switch(r){case oe:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return!1;t=t.buffer,e=e.buffer;case ie:return!(t.byteLength!=e.byteLength||!n(new Re(t),new Re(e)));case Wt:case Gt:case Zt:return xt(+t,+e);case Yt:return t.name==e.name&&t.message==e.message;case te:case re:return t==e+"";case Xt:var s=c;case ee:var u=o&Ft;if(s||(s=l),t.size!=e.size&&!u)return!1;var f=a.get(t);if(f)return f==e;o|=Ut,a.set(t,e);var h=nt(s(t),s(e),n,i,o,a);return a.delete(t),h;case ne:if(Qe)return Qe.call(t)==Qe.call(e)}return!1}function ot(t,e,r,n,i,o){var a=i&Ft,s=Rt(t),u=s.length;if(u!=Rt(e).length&&!a)return!1;for(var c=u;c--;){var l=s[c];if(!(a?l in e:Le.call(e,l)))return!1}var f=o.get(t);if(f&&o.get(e))return f==e;var h=!0;o.set(t,e),o.set(e,t);for(var p=a;++c<u;){l=s[c];var d=t[l],g=e[l];if(n)var v=a?n(g,d,l,e,t,o):n(d,g,l,t,e,o);if(!(void 0===v?d===g||r(d,g,n,i,o):v)){h=!1;break}p||(p="constructor"==l)}if(h&&!p){var y=t.constructor,b=e.constructor;y!=b&&"constructor"in t&&"constructor"in e&&!("function"==typeof y&&y instanceof y&&"function"==typeof b&&b instanceof b)&&(h=!1)}return o.delete(t),o.delete(e),h}function at(t,e){var r=t.__data__;return ht(e)?r["string"==typeof e?"string":"hash"]:r.map}function st(t){for(var e=Rt(t),r=e.length;r--;){var n=e[r],i=t[n];e[r]=[n,i,gt(i)]}return e}function ut(t,e){var r=s(t,e);return Y(r)?r:void 0}function ct(t,e,r){e=ft(e,t)?[e]:rt(e);for(var n,i=-1,o=e.length;++i<o;){var a=yt(e[i]);if(!(n=null!=t&&r(t,a)))break;t=t[a]}if(n)return n;var o=t?t.length:0;return!!o&&Et(o)&&lt(a,o)&&(rr(t)||St(t))}function lt(t,e){return!!(e=null==e?$t:e)&&("number"==typeof t||pe.test(t))&&t>-1&&t%1==0&&t<e}function ft(t,e){if(rr(t))return!1;var r=typeof t;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=t&&!Lt(t))||(se.test(t)||!ae.test(t)||null!=e&&t in Object(e))}function ht(t){var e=typeof t;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t}function pt(t){return!!Te&&Te in t}function dt(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||Ae)}function gt(t){return t===t&&!Tt(t)}function vt(t,e){return function(r){return null!=r&&(r[t]===e&&(void 0!==e||t in Object(r)))}}function yt(t){if("string"==typeof t||Lt(t))return t;var e=t+"";return"0"==e&&1/t==-Vt?"-0":e}function bt(t){if(null!=t){try{return Oe.call(t)}catch(t){}try{return t+""}catch(t){}}return""}function mt(t,e){return(rr(t)?n:U)(t,wt(Q(e,3)))}function _t(t,e){if("function"!=typeof t||e&&"function"!=typeof e)throw new TypeError(It);var r=function(){var n=arguments,i=e?e.apply(this,n):n[0],o=r.cache;if(o.has(i))return o.get(i);var a=t.apply(this,n);return r.cache=o.set(i,a),a};return r.cache=new(_t.Cache||S),r}function wt(t){if("function"!=typeof t)throw new TypeError(It);return function(){var e=arguments;switch(e.length){case 0:return!t.call(this);case 1:return!t.call(this,e[0]);case 2:return!t.call(this,e[0],e[1]);case 3:return!t.call(this,e[0],e[1],e[2])}return!t.apply(this,e)}}function xt(t,e){return t===e||t!==t&&e!==e}function St(t){return kt(t)&&Le.call(t,"callee")&&(!Pe.call(t,"callee")||Ce.call(t)==zt)}function jt(t){return null!=t&&Et(t.length)&&!At(t)}function kt(t){return Ot(t)&&jt(t)}function At(t){var e=Tt(t)?Ce.call(t):"";return e==Jt||e==Qt}function Et(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=$t}function Tt(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function Ot(t){return!!t&&"object"==typeof t}function Lt(t){return"symbol"==typeof t||Ot(t)&&Ce.call(t)==ne}function Ct(t){return null==t?"":et(t)}function Bt(t,e,r){var n=null==t?void 0:V(t,e);return void 0===n?r:n}function Dt(t,e){return null!=t&&ct(t,e,z)}function Rt(t){return jt(t)?I(t):X(t)}function Pt(t){return t}function qt(t){return ft(t)?o(yt(t)):tt(t)}var Mt=200,It="Expected a function",Nt="__lodash_hash_undefined__",Ut=1,Ft=2,Vt=1/0,$t=9007199254740991,zt="[object Arguments]",Ht="[object Array]",Wt="[object Boolean]",Gt="[object Date]",Yt="[object Error]",Jt="[object Function]",Qt="[object GeneratorFunction]",Xt="[object Map]",Zt="[object Number]",Kt="[object Object]",te="[object RegExp]",ee="[object Set]",re="[object String]",ne="[object Symbol]",ie="[object ArrayBuffer]",oe="[object DataView]",ae=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,se=/^\w*$/,ue=/^\./,ce=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,le=/[\\^$.*+?()[\]{}|]/g,fe=/\\(\\)?/g,he=/^\[object .+?Constructor\]$/,pe=/^(?:0|[1-9]\d*)$/,de={};de["[object Float32Array]"]=de["[object Float64Array]"]=de["[object Int8Array]"]=de["[object Int16Array]"]=de["[object Int32Array]"]=de["[object Uint8Array]"]=de["[object Uint8ClampedArray]"]=de["[object Uint16Array]"]=de["[object Uint32Array]"]=!0,de[zt]=de[Ht]=de[ie]=de[Wt]=de[oe]=de[Gt]=de[Yt]=de[Jt]=de[Xt]=de[Zt]=de[Kt]=de[te]=de[ee]=de[re]=de["[object WeakMap]"]=!1;var ge="object"==typeof t&&t&&t.Object===Object&&t,ve="object"==typeof self&&self&&self.Object===Object&&self,ye=ge||ve||Function("return this")(),be="object"==typeof e&&e&&!e.nodeType&&e,me=be&&"object"==typeof r&&r&&!r.nodeType&&r,_e=me&&me.exports===be,we=_e&&ge.process,xe=function(){try{return we&&we.binding("util")}catch(t){}}(),Se=xe&&xe.isTypedArray,je=Array.prototype,ke=Function.prototype,Ae=Object.prototype,Ee=ye["__core-js_shared__"],Te=function(){var t=/[^.]+$/.exec(Ee&&Ee.keys&&Ee.keys.IE_PROTO||"");return t?"Symbol(src)_1."+t:""}(),Oe=ke.toString,Le=Ae.hasOwnProperty,Ce=Ae.toString,Be=RegExp("^"+Oe.call(Le).replace(le,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),De=ye.Symbol,Re=ye.Uint8Array,Pe=Ae.propertyIsEnumerable,qe=je.splice,Me=function(t,e){return function(r){return t(e(r))}}(Object.keys,Object),Ie=ut(ye,"DataView"),Ne=ut(ye,"Map"),Ue=ut(ye,"Promise"),Fe=ut(ye,"Set"),Ve=ut(ye,"WeakMap"),$e=ut(Object,"create"),ze=bt(Ie),He=bt(Ne),We=bt(Ue),Ge=bt(Fe),Ye=bt(Ve),Je=De?De.prototype:void 0,Qe=Je?Je.valueOf:void 0,Xe=Je?Je.toString:void 0;f.prototype.clear=h,f.prototype.delete=p,f.prototype.get=d,f.prototype.has=g,f.prototype.set=v,y.prototype.clear=b,y.prototype.delete=m,y.prototype.get=_,y.prototype.has=w,y.prototype.set=x,S.prototype.clear=j,S.prototype.delete=k,S.prototype.get=A,S.prototype.has=E,S.prototype.set=T,O.prototype.add=O.prototype.push=L,O.prototype.has=C,B.prototype.clear=D,B.prototype.delete=R,B.prototype.get=P,B.prototype.has=q,B.prototype.set=M;var Ze=function(t,e){return function(r,n){if(null==r)return r;if(!jt(r))return t(r,n);for(var i=r.length,o=e?i:-1,a=Object(r);(e?o--:++o<i)&&!1!==n(a[o],o,a););return r}}(F),Ke=function(t){return function(e,r,n){for(var i=-1,o=Object(e),a=n(e),s=a.length;s--;){var u=a[t?s:++i];if(!1===r(o[u],u,o))break}return e}}(),tr=$;(Ie&&tr(new Ie(new ArrayBuffer(1)))!=oe||Ne&&tr(new Ne)!=Xt||Ue&&"[object Promise]"!=tr(Ue.resolve())||Fe&&tr(new Fe)!=ee||Ve&&"[object WeakMap]"!=tr(new Ve))&&(tr=function(t){var e=Ce.call(t),r=e==Kt?t.constructor:void 0,n=r?bt(r):void 0;if(n)switch(n){case ze:return oe;case He:return Xt;case We:return"[object Promise]";case Ge:return ee;case Ye:return"[object WeakMap]"}return e});var er=_t(function(t){t=Ct(t);var e=[];return ue.test(t)&&e.push(""),t.replace(ce,function(t,r,n,i){e.push(n?i.replace(fe,"$1"):r||t)}),e});_t.Cache=S;var rr=Array.isArray,nr=Se?function(t){return function(e){return t(e)}}(Se):J;r.exports=mt}).call(e,r(0),r(5)(t))},function(t,e,r){(function(t,r){function n(t,e){for(var r=-1,n=t?t.length:0,i=0,o=[];++r<n;){var a=t[r];e(a,r,t)&&(o[i++]=a)}return o}function i(t,e){for(var r=-1,n=t?t.length:0;++r<n;)if(e(t[r],r,t))return!0;return!1}function o(t){return function(e){return null==e?void 0:e[t]}}function a(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}function s(t,e){return null==t?void 0:t[e]}function u(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"")}catch(t){}return e}function c(t){var e=-1,r=Array(t.size);return t.forEach(function(t,n){r[++e]=[n,t]}),r}function l(t){var e=-1,r=Array(t.size);return t.forEach(function(t){r[++e]=t}),r}function f(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function h(){this.__data__=Ve?Ve(null):{}}function p(t){return this.has(t)&&delete this.__data__[t]}function d(t){var e=this.__data__;if(Ve){var r=e[t];return r===It?void 0:r}return Oe.call(e,t)?e[t]:void 0}function g(t){var e=this.__data__;return Ve?void 0!==e[t]:Oe.call(e,t)}function v(t,e){return this.__data__[t]=Ve&&void 0===e?It:e,this}function y(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function b(){this.__data__=[]}function m(t){var e=this.__data__,r=N(e,t);return!(r<0)&&(r==e.length-1?e.pop():Pe.call(e,r,1),!0)}function _(t){var e=this.__data__,r=N(e,t);return r<0?void 0:e[r][1]}function w(t){return N(this.__data__,t)>-1}function x(t,e){var r=this.__data__,n=N(r,t);return n<0?r.push([t,e]):r[n][1]=e,this}function S(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function j(){this.__data__={hash:new f,map:new(Ie||y),string:new f}}function k(t){return at(this,t).delete(t)}function A(t){return at(this,t).get(t)}function E(t){return at(this,t).has(t)}function T(t,e){return at(this,t).set(t,e),this}function O(t){var e=-1,r=t?t.length:0;for(this.__data__=new S;++e<r;)this.add(t[e])}function L(t){return this.__data__.set(t,It),this}function C(t){return this.__data__.has(t)}function B(t){this.__data__=new y(t)}function D(){this.__data__=new y}function R(t){return this.__data__.delete(t)}function P(t){return this.__data__.get(t)}function q(t){return this.__data__.has(t)}function M(t,e){var r=this.__data__;if(r instanceof y){var n=r.__data__;if(!Ie||n.length<qt-1)return n.push([t,e]),this;r=this.__data__=new S(n)}return r.set(t,e),this}function I(t,e){var r=er(t)||xt(t)?a(t.length,String):[],n=r.length,i=!!n;for(var o in t)!e&&!Oe.call(t,o)||i&&("length"==o||lt(o,n))||r.push(o);return r}function N(t,e){for(var r=t.length;r--;)if(wt(t[r][0],e))return r;return-1}function U(t,e){var r=[];return Xe(t,function(t,n,i){e(t,n,i)&&r.push(t)}),r}function F(t,e){return t&&Ze(t,e,Dt)}function V(t,e){e=ft(e,t)?[e]:rt(e);for(var r=0,n=e.length;null!=t&&r<n;)t=t[yt(e[r++])];return r&&r==n?t:void 0}function $(t){return Le.call(t)}function z(t,e){return null!=t&&e in Object(t)}function H(t,e,r,n,i){return t===e||(null==t||null==e||!Et(t)&&!Tt(e)?t!==t&&e!==e:W(t,e,H,r,n,i))}function W(t,e,r,n,i,o){var a=er(t),s=er(e),c=zt,l=zt;a||(c=Ke(t),c=c==$t?Zt:c),s||(l=Ke(e),l=l==$t?Zt:l);var f=c==Zt&&!u(t),h=l==Zt&&!u(e),p=c==l;if(p&&!f)return o||(o=new B),a||rr(t)?nt(t,e,r,n,i,o):it(t,e,c,r,n,i,o);if(!(i&Ut)){var d=f&&Oe.call(t,"__wrapped__"),g=h&&Oe.call(e,"__wrapped__");if(d||g){var v=d?t.value():t,y=g?e.value():e;return o||(o=new B),r(v,y,n,i,o)}}return!!p&&(o||(o=new B),ot(t,e,r,n,i,o))}function G(t,e,r,n){var i=r.length,o=i,a=!n;if(null==t)return!o;for(t=Object(t);i--;){var s=r[i];if(a&&s[2]?s[1]!==t[s[0]]:!(s[0]in t))return!1}for(;++i<o;){s=r[i];var u=s[0],c=t[u],l=s[1];if(a&&s[2]){if(void 0===c&&!(u in t))return!1}else{var f=new B;if(n)var h=n(c,l,u,t,e,f);if(!(void 0===h?H(l,c,n,Nt|Ut,f):h))return!1}}return!0}function Y(t){return!(!Et(t)||pt(t))&&(kt(t)||u(t)?Ce:fe).test(bt(t))}function J(t){return Tt(t)&&At(t.length)&&!!pe[Le.call(t)]}function Q(t){return"function"==typeof t?t:null==t?Rt:"object"==typeof t?er(t)?K(t[0],t[1]):Z(t):Pt(t)}function X(t){if(!dt(t))return qe(t);var e=[];for(var r in Object(t))Oe.call(t,r)&&"constructor"!=r&&e.push(r);return e}function Z(t){var e=st(t);return 1==e.length&&e[0][2]?vt(e[0][0],e[0][1]):function(r){return r===t||G(r,t,e)}}function K(t,e){return ft(t)&&gt(e)?vt(yt(t),e):function(r){var n=Ct(r,t);return void 0===n&&n===e?Bt(r,t):H(e,n,void 0,Nt|Ut)}}function tt(t){return function(e){return V(e,t)}}function et(t){if("string"==typeof t)return t;if(Ot(t))return Qe?Qe.call(t):"";var e=t+"";return"0"==e&&1/t==-Ft?"-0":e}function rt(t){return er(t)?t:tr(t)}function nt(t,e,r,n,o,a){var s=o&Ut,u=t.length,c=e.length;if(u!=c&&!(s&&c>u))return!1;var l=a.get(t);if(l&&a.get(e))return l==e;var f=-1,h=!0,p=o&Nt?new O:void 0;for(a.set(t,e),a.set(e,t);++f<u;){var d=t[f],g=e[f];if(n)var v=s?n(g,d,f,e,t,a):n(d,g,f,t,e,a);if(void 0!==v){if(v)continue;h=!1;break}if(p){if(!i(e,function(t,e){if(!p.has(e)&&(d===t||r(d,t,n,o,a)))return p.add(e)})){h=!1;break}}else if(d!==g&&!r(d,g,n,o,a)){h=!1;break}}return a.delete(t),a.delete(e),h}function it(t,e,r,n,i,o,a){switch(r){case ie:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return!1;t=t.buffer,e=e.buffer;case ne:return!(t.byteLength!=e.byteLength||!n(new De(t),new De(e)));case Ht:case Wt:case Xt:return wt(+t,+e);case Gt:return t.name==e.name&&t.message==e.message;case Kt:case ee:return t==e+"";case Qt:var s=c;case te:var u=o&Ut;if(s||(s=l),t.size!=e.size&&!u)return!1;var f=a.get(t);if(f)return f==e;o|=Nt,a.set(t,e);var h=nt(s(t),s(e),n,i,o,a);return a.delete(t),h;case re:if(Je)return Je.call(t)==Je.call(e)}return!1}function ot(t,e,r,n,i,o){var a=i&Ut,s=Dt(t),u=s.length;if(u!=Dt(e).length&&!a)return!1;for(var c=u;c--;){var l=s[c];if(!(a?l in e:Oe.call(e,l)))return!1}var f=o.get(t);if(f&&o.get(e))return f==e;var h=!0;o.set(t,e),o.set(e,t);for(var p=a;++c<u;){l=s[c];var d=t[l],g=e[l];if(n)var v=a?n(g,d,l,e,t,o):n(d,g,l,t,e,o);if(!(void 0===v?d===g||r(d,g,n,i,o):v)){h=!1;break}p||(p="constructor"==l)}if(h&&!p){var y=t.constructor,b=e.constructor;y!=b&&"constructor"in t&&"constructor"in e&&!("function"==typeof y&&y instanceof y&&"function"==typeof b&&b instanceof b)&&(h=!1)}return o.delete(t),o.delete(e),h}function at(t,e){var r=t.__data__;return ht(e)?r["string"==typeof e?"string":"hash"]:r.map}function st(t){for(var e=Dt(t),r=e.length;r--;){var n=e[r],i=t[n];e[r]=[n,i,gt(i)]}return e}function ut(t,e){var r=s(t,e);return Y(r)?r:void 0}function ct(t,e,r){e=ft(e,t)?[e]:rt(e);for(var n,i=-1,o=e.length;++i<o;){var a=yt(e[i]);if(!(n=null!=t&&r(t,a)))break;t=t[a]}if(n)return n;var o=t?t.length:0;return!!o&&At(o)&&lt(a,o)&&(er(t)||xt(t))}function lt(t,e){return!!(e=null==e?Vt:e)&&("number"==typeof t||he.test(t))&&t>-1&&t%1==0&&t<e}function ft(t,e){if(er(t))return!1;var r=typeof t;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=t&&!Ot(t))||(ae.test(t)||!oe.test(t)||null!=e&&t in Object(e))}function ht(t){var e=typeof t;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t}function pt(t){return!!Ee&&Ee in t}function dt(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||ke)}function gt(t){return t===t&&!Et(t)}function vt(t,e){return function(r){return null!=r&&(r[t]===e&&(void 0!==e||t in Object(r)))}}function yt(t){if("string"==typeof t||Ot(t))return t;var e=t+"";return"0"==e&&1/t==-Ft?"-0":e}function bt(t){if(null!=t){try{return Te.call(t)}catch(t){}try{return t+""}catch(t){}}return""}function mt(t,e){return(er(t)?n:U)(t,Q(e,3))}function _t(t,e){if("function"!=typeof t||e&&"function"!=typeof e)throw new TypeError(Mt);var r=function(){var n=arguments,i=e?e.apply(this,n):n[0],o=r.cache;if(o.has(i))return o.get(i);var a=t.apply(this,n);return r.cache=o.set(i,a),a};return r.cache=new(_t.Cache||S),r}function wt(t,e){return t===e||t!==t&&e!==e}function xt(t){return jt(t)&&Oe.call(t,"callee")&&(!Re.call(t,"callee")||Le.call(t)==$t)}function St(t){return null!=t&&At(t.length)&&!kt(t)}function jt(t){return Tt(t)&&St(t)}function kt(t){var e=Et(t)?Le.call(t):"";return e==Yt||e==Jt}function At(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=Vt}function Et(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function Tt(t){return!!t&&"object"==typeof t}function Ot(t){return"symbol"==typeof t||Tt(t)&&Le.call(t)==re}function Lt(t){return null==t?"":et(t)}function Ct(t,e,r){var n=null==t?void 0:V(t,e);return void 0===n?r:n}function Bt(t,e){return null!=t&&ct(t,e,z)}function Dt(t){return St(t)?I(t):X(t)}function Rt(t){return t}function Pt(t){return ft(t)?o(yt(t)):tt(t)}var qt=200,Mt="Expected a function",It="__lodash_hash_undefined__",Nt=1,Ut=2,Ft=1/0,Vt=9007199254740991,$t="[object Arguments]",zt="[object Array]",Ht="[object Boolean]",Wt="[object Date]",Gt="[object Error]",Yt="[object Function]",Jt="[object GeneratorFunction]",Qt="[object Map]",Xt="[object Number]",Zt="[object Object]",Kt="[object RegExp]",te="[object Set]",ee="[object String]",re="[object Symbol]",ne="[object ArrayBuffer]",ie="[object DataView]",oe=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,ae=/^\w*$/,se=/^\./,ue=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,ce=/[\\^$.*+?()[\]{}|]/g,le=/\\(\\)?/g,fe=/^\[object .+?Constructor\]$/,he=/^(?:0|[1-9]\d*)$/,pe={};pe["[object Float32Array]"]=pe["[object Float64Array]"]=pe["[object Int8Array]"]=pe["[object Int16Array]"]=pe["[object Int32Array]"]=pe["[object Uint8Array]"]=pe["[object Uint8ClampedArray]"]=pe["[object Uint16Array]"]=pe["[object Uint32Array]"]=!0,pe[$t]=pe[zt]=pe[ne]=pe[Ht]=pe[ie]=pe[Wt]=pe[Gt]=pe[Yt]=pe[Qt]=pe[Xt]=pe[Zt]=pe[Kt]=pe[te]=pe[ee]=pe["[object WeakMap]"]=!1;var de="object"==typeof t&&t&&t.Object===Object&&t,ge="object"==typeof self&&self&&self.Object===Object&&self,ve=de||ge||Function("return this")(),ye="object"==typeof e&&e&&!e.nodeType&&e,be=ye&&"object"==typeof r&&r&&!r.nodeType&&r,me=be&&be.exports===ye,_e=me&&de.process,we=function(){try{return _e&&_e.binding("util")}catch(t){}}(),xe=we&&we.isTypedArray,Se=Array.prototype,je=Function.prototype,ke=Object.prototype,Ae=ve["__core-js_shared__"],Ee=function(){var t=/[^.]+$/.exec(Ae&&Ae.keys&&Ae.keys.IE_PROTO||"");return t?"Symbol(src)_1."+t:""}(),Te=je.toString,Oe=ke.hasOwnProperty,Le=ke.toString,Ce=RegExp("^"+Te.call(Oe).replace(ce,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Be=ve.Symbol,De=ve.Uint8Array,Re=ke.propertyIsEnumerable,Pe=Se.splice,qe=function(t,e){return function(r){return t(e(r))}}(Object.keys,Object),Me=ut(ve,"DataView"),Ie=ut(ve,"Map"),Ne=ut(ve,"Promise"),Ue=ut(ve,"Set"),Fe=ut(ve,"WeakMap"),Ve=ut(Object,"create"),$e=bt(Me),ze=bt(Ie),He=bt(Ne),We=bt(Ue),Ge=bt(Fe),Ye=Be?Be.prototype:void 0,Je=Ye?Ye.valueOf:void 0,Qe=Ye?Ye.toString:void 0;f.prototype.clear=h,f.prototype.delete=p,f.prototype.get=d,f.prototype.has=g,f.prototype.set=v,y.prototype.clear=b,y.prototype.delete=m,y.prototype.get=_,y.prototype.has=w,y.prototype.set=x,S.prototype.clear=j,S.prototype.delete=k,S.prototype.get=A,S.prototype.has=E,S.prototype.set=T,O.prototype.add=O.prototype.push=L,O.prototype.has=C,B.prototype.clear=D,B.prototype.delete=R,B.prototype.get=P,B.prototype.has=q,B.prototype.set=M;var Xe=function(t,e){return function(r,n){if(null==r)return r;if(!St(r))return t(r,n);for(var i=r.length,o=e?i:-1,a=Object(r);(e?o--:++o<i)&&!1!==n(a[o],o,a););return r}}(F),Ze=function(t){return function(e,r,n){for(var i=-1,o=Object(e),a=n(e),s=a.length;s--;){var u=a[t?s:++i];if(!1===r(o[u],u,o))break}return e}}(),Ke=$;(Me&&Ke(new Me(new ArrayBuffer(1)))!=ie||Ie&&Ke(new Ie)!=Qt||Ne&&"[object Promise]"!=Ke(Ne.resolve())||Ue&&Ke(new Ue)!=te||Fe&&"[object WeakMap]"!=Ke(new Fe))&&(Ke=function(t){var e=Le.call(t),r=e==Zt?t.constructor:void 0,n=r?bt(r):void 0;if(n)switch(n){case $e:return ie;case ze:return Qt;case He:return"[object Promise]";case We:return te;case Ge:return"[object WeakMap]"}return e});var tr=_t(function(t){t=Lt(t);var e=[];return se.test(t)&&e.push(""),t.replace(ue,function(t,r,n,i){e.push(n?i.replace(le,"$1"):r||t)}),e});_t.Cache=S;var er=Array.isArray,rr=xe?function(t){return function(e){return t(e)}}(xe):J;r.exports=mt}).call(e,r(0),r(5)(t))},function(t,e,r){(function(t,r){function n(t,e,r,n){var i=-1,o=t?t.length:0;for(n&&o&&(r=t[++i]);++i<o;)r=e(r,t[i],i,t);return r}function i(t,e){for(var r=-1,n=t?t.length:0;++r<n;)if(e(t[r],r,t))return!0;return!1}function o(t){return function(e){return null==e?void 0:e[t]}}function a(t,e,r,n,i){return i(t,function(t,i,o){r=n?(n=!1,t):e(r,t,i,o)}),r}function s(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}function u(t,e){return null==t?void 0:t[e]}function c(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"")}catch(t){}return e}function l(t){var e=-1,r=Array(t.size);return t.forEach(function(t,n){r[++e]=[n,t]}),r}function f(t){var e=-1,r=Array(t.size);return t.forEach(function(t){r[++e]=t}),r}function h(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function p(){this.__data__=Ve?Ve(null):{}}function d(t){return this.has(t)&&delete this.__data__[t]}function g(t){var e=this.__data__;if(Ve){var r=e[t];return r===It?void 0:r}return Oe.call(e,t)?e[t]:void 0}function v(t){var e=this.__data__;return Ve?void 0!==e[t]:Oe.call(e,t)}function y(t,e){return this.__data__[t]=Ve&&void 0===e?It:e,this}function b(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function m(){this.__data__=[]}function _(t){var e=this.__data__,r=U(e,t);return!(r<0)&&(r==e.length-1?e.pop():Pe.call(e,r,1),!0)}function w(t){var e=this.__data__,r=U(e,t);return r<0?void 0:e[r][1]}function x(t){return U(this.__data__,t)>-1}function S(t,e){var r=this.__data__,n=U(r,t);return n<0?r.push([t,e]):r[n][1]=e,this}function j(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function k(){this.__data__={hash:new h,map:new(Ie||b),string:new h}}function A(t){return at(this,t).delete(t)}function E(t){return at(this,t).get(t)}function T(t){return at(this,t).has(t)}function O(t,e){return at(this,t).set(t,e),this}function L(t){var e=-1,r=t?t.length:0;for(this.__data__=new j;++e<r;)this.add(t[e])}function C(t){return this.__data__.set(t,It),this}function B(t){return this.__data__.has(t)}function D(t){this.__data__=new b(t)}function R(){this.__data__=new b}function P(t){return this.__data__.delete(t)}function q(t){return this.__data__.get(t)}function M(t){return this.__data__.has(t)}function I(t,e){var r=this.__data__;if(r instanceof b){var n=r.__data__;if(!Ie||n.length<qt-1)return n.push([t,e]),this;r=this.__data__=new j(n)}return r.set(t,e),this}function N(t,e){var r=er(t)||xt(t)?s(t.length,String):[],n=r.length,i=!!n;for(var o in t)!e&&!Oe.call(t,o)||i&&("length"==o||lt(o,n))||r.push(o);return r}function U(t,e){for(var r=t.length;r--;)if(wt(t[r][0],e))return r;return-1}function F(t,e){return t&&Ze(t,e,Dt)}function V(t,e){e=ft(e,t)?[e]:rt(e);for(var r=0,n=e.length;null!=t&&r<n;)t=t[yt(e[r++])];return r&&r==n?t:void 0}function $(t){return Le.call(t)}function z(t,e){return null!=t&&e in Object(t)}function H(t,e,r,n,i){return t===e||(null==t||null==e||!Et(t)&&!Tt(e)?t!==t&&e!==e:W(t,e,H,r,n,i))}function W(t,e,r,n,i,o){var a=er(t),s=er(e),u=zt,l=zt;a||(u=Ke(t),u=u==$t?Zt:u),s||(l=Ke(e),l=l==$t?Zt:l);var f=u==Zt&&!c(t),h=l==Zt&&!c(e),p=u==l;if(p&&!f)return o||(o=new D),a||rr(t)?nt(t,e,r,n,i,o):it(t,e,u,r,n,i,o);if(!(i&Ut)){var d=f&&Oe.call(t,"__wrapped__"),g=h&&Oe.call(e,"__wrapped__");if(d||g){var v=d?t.value():t,y=g?e.value():e;return o||(o=new D),r(v,y,n,i,o)}}return!!p&&(o||(o=new D),ot(t,e,r,n,i,o))}function G(t,e,r,n){var i=r.length,o=i,a=!n;if(null==t)return!o;for(t=Object(t);i--;){var s=r[i];if(a&&s[2]?s[1]!==t[s[0]]:!(s[0]in t))return!1}for(;++i<o;){s=r[i];var u=s[0],c=t[u],l=s[1];if(a&&s[2]){if(void 0===c&&!(u in t))return!1}else{var f=new D;if(n)var h=n(c,l,u,t,e,f);if(!(void 0===h?H(l,c,n,Nt|Ut,f):h))return!1}}return!0}function Y(t){return!(!Et(t)||pt(t))&&(kt(t)||c(t)?Ce:fe).test(bt(t))}function J(t){return Tt(t)&&At(t.length)&&!!pe[Le.call(t)]}function Q(t){return"function"==typeof t?t:null==t?Rt:"object"==typeof t?er(t)?K(t[0],t[1]):Z(t):Pt(t)}function X(t){if(!dt(t))return qe(t);var e=[];for(var r in Object(t))Oe.call(t,r)&&"constructor"!=r&&e.push(r);return e}function Z(t){var e=st(t);return 1==e.length&&e[0][2]?vt(e[0][0],e[0][1]):function(r){return r===t||G(r,t,e)}}function K(t,e){return ft(t)&&gt(e)?vt(yt(t),e):function(r){var n=Ct(r,t);return void 0===n&&n===e?Bt(r,t):H(e,n,void 0,Nt|Ut)}}function tt(t){return function(e){return V(e,t)}}function et(t){if("string"==typeof t)return t;if(Ot(t))return Qe?Qe.call(t):"";var e=t+"";return"0"==e&&1/t==-Ft?"-0":e}function rt(t){return er(t)?t:tr(t)}function nt(t,e,r,n,o,a){var s=o&Ut,u=t.length,c=e.length;if(u!=c&&!(s&&c>u))return!1;var l=a.get(t);if(l&&a.get(e))return l==e;var f=-1,h=!0,p=o&Nt?new L:void 0;for(a.set(t,e),a.set(e,t);++f<u;){var d=t[f],g=e[f];if(n)var v=s?n(g,d,f,e,t,a):n(d,g,f,t,e,a);if(void 0!==v){if(v)continue;h=!1;break}if(p){if(!i(e,function(t,e){if(!p.has(e)&&(d===t||r(d,t,n,o,a)))return p.add(e)})){h=!1;break}}else if(d!==g&&!r(d,g,n,o,a)){h=!1;break}}return a.delete(t),a.delete(e),h}function it(t,e,r,n,i,o,a){switch(r){case ie:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return!1;t=t.buffer,e=e.buffer;case ne:return!(t.byteLength!=e.byteLength||!n(new De(t),new De(e)));case Ht:case Wt:case Xt:return wt(+t,+e);case Gt:return t.name==e.name&&t.message==e.message;case Kt:case ee:return t==e+"";case Qt:var s=l;case te:var u=o&Ut;if(s||(s=f),t.size!=e.size&&!u)return!1;var c=a.get(t);if(c)return c==e;o|=Nt,a.set(t,e);var h=nt(s(t),s(e),n,i,o,a);return a.delete(t),h;case re:if(Je)return Je.call(t)==Je.call(e)}return!1}function ot(t,e,r,n,i,o){var a=i&Ut,s=Dt(t),u=s.length;if(u!=Dt(e).length&&!a)return!1;for(var c=u;c--;){var l=s[c];if(!(a?l in e:Oe.call(e,l)))return!1}var f=o.get(t);if(f&&o.get(e))return f==e;var h=!0;o.set(t,e),o.set(e,t);for(var p=a;++c<u;){l=s[c];var d=t[l],g=e[l];if(n)var v=a?n(g,d,l,e,t,o):n(d,g,l,t,e,o);if(!(void 0===v?d===g||r(d,g,n,i,o):v)){h=!1;break}p||(p="constructor"==l)}if(h&&!p){var y=t.constructor,b=e.constructor;y!=b&&"constructor"in t&&"constructor"in e&&!("function"==typeof y&&y instanceof y&&"function"==typeof b&&b instanceof b)&&(h=!1)}return o.delete(t),o.delete(e),h}function at(t,e){var r=t.__data__;return ht(e)?r["string"==typeof e?"string":"hash"]:r.map}function st(t){for(var e=Dt(t),r=e.length;r--;){var n=e[r],i=t[n];e[r]=[n,i,gt(i)]}return e}function ut(t,e){var r=u(t,e);return Y(r)?r:void 0}function ct(t,e,r){e=ft(e,t)?[e]:rt(e);for(var n,i=-1,o=e.length;++i<o;){var a=yt(e[i]);if(!(n=null!=t&&r(t,a)))break;t=t[a]}if(n)return n;var o=t?t.length:0;return!!o&&At(o)&&lt(a,o)&&(er(t)||xt(t))}function lt(t,e){return!!(e=null==e?Vt:e)&&("number"==typeof t||he.test(t))&&t>-1&&t%1==0&&t<e}function ft(t,e){if(er(t))return!1;var r=typeof t;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=t&&!Ot(t))||(ae.test(t)||!oe.test(t)||null!=e&&t in Object(e))}function ht(t){var e=typeof t;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t}function pt(t){return!!Ee&&Ee in t}function dt(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||ke)}function gt(t){return t===t&&!Et(t)}function vt(t,e){return function(r){return null!=r&&(r[t]===e&&(void 0!==e||t in Object(r)))}}function yt(t){if("string"==typeof t||Ot(t))return t;var e=t+"";return"0"==e&&1/t==-Ft?"-0":e}function bt(t){if(null!=t){try{return Te.call(t)}catch(t){}try{return t+""}catch(t){}}return""}function mt(t,e,r){var i=er(t)?n:a,o=arguments.length<3;return i(t,Q(e,4),r,o,Xe)}function _t(t,e){if("function"!=typeof t||e&&"function"!=typeof e)throw new TypeError(Mt);var r=function(){var n=arguments,i=e?e.apply(this,n):n[0],o=r.cache;if(o.has(i))return o.get(i);var a=t.apply(this,n);return r.cache=o.set(i,a),a};return r.cache=new(_t.Cache||j),r}function wt(t,e){return t===e||t!==t&&e!==e}function xt(t){return jt(t)&&Oe.call(t,"callee")&&(!Re.call(t,"callee")||Le.call(t)==$t)}function St(t){return null!=t&&At(t.length)&&!kt(t)}function jt(t){return Tt(t)&&St(t)}function kt(t){var e=Et(t)?Le.call(t):"";return e==Yt||e==Jt}function At(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=Vt}function Et(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function Tt(t){return!!t&&"object"==typeof t}function Ot(t){return"symbol"==typeof t||Tt(t)&&Le.call(t)==re}function Lt(t){return null==t?"":et(t)}function Ct(t,e,r){var n=null==t?void 0:V(t,e);return void 0===n?r:n}function Bt(t,e){return null!=t&&ct(t,e,z)}function Dt(t){return St(t)?N(t):X(t)}function Rt(t){return t}function Pt(t){return ft(t)?o(yt(t)):tt(t)}var qt=200,Mt="Expected a function",It="__lodash_hash_undefined__",Nt=1,Ut=2,Ft=1/0,Vt=9007199254740991,$t="[object Arguments]",zt="[object Array]",Ht="[object Boolean]",Wt="[object Date]",Gt="[object Error]",Yt="[object Function]",Jt="[object GeneratorFunction]",Qt="[object Map]",Xt="[object Number]",Zt="[object Object]",Kt="[object RegExp]",te="[object Set]",ee="[object String]",re="[object Symbol]",ne="[object ArrayBuffer]",ie="[object DataView]",oe=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,ae=/^\w*$/,se=/^\./,ue=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,ce=/[\\^$.*+?()[\]{}|]/g,le=/\\(\\)?/g,fe=/^\[object .+?Constructor\]$/,he=/^(?:0|[1-9]\d*)$/,pe={};pe["[object Float32Array]"]=pe["[object Float64Array]"]=pe["[object Int8Array]"]=pe["[object Int16Array]"]=pe["[object Int32Array]"]=pe["[object Uint8Array]"]=pe["[object Uint8ClampedArray]"]=pe["[object Uint16Array]"]=pe["[object Uint32Array]"]=!0,pe[$t]=pe[zt]=pe[ne]=pe[Ht]=pe[ie]=pe[Wt]=pe[Gt]=pe[Yt]=pe[Qt]=pe[Xt]=pe[Zt]=pe[Kt]=pe[te]=pe[ee]=pe["[object WeakMap]"]=!1;var de="object"==typeof t&&t&&t.Object===Object&&t,ge="object"==typeof self&&self&&self.Object===Object&&self,ve=de||ge||Function("return this")(),ye="object"==typeof e&&e&&!e.nodeType&&e,be=ye&&"object"==typeof r&&r&&!r.nodeType&&r,me=be&&be.exports===ye,_e=me&&de.process,we=function(){try{return _e&&_e.binding("util")}catch(t){}}(),xe=we&&we.isTypedArray,Se=Array.prototype,je=Function.prototype,ke=Object.prototype,Ae=ve["__core-js_shared__"],Ee=function(){var t=/[^.]+$/.exec(Ae&&Ae.keys&&Ae.keys.IE_PROTO||"");return t?"Symbol(src)_1."+t:""}(),Te=je.toString,Oe=ke.hasOwnProperty,Le=ke.toString,Ce=RegExp("^"+Te.call(Oe).replace(ce,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Be=ve.Symbol,De=ve.Uint8Array,Re=ke.propertyIsEnumerable,Pe=Se.splice,qe=function(t,e){return function(r){return t(e(r))}}(Object.keys,Object),Me=ut(ve,"DataView"),Ie=ut(ve,"Map"),Ne=ut(ve,"Promise"),Ue=ut(ve,"Set"),Fe=ut(ve,"WeakMap"),Ve=ut(Object,"create"),$e=bt(Me),ze=bt(Ie),He=bt(Ne),We=bt(Ue),Ge=bt(Fe),Ye=Be?Be.prototype:void 0,Je=Ye?Ye.valueOf:void 0,Qe=Ye?Ye.toString:void 0;h.prototype.clear=p,h.prototype.delete=d,h.prototype.get=g,h.prototype.has=v,h.prototype.set=y,b.prototype.clear=m,b.prototype.delete=_,b.prototype.get=w,b.prototype.has=x,b.prototype.set=S,j.prototype.clear=k,j.prototype.delete=A,j.prototype.get=E,j.prototype.has=T,j.prototype.set=O,L.prototype.add=L.prototype.push=C,L.prototype.has=B,D.prototype.clear=R,D.prototype.delete=P,D.prototype.get=q,D.prototype.has=M,D.prototype.set=I;var Xe=function(t,e){return function(r,n){if(null==r)return r;if(!St(r))return t(r,n);for(var i=r.length,o=e?i:-1,a=Object(r);(e?o--:++o<i)&&!1!==n(a[o],o,a););return r}}(F),Ze=function(t){return function(e,r,n){for(var i=-1,o=Object(e),a=n(e),s=a.length;s--;){var u=a[t?s:++i];if(!1===r(o[u],u,o))break}return e}}(),Ke=$;(Me&&Ke(new Me(new ArrayBuffer(1)))!=ie||Ie&&Ke(new Ie)!=Qt||Ne&&"[object Promise]"!=Ke(Ne.resolve())||Ue&&Ke(new Ue)!=te||Fe&&"[object WeakMap]"!=Ke(new Fe))&&(Ke=function(t){var e=Le.call(t),r=e==Zt?t.constructor:void 0,n=r?bt(r):void 0;if(n)switch(n){case $e:return ie;case ze:return Qt;case He:return"[object Promise]";case We:return te;case Ge:return"[object WeakMap]"}return e});var tr=_t(function(t){t=Lt(t);var e=[];return se.test(t)&&e.push(""),t.replace(ue,function(t,r,n,i){e.push(n?i.replace(le,"$1"):r||t)}),e});_t.Cache=j;var er=Array.isArray,rr=xe?function(t){return function(e){return t(e)}}(xe):J;r.exports=mt}).call(e,r(0),r(5)(t))},function(t,e,r){var n=r(12),i=r(25),o=n.update,a=n.evaluate,s=r(10),u=s.domEach,c=s.cloneDom,l=s.isHtml,f=Array.prototype.slice,h={flatten:r(99),bind:r(24),forEach:r(15)};e._makeDomArray=function(t,e){return null==t?[]:t.cheerio?e?c(t.get(),t.options):t.get():Array.isArray(t)?h.flatten(t.map(function(t){return this._makeDomArray(t,e)},this)):"string"==typeof t?a(t,this.options):e?c([t]):[t]};var p=function(t){return function(){var e=f.call(arguments),r=this.length-1;return u(this,function(n,o){var a,s;s="function"==typeof e[0]?e[0].call(o,n,i.html(o.children)):e,a=this._makeDomArray(s,n<r),t(a,o.children,o)})}},d=function(t,e,r,n,i){var o,a,s,u,c,l=[e,r].concat(n),f=t[e-1]||null,h=t[e]||null;for(o=0,a=n.length;o<a;++o)u=n[o],c=u.parent||u.root,s=c&&c.children.indexOf(n[o]),c&&s>-1&&(c.children.splice(s,1),i===c&&e>s&&l[0]--),u.root=null,u.parent=i,u.prev&&(u.prev.next=u.next||null),u.next&&(u.next.prev=u.prev||null),u.prev=n[o-1]||f,u.next=n[o+1]||h;return f&&(f.next=n[0]),h&&(h.prev=n[n.length-1]),t.splice.apply(t,l)};e.appendTo=function(t){return t.cheerio||(t=this.constructor.call(this.constructor,t,null,this._originalRoot)),t.append(this),this},e.prependTo=function(t){return t.cheerio||(t=this.constructor.call(this.constructor,t,null,this._originalRoot)),t.prepend(this),this},e.append=p(function(t,e,r){d(e,e.length,0,t,r)}),e.prepend=p(function(t,e,r){d(e,0,0,t,r)}),e.wrap=function(t){var e="function"==typeof t&&t,r=this.length-1;return h.forEach(this,h.bind(function(n,i){var a,s,u=n.parent||n.root,c=u.children;u&&(e&&(t=e.call(n,i)),"string"!=typeof t||l(t)||(t=this.parents().last().find(t).clone()),a=this._makeDomArray(t,i<r).slice(0,1),s=c.indexOf(n),o([n],a[0]),d(c,s,0,a,u))},this)),this},e.after=function(){var t=f.call(arguments),e=this.length-1;return u(this,function(r,n){var o=n.parent||n.root;if(o){var a,s,u=o.children,c=u.indexOf(n);c<0||(a="function"==typeof t[0]?t[0].call(n,r,i.html(n.children)):t,s=this._makeDomArray(a,r<e),d(u,c+1,0,s,o))}}),this},e.insertAfter=function(t){var e=[],r=this;return"string"==typeof t&&(t=this.constructor.call(this.constructor,t,null,this._originalRoot)),t=this._makeDomArray(t),r.remove(),u(t,function(t,n){var i=r._makeDomArray(r.clone()),o=n.parent||n.root;if(o){var a=o.children,s=a.indexOf(n);s<0||(d(a,s+1,0,i,o),e.push(i))}}),this.constructor.call(this.constructor,this._makeDomArray(e))},e.before=function(){var t=f.call(arguments),e=this.length-1;return u(this,function(r,n){var o=n.parent||n.root;if(o){var a,s,u=o.children,c=u.indexOf(n);c<0||(a="function"==typeof t[0]?t[0].call(n,r,i.html(n.children)):t,s=this._makeDomArray(a,r<e),d(u,c,0,s,o))}}),this},e.insertBefore=function(t){var e=[],r=this;return"string"==typeof t&&(t=this.constructor.call(this.constructor,t,null,this._originalRoot)),t=this._makeDomArray(t),r.remove(),u(t,function(t,n){var i=r._makeDomArray(r.clone()),o=n.parent||n.root;if(o){var a=o.children,s=a.indexOf(n);s<0||(d(a,s,0,i,o),e.push(i))}}),this.constructor.call(this.constructor,this._makeDomArray(e))},e.remove=function(t){var e=this;return t&&(e=e.filter(t)),u(e,function(t,e){var r=e.parent||e.root;if(r){var n=r.children,i=n.indexOf(e);i<0||(n.splice(i,1),e.prev&&(e.prev.next=e.next),e.next&&(e.next.prev=e.prev),e.prev=e.next=e.parent=e.root=null)}}),this},e.replaceWith=function(t){var e=this;return u(this,function(r,n){var i=n.parent||n.root;if(i){var a,s=i.children,u=e._makeDomArray("function"==typeof t?t.call(n,r,n):t);o(u,null),a=s.indexOf(n),d(s,a,1,u,i),n.parent=n.prev=n.next=n.root=null}}),this},e.empty=function(){return u(this,function(t,e){h.forEach(e.children,function(t){t.next=t.prev=t.parent=null}),e.children.length=0}),this},e.html=function(t){if(void 0===t)return this[0]&&this[0].children?i.html(this[0].children,this.options):null;var e=this.options;return u(this,function(r,n){h.forEach(n.children,function(t){t.next=t.prev=t.parent=null});var i=t.cheerio?t.clone().get():a(""+t,e);o(i,n)}),this},e.toString=function(){return i.html(this,this.options)},e.text=function(t){return void 0===t?i.text(this):"function"==typeof t?u(this,function(r,n){var o=[n];return e.text.call(o,t.call(n,r,i.text(o)))}):(u(this,function(e,r){h.forEach(r.children,function(t){t.next=t.prev=t.parent=null}),o({data:""+t,type:"text",parent:r,prev:null,next:null,children:[]},r)}),this)},e.clone=function(){return this._make(c(this.get(),this.options))}},function(t,e,r){(function(e){function r(t,e){for(var r=-1,n=e.length,i=t.length;++r<n;)t[i+r]=e[r];return t}function n(t,e,o,a,s){var u=-1,c=t.length;for(o||(o=i),s||(s=[]);++u<c;){var l=t[u];e>0&&o(l)?e>1?n(l,e-1,o,a,s):r(s,l):a||(s[s.length]=l)}return s}function i(t){return A(t)||a(t)||!!(k&&t&&t[k])}function o(t){return(t?t.length:0)?n(t,1):[]}function a(t){return u(t)&&w.call(t,"callee")&&(!j.call(t,"callee")||x.call(t)==d)}function s(t){return null!=t&&l(t.length)&&!c(t)}function u(t){return h(t)&&s(t)}function c(t){var e=f(t)?x.call(t):"";return e==g||e==v}function l(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=p}function f(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function h(t){return!!t&&"object"==typeof t}var p=9007199254740991,d="[object Arguments]",g="[object Function]",v="[object GeneratorFunction]",y="object"==typeof e&&e&&e.Object===Object&&e,b="object"==typeof self&&self&&self.Object===Object&&self,m=y||b||Function("return this")(),_=Object.prototype,w=_.hasOwnProperty,x=_.toString,S=m.Symbol,j=_.propertyIsEnumerable,k=S?S.isConcatSpreadable:void 0,A=Array.isArray;t.exports=o}).call(e,r(0))},function(t,e,r){function n(t,e,r,a){if("string"==typeof e){var s=i(t);"function"==typeof r&&(r=r.call(t,a,s[e])),""===r?delete s[e]:null!=r&&(s[e]=r),t.attribs.style=o(s)}else"object"==typeof e&&Object.keys(e).forEach(function(r){n(t,r,e[r])})}function i(t,e){var r=a(t.attribs.style);return"string"==typeof e?r[e]:Array.isArray(e)?u.pick(r,e):r}function o(t){return Object.keys(t||{}).reduce(function(e,r){return e+=(e?" ":"")+r+": "+t[r]+";"},"")}function a(t){return t=(t||"").trim(),t?t.split(";").reduce(function(t,e){var r=e.indexOf(":");return r<1||r===e.length-1?t:(t[e.slice(0,r).trim()]=e.slice(r+1).trim(),t)},{}):{}}var s=r(10).domEach,u={pick:r(101)},c=Object.prototype.toString;e.css=function(t,e){return 2===arguments.length||"[object Object]"===c.call(t)?s(this,function(r,i){n(i,t,e,r)}):i(this[0],t)}},function(t,e,r){(function(e){function r(t,e,r){switch(r.length){case 0:return t.call(e);case 1:return t.call(e,r[0]);case 2:return t.call(e,r[0],r[1]);case 3:return t.call(e,r[0],r[1],r[2])}return t.apply(e,r)}function n(t,e){for(var r=-1,n=t?t.length:0,i=Array(n);++r<n;)i[r]=e(t[r],r,t);return i}function i(t,e){for(var r=-1,n=e.length,i=t.length;++r<n;)t[i+r]=e[r];return t}function o(t,e,r,n,a){var s=-1,c=t.length;for(r||(r=u),a||(a=[]);++s<c;){var l=t[s];e>0&&r(l)?e>1?o(l,e-1,r,n,a):i(a,l):n||(a[a.length]=l)}return a}function a(t,e){return t=Object(t),s(t,e,function(e,r){return r in t})}function s(t,e,r){for(var n=-1,i=e.length,o={};++n<i;){var a=e[n],s=t[a];r(s,a)&&(o[a]=s)}return o}function u(t){return R(t)||l(t)||!!(B&&t&&t[B])}function c(t){if("string"==typeof t||y(t))return t;var e=t+"";return"0"==e&&1/t==-b?"-0":e}function l(t){return h(t)&&T.call(t,"callee")&&(!C.call(t,"callee")||O.call(t)==_)}function f(t){return null!=t&&d(t.length)&&!p(t)}function h(t){return v(t)&&f(t)}function p(t){var e=g(t)?O.call(t):"";return e==w||e==x}function d(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=m}function g(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function v(t){return!!t&&"object"==typeof t}function y(t){return"symbol"==typeof t||v(t)&&O.call(t)==S}var b=1/0,m=9007199254740991,_="[object Arguments]",w="[object Function]",x="[object GeneratorFunction]",S="[object Symbol]",j="object"==typeof e&&e&&e.Object===Object&&e,k="object"==typeof self&&self&&self.Object===Object&&self,A=j||k||Function("return this")(),E=Object.prototype,T=E.hasOwnProperty,O=E.toString,L=A.Symbol,C=E.propertyIsEnumerable,B=L?L.isConcatSpreadable:void 0,D=Math.max,R=Array.isArray,P=function(t,e){return e=D(void 0===e?t.length-1:e,0),function(){for(var n=arguments,i=-1,o=D(n.length-e,0),a=Array(o);++i<o;)a[i]=n[e+i];i=-1;for(var s=Array(e+1);++i<e;)s[i]=n[i];return s[e]=a,r(t,this,s)}}(function(t,e){return null==t?{}:a(t,n(o(e,1),c))});t.exports=P}).call(e,r(0))},function(t,e,r){var n=/%20/g,i=/\r?\n/g,o={map:r(103)};e.serialize=function(){var t=this.serializeArray();return o.map(t,function(t){return encodeURIComponent(t.name)+"="+encodeURIComponent(t.value)}).join("&").replace(n,"+")},e.serializeArray=function(){var t=this.constructor;return this.map(function(){var e=this,r=t(e);return"form"===e.name?r.find("input,select,textarea,keygen").toArray():r.filter("input,select,textarea,keygen").toArray()}).filter('[name!=""]:not(:disabled):not(:submit, :button, :image, :reset, :file):matches([checked], :not(:checkbox, :radio))').map(function(e,r){var n=t(r),a=n.attr("name"),s=n.val();return null==s?null:Array.isArray(s)?o.map(s,function(t){return{name:a,value:t.replace(i,"\r\n")}}):{name:a,value:s.replace(i,"\r\n")}}).get()}},function(t,e,r){(function(t,r){function n(t,e){for(var r=-1,n=t?t.length:0,i=Array(n);++r<n;)i[r]=e(t[r],r,t);return i}function i(t,e){for(var r=-1,n=t?t.length:0;++r<n;)if(e(t[r],r,t))return!0;return!1}function o(t){return function(e){return null==e?void 0:e[t]}}function a(t,e){for(var r=-1,n=Array(t);++r<t;)n[r]=e(r);return n}function s(t,e){return null==t?void 0:t[e]}function u(t){var e=!1;if(null!=t&&"function"!=typeof t.toString)try{e=!!(t+"")}catch(t){}return e}function c(t){var e=-1,r=Array(t.size);return t.forEach(function(t,n){r[++e]=[n,t]}),r}function l(t){var e=-1,r=Array(t.size);return t.forEach(function(t){r[++e]=t}),r}function f(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function h(){this.__data__=Ve?Ve(null):{}}function p(t){return this.has(t)&&delete this.__data__[t]}function d(t){var e=this.__data__;if(Ve){var r=e[t];return r===It?void 0:r}return Oe.call(e,t)?e[t]:void 0}function g(t){var e=this.__data__;return Ve?void 0!==e[t]:Oe.call(e,t)}function v(t,e){return this.__data__[t]=Ve&&void 0===e?It:e,this}function y(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function b(){this.__data__=[]}function m(t){var e=this.__data__,r=N(e,t);return!(r<0)&&(r==e.length-1?e.pop():Pe.call(e,r,1),!0)}function _(t){var e=this.__data__,r=N(e,t);return r<0?void 0:e[r][1]}function w(t){return N(this.__data__,t)>-1}function x(t,e){var r=this.__data__,n=N(r,t);return n<0?r.push([t,e]):r[n][1]=e,this}function S(t){var e=-1,r=t?t.length:0;for(this.clear();++e<r;){var n=t[e];this.set(n[0],n[1])}}function j(){this.__data__={hash:new f,map:new(Ie||y),string:new f}}function k(t){return at(this,t).delete(t)}function A(t){return at(this,t).get(t)}function E(t){return at(this,t).has(t)}function T(t,e){return at(this,t).set(t,e),this}function O(t){var e=-1,r=t?t.length:0;for(this.__data__=new S;++e<r;)this.add(t[e])}function L(t){return this.__data__.set(t,It),this}function C(t){return this.__data__.has(t)}function B(t){this.__data__=new y(t)}function D(){this.__data__=new y}function R(t){return this.__data__.delete(t)}function P(t){return this.__data__.get(t)}function q(t){return this.__data__.has(t)}function M(t,e){var r=this.__data__;if(r instanceof y){var n=r.__data__;if(!Ie||n.length<qt-1)return n.push([t,e]),this;r=this.__data__=new S(n)}return r.set(t,e),this}function I(t,e){var r=er(t)||xt(t)?a(t.length,String):[],n=r.length,i=!!n;for(var o in t)!e&&!Oe.call(t,o)||i&&("length"==o||lt(o,n))||r.push(o);return r}function N(t,e){for(var r=t.length;r--;)if(wt(t[r][0],e))return r;return-1}function U(t,e){return t&&Ze(t,e,Dt)}function F(t,e){e=ft(e,t)?[e]:rt(e);for(var r=0,n=e.length;null!=t&&r<n;)t=t[yt(e[r++])];return r&&r==n?t:void 0}function V(t){return Le.call(t)}function $(t,e){return null!=t&&e in Object(t)}function z(t,e,r,n,i){return t===e||(null==t||null==e||!Et(t)&&!Tt(e)?t!==t&&e!==e:H(t,e,z,r,n,i))}function H(t,e,r,n,i,o){var a=er(t),s=er(e),c=zt,l=zt;a||(c=Ke(t),c=c==$t?Zt:c),s||(l=Ke(e),l=l==$t?Zt:l);var f=c==Zt&&!u(t),h=l==Zt&&!u(e),p=c==l;if(p&&!f)return o||(o=new B),a||rr(t)?nt(t,e,r,n,i,o):it(t,e,c,r,n,i,o);if(!(i&Ut)){var d=f&&Oe.call(t,"__wrapped__"),g=h&&Oe.call(e,"__wrapped__");if(d||g){var v=d?t.value():t,y=g?e.value():e;return o||(o=new B),r(v,y,n,i,o)}}return!!p&&(o||(o=new B),ot(t,e,r,n,i,o))}function W(t,e,r,n){var i=r.length,o=i,a=!n;if(null==t)return!o;for(t=Object(t);i--;){var s=r[i];if(a&&s[2]?s[1]!==t[s[0]]:!(s[0]in t))return!1}for(;++i<o;){s=r[i];var u=s[0],c=t[u],l=s[1];if(a&&s[2]){if(void 0===c&&!(u in t))return!1}else{var f=new B;if(n)var h=n(c,l,u,t,e,f);if(!(void 0===h?z(l,c,n,Nt|Ut,f):h))return!1}}return!0}function G(t){return!(!Et(t)||pt(t))&&(kt(t)||u(t)?Ce:fe).test(bt(t))}function Y(t){return Tt(t)&&At(t.length)&&!!pe[Le.call(t)]}function J(t){return"function"==typeof t?t:null==t?Rt:"object"==typeof t?er(t)?K(t[0],t[1]):Z(t):Pt(t)}function Q(t){if(!dt(t))return qe(t);var e=[];for(var r in Object(t))Oe.call(t,r)&&"constructor"!=r&&e.push(r);return e}function X(t,e){var r=-1,n=St(t)?Array(t.length):[];return Xe(t,function(t,i,o){n[++r]=e(t,i,o)}),n}function Z(t){var e=st(t);return 1==e.length&&e[0][2]?vt(e[0][0],e[0][1]):function(r){return r===t||W(r,t,e)}}function K(t,e){return ft(t)&&gt(e)?vt(yt(t),e):function(r){var n=Ct(r,t);return void 0===n&&n===e?Bt(r,t):z(e,n,void 0,Nt|Ut)}}function tt(t){return function(e){return F(e,t)}}function et(t){if("string"==typeof t)return t;if(Ot(t))return Qe?Qe.call(t):"";var e=t+"";return"0"==e&&1/t==-Ft?"-0":e}function rt(t){return er(t)?t:tr(t)}function nt(t,e,r,n,o,a){var s=o&Ut,u=t.length,c=e.length;if(u!=c&&!(s&&c>u))return!1;var l=a.get(t);if(l&&a.get(e))return l==e;var f=-1,h=!0,p=o&Nt?new O:void 0;for(a.set(t,e),a.set(e,t);++f<u;){var d=t[f],g=e[f];if(n)var v=s?n(g,d,f,e,t,a):n(d,g,f,t,e,a);if(void 0!==v){if(v)continue;h=!1;break}if(p){if(!i(e,function(t,e){if(!p.has(e)&&(d===t||r(d,t,n,o,a)))return p.add(e)})){h=!1;break}}else if(d!==g&&!r(d,g,n,o,a)){h=!1;break}}return a.delete(t),a.delete(e),h}function it(t,e,r,n,i,o,a){switch(r){case ie:if(t.byteLength!=e.byteLength||t.byteOffset!=e.byteOffset)return!1;t=t.buffer,e=e.buffer;case ne:return!(t.byteLength!=e.byteLength||!n(new De(t),new De(e)));case Ht:case Wt:case Xt:return wt(+t,+e);case Gt:return t.name==e.name&&t.message==e.message;case Kt:case ee:return t==e+"";case Qt:var s=c;case te:var u=o&Ut;if(s||(s=l),t.size!=e.size&&!u)return!1;var f=a.get(t);if(f)return f==e;o|=Nt,a.set(t,e);var h=nt(s(t),s(e),n,i,o,a);return a.delete(t),h;case re:if(Je)return Je.call(t)==Je.call(e)}return!1}function ot(t,e,r,n,i,o){var a=i&Ut,s=Dt(t),u=s.length;if(u!=Dt(e).length&&!a)return!1;for(var c=u;c--;){var l=s[c];if(!(a?l in e:Oe.call(e,l)))return!1}var f=o.get(t);if(f&&o.get(e))return f==e;var h=!0;o.set(t,e),o.set(e,t);for(var p=a;++c<u;){l=s[c];var d=t[l],g=e[l];if(n)var v=a?n(g,d,l,e,t,o):n(d,g,l,t,e,o);if(!(void 0===v?d===g||r(d,g,n,i,o):v)){h=!1;break}p||(p="constructor"==l)}if(h&&!p){var y=t.constructor,b=e.constructor;y!=b&&"constructor"in t&&"constructor"in e&&!("function"==typeof y&&y instanceof y&&"function"==typeof b&&b instanceof b)&&(h=!1)}return o.delete(t),o.delete(e),h}function at(t,e){var r=t.__data__;return ht(e)?r["string"==typeof e?"string":"hash"]:r.map}function st(t){for(var e=Dt(t),r=e.length;r--;){var n=e[r],i=t[n];e[r]=[n,i,gt(i)]}return e}function ut(t,e){var r=s(t,e);return G(r)?r:void 0}function ct(t,e,r){e=ft(e,t)?[e]:rt(e);for(var n,i=-1,o=e.length;++i<o;){var a=yt(e[i]);if(!(n=null!=t&&r(t,a)))break;t=t[a]}if(n)return n;var o=t?t.length:0;return!!o&&At(o)&&lt(a,o)&&(er(t)||xt(t))}function lt(t,e){return!!(e=null==e?Vt:e)&&("number"==typeof t||he.test(t))&&t>-1&&t%1==0&&t<e}function ft(t,e){if(er(t))return!1;var r=typeof t;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=t&&!Ot(t))||(ae.test(t)||!oe.test(t)||null!=e&&t in Object(e))}function ht(t){var e=typeof t;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==t:null===t}function pt(t){return!!Ee&&Ee in t}function dt(t){var e=t&&t.constructor;return t===("function"==typeof e&&e.prototype||ke)}function gt(t){return t===t&&!Et(t)}function vt(t,e){return function(r){return null!=r&&(r[t]===e&&(void 0!==e||t in Object(r)))}}function yt(t){if("string"==typeof t||Ot(t))return t;var e=t+"";return"0"==e&&1/t==-Ft?"-0":e}function bt(t){if(null!=t){try{return Te.call(t)}catch(t){}try{return t+""}catch(t){}}return""}function mt(t,e){return(er(t)?n:X)(t,J(e,3))}function _t(t,e){if("function"!=typeof t||e&&"function"!=typeof e)throw new TypeError(Mt);var r=function(){var n=arguments,i=e?e.apply(this,n):n[0],o=r.cache;if(o.has(i))return o.get(i);var a=t.apply(this,n);return r.cache=o.set(i,a),a};return r.cache=new(_t.Cache||S),r}function wt(t,e){return t===e||t!==t&&e!==e}function xt(t){return jt(t)&&Oe.call(t,"callee")&&(!Re.call(t,"callee")||Le.call(t)==$t)}function St(t){return null!=t&&At(t.length)&&!kt(t)}function jt(t){return Tt(t)&&St(t)}function kt(t){var e=Et(t)?Le.call(t):"";return e==Yt||e==Jt}function At(t){return"number"==typeof t&&t>-1&&t%1==0&&t<=Vt}function Et(t){var e=typeof t;return!!t&&("object"==e||"function"==e)}function Tt(t){return!!t&&"object"==typeof t}function Ot(t){return"symbol"==typeof t||Tt(t)&&Le.call(t)==re}function Lt(t){return null==t?"":et(t)}function Ct(t,e,r){var n=null==t?void 0:F(t,e);return void 0===n?r:n}function Bt(t,e){return null!=t&&ct(t,e,$)}function Dt(t){return St(t)?I(t):Q(t)}function Rt(t){return t}function Pt(t){return ft(t)?o(yt(t)):tt(t)}var qt=200,Mt="Expected a function",It="__lodash_hash_undefined__",Nt=1,Ut=2,Ft=1/0,Vt=9007199254740991,$t="[object Arguments]",zt="[object Array]",Ht="[object Boolean]",Wt="[object Date]",Gt="[object Error]",Yt="[object Function]",Jt="[object GeneratorFunction]",Qt="[object Map]",Xt="[object Number]",Zt="[object Object]",Kt="[object RegExp]",te="[object Set]",ee="[object String]",re="[object Symbol]",ne="[object ArrayBuffer]",ie="[object DataView]",oe=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,ae=/^\w*$/,se=/^\./,ue=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,ce=/[\\^$.*+?()[\]{}|]/g,le=/\\(\\)?/g,fe=/^\[object .+?Constructor\]$/,he=/^(?:0|[1-9]\d*)$/,pe={};pe["[object Float32Array]"]=pe["[object Float64Array]"]=pe["[object Int8Array]"]=pe["[object Int16Array]"]=pe["[object Int32Array]"]=pe["[object Uint8Array]"]=pe["[object Uint8ClampedArray]"]=pe["[object Uint16Array]"]=pe["[object Uint32Array]"]=!0,pe[$t]=pe[zt]=pe[ne]=pe[Ht]=pe[ie]=pe[Wt]=pe[Gt]=pe[Yt]=pe[Qt]=pe[Xt]=pe[Zt]=pe[Kt]=pe[te]=pe[ee]=pe["[object WeakMap]"]=!1;var de="object"==typeof t&&t&&t.Object===Object&&t,ge="object"==typeof self&&self&&self.Object===Object&&self,ve=de||ge||Function("return this")(),ye="object"==typeof e&&e&&!e.nodeType&&e,be=ye&&"object"==typeof r&&r&&!r.nodeType&&r,me=be&&be.exports===ye,_e=me&&de.process,we=function(){try{return _e&&_e.binding("util")}catch(t){}}(),xe=we&&we.isTypedArray,Se=Array.prototype,je=Function.prototype,ke=Object.prototype,Ae=ve["__core-js_shared__"],Ee=function(){var t=/[^.]+$/.exec(Ae&&Ae.keys&&Ae.keys.IE_PROTO||"");return t?"Symbol(src)_1."+t:""}(),Te=je.toString,Oe=ke.hasOwnProperty,Le=ke.toString,Ce=RegExp("^"+Te.call(Oe).replace(ce,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Be=ve.Symbol,De=ve.Uint8Array,Re=ke.propertyIsEnumerable,Pe=Se.splice,qe=function(t,e){return function(r){return t(e(r))}}(Object.keys,Object),Me=ut(ve,"DataView"),Ie=ut(ve,"Map"),Ne=ut(ve,"Promise"),Ue=ut(ve,"Set"),Fe=ut(ve,"WeakMap"),Ve=ut(Object,"create"),$e=bt(Me),ze=bt(Ie),He=bt(Ne),We=bt(Ue),Ge=bt(Fe),Ye=Be?Be.prototype:void 0,Je=Ye?Ye.valueOf:void 0,Qe=Ye?Ye.toString:void 0;f.prototype.clear=h,f.prototype.delete=p,f.prototype.get=d,f.prototype.has=g,f.prototype.set=v,y.prototype.clear=b,y.prototype.delete=m,y.prototype.get=_,y.prototype.has=w,y.prototype.set=x,S.prototype.clear=j,S.prototype.delete=k,S.prototype.get=A,S.prototype.has=E,S.prototype.set=T,O.prototype.add=O.prototype.push=L,O.prototype.has=C,B.prototype.clear=D,B.prototype.delete=R,B.prototype.get=P,B.prototype.has=q,B.prototype.set=M;var Xe=function(t,e){return function(r,n){if(null==r)return r;if(!St(r))return t(r,n);for(var i=r.length,o=e?i:-1,a=Object(r);(e?o--:++o<i)&&!1!==n(a[o],o,a););return r}}(U),Ze=function(t){return function(e,r,n){for(var i=-1,o=Object(e),a=n(e),s=a.length;s--;){var u=a[t?s:++i];if(!1===r(o[u],u,o))break}return e}}(),Ke=V;(Me&&Ke(new Me(new ArrayBuffer(1)))!=ie||Ie&&Ke(new Ie)!=Qt||Ne&&"[object Promise]"!=Ke(Ne.resolve())||Ue&&Ke(new Ue)!=te||Fe&&"[object WeakMap]"!=Ke(new Fe))&&(Ke=function(t){var e=Le.call(t),r=e==Zt?t.constructor:void 0,n=r?bt(r):void 0;if(n)switch(n){case $e:return ie;case ze:return Qt;case He:return"[object Promise]";case We:return te;case Ge:return"[object WeakMap]"}return e});var tr=_t(function(t){t=Lt(t);var e=[];return se.test(t)&&e.push(""),t.replace(ue,function(t,r,n,i){e.push(n?i.replace(le,"$1"):r||t)}),e});_t.Cache=S;var er=Array.isArray,rr=xe?function(t){return function(e){return t(e)}}(xe):Y;r.exports=mt}).call(e,r(0),r(5)(t))},function(t,e){t.exports={name:"cheerio",version:"0.22.0",description:"Tiny, fast, and elegant implementation of core jQuery designed specifically for the server",author:"Matt Mueller <mattmuelle@gmail.com> (mat.io)",license:"MIT",keywords:["htmlparser","jquery","selector","scraper","parser","html"],repository:{type:"git",url:"git://github.com/cheeriojs/cheerio.git"},main:"./index.js",files:["index.js","lib"],engines:{node:">= 0.6"},dependencies:{"css-select":"~1.2.0","dom-serializer":"~0.1.0",entities:"~1.1.1",htmlparser2:"^3.9.1","lodash.assignin":"^4.0.9","lodash.bind":"^4.1.4","lodash.defaults":"^4.0.1","lodash.filter":"^4.4.0","lodash.flatten":"^4.2.0","lodash.foreach":"^4.3.0","lodash.map":"^4.4.0","lodash.merge":"^4.4.0","lodash.pick":"^4.2.1","lodash.reduce":"^4.4.0","lodash.reject":"^4.4.0","lodash.some":"^4.4.0"},devDependencies:{benchmark:"^2.1.0",coveralls:"^2.11.9","expect.js":"~0.3.1",istanbul:"^0.4.3",jsdom:"^9.2.1",jquery:"^3.0.0",jshint:"^2.9.2",mocha:"^2.5.3",xyz:"~0.5.0"},scripts:{test:"make test"}}},function(t,e,r){t.exports={lex:r(45),parse:r(106),stringify:r(107)}},function(t,e,r){function n(t,e){var r;e||(e={}),w=!!e.comments,S=!!e.position,x=0,j=Array.isArray(t)?t.slice():_(t);var n,i,a=[];for(b&&(r=Date.now());i=o();)(n=p(i))&&a.push(n);return b&&m("ran in",Date.now()-r+"ms"),{type:"stylesheet",stylesheet:{rules:a}}}function i(t,e){e||(e={});for(var r,n=["type","name","value"],i={},o=0;o<n.length;++o)r=n[o],t[r]&&(i[r]=e[r]||t[r]);for(n=Object.keys(e),o=0;o<n.length;++o)r=n[o],i[r]||(i[r]=e[r]);return S&&(i.position={start:t.start,end:t.end}),y&&m("astNode:",JSON.stringify(i,null,2)),i}function o(){var t=j.shift();return y&&m("next:",JSON.stringify(t,null,2)),t}function a(t){x+=1;var e={};switch(t.type){case"font-face":case"viewport":e.declarations=g();break;case"page":e.prefix=t.prefix,e.declarations=g();break;default:e.prefix=t.prefix,e.rules=v()}return i(t,e)}function s(t){return i(t)}function u(t){return i(t)}function c(t){return i(t,{text:t.text})}function l(t){return i(t)}function f(t){return i(t)}function h(t){function e(t){return t.trim()}return i(t,{type:"rule",selectors:t.text.split(",").map(e),declarations:g()})}function p(t){switch(t.type){case"property":return f(t);case"selector":return h(t);case"at-group-end":return void(x-=1);case"media":case"keyframes":return a(t);case"comment":if(w)return c(t);break;case"charset":return u(t);case"import":return s(t);case"namespace":return l(t);case"font-face":case"supports":case"viewport":case"document":case"page":return a(t)}y&&m("parseToken: unexpected token:",JSON.stringify(t))}function d(t){for(var e,r,n=[];(r=o())&&t&&t(r);)(e=p(r))&&n.push(e);return r&&"end"!==r.type&&j.unshift(r),n}function g(){return d(function(t){return"property"===t.type||"comment"===t.type})}function v(){return d(function(){return x})}var y=!1,b=!1,m=r(28)("parse"),_=r(45);t.exports=n;var w,x,S,j},function(t,e,r){function n(t,e){var r;e||(e={}),y=e.indentation||"",v=!!e.compress,g=!!e.comments,v?b=m="":(b="\n",m=" "),w&&(r=Date.now());var n=c(t.stylesheet.rules,p).join("\n").trim();return w&&x("ran in",Date.now()-r+"ms"),n}function i(t){return this.level||(this.level=1),t?void(this.level+=t):v?"":Array(this.level).join(y||"")}function o(t){return"@"+t.type+" "+t.value+";"+b}function a(t){var e="",r=t.prefix||"";t.name&&(e=" "+t.name);var n="page"!==t.type;return"@"+r+t.type+e+m+l(t,n)+b}function s(t){return g?"/*"+(t.text||"")+"*/"+b:""}function u(t){var e;return t.selectors?e=t.selectors.join(","+b):(e="@"+t.type,e+=t.name?" "+t.name:""),i()+e+m+l(t)+b}function c(t,e){return t.reduce(function(t,r){var n="comment"===r.type?s(r):e(r);return n&&t.push(n),t},[])}function l(t,e){var r=t.declarations,n=h;return t.rules&&(r=t.rules,n=u),r=f(r,n),r&&(r=b+r+(e?"":b)),"{"+r+i()+"}"}function f(t,e){if(!t)return"";i(1);var r=c(t,e);return i(-1),r.length?r.join(b):""}function h(t){if("property"===t.type)return d(t);_&&x("stringifyDeclaration: unexpected node:",JSON.stringify(t))}function p(t){switch(t.type){case"rule":return u(t);case"media":case"keyframes":return a(t);case"comment":return s(t);case"import":case"charset":case"namespace":return o(t);case"font-face":case"supports":case"viewport":case"document":case"page":return a(t)}_&&x("stringifyNode: unexpected node: "+JSON.stringify(t))}function d(t){var e=t.name?t.name+":"+m:"";return i()+e+t.value+";"}var g,v,y,b,m,_=!1,w=!1,x=r(28)("stringify");t.exports=n},function(t,e,r){"use strict";function n(t,e){this.text=t,this.spec=void 0,this.styleAttribute=e||!1}function i(t){try{return o(t)[0]}catch(t){return[]}}var o=r(109);t.exports=n,n.prototype.parsed=function(){return this.tokens||(this.tokens=i(this.text)),this.tokens},n.prototype.specificity=function(){function t(r,n){for(var o=n||i(r),a=[e?1:0,0,0,0],s=[],u=0;u<o.length;u++){var c=o[u],l=c.pseudos;if(c.id&&a[1]++,c.attributes&&(a[2]+=c.attributes.length),c.classList&&(a[2]+=c.classList.length),c.tag&&"*"!==c.tag&&a[3]++,l){a[3]+=l.length;for(var f=0;f<l.length;f++)"not"===l[f].name&&(s.push(l[f].value),a[3]--)}}for(var h=s.length;h--;)for(var p=t(s[h]),d=4;d--;)a[d]+=p[d];return a}var e=this.styleAttribute;return this.spec||(this.spec=t(this.text,this.parsed())),this.spec}},function(t,e,r){"use strict";var n=/([-.*+?^${}()|[\]\/\\])/g,i=/\\/g,o=function(t){return(t+"").replace(n,"\\$1")},a=function(t){return(t+"").replace(i,"")},s=RegExp("^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)".replace(/<combinator>/,"["+o(">+~`!@$%^&={}\\;</")+"]").replace(/<unicode>/g,"(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])").replace(/<unicode1>/g,"(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])")),u=function(t){this.combinator=t||" ",this.tag="*"};u.prototype.toString=function(){if(!this.raw){var t,e,r="";if(r+=this.tag||"*",this.id&&(r+="#"+this.id),this.classes&&(r+="."+this.classList.join(".")),this.attributes)for(t=0;e=this.attributes[t++];)r+="["+e.name+(e.operator?e.operator+'"'+e.value+'"':"")+"]";if(this.pseudos)for(t=0;e=this.pseudos[t++];)r+=":"+e.name,e.value&&(r+="("+e.value+")");this.raw=r}return this.raw};var c=function(){this.length=0};c.prototype.toString=function(){if(!this.raw){for(var t,e="",r=0;t=this[r++];)1!==r&&(e+=" ")," "!==t.combinator&&(e+=t.combinator+" "),e+=t;this.raw=e}return this.raw};var l=function(t,e,r,n,i,s,l,f,h,p,d,g,v,y,b,m){var _,w;if((e||!this.length)&&(_=this[this.length++]=new c,e))return"";if(_||(_=this[this.length-1]),(r||n||!_.length)&&(w=_[_.length++]=new u(r)),w||(w=_[_.length-1]),i)w.tag=a(i);else if(s)w.id=a(s);else if(l){var x=a(l),S=w.classes||(w.classes={});if(!S[x]){S[x]=o(l);var j=w.classList||(w.classList=[]);j.push(x),j.sort()}}else v?(m=m||b,(w.pseudos||(w.pseudos=[])).push({type:1==g.length?"class":"element",name:a(v),escapedName:o(v),value:m?a(m):null,escapedValue:m?o(m):null})):f&&(d=d?o(d):null,(w.attributes||(w.attributes=[])).push({operator:h,name:a(f),escapedName:o(f),value:d?a(d):null,escapedValue:d?o(d):null}));return""},f=function(t){this.length=0;for(var e,r=this,n=t;t;){if((e=t.replace(s,function(){return l.apply(r,arguments)}))===t)throw new Error(n+" is an invalid expression");t=e}};f.prototype.toString=function(){if(!this.raw){for(var t,e=[],r=0;t=this[r++];)e.push(t);this.raw=e.join(", ")}return this.raw};var h={},p=function(t){return null==t?null:(t=(""+t).replace(/^\s+|\s+$/g,""),h[t]||(h[t]=new f(t)))};t.exports=p},function(t,e,r){"use strict";function n(t,e,r,n,i){this.prop=t,this.value=e,this.selector=r,this.priority=n||0,this.additionalPriority=i||[]}t.exports=n;var i=r(27);n.prototype.compareFunc=function(t){var e=[];e.push.apply(e,this.selector.specificity()),e.push.apply(e,this.additionalPriority),e[0]+=this.priority;var r=[];return r.push.apply(r,t.selector.specificity()),r.push.apply(r,t.additionalPriority),r[0]+=t.priority,i.compareFunc(e,r)},n.prototype.compare=function(t){return 1===this.compareFunc(t)?this:t},n.prototype.toString=function(){return this.prop+": "+this.value.replace(/['"]+/g,"")+";"}},function(t,e,r){"use strict";var n=r(27);t.exports=function(t){function e(e,o,s){function u(r){for(var o=r[0],u=r[1],c=new n.Selector(o),l=c.parsed(),f=i(l),h=0;h<l.length;++h){var p=l[h];if(p.pseudos)for(var d=0;d<p.pseudos.length;++d){var y=p.pseudos[d];if(t.ignoredPseudos.indexOf(y.name)>=0)return}}if(f){var b=l[l.length-1],m=b.pseudos;b.pseudos=a(b.pseudos),o=l.toString(),b.pseudos=m}var _;try{_=e(o)}catch(t){return}_.each(function(){function r(e,r){for(var o=0,a=e.length;o<a;o++)if("property"==e[o].type){var u=e[o].name,c=e[o].value,l=null!==e[o].value.match(/!important$/);l&&!s.preserveImportant&&(c=c.replace(/\s*!important$/,""));var f=[e[o].position.start.line,e[o].position.start.col],h=new n.Property(u,c,r,l?2:0,f),p=i.styleProps[u];t.excludedProperties.indexOf(u)<0&&(p&&p.compare(h)===h||!p)&&(p&&p.selector!==r?delete i.styleProps[u]:p&&(h.nextProp=p),i.styleProps[u]=h)}}var i=this;if(!(i.name&&t.nonVisualElements.indexOf(i.name.toUpperCase())>=0)){if(f){var o="pseudo"+f,a=i[o];a||(a=i[o]=e("<span />").get(0),a.pseudoElementType=f,a.pseudoElementParent=i,i[o]=a),i=a}if(!i.styleProps){if(i.styleProps={},e(i).attr(v)){var l="* { "+e(i).attr(v)+" } ";r(n.parseCSS(l)[0][1],new n.Selector("<style>",!0))}g.push(i)}r(u,c)}})}function c(t){var r=(Object.keys(t.styleProps).length,[]);Object.keys(t.styleProps).forEach(function(e){for(var n=t.styleProps[e];void 0!==n;)r.push(n),n=n.nextProp}),r.sort(function(t,e){return t.compareFunc(e)});var n=r.filter(function(t){return"content"!==t.prop}).map(function(t){return t.prop+": "+t.value.replace(/["]/g,"'")+";"}).join(" ");n&&e(t).attr(v,n)}function l(t){if(t.pseudoElementType&&t.styleProps.content){var n=r(t.styleProps.content.value);n.img?(t.name="img",e(t).attr("src",n.img)):e(t).text(n);var i=t.pseudoElementParent;"before"===t.pseudoElementType?e(i).prepend(t):e(i).append(t)}}function f(r,n){if(r.name){var i=r.name.toUpperCase();if(t[n+"Elements"].indexOf(i)>-1)for(var o in r.styleProps)if(r.styleProps[o].prop===n){if(r.styleProps[o].value.match(/px/)){var a=r.styleProps[o].value.replace("px","");return void e(r).attr(n,a)}if(t.tableElements.indexOf(i)>-1&&r.styleProps[o].value.match(/\%/))return void e(r).attr(n,r.styleProps[o].value)}}}function h(t){return 0!==t.indexOf("url(")?t:t.replace(/^url\((["'])?([^"']+)\1\)$/,"$2")}function p(r){if(r.name){var n=r.name.toUpperCase(),i=Object.keys(t.styleToAttribute);if(t.tableElements.indexOf(n)>-1)for(var o in r.styleProps)if(i.indexOf(r.styleProps[o].prop)>-1){var a=t.styleToAttribute[r.styleProps[o].prop],s=r.styleProps[o].value;"background"===a&&(s=h(s)),e(r).attr(a,s)}}}s=s||{};var d=n.parseCSS(o),g=[],v="style";if(s.styleAttributeName&&(v=s.styleAttributeName),d.forEach(u),g.forEach(c),s.inlinePseudoElements&&g.forEach(l),s.applyWidthAttributes&&g.forEach(function(t){f(t,"width")}),s.applyHeightAttributes&&g.forEach(function(t){f(t,"height")}),s.applyAttributesTableElements&&g.forEach(p),s.insertPreservedExtraCss&&s.extraCss){var y=n.getPreservedText(s.extraCss,{mediaQueries:s.preserveMediaQueries,fontFaces:s.preserveFontFaces});if(y){var b=null;!0!==s.insertPreservedExtraCss?b=e(s.insertPreservedExtraCss):(b=e("head"),b.length||(b=e("body")),b.length||(b=e.root())),b.first().append("<style>"+y+"</style>")}}}function r(t){if("none"===t||"normal"===t)return"";var e=t.match(/^\s*url\s*\(\s*(.*?)\s*\)\s*$/i);if(e){return{img:e[1].replace(/^['"]|['"]$/g,"")}}return t=t.slice(1,t.length-1),t=t.replace(/\\/g,"")}function i(t){if(0!==t.length){var e=t[t.length-1].pseudos;if(e)for(var r=0;r<e.length;r++)if(o(e[r]))return e[r].name}}function o(t){return"before"===t.name||"after"===t.name}function a(t){return t.filter(function(t){return!o(t)})}function s(t,r){r=n.getDefaultOptions(r);var i=c(t,r);return i+="\n"+r.extraCss,e(t,i,r),t}function u(t,e){var r,i,o,a=[],s=t("style");return s.each(function(){if(o=this,r=o.childNodes,1===r.length){if(i=r[0].data,e.applyStyleTags&&void 0===t(o).attr("data-embed")&&a.push(i),e.removeStyleTags&&void 0===t(o).attr("data-embed")){var s=n.getPreservedText(o.childNodes[0].nodeValue,{mediaQueries:e.preserveMediaQueries,fontFaces:e.preserveFontFaces});s?o.childNodes[0].nodeValue=s:t(o).remove()}t(o).removeAttr("data-embed")}}),a}function c(t,e){return u(t,e).join("\n")}return t.ignoredPseudos=["hover","active","focus","visited","link"],t.widthElements=["TABLE","TD","IMG"],t.heightElements=["TABLE","TD","IMG"],t.tableElements=["TABLE","TD","TH","TR","TD","CAPTION","COLGROUP","COL","THEAD","TBODY","TFOOT"],t.nonVisualElements=["HEAD","TITLE","BASE","LINK","STYLE","META","SCRIPT","NOSCRIPT"],t.styleToAttribute={"background-color":"bgcolor","background-image":"background","text-align":"align","vertical-align":"valign"},t.excludedProperties=[],t.juiceDocument=s,t.inlineDocument=e,t}},function(t,e,r){"use strict";var n;void 0!==(n=function(){return function(){var t=(arguments.length>0&&void 0!==arguments[0]&&arguments[0],function t(e,r){e.each(function(e){if("image"==e.get("type")){var n=e.get("src");r?"##"==n&&e.set("src",e.get("src_bkp")):"##"!=n&&(e.set("src_bkp",e.get("src")),e.set("src","##"))}t(e.get("components"),r)})});return{run:function(e){var r=e.getComponents();t(r)},stop:function(e){var r=e.getComponents();t(r,1)}}}}.call(e,r,e,t))&&(t.exports=n)},function(t,e,r){"use strict";var n;void 0!==(n=function(){return function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e="",r="",n=t.editor,i=t.tableStyle||{},o=t.cellStyle||{},a=n.BlockManager;for(var s in i)e+=s+": "+i[s]+"; ";for(var u in o)r+=u+": "+o[u]+"; ";a.getAll().reset(),a.add("sect100",{label:t.sect100BlkLabel,category:t.categoryLabel,attributes:{class:"gjs-fonts gjs-f-b1"},content:'<table style="'+e+'">\n        <tr>\n          <td style="'+r+'"></td>\n        </tr>\n        </table>'}),a.add("sect50",{label:t.sect50BlkLabel,category:t.categoryLabel,attributes:{class:"gjs-fonts gjs-f-b2"},content:'<table style="'+e+'">\n        <tr>\n          <td style="'+r+' width: 50%"></td>\n          <td style="'+r+' width: 50%"></td>\n        </tr>\n        </table>'}),a.add("sect30",{label:t.sect30BlkLabel,category:t.categoryLabel,attributes:{class:"gjs-fonts gjs-f-b3"},content:'<table style="'+e+'">\n        <tr>\n          <td style="'+r+' width: 33.3333%"></td>\n          <td style="'+r+' width: 33.3333%"></td>\n          <td style="'+r+' width: 33.3333%"></td>\n        </tr>\n        </table>'}),a.add("sect37",{label:t.sect37BlkLabel,category:t.categoryLabel,attributes:{class:"gjs-fonts gjs-f-b37"},content:'<table style="'+e+'">\n        <tr>\n          <td style="'+r+' width:30%"></td>\n          <td style="'+r+' width:70%"></td>\n        </tr>\n        </table>'}),a.add("button",{label:t.buttonBlkLabel,category:t.categoryLabel,content:'<a class="button">Button</a>',attributes:{class:"gjs-fonts gjs-f-button"}}),a.add("divider",{label:t.dividerBlkLabel,category:t.categoryLabel,content:'<table style="width: 100%; margin-top: 10px; margin-bottom: 10px;">\n        <tr>\n          <td class="divider"></td>\n        </tr>\n      </table>\n      <style>\n      .divider {\n        background-color: rgba(0, 0, 0, 0.1);\n        height: 1px;\n      }\n      </style>',attributes:{class:"gjs-fonts gjs-f-divider"}}),a.add("text",{label:t.textBlkLabel,category:t.categoryLabel,attributes:{class:"gjs-fonts gjs-f-text"},content:{type:"text",content:"Insert your text here",style:{padding:"10px"},activeOnRender:1}}),a.add("text-sect",{label:t.textSectionBlkLabel,category:t.categoryLabel,content:'<h1 class="heading">Insert title here</h1><p class="paragraph">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua</p>',attributes:{class:"gjs-fonts gjs-f-h1p"}}),a.add("image",{label:t.imageBlkLabel,category:t.categoryLabel,attributes:{class:"gjs-fonts gjs-f-image"},content:{type:"image",style:{color:"black"},activeOnRender:1}}),a.add("quote",{label:t.quoteBlkLabel,category:t.categoryLabel,content:'<blockquote class="quote">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore ipsum dolor sit</blockquote>',attributes:{class:"fa fa-quote-right"}}),a.add("link",{label:t.linkBlkLabel,category:t.categoryLabel,attributes:{class:"fa fa-link"},content:{type:"link",content:"Link",style:{color:"#3b97e3"}}}),a.add("link-block",{label:t.linkBlockBlkLabel,category:t.categoryLabel,attributes:{class:"fa fa-link"},content:{type:"link",editable:!1,droppable:!0,style:{display:"inline-block",padding:"5px","min-height":"50px","min-width":"50px"}}});var c='<table class="grid-item-card">\n        <tr>\n          <td class="grid-item-card-cell">\n            <img class="grid-item-image" src="http://placehold.it/250x150/78c5d6/fff/" alt="Image"/>\n            <table class="grid-item-card-body">\n              <tr>\n                <td class="grid-item-card-content">\n                  <h1 class="card-title">Title here</h1>\n                  <p class="card-text">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt</p>\n                </td>\n              </tr>\n            </table>\n          </td>\n        </tr>\n      </table>';a.add("grid-items",{label:t.gridItemsBlkLabel,category:t.categoryLabel,content:'<table class="grid-item-row">\n        <tr>\n          <td class="grid-item-cell2-l">'+c+'</td>\n          <td class="grid-item-cell2-r">'+c+"</td>\n        </tr>\n      </table>",attributes:{class:"fa fa-th"}});var l='<table class="list-item">\n        <tr>\n          <td class="list-item-cell">\n            <table class="list-item-content">\n              <tr class="list-item-row">\n                <td class="list-cell-left">\n                  <img class="list-item-image" src="http://placehold.it/150x150/78c5d6/fff/" alt="Image"/>\n                </td>\n                <td class="list-cell-right">\n                  <h1 class="card-title">Title here</h1>\n                  <p class="card-text">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt</p>\n                </td>\n              </tr>\n            </table>\n          </td>\n        </tr>\n      </table>';a.add("list-items",{label:t.listItemsBlkLabel,category:t.categoryLabel,content:l+l,attributes:{class:"fa fa-th-list"}})}}.call(e,r,e,t))&&(t.exports=n)},function(t,e,r){"use strict";function n(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var i;void 0!==(i=function(){var t=function(t){t.each(function(t){var e=t.get("attributes");e["data-tooltip-pos"]="bottom",t.set("attributes",e)})};return function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.editor,i=r.Panels,o=i.getPanel("options");if(i.addButton("options",{id:e.cmdOpenImport,className:"fa fa-download",command:e.cmdOpenImport,attributes:n({},"title",e.modalTitleImport)}),i.addButton("options",{id:e.cmdTglImages,className:"fa fa-warning",command:e.cmdTglImages,attributes:n({},"title",e.cmtTglImagesLabel)}),o){var a=o.get("buttons");a.each(function(t){var e=t.get("attributes");e["data-tooltip-pos"]="bottom",t.set("attributes",e)});var s=i.addButton("options","preview");s&&a.remove(s)}var u=i.getPanel("commands");if(u){var c=u.get("buttons");c.reset(),c.add([{id:"undo",className:"fa fa-undo",command:"undo",attributes:n({},"title",e.cmdBtnUndoLabel)},{id:"redo",className:"fa fa-repeat",command:"redo",attributes:n({},"title",e.cmdBtnRedoLabel)}]),t(c)}r.getConfig().showDevices=0;var l=i.addPanel({id:"devices-c"}),f=l.get("buttons");l.get("buttons").add([{id:"deviceDesktop",command:"set-device-desktop",className:"fa fa-desktop",attributes:n({},"title",e.cmdBtnDesktopLabel),active:1},{id:"deviceTablet",command:"set-device-tablet",className:"fa fa-tablet",attributes:n({},"title",e.cmdBtnTabletLabel)},{id:"deviceMobile",command:"set-device-mobile",className:"fa fa-mobile",attributes:n({},"title",e.cmdBtnMobileLabel)}]),t(f)}}.call(e,r,e,t))&&(t.exports=i)},function(t,e,r){"use strict";var n;void 0!==(n=function(){return function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=t.editor,r=e.StyleManager.getSectors();e.on("load",function(){r.reset(),r.add(t.styleManagerSectors)})}}.call(e,r,e,t))&&(t.exports=n)}])});
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

// This is CodeMirror (http://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.CodeMirror = factory());
}(this, (function () { 'use strict';

// Kludges for bugs and behavior differences that can't be feature
// detected are enabled based on userAgent etc sniffing.
var userAgent = navigator.userAgent
var platform = navigator.platform

var gecko = /gecko\/\d/i.test(userAgent)
var ie_upto10 = /MSIE \d/.test(userAgent)
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent)
var edge = /Edge\/(\d+)/.exec(userAgent)
var ie = ie_upto10 || ie_11up || edge
var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1])
var webkit = !edge && /WebKit\//.test(userAgent)
var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent)
var chrome = !edge && /Chrome\//.test(userAgent)
var presto = /Opera\//.test(userAgent)
var safari = /Apple Computer/.test(navigator.vendor)
var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent)
var phantom = /PhantomJS/.test(userAgent)

var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent)
var android = /Android/.test(userAgent)
// This is woefully incomplete. Suggestions for alternative methods welcome.
var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent)
var mac = ios || /Mac/.test(platform)
var chromeOS = /\bCrOS\b/.test(userAgent)
var windows = /win/i.test(platform)

var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/)
if (presto_version) { presto_version = Number(presto_version[1]) }
if (presto_version && presto_version >= 15) { presto = false; webkit = true }
// Some browsers use the wrong event properties to signal cmd/ctrl on OS X
var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11))
var captureRightClick = gecko || (ie && ie_version >= 9)

function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

var rmClass = function(node, cls) {
  var current = node.className
  var match = classTest(cls).exec(current)
  if (match) {
    var after = current.slice(match.index + match[0].length)
    node.className = current.slice(0, match.index) + (after ? match[1] + after : "")
  }
}

function removeChildren(e) {
  for (var count = e.childNodes.length; count > 0; --count)
    { e.removeChild(e.firstChild) }
  return e
}

function removeChildrenAndAdd(parent, e) {
  return removeChildren(parent).appendChild(e)
}

function elt(tag, content, className, style) {
  var e = document.createElement(tag)
  if (className) { e.className = className }
  if (style) { e.style.cssText = style }
  if (typeof content == "string") { e.appendChild(document.createTextNode(content)) }
  else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]) } }
  return e
}
// wrapper for elt, which removes the elt from the accessibility tree
function eltP(tag, content, className, style) {
  var e = elt(tag, content, className, style)
  e.setAttribute("role", "presentation")
  return e
}

var range
if (document.createRange) { range = function(node, start, end, endNode) {
  var r = document.createRange()
  r.setEnd(endNode || node, end)
  r.setStart(node, start)
  return r
} }
else { range = function(node, start, end) {
  var r = document.body.createTextRange()
  try { r.moveToElementText(node.parentNode) }
  catch(e) { return r }
  r.collapse(true)
  r.moveEnd("character", end)
  r.moveStart("character", start)
  return r
} }

function contains(parent, child) {
  if (child.nodeType == 3) // Android browser always returns false when child is a textnode
    { child = child.parentNode }
  if (parent.contains)
    { return parent.contains(child) }
  do {
    if (child.nodeType == 11) { child = child.host }
    if (child == parent) { return true }
  } while (child = child.parentNode)
}

function activeElt() {
  // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
  // IE < 10 will throw when accessed while the page is loading or in an iframe.
  // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
  var activeElement
  try {
    activeElement = document.activeElement
  } catch(e) {
    activeElement = document.body || null
  }
  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
    { activeElement = activeElement.shadowRoot.activeElement }
  return activeElement
}

function addClass(node, cls) {
  var current = node.className
  if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls }
}
function joinClasses(a, b) {
  var as = a.split(" ")
  for (var i = 0; i < as.length; i++)
    { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i] } }
  return b
}

var selectInput = function(node) { node.select() }
if (ios) // Mobile Safari apparently has a bug where select() is broken.
  { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length } }
else if (ie) // Suppress mysterious IE10 errors
  { selectInput = function(node) { try { node.select() } catch(_e) {} } }

function bind(f) {
  var args = Array.prototype.slice.call(arguments, 1)
  return function(){return f.apply(null, args)}
}

function copyObj(obj, target, overwrite) {
  if (!target) { target = {} }
  for (var prop in obj)
    { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
      { target[prop] = obj[prop] } }
  return target
}

// Counts the column offset in a string, taking tabs into account.
// Used mostly to find indentation.
function countColumn(string, end, tabSize, startIndex, startValue) {
  if (end == null) {
    end = string.search(/[^\s\u00a0]/)
    if (end == -1) { end = string.length }
  }
  for (var i = startIndex || 0, n = startValue || 0;;) {
    var nextTab = string.indexOf("\t", i)
    if (nextTab < 0 || nextTab >= end)
      { return n + (end - i) }
    n += nextTab - i
    n += tabSize - (n % tabSize)
    i = nextTab + 1
  }
}

var Delayed = function() {this.id = null};
Delayed.prototype.set = function (ms, f) {
  clearTimeout(this.id)
  this.id = setTimeout(f, ms)
};

function indexOf(array, elt) {
  for (var i = 0; i < array.length; ++i)
    { if (array[i] == elt) { return i } }
  return -1
}

// Number of pixels added to scroller and sizer to hide scrollbar
var scrollerGap = 30

// Returned or thrown by various protocols to signal 'I'm not
// handling this'.
var Pass = {toString: function(){return "CodeMirror.Pass"}}

// Reused option objects for setSelection & friends
var sel_dontScroll = {scroll: false};
var sel_mouse = {origin: "*mouse"};
var sel_move = {origin: "+move"};
// The inverse of countColumn -- find the offset that corresponds to
// a particular column.
function findColumn(string, goal, tabSize) {
  for (var pos = 0, col = 0;;) {
    var nextTab = string.indexOf("\t", pos)
    if (nextTab == -1) { nextTab = string.length }
    var skipped = nextTab - pos
    if (nextTab == string.length || col + skipped >= goal)
      { return pos + Math.min(skipped, goal - col) }
    col += nextTab - pos
    col += tabSize - (col % tabSize)
    pos = nextTab + 1
    if (col >= goal) { return pos }
  }
}

var spaceStrs = [""]
function spaceStr(n) {
  while (spaceStrs.length <= n)
    { spaceStrs.push(lst(spaceStrs) + " ") }
  return spaceStrs[n]
}

function lst(arr) { return arr[arr.length-1] }

function map(array, f) {
  var out = []
  for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i) }
  return out
}

function insertSorted(array, value, score) {
  var pos = 0, priority = score(value)
  while (pos < array.length && score(array[pos]) <= priority) { pos++ }
  array.splice(pos, 0, value)
}

function nothing() {}

function createObj(base, props) {
  var inst
  if (Object.create) {
    inst = Object.create(base)
  } else {
    nothing.prototype = base
    inst = new nothing()
  }
  if (props) { copyObj(props, inst) }
  return inst
}

var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/
function isWordCharBasic(ch) {
  return /\w/.test(ch) || ch > "\x80" &&
    (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
}
function isWordChar(ch, helper) {
  if (!helper) { return isWordCharBasic(ch) }
  if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
  return helper.test(ch)
}

function isEmpty(obj) {
  for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
  return true
}

// Extending unicode characters. A series of a non-extending char +
// any number of extending chars is treated as a single unit as far
// as editing and measuring is concerned. This is not fully correct,
// since some scripts/fonts/browsers also treat other configurations
// of code points as a group.
var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/
function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

// Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
function skipExtendingChars(str, pos, dir) {
  while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir }
  return pos
}

// Returns the value from the range [`from`; `to`] that satisfies
// `pred` and is closest to `from`. Assumes that at least `to`
// satisfies `pred`. Supports `from` being greater than `to`.
function findFirst(pred, from, to) {
  // At any point we are certain `to` satisfies `pred`, don't know
  // whether `from` does.
  var dir = from > to ? -1 : 1
  for (;;) {
    if (from == to) { return from }
    var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF)
    if (mid == from) { return pred(mid) ? from : to }
    if (pred(mid)) { to = mid }
    else { from = mid + dir }
  }
}

// The display handles the DOM integration, both for input reading
// and content drawing. It holds references to DOM nodes and
// display-related state.

function Display(place, doc, input) {
  var d = this
  this.input = input

  // Covers bottom-right square when both scrollbars are present.
  d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler")
  d.scrollbarFiller.setAttribute("cm-not-content", "true")
  // Covers bottom of gutter when coverGutterNextToScrollbar is on
  // and h scrollbar is present.
  d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler")
  d.gutterFiller.setAttribute("cm-not-content", "true")
  // Will contain the actual code, positioned to cover the viewport.
  d.lineDiv = eltP("div", null, "CodeMirror-code")
  // Elements are added to these to represent selection and cursors.
  d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1")
  d.cursorDiv = elt("div", null, "CodeMirror-cursors")
  // A visibility: hidden element used to find the size of things.
  d.measure = elt("div", null, "CodeMirror-measure")
  // When lines outside of the viewport are measured, they are drawn in this.
  d.lineMeasure = elt("div", null, "CodeMirror-measure")
  // Wraps everything that needs to exist inside the vertically-padded coordinate system
  d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                    null, "position: relative; outline: none")
  var lines = eltP("div", [d.lineSpace], "CodeMirror-lines")
  // Moved around its parent to cover visible view.
  d.mover = elt("div", [lines], null, "position: relative")
  // Set to the height of the document, allowing scrolling.
  d.sizer = elt("div", [d.mover], "CodeMirror-sizer")
  d.sizerWidth = null
  // Behavior of elts with overflow: auto and padding is
  // inconsistent across browsers. This is used to ensure the
  // scrollable area is big enough.
  d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;")
  // Will contain the gutters, if any.
  d.gutters = elt("div", null, "CodeMirror-gutters")
  d.lineGutter = null
  // Actual scrollable element.
  d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll")
  d.scroller.setAttribute("tabIndex", "-1")
  // The element in which the editor lives.
  d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror")

  // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
  if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0 }
  if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true }

  if (place) {
    if (place.appendChild) { place.appendChild(d.wrapper) }
    else { place(d.wrapper) }
  }

  // Current rendered range (may be bigger than the view window).
  d.viewFrom = d.viewTo = doc.first
  d.reportedViewFrom = d.reportedViewTo = doc.first
  // Information about the rendered lines.
  d.view = []
  d.renderedView = null
  // Holds info about a single rendered line when it was rendered
  // for measurement, while not in view.
  d.externalMeasured = null
  // Empty space (in pixels) above the view
  d.viewOffset = 0
  d.lastWrapHeight = d.lastWrapWidth = 0
  d.updateLineNumbers = null

  d.nativeBarWidth = d.barHeight = d.barWidth = 0
  d.scrollbarsClipped = false

  // Used to only resize the line number gutter when necessary (when
  // the amount of lines crosses a boundary that makes its width change)
  d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null
  // Set to true when a non-horizontal-scrolling line widget is
  // added. As an optimization, line widget aligning is skipped when
  // this is false.
  d.alignWidgets = false

  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null

  // Tracks the maximum line length so that the horizontal scrollbar
  // can be kept static when scrolling.
  d.maxLine = null
  d.maxLineLength = 0
  d.maxLineChanged = false

  // Used for measuring wheel scrolling granularity
  d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null

  // True when shift is held down.
  d.shift = false

  // Used to track whether anything happened since the context menu
  // was opened.
  d.selForContextMenu = null

  d.activeTouch = null

  input.init(d)
}

// Find the line object corresponding to the given line number.
function getLine(doc, n) {
  n -= doc.first
  if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
  var chunk = doc
  while (!chunk.lines) {
    for (var i = 0;; ++i) {
      var child = chunk.children[i], sz = child.chunkSize()
      if (n < sz) { chunk = child; break }
      n -= sz
    }
  }
  return chunk.lines[n]
}

// Get the part of a document between two positions, as an array of
// strings.
function getBetween(doc, start, end) {
  var out = [], n = start.line
  doc.iter(start.line, end.line + 1, function (line) {
    var text = line.text
    if (n == end.line) { text = text.slice(0, end.ch) }
    if (n == start.line) { text = text.slice(start.ch) }
    out.push(text)
    ++n
  })
  return out
}
// Get the lines between from and to, as array of strings.
function getLines(doc, from, to) {
  var out = []
  doc.iter(from, to, function (line) { out.push(line.text) }) // iter aborts when callback returns truthy value
  return out
}

// Update the height of a line, propagating the height change
// upwards to parent nodes.
function updateLineHeight(line, height) {
  var diff = height - line.height
  if (diff) { for (var n = line; n; n = n.parent) { n.height += diff } }
}

// Given a line object, find its line number by walking up through
// its parent links.
function lineNo(line) {
  if (line.parent == null) { return null }
  var cur = line.parent, no = indexOf(cur.lines, line)
  for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
    for (var i = 0;; ++i) {
      if (chunk.children[i] == cur) { break }
      no += chunk.children[i].chunkSize()
    }
  }
  return no + cur.first
}

// Find the line at the given vertical position, using the height
// information in the document tree.
function lineAtHeight(chunk, h) {
  var n = chunk.first
  outer: do {
    for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
      var child = chunk.children[i$1], ch = child.height
      if (h < ch) { chunk = child; continue outer }
      h -= ch
      n += child.chunkSize()
    }
    return n
  } while (!chunk.lines)
  var i = 0
  for (; i < chunk.lines.length; ++i) {
    var line = chunk.lines[i], lh = line.height
    if (h < lh) { break }
    h -= lh
  }
  return n + i
}

function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

function lineNumberFor(options, i) {
  return String(options.lineNumberFormatter(i + options.firstLineNumber))
}

// A Pos instance represents a position within the text.
function Pos(line, ch, sticky) {
  if ( sticky === void 0 ) sticky = null;

  if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
  this.line = line
  this.ch = ch
  this.sticky = sticky
}

// Compare two positions, return 0 if they are the same, a negative
// number when a is less, and a positive number otherwise.
function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

function copyPos(x) {return Pos(x.line, x.ch)}
function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

// Most of the external API clips given positions to make sure they
// actually exist within the document.
function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
function clipPos(doc, pos) {
  if (pos.line < doc.first) { return Pos(doc.first, 0) }
  var last = doc.first + doc.size - 1
  if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
  return clipToLen(pos, getLine(doc, pos.line).text.length)
}
function clipToLen(pos, linelen) {
  var ch = pos.ch
  if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
  else if (ch < 0) { return Pos(pos.line, 0) }
  else { return pos }
}
function clipPosArray(doc, array) {
  var out = []
  for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]) }
  return out
}

// Optimize some code when these features are not used.
var sawReadOnlySpans = false;
var sawCollapsedSpans = false;
function seeReadOnlySpans() {
  sawReadOnlySpans = true
}

function seeCollapsedSpans() {
  sawCollapsedSpans = true
}

// TEXTMARKER SPANS

function MarkedSpan(marker, from, to) {
  this.marker = marker
  this.from = from; this.to = to
}

// Search an array of spans for a span matching the given marker.
function getMarkedSpanFor(spans, marker) {
  if (spans) { for (var i = 0; i < spans.length; ++i) {
    var span = spans[i]
    if (span.marker == marker) { return span }
  } }
}
// Remove a span from an array, returning undefined if no spans are
// left (we don't store arrays for lines without spans).
function removeMarkedSpan(spans, span) {
  var r
  for (var i = 0; i < spans.length; ++i)
    { if (spans[i] != span) { (r || (r = [])).push(spans[i]) } }
  return r
}
// Add a span to a line.
function addMarkedSpan(line, span) {
  line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span]
  span.marker.attachLine(line)
}

// Used for the algorithm that adjusts markers for a change in the
// document. These functions cut an array of spans at a given
// character position, returning an array of remaining chunks (or
// undefined if nothing remains).
function markedSpansBefore(old, startCh, isInsert) {
  var nw
  if (old) { for (var i = 0; i < old.length; ++i) {
    var span = old[i], marker = span.marker
    var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh)
    if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
      ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to))
    }
  } }
  return nw
}
function markedSpansAfter(old, endCh, isInsert) {
  var nw
  if (old) { for (var i = 0; i < old.length; ++i) {
    var span = old[i], marker = span.marker
    var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh)
    if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
      ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                            span.to == null ? null : span.to - endCh))
    }
  } }
  return nw
}

// Given a change object, compute the new set of marker spans that
// cover the line in which the change took place. Removes spans
// entirely within the change, reconnects spans belonging to the
// same marker that appear on both sides of the change, and cuts off
// spans partially within the change. Returns an array of span
// arrays with one element for each line in (after) the change.
function stretchSpansOverChange(doc, change) {
  if (change.full) { return null }
  var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans
  var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans
  if (!oldFirst && !oldLast) { return null }

  var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0
  // Get the spans that 'stick out' on both sides
  var first = markedSpansBefore(oldFirst, startCh, isInsert)
  var last = markedSpansAfter(oldLast, endCh, isInsert)

  // Next, merge those two ends
  var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0)
  if (first) {
    // Fix up .to properties of first
    for (var i = 0; i < first.length; ++i) {
      var span = first[i]
      if (span.to == null) {
        var found = getMarkedSpanFor(last, span.marker)
        if (!found) { span.to = startCh }
        else if (sameLine) { span.to = found.to == null ? null : found.to + offset }
      }
    }
  }
  if (last) {
    // Fix up .from in last (or move them into first in case of sameLine)
    for (var i$1 = 0; i$1 < last.length; ++i$1) {
      var span$1 = last[i$1]
      if (span$1.to != null) { span$1.to += offset }
      if (span$1.from == null) {
        var found$1 = getMarkedSpanFor(first, span$1.marker)
        if (!found$1) {
          span$1.from = offset
          if (sameLine) { (first || (first = [])).push(span$1) }
        }
      } else {
        span$1.from += offset
        if (sameLine) { (first || (first = [])).push(span$1) }
      }
    }
  }
  // Make sure we didn't create any zero-length spans
  if (first) { first = clearEmptySpans(first) }
  if (last && last != first) { last = clearEmptySpans(last) }

  var newMarkers = [first]
  if (!sameLine) {
    // Fill gap with whole-line-spans
    var gap = change.text.length - 2, gapMarkers
    if (gap > 0 && first)
      { for (var i$2 = 0; i$2 < first.length; ++i$2)
        { if (first[i$2].to == null)
          { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)) } } }
    for (var i$3 = 0; i$3 < gap; ++i$3)
      { newMarkers.push(gapMarkers) }
    newMarkers.push(last)
  }
  return newMarkers
}

// Remove spans that are empty and don't have a clearWhenEmpty
// option of false.
function clearEmptySpans(spans) {
  for (var i = 0; i < spans.length; ++i) {
    var span = spans[i]
    if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
      { spans.splice(i--, 1) }
  }
  if (!spans.length) { return null }
  return spans
}

// Used to 'clip' out readOnly ranges when making a change.
function removeReadOnlyRanges(doc, from, to) {
  var markers = null
  doc.iter(from.line, to.line + 1, function (line) {
    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
      var mark = line.markedSpans[i].marker
      if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
        { (markers || (markers = [])).push(mark) }
    } }
  })
  if (!markers) { return null }
  var parts = [{from: from, to: to}]
  for (var i = 0; i < markers.length; ++i) {
    var mk = markers[i], m = mk.find(0)
    for (var j = 0; j < parts.length; ++j) {
      var p = parts[j]
      if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
      var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to)
      if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
        { newParts.push({from: p.from, to: m.from}) }
      if (dto > 0 || !mk.inclusiveRight && !dto)
        { newParts.push({from: m.to, to: p.to}) }
      parts.splice.apply(parts, newParts)
      j += newParts.length - 3
    }
  }
  return parts
}

// Connect or disconnect spans from a line.
function detachMarkedSpans(line) {
  var spans = line.markedSpans
  if (!spans) { return }
  for (var i = 0; i < spans.length; ++i)
    { spans[i].marker.detachLine(line) }
  line.markedSpans = null
}
function attachMarkedSpans(line, spans) {
  if (!spans) { return }
  for (var i = 0; i < spans.length; ++i)
    { spans[i].marker.attachLine(line) }
  line.markedSpans = spans
}

// Helpers used when computing which overlapping collapsed span
// counts as the larger one.
function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

// Returns a number indicating which of two overlapping collapsed
// spans is larger (and thus includes the other). Falls back to
// comparing ids when the spans cover exactly the same range.
function compareCollapsedMarkers(a, b) {
  var lenDiff = a.lines.length - b.lines.length
  if (lenDiff != 0) { return lenDiff }
  var aPos = a.find(), bPos = b.find()
  var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b)
  if (fromCmp) { return -fromCmp }
  var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b)
  if (toCmp) { return toCmp }
  return b.id - a.id
}

// Find out whether a line ends or starts in a collapsed span. If
// so, return the marker for that span.
function collapsedSpanAtSide(line, start) {
  var sps = sawCollapsedSpans && line.markedSpans, found
  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
    sp = sps[i]
    if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
        (!found || compareCollapsedMarkers(found, sp.marker) < 0))
      { found = sp.marker }
  } }
  return found
}
function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

// Test whether there exists a collapsed span that partially
// overlaps (covers the start or end, but not both) of a new span.
// Such overlap is not allowed.
function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
  var line = getLine(doc, lineNo)
  var sps = sawCollapsedSpans && line.markedSpans
  if (sps) { for (var i = 0; i < sps.length; ++i) {
    var sp = sps[i]
    if (!sp.marker.collapsed) { continue }
    var found = sp.marker.find(0)
    var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker)
    var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker)
    if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
    if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
        fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
      { return true }
  } }
}

// A visual line is a line as drawn on the screen. Folding, for
// example, can cause multiple logical lines to appear on the same
// visual line. This finds the start of the visual line that the
// given line is part of (usually that is the line itself).
function visualLine(line) {
  var merged
  while (merged = collapsedSpanAtStart(line))
    { line = merged.find(-1, true).line }
  return line
}

function visualLineEnd(line) {
  var merged
  while (merged = collapsedSpanAtEnd(line))
    { line = merged.find(1, true).line }
  return line
}

// Returns an array of logical lines that continue the visual line
// started by the argument, or undefined if there are no such lines.
function visualLineContinued(line) {
  var merged, lines
  while (merged = collapsedSpanAtEnd(line)) {
    line = merged.find(1, true).line
    ;(lines || (lines = [])).push(line)
  }
  return lines
}

// Get the line number of the start of the visual line that the
// given line number is part of.
function visualLineNo(doc, lineN) {
  var line = getLine(doc, lineN), vis = visualLine(line)
  if (line == vis) { return lineN }
  return lineNo(vis)
}

// Get the line number of the start of the next visual line after
// the given line.
function visualLineEndNo(doc, lineN) {
  if (lineN > doc.lastLine()) { return lineN }
  var line = getLine(doc, lineN), merged
  if (!lineIsHidden(doc, line)) { return lineN }
  while (merged = collapsedSpanAtEnd(line))
    { line = merged.find(1, true).line }
  return lineNo(line) + 1
}

// Compute whether a line is hidden. Lines count as hidden when they
// are part of a visual line that starts with another line, or when
// they are entirely covered by collapsed, non-widget span.
function lineIsHidden(doc, line) {
  var sps = sawCollapsedSpans && line.markedSpans
  if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
    sp = sps[i]
    if (!sp.marker.collapsed) { continue }
    if (sp.from == null) { return true }
    if (sp.marker.widgetNode) { continue }
    if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
      { return true }
  } }
}
function lineIsHiddenInner(doc, line, span) {
  if (span.to == null) {
    var end = span.marker.find(1, true)
    return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
  }
  if (span.marker.inclusiveRight && span.to == line.text.length)
    { return true }
  for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
    sp = line.markedSpans[i]
    if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
        (sp.to == null || sp.to != span.from) &&
        (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
        lineIsHiddenInner(doc, line, sp)) { return true }
  }
}

// Find the height above the given line.
function heightAtLine(lineObj) {
  lineObj = visualLine(lineObj)

  var h = 0, chunk = lineObj.parent
  for (var i = 0; i < chunk.lines.length; ++i) {
    var line = chunk.lines[i]
    if (line == lineObj) { break }
    else { h += line.height }
  }
  for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
    for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
      var cur = p.children[i$1]
      if (cur == chunk) { break }
      else { h += cur.height }
    }
  }
  return h
}

// Compute the character length of a line, taking into account
// collapsed ranges (see markText) that might hide parts, and join
// other lines onto it.
function lineLength(line) {
  if (line.height == 0) { return 0 }
  var len = line.text.length, merged, cur = line
  while (merged = collapsedSpanAtStart(cur)) {
    var found = merged.find(0, true)
    cur = found.from.line
    len += found.from.ch - found.to.ch
  }
  cur = line
  while (merged = collapsedSpanAtEnd(cur)) {
    var found$1 = merged.find(0, true)
    len -= cur.text.length - found$1.from.ch
    cur = found$1.to.line
    len += cur.text.length - found$1.to.ch
  }
  return len
}

// Find the longest line in the document.
function findMaxLine(cm) {
  var d = cm.display, doc = cm.doc
  d.maxLine = getLine(doc, doc.first)
  d.maxLineLength = lineLength(d.maxLine)
  d.maxLineChanged = true
  doc.iter(function (line) {
    var len = lineLength(line)
    if (len > d.maxLineLength) {
      d.maxLineLength = len
      d.maxLine = line
    }
  })
}

// BIDI HELPERS

function iterateBidiSections(order, from, to, f) {
  if (!order) { return f(from, to, "ltr", 0) }
  var found = false
  for (var i = 0; i < order.length; ++i) {
    var part = order[i]
    if (part.from < to && part.to > from || from == to && part.to == from) {
      f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i)
      found = true
    }
  }
  if (!found) { f(from, to, "ltr") }
}

var bidiOther = null
function getBidiPartAt(order, ch, sticky) {
  var found
  bidiOther = null
  for (var i = 0; i < order.length; ++i) {
    var cur = order[i]
    if (cur.from < ch && cur.to > ch) { return i }
    if (cur.to == ch) {
      if (cur.from != cur.to && sticky == "before") { found = i }
      else { bidiOther = i }
    }
    if (cur.from == ch) {
      if (cur.from != cur.to && sticky != "before") { found = i }
      else { bidiOther = i }
    }
  }
  return found != null ? found : bidiOther
}

// Bidirectional ordering algorithm
// See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
// that this (partially) implements.

// One-char codes used for character types:
// L (L):   Left-to-Right
// R (R):   Right-to-Left
// r (AL):  Right-to-Left Arabic
// 1 (EN):  European Number
// + (ES):  European Number Separator
// % (ET):  European Number Terminator
// n (AN):  Arabic Number
// , (CS):  Common Number Separator
// m (NSM): Non-Spacing Mark
// b (BN):  Boundary Neutral
// s (B):   Paragraph Separator
// t (S):   Segment Separator
// w (WS):  Whitespace
// N (ON):  Other Neutrals

// Returns null if characters are ordered as they appear
// (left-to-right), or an array of sections ({from, to, level}
// objects) in the order in which they occur visually.
var bidiOrdering = (function() {
  // Character types for codepoints 0 to 0xff
  var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN"
  // Character types for codepoints 0x600 to 0x6f9
  var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111"
  function charType(code) {
    if (code <= 0xf7) { return lowTypes.charAt(code) }
    else if (0x590 <= code && code <= 0x5f4) { return "R" }
    else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
    else if (0x6ee <= code && code <= 0x8ac) { return "r" }
    else if (0x2000 <= code && code <= 0x200b) { return "w" }
    else if (code == 0x200c) { return "b" }
    else { return "L" }
  }

  var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/
  var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/

  function BidiSpan(level, from, to) {
    this.level = level
    this.from = from; this.to = to
  }

  return function(str, direction) {
    var outerType = direction == "ltr" ? "L" : "R"

    if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
    var len = str.length, types = []
    for (var i = 0; i < len; ++i)
      { types.push(charType(str.charCodeAt(i))) }

    // W1. Examine each non-spacing mark (NSM) in the level run, and
    // change the type of the NSM to the type of the previous
    // character. If the NSM is at the start of the level run, it will
    // get the type of sor.
    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
      var type = types[i$1]
      if (type == "m") { types[i$1] = prev }
      else { prev = type }
    }

    // W2. Search backwards from each instance of a European number
    // until the first strong type (R, L, AL, or sor) is found. If an
    // AL is found, change the type of the European number to Arabic
    // number.
    // W3. Change all ALs to R.
    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
      var type$1 = types[i$2]
      if (type$1 == "1" && cur == "r") { types[i$2] = "n" }
      else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R" } }
    }

    // W4. A single European separator between two European numbers
    // changes to a European number. A single common separator between
    // two numbers of the same type changes to that type.
    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
      var type$2 = types[i$3]
      if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1" }
      else if (type$2 == "," && prev$1 == types[i$3+1] &&
               (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1 }
      prev$1 = type$2
    }

    // W5. A sequence of European terminators adjacent to European
    // numbers changes to all European numbers.
    // W6. Otherwise, separators and terminators change to Other
    // Neutral.
    for (var i$4 = 0; i$4 < len; ++i$4) {
      var type$3 = types[i$4]
      if (type$3 == ",") { types[i$4] = "N" }
      else if (type$3 == "%") {
        var end = (void 0)
        for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
        var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N"
        for (var j = i$4; j < end; ++j) { types[j] = replace }
        i$4 = end - 1
      }
    }

    // W7. Search backwards from each instance of a European number
    // until the first strong type (R, L, or sor) is found. If an L is
    // found, then change the type of the European number to L.
    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
      var type$4 = types[i$5]
      if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L" }
      else if (isStrong.test(type$4)) { cur$1 = type$4 }
    }

    // N1. A sequence of neutrals takes the direction of the
    // surrounding strong text if the text on both sides has the same
    // direction. European and Arabic numbers act as if they were R in
    // terms of their influence on neutrals. Start-of-level-run (sor)
    // and end-of-level-run (eor) are used at level run boundaries.
    // N2. Any remaining neutrals take the embedding direction.
    for (var i$6 = 0; i$6 < len; ++i$6) {
      if (isNeutral.test(types[i$6])) {
        var end$1 = (void 0)
        for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
        var before = (i$6 ? types[i$6-1] : outerType) == "L"
        var after = (end$1 < len ? types[end$1] : outerType) == "L"
        var replace$1 = before == after ? (before ? "L" : "R") : outerType
        for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1 }
        i$6 = end$1 - 1
      }
    }

    // Here we depart from the documented algorithm, in order to avoid
    // building up an actual levels array. Since there are only three
    // levels (0, 1, 2) in an implementation that doesn't take
    // explicit embedding into account, we can build up the order on
    // the fly, without following the level-based algorithm.
    var order = [], m
    for (var i$7 = 0; i$7 < len;) {
      if (countsAsLeft.test(types[i$7])) {
        var start = i$7
        for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
        order.push(new BidiSpan(0, start, i$7))
      } else {
        var pos = i$7, at = order.length
        for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
        for (var j$2 = pos; j$2 < i$7;) {
          if (countsAsNum.test(types[j$2])) {
            if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)) }
            var nstart = j$2
            for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
            order.splice(at, 0, new BidiSpan(2, nstart, j$2))
            pos = j$2
          } else { ++j$2 }
        }
        if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)) }
      }
    }
    if (order[0].level == 1 && (m = str.match(/^\s+/))) {
      order[0].from = m[0].length
      order.unshift(new BidiSpan(0, 0, m[0].length))
    }
    if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
      lst(order).to -= m[0].length
      order.push(new BidiSpan(0, len - m[0].length, len))
    }

    return direction == "rtl" ? order.reverse() : order
  }
})()

// Get the bidi ordering for the given line (and cache it). Returns
// false for lines that are fully left-to-right, and an array of
// BidiSpan objects otherwise.
function getOrder(line, direction) {
  var order = line.order
  if (order == null) { order = line.order = bidiOrdering(line.text, direction) }
  return order
}

// EVENT HANDLING

// Lightweight event framework. on/off also work on DOM nodes,
// registering native DOM handlers.

var noHandlers = []

var on = function(emitter, type, f) {
  if (emitter.addEventListener) {
    emitter.addEventListener(type, f, false)
  } else if (emitter.attachEvent) {
    emitter.attachEvent("on" + type, f)
  } else {
    var map = emitter._handlers || (emitter._handlers = {})
    map[type] = (map[type] || noHandlers).concat(f)
  }
}

function getHandlers(emitter, type) {
  return emitter._handlers && emitter._handlers[type] || noHandlers
}

function off(emitter, type, f) {
  if (emitter.removeEventListener) {
    emitter.removeEventListener(type, f, false)
  } else if (emitter.detachEvent) {
    emitter.detachEvent("on" + type, f)
  } else {
    var map = emitter._handlers, arr = map && map[type]
    if (arr) {
      var index = indexOf(arr, f)
      if (index > -1)
        { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)) }
    }
  }
}

function signal(emitter, type /*, values...*/) {
  var handlers = getHandlers(emitter, type)
  if (!handlers.length) { return }
  var args = Array.prototype.slice.call(arguments, 2)
  for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args) }
}

// The DOM events that CodeMirror handles can be overridden by
// registering a (non-DOM) handler on the editor for the event name,
// and preventDefault-ing the event in that handler.
function signalDOMEvent(cm, e, override) {
  if (typeof e == "string")
    { e = {type: e, preventDefault: function() { this.defaultPrevented = true }} }
  signal(cm, override || e.type, cm, e)
  return e_defaultPrevented(e) || e.codemirrorIgnore
}

function signalCursorActivity(cm) {
  var arr = cm._handlers && cm._handlers.cursorActivity
  if (!arr) { return }
  var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = [])
  for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
    { set.push(arr[i]) } }
}

function hasHandler(emitter, type) {
  return getHandlers(emitter, type).length > 0
}

// Add on and off methods to a constructor's prototype, to make
// registering events on such objects more convenient.
function eventMixin(ctor) {
  ctor.prototype.on = function(type, f) {on(this, type, f)}
  ctor.prototype.off = function(type, f) {off(this, type, f)}
}

// Due to the fact that we still support jurassic IE versions, some
// compatibility wrappers are needed.

function e_preventDefault(e) {
  if (e.preventDefault) { e.preventDefault() }
  else { e.returnValue = false }
}
function e_stopPropagation(e) {
  if (e.stopPropagation) { e.stopPropagation() }
  else { e.cancelBubble = true }
}
function e_defaultPrevented(e) {
  return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
}
function e_stop(e) {e_preventDefault(e); e_stopPropagation(e)}

function e_target(e) {return e.target || e.srcElement}
function e_button(e) {
  var b = e.which
  if (b == null) {
    if (e.button & 1) { b = 1 }
    else if (e.button & 2) { b = 3 }
    else if (e.button & 4) { b = 2 }
  }
  if (mac && e.ctrlKey && b == 1) { b = 3 }
  return b
}

// Detect drag-and-drop
var dragAndDrop = function() {
  // There is *some* kind of drag-and-drop support in IE6-8, but I
  // couldn't get it to work yet.
  if (ie && ie_version < 9) { return false }
  var div = elt('div')
  return "draggable" in div || "dragDrop" in div
}()

var zwspSupported
function zeroWidthElement(measure) {
  if (zwspSupported == null) {
    var test = elt("span", "\u200b")
    removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]))
    if (measure.firstChild.offsetHeight != 0)
      { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8) }
  }
  var node = zwspSupported ? elt("span", "\u200b") :
    elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px")
  node.setAttribute("cm-text", "")
  return node
}

// Feature-detect IE's crummy client rect reporting for bidi text
var badBidiRects
function hasBadBidiRects(measure) {
  if (badBidiRects != null) { return badBidiRects }
  var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"))
  var r0 = range(txt, 0, 1).getBoundingClientRect()
  var r1 = range(txt, 1, 2).getBoundingClientRect()
  removeChildren(measure)
  if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
  return badBidiRects = (r1.right - r0.right < 3)
}

// See if "".split is the broken IE version, if so, provide an
// alternative way to split lines.
var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
  var pos = 0, result = [], l = string.length
  while (pos <= l) {
    var nl = string.indexOf("\n", pos)
    if (nl == -1) { nl = string.length }
    var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl)
    var rt = line.indexOf("\r")
    if (rt != -1) {
      result.push(line.slice(0, rt))
      pos += rt + 1
    } else {
      result.push(line)
      pos = nl + 1
    }
  }
  return result
} : function (string) { return string.split(/\r\n?|\n/); }

var hasSelection = window.getSelection ? function (te) {
  try { return te.selectionStart != te.selectionEnd }
  catch(e) { return false }
} : function (te) {
  var range
  try {range = te.ownerDocument.selection.createRange()}
  catch(e) {}
  if (!range || range.parentElement() != te) { return false }
  return range.compareEndPoints("StartToEnd", range) != 0
}

var hasCopyEvent = (function () {
  var e = elt("div")
  if ("oncopy" in e) { return true }
  e.setAttribute("oncopy", "return;")
  return typeof e.oncopy == "function"
})()

var badZoomedRects = null
function hasBadZoomedRects(measure) {
  if (badZoomedRects != null) { return badZoomedRects }
  var node = removeChildrenAndAdd(measure, elt("span", "x"))
  var normal = node.getBoundingClientRect()
  var fromRange = range(node, 0, 1).getBoundingClientRect()
  return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
}

var modes = {};
var mimeModes = {};
// Extra arguments are stored as the mode's dependencies, which is
// used by (legacy) mechanisms like loadmode.js to automatically
// load a mode. (Preferred mechanism is the require/define calls.)
function defineMode(name, mode) {
  if (arguments.length > 2)
    { mode.dependencies = Array.prototype.slice.call(arguments, 2) }
  modes[name] = mode
}

function defineMIME(mime, spec) {
  mimeModes[mime] = spec
}

// Given a MIME type, a {name, ...options} config object, or a name
// string, return a mode config object.
function resolveMode(spec) {
  if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
    spec = mimeModes[spec]
  } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
    var found = mimeModes[spec.name]
    if (typeof found == "string") { found = {name: found} }
    spec = createObj(found, spec)
    spec.name = found.name
  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
    return resolveMode("application/xml")
  } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
    return resolveMode("application/json")
  }
  if (typeof spec == "string") { return {name: spec} }
  else { return spec || {name: "null"} }
}

// Given a mode spec (anything that resolveMode accepts), find and
// initialize an actual mode object.
function getMode(options, spec) {
  spec = resolveMode(spec)
  var mfactory = modes[spec.name]
  if (!mfactory) { return getMode(options, "text/plain") }
  var modeObj = mfactory(options, spec)
  if (modeExtensions.hasOwnProperty(spec.name)) {
    var exts = modeExtensions[spec.name]
    for (var prop in exts) {
      if (!exts.hasOwnProperty(prop)) { continue }
      if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop] }
      modeObj[prop] = exts[prop]
    }
  }
  modeObj.name = spec.name
  if (spec.helperType) { modeObj.helperType = spec.helperType }
  if (spec.modeProps) { for (var prop$1 in spec.modeProps)
    { modeObj[prop$1] = spec.modeProps[prop$1] } }

  return modeObj
}

// This can be used to attach properties to mode objects from
// outside the actual mode definition.
var modeExtensions = {}
function extendMode(mode, properties) {
  var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {})
  copyObj(properties, exts)
}

function copyState(mode, state) {
  if (state === true) { return state }
  if (mode.copyState) { return mode.copyState(state) }
  var nstate = {}
  for (var n in state) {
    var val = state[n]
    if (val instanceof Array) { val = val.concat([]) }
    nstate[n] = val
  }
  return nstate
}

// Given a mode and a state (for that mode), find the inner mode and
// state at the position that the state refers to.
function innerMode(mode, state) {
  var info
  while (mode.innerMode) {
    info = mode.innerMode(state)
    if (!info || info.mode == mode) { break }
    state = info.state
    mode = info.mode
  }
  return info || {mode: mode, state: state}
}

function startState(mode, a1, a2) {
  return mode.startState ? mode.startState(a1, a2) : true
}

// STRING STREAM

// Fed to the mode parsers, provides helper functions to make
// parsers more succinct.

var StringStream = function(string, tabSize, lineOracle) {
  this.pos = this.start = 0
  this.string = string
  this.tabSize = tabSize || 8
  this.lastColumnPos = this.lastColumnValue = 0
  this.lineStart = 0
  this.lineOracle = lineOracle
};

StringStream.prototype.eol = function () {return this.pos >= this.string.length};
StringStream.prototype.sol = function () {return this.pos == this.lineStart};
StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
StringStream.prototype.next = function () {
  if (this.pos < this.string.length)
    { return this.string.charAt(this.pos++) }
};
StringStream.prototype.eat = function (match) {
  var ch = this.string.charAt(this.pos)
  var ok
  if (typeof match == "string") { ok = ch == match }
  else { ok = ch && (match.test ? match.test(ch) : match(ch)) }
  if (ok) {++this.pos; return ch}
};
StringStream.prototype.eatWhile = function (match) {
  var start = this.pos
  while (this.eat(match)){}
  return this.pos > start
};
StringStream.prototype.eatSpace = function () {
    var this$1 = this;

  var start = this.pos
  while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos }
  return this.pos > start
};
StringStream.prototype.skipToEnd = function () {this.pos = this.string.length};
StringStream.prototype.skipTo = function (ch) {
  var found = this.string.indexOf(ch, this.pos)
  if (found > -1) {this.pos = found; return true}
};
StringStream.prototype.backUp = function (n) {this.pos -= n};
StringStream.prototype.column = function () {
  if (this.lastColumnPos < this.start) {
    this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue)
    this.lastColumnPos = this.start
  }
  return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
};
StringStream.prototype.indentation = function () {
  return countColumn(this.string, null, this.tabSize) -
    (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
};
StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
  if (typeof pattern == "string") {
    var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; }
    var substr = this.string.substr(this.pos, pattern.length)
    if (cased(substr) == cased(pattern)) {
      if (consume !== false) { this.pos += pattern.length }
      return true
    }
  } else {
    var match = this.string.slice(this.pos).match(pattern)
    if (match && match.index > 0) { return null }
    if (match && consume !== false) { this.pos += match[0].length }
    return match
  }
};
StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
StringStream.prototype.hideFirstChars = function (n, inner) {
  this.lineStart += n
  try { return inner() }
  finally { this.lineStart -= n }
};
StringStream.prototype.lookAhead = function (n) {
  var oracle = this.lineOracle
  return oracle && oracle.lookAhead(n)
};

var SavedContext = function(state, lookAhead) {
  this.state = state
  this.lookAhead = lookAhead
};

var Context = function(doc, state, line, lookAhead) {
  this.state = state
  this.doc = doc
  this.line = line
  this.maxLookAhead = lookAhead || 0
};

Context.prototype.lookAhead = function (n) {
  var line = this.doc.getLine(this.line + n)
  if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n }
  return line
};

Context.prototype.nextLine = function () {
  this.line++
  if (this.maxLookAhead > 0) { this.maxLookAhead-- }
};

Context.fromSaved = function (doc, saved, line) {
  if (saved instanceof SavedContext)
    { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
  else
    { return new Context(doc, copyState(doc.mode, saved), line) }
};

Context.prototype.save = function (copy) {
  var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state
  return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
};


// Compute a style array (an array starting with a mode generation
// -- for invalidation -- followed by pairs of end positions and
// style strings), which is used to highlight the tokens on the
// line.
function highlightLine(cm, line, context, forceToEnd) {
  // A styles array always starts with a number identifying the
  // mode/overlays that it is based on (for easy invalidation).
  var st = [cm.state.modeGen], lineClasses = {}
  // Compute the base array of styles
  runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
          lineClasses, forceToEnd)
  var state = context.state

  // Run overlays, adjust style array.
  var loop = function ( o ) {
    var overlay = cm.state.overlays[o], i = 1, at = 0
    context.state = true
    runMode(cm, line.text, overlay.mode, context, function (end, style) {
      var start = i
      // Ensure there's a token end at the current position, and that i points at it
      while (at < end) {
        var i_end = st[i]
        if (i_end > end)
          { st.splice(i, 1, end, st[i+1], i_end) }
        i += 2
        at = Math.min(end, i_end)
      }
      if (!style) { return }
      if (overlay.opaque) {
        st.splice(start, i - start, end, "overlay " + style)
        i = start + 2
      } else {
        for (; start < i; start += 2) {
          var cur = st[start+1]
          st[start+1] = (cur ? cur + " " : "") + "overlay " + style
        }
      }
    }, lineClasses)
  };

  for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );
  context.state = state

  return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
}

function getLineStyles(cm, line, updateFrontier) {
  if (!line.styles || line.styles[0] != cm.state.modeGen) {
    var context = getContextBefore(cm, lineNo(line))
    var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state)
    var result = highlightLine(cm, line, context)
    if (resetState) { context.state = resetState }
    line.stateAfter = context.save(!resetState)
    line.styles = result.styles
    if (result.classes) { line.styleClasses = result.classes }
    else if (line.styleClasses) { line.styleClasses = null }
    if (updateFrontier === cm.doc.highlightFrontier)
      { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier) }
  }
  return line.styles
}

function getContextBefore(cm, n, precise) {
  var doc = cm.doc, display = cm.display
  if (!doc.mode.startState) { return new Context(doc, true, n) }
  var start = findStartLine(cm, n, precise)
  var saved = start > doc.first && getLine(doc, start - 1).stateAfter
  var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start)

  doc.iter(start, n, function (line) {
    processLine(cm, line.text, context)
    var pos = context.line
    line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null
    context.nextLine()
  })
  if (precise) { doc.modeFrontier = context.line }
  return context
}

// Lightweight form of highlight -- proceed over this line and
// update state, but don't save a style array. Used for lines that
// aren't currently visible.
function processLine(cm, text, context, startAt) {
  var mode = cm.doc.mode
  var stream = new StringStream(text, cm.options.tabSize, context)
  stream.start = stream.pos = startAt || 0
  if (text == "") { callBlankLine(mode, context.state) }
  while (!stream.eol()) {
    readToken(mode, stream, context.state)
    stream.start = stream.pos
  }
}

function callBlankLine(mode, state) {
  if (mode.blankLine) { return mode.blankLine(state) }
  if (!mode.innerMode) { return }
  var inner = innerMode(mode, state)
  if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
}

function readToken(mode, stream, state, inner) {
  for (var i = 0; i < 10; i++) {
    if (inner) { inner[0] = innerMode(mode, state).mode }
    var style = mode.token(stream, state)
    if (stream.pos > stream.start) { return style }
  }
  throw new Error("Mode " + mode.name + " failed to advance stream.")
}

var Token = function(stream, type, state) {
  this.start = stream.start; this.end = stream.pos
  this.string = stream.current()
  this.type = type || null
  this.state = state
};

// Utility for getTokenAt and getLineTokens
function takeToken(cm, pos, precise, asArray) {
  var doc = cm.doc, mode = doc.mode, style
  pos = clipPos(doc, pos)
  var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise)
  var stream = new StringStream(line.text, cm.options.tabSize, context), tokens
  if (asArray) { tokens = [] }
  while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
    stream.start = stream.pos
    style = readToken(mode, stream, context.state)
    if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))) }
  }
  return asArray ? tokens : new Token(stream, style, context.state)
}

function extractLineClasses(type, output) {
  if (type) { for (;;) {
    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/)
    if (!lineClass) { break }
    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length)
    var prop = lineClass[1] ? "bgClass" : "textClass"
    if (output[prop] == null)
      { output[prop] = lineClass[2] }
    else if (!(new RegExp("(?:^|\s)" + lineClass[2] + "(?:$|\s)")).test(output[prop]))
      { output[prop] += " " + lineClass[2] }
  } }
  return type
}

// Run the given mode's parser over a line, calling f for each token.
function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
  var flattenSpans = mode.flattenSpans
  if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans }
  var curStart = 0, curStyle = null
  var stream = new StringStream(text, cm.options.tabSize, context), style
  var inner = cm.options.addModeClass && [null]
  if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses) }
  while (!stream.eol()) {
    if (stream.pos > cm.options.maxHighlightLength) {
      flattenSpans = false
      if (forceToEnd) { processLine(cm, text, context, stream.pos) }
      stream.pos = text.length
      style = null
    } else {
      style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses)
    }
    if (inner) {
      var mName = inner[0].name
      if (mName) { style = "m-" + (style ? mName + " " + style : mName) }
    }
    if (!flattenSpans || curStyle != style) {
      while (curStart < stream.start) {
        curStart = Math.min(stream.start, curStart + 5000)
        f(curStart, curStyle)
      }
      curStyle = style
    }
    stream.start = stream.pos
  }
  while (curStart < stream.pos) {
    // Webkit seems to refuse to render text nodes longer than 57444
    // characters, and returns inaccurate measurements in nodes
    // starting around 5000 chars.
    var pos = Math.min(stream.pos, curStart + 5000)
    f(pos, curStyle)
    curStart = pos
  }
}

// Finds the line to start with when starting a parse. Tries to
// find a line with a stateAfter, so that it can start with a
// valid state. If that fails, it returns the line with the
// smallest indentation, which tends to need the least context to
// parse correctly.
function findStartLine(cm, n, precise) {
  var minindent, minline, doc = cm.doc
  var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100)
  for (var search = n; search > lim; --search) {
    if (search <= doc.first) { return doc.first }
    var line = getLine(doc, search - 1), after = line.stateAfter
    if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
      { return search }
    var indented = countColumn(line.text, null, cm.options.tabSize)
    if (minline == null || minindent > indented) {
      minline = search - 1
      minindent = indented
    }
  }
  return minline
}

function retreatFrontier(doc, n) {
  doc.modeFrontier = Math.min(doc.modeFrontier, n)
  if (doc.highlightFrontier < n - 10) { return }
  var start = doc.first
  for (var line = n - 1; line > start; line--) {
    var saved = getLine(doc, line).stateAfter
    // change is on 3
    // state on line 1 looked ahead 2 -- so saw 3
    // test 1 + 2 < 3 should cover this
    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
      start = line + 1
      break
    }
  }
  doc.highlightFrontier = Math.min(doc.highlightFrontier, start)
}

// LINE DATA STRUCTURE

// Line objects. These hold state related to a line, including
// highlighting info (the styles array).
var Line = function(text, markedSpans, estimateHeight) {
  this.text = text
  attachMarkedSpans(this, markedSpans)
  this.height = estimateHeight ? estimateHeight(this) : 1
};

Line.prototype.lineNo = function () { return lineNo(this) };
eventMixin(Line)

// Change the content (text, markers) of a line. Automatically
// invalidates cached information and tries to re-estimate the
// line's height.
function updateLine(line, text, markedSpans, estimateHeight) {
  line.text = text
  if (line.stateAfter) { line.stateAfter = null }
  if (line.styles) { line.styles = null }
  if (line.order != null) { line.order = null }
  detachMarkedSpans(line)
  attachMarkedSpans(line, markedSpans)
  var estHeight = estimateHeight ? estimateHeight(line) : 1
  if (estHeight != line.height) { updateLineHeight(line, estHeight) }
}

// Detach a line from the document tree and its markers.
function cleanUpLine(line) {
  line.parent = null
  detachMarkedSpans(line)
}

// Convert a style as returned by a mode (either null, or a string
// containing one or more styles) to a CSS style. This is cached,
// and also looks for line-wide styles.
var styleToClassCache = {};
var styleToClassCacheWithMode = {};
function interpretTokenStyle(style, options) {
  if (!style || /^\s*$/.test(style)) { return null }
  var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache
  return cache[style] ||
    (cache[style] = style.replace(/\S+/g, "cm-$&"))
}

// Render the DOM representation of the text of a line. Also builds
// up a 'line map', which points at the DOM nodes that represent
// specific stretches of text, and is used by the measuring code.
// The returned object contains the DOM node, this map, and
// information about line-wide styles that were set by the mode.
function buildLineContent(cm, lineView) {
  // The padding-right forces the element to have a 'border', which
  // is needed on Webkit to be able to get line-level bounding
  // rectangles for it (in measureChar).
  var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null)
  var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                 col: 0, pos: 0, cm: cm,
                 trailingSpace: false,
                 splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")}
  lineView.measure = {}

  // Iterate over the logical lines that make up this visual line.
  for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
    var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0)
    builder.pos = 0
    builder.addToken = buildToken
    // Optionally wire in some hacks into the token-rendering
    // algorithm, to deal with browser quirks.
    if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
      { builder.addToken = buildTokenBadBidi(builder.addToken, order) }
    builder.map = []
    var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line)
    insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate))
    if (line.styleClasses) {
      if (line.styleClasses.bgClass)
        { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "") }
      if (line.styleClasses.textClass)
        { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "") }
    }

    // Ensure at least a single node is present, for measuring.
    if (builder.map.length == 0)
      { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))) }

    // Store the map and a cache object for the current logical line
    if (i == 0) {
      lineView.measure.map = builder.map
      lineView.measure.cache = {}
    } else {
      ;(lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
      ;(lineView.measure.caches || (lineView.measure.caches = [])).push({})
    }
  }

  // See issue #2901
  if (webkit) {
    var last = builder.content.lastChild
    if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
      { builder.content.className = "cm-tab-wrap-hack" }
  }

  signal(cm, "renderLine", cm, lineView.line, builder.pre)
  if (builder.pre.className)
    { builder.textClass = joinClasses(builder.pre.className, builder.textClass || "") }

  return builder
}

function defaultSpecialCharPlaceholder(ch) {
  var token = elt("span", "\u2022", "cm-invalidchar")
  token.title = "\\u" + ch.charCodeAt(0).toString(16)
  token.setAttribute("aria-label", token.title)
  return token
}

// Build up the DOM representation for a single token, and add it to
// the line map. Takes care to render special characters separately.
function buildToken(builder, text, style, startStyle, endStyle, title, css) {
  if (!text) { return }
  var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text
  var special = builder.cm.state.specialChars, mustWrap = false
  var content
  if (!special.test(text)) {
    builder.col += text.length
    content = document.createTextNode(displayText)
    builder.map.push(builder.pos, builder.pos + text.length, content)
    if (ie && ie_version < 9) { mustWrap = true }
    builder.pos += text.length
  } else {
    content = document.createDocumentFragment()
    var pos = 0
    while (true) {
      special.lastIndex = pos
      var m = special.exec(text)
      var skipped = m ? m.index - pos : text.length - pos
      if (skipped) {
        var txt = document.createTextNode(displayText.slice(pos, pos + skipped))
        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])) }
        else { content.appendChild(txt) }
        builder.map.push(builder.pos, builder.pos + skipped, txt)
        builder.col += skipped
        builder.pos += skipped
      }
      if (!m) { break }
      pos += skipped + 1
      var txt$1 = (void 0)
      if (m[0] == "\t") {
        var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize
        txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"))
        txt$1.setAttribute("role", "presentation")
        txt$1.setAttribute("cm-text", "\t")
        builder.col += tabWidth
      } else if (m[0] == "\r" || m[0] == "\n") {
        txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"))
        txt$1.setAttribute("cm-text", m[0])
        builder.col += 1
      } else {
        txt$1 = builder.cm.options.specialCharPlaceholder(m[0])
        txt$1.setAttribute("cm-text", m[0])
        if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])) }
        else { content.appendChild(txt$1) }
        builder.col += 1
      }
      builder.map.push(builder.pos, builder.pos + 1, txt$1)
      builder.pos++
    }
  }
  builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32
  if (style || startStyle || endStyle || mustWrap || css) {
    var fullStyle = style || ""
    if (startStyle) { fullStyle += startStyle }
    if (endStyle) { fullStyle += endStyle }
    var token = elt("span", [content], fullStyle, css)
    if (title) { token.title = title }
    return builder.content.appendChild(token)
  }
  builder.content.appendChild(content)
}

function splitSpaces(text, trailingBefore) {
  if (text.length > 1 && !/  /.test(text)) { return text }
  var spaceBefore = trailingBefore, result = ""
  for (var i = 0; i < text.length; i++) {
    var ch = text.charAt(i)
    if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
      { ch = "\u00a0" }
    result += ch
    spaceBefore = ch == " "
  }
  return result
}

// Work around nonsense dimensions being reported for stretches of
// right-to-left text.
function buildTokenBadBidi(inner, order) {
  return function (builder, text, style, startStyle, endStyle, title, css) {
    style = style ? style + " cm-force-border" : "cm-force-border"
    var start = builder.pos, end = start + text.length
    for (;;) {
      // Find the part that overlaps with the start of this text
      var part = (void 0)
      for (var i = 0; i < order.length; i++) {
        part = order[i]
        if (part.to > start && part.from <= start) { break }
      }
      if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, title, css) }
      inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css)
      startStyle = null
      text = text.slice(part.to - start)
      start = part.to
    }
  }
}

function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
  var widget = !ignoreWidget && marker.widgetNode
  if (widget) { builder.map.push(builder.pos, builder.pos + size, widget) }
  if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
    if (!widget)
      { widget = builder.content.appendChild(document.createElement("span")) }
    widget.setAttribute("cm-marker", marker.id)
  }
  if (widget) {
    builder.cm.display.input.setUneditable(widget)
    builder.content.appendChild(widget)
  }
  builder.pos += size
  builder.trailingSpace = false
}

// Outputs a number of spans to make up a line, taking highlighting
// and marked text into account.
function insertLineContent(line, builder, styles) {
  var spans = line.markedSpans, allText = line.text, at = 0
  if (!spans) {
    for (var i$1 = 1; i$1 < styles.length; i$1+=2)
      { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)) }
    return
  }

  var len = allText.length, pos = 0, i = 1, text = "", style, css
  var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed
  for (;;) {
    if (nextChange == pos) { // Update current marker set
      spanStyle = spanEndStyle = spanStartStyle = title = css = ""
      collapsed = null; nextChange = Infinity
      var foundBookmarks = [], endStyles = (void 0)
      for (var j = 0; j < spans.length; ++j) {
        var sp = spans[j], m = sp.marker
        if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
          foundBookmarks.push(m)
        } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
          if (sp.to != null && sp.to != pos && nextChange > sp.to) {
            nextChange = sp.to
            spanEndStyle = ""
          }
          if (m.className) { spanStyle += " " + m.className }
          if (m.css) { css = (css ? css + ";" : "") + m.css }
          if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle }
          if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to) }
          if (m.title && !title) { title = m.title }
          if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
            { collapsed = sp }
        } else if (sp.from > pos && nextChange > sp.from) {
          nextChange = sp.from
        }
      }
      if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
        { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1] } } }

      if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
        { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]) } }
      if (collapsed && (collapsed.from || 0) == pos) {
        buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                           collapsed.marker, collapsed.from == null)
        if (collapsed.to == null) { return }
        if (collapsed.to == pos) { collapsed = false }
      }
    }
    if (pos >= len) { break }

    var upto = Math.min(len, nextChange)
    while (true) {
      if (text) {
        var end = pos + text.length
        if (!collapsed) {
          var tokenText = end > upto ? text.slice(0, upto - pos) : text
          builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                           spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css)
        }
        if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
        pos = end
        spanStartStyle = ""
      }
      text = allText.slice(at, at = styles[i++])
      style = interpretTokenStyle(styles[i++], builder.cm.options)
    }
  }
}


// These objects are used to represent the visible (currently drawn)
// part of the document. A LineView may correspond to multiple
// logical lines, if those are connected by collapsed ranges.
function LineView(doc, line, lineN) {
  // The starting line
  this.line = line
  // Continuing lines, if any
  this.rest = visualLineContinued(line)
  // Number of logical lines in this visual line
  this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1
  this.node = this.text = null
  this.hidden = lineIsHidden(doc, line)
}

// Create a range of LineView objects for the given lines.
function buildViewArray(cm, from, to) {
  var array = [], nextPos
  for (var pos = from; pos < to; pos = nextPos) {
    var view = new LineView(cm.doc, getLine(cm.doc, pos), pos)
    nextPos = pos + view.size
    array.push(view)
  }
  return array
}

var operationGroup = null

function pushOperation(op) {
  if (operationGroup) {
    operationGroup.ops.push(op)
  } else {
    op.ownsGroup = operationGroup = {
      ops: [op],
      delayedCallbacks: []
    }
  }
}

function fireCallbacksForOps(group) {
  // Calls delayed callbacks and cursorActivity handlers until no
  // new ones appear
  var callbacks = group.delayedCallbacks, i = 0
  do {
    for (; i < callbacks.length; i++)
      { callbacks[i].call(null) }
    for (var j = 0; j < group.ops.length; j++) {
      var op = group.ops[j]
      if (op.cursorActivityHandlers)
        { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
          { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm) } }
    }
  } while (i < callbacks.length)
}

function finishOperation(op, endCb) {
  var group = op.ownsGroup
  if (!group) { return }

  try { fireCallbacksForOps(group) }
  finally {
    operationGroup = null
    endCb(group)
  }
}

var orphanDelayedCallbacks = null

// Often, we want to signal events at a point where we are in the
// middle of some work, but don't want the handler to start calling
// other methods on the editor, which might be in an inconsistent
// state or simply not expect any other events to happen.
// signalLater looks whether there are any handlers, and schedules
// them to be executed when the last operation ends, or, if no
// operation is active, when a timeout fires.
function signalLater(emitter, type /*, values...*/) {
  var arr = getHandlers(emitter, type)
  if (!arr.length) { return }
  var args = Array.prototype.slice.call(arguments, 2), list
  if (operationGroup) {
    list = operationGroup.delayedCallbacks
  } else if (orphanDelayedCallbacks) {
    list = orphanDelayedCallbacks
  } else {
    list = orphanDelayedCallbacks = []
    setTimeout(fireOrphanDelayed, 0)
  }
  var loop = function ( i ) {
    list.push(function () { return arr[i].apply(null, args); })
  };

  for (var i = 0; i < arr.length; ++i)
    loop( i );
}

function fireOrphanDelayed() {
  var delayed = orphanDelayedCallbacks
  orphanDelayedCallbacks = null
  for (var i = 0; i < delayed.length; ++i) { delayed[i]() }
}

// When an aspect of a line changes, a string is added to
// lineView.changes. This updates the relevant part of the line's
// DOM structure.
function updateLineForChanges(cm, lineView, lineN, dims) {
  for (var j = 0; j < lineView.changes.length; j++) {
    var type = lineView.changes[j]
    if (type == "text") { updateLineText(cm, lineView) }
    else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims) }
    else if (type == "class") { updateLineClasses(cm, lineView) }
    else if (type == "widget") { updateLineWidgets(cm, lineView, dims) }
  }
  lineView.changes = null
}

// Lines with gutter elements, widgets or a background class need to
// be wrapped, and have the extra elements added to the wrapper div
function ensureLineWrapped(lineView) {
  if (lineView.node == lineView.text) {
    lineView.node = elt("div", null, null, "position: relative")
    if (lineView.text.parentNode)
      { lineView.text.parentNode.replaceChild(lineView.node, lineView.text) }
    lineView.node.appendChild(lineView.text)
    if (ie && ie_version < 8) { lineView.node.style.zIndex = 2 }
  }
  return lineView.node
}

function updateLineBackground(cm, lineView) {
  var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass
  if (cls) { cls += " CodeMirror-linebackground" }
  if (lineView.background) {
    if (cls) { lineView.background.className = cls }
    else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null }
  } else if (cls) {
    var wrap = ensureLineWrapped(lineView)
    lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild)
    cm.display.input.setUneditable(lineView.background)
  }
}

// Wrapper around buildLineContent which will reuse the structure
// in display.externalMeasured when possible.
function getLineContent(cm, lineView) {
  var ext = cm.display.externalMeasured
  if (ext && ext.line == lineView.line) {
    cm.display.externalMeasured = null
    lineView.measure = ext.measure
    return ext.built
  }
  return buildLineContent(cm, lineView)
}

// Redraw the line's text. Interacts with the background and text
// classes because the mode may output tokens that influence these
// classes.
function updateLineText(cm, lineView) {
  var cls = lineView.text.className
  var built = getLineContent(cm, lineView)
  if (lineView.text == lineView.node) { lineView.node = built.pre }
  lineView.text.parentNode.replaceChild(built.pre, lineView.text)
  lineView.text = built.pre
  if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
    lineView.bgClass = built.bgClass
    lineView.textClass = built.textClass
    updateLineClasses(cm, lineView)
  } else if (cls) {
    lineView.text.className = cls
  }
}

function updateLineClasses(cm, lineView) {
  updateLineBackground(cm, lineView)
  if (lineView.line.wrapClass)
    { ensureLineWrapped(lineView).className = lineView.line.wrapClass }
  else if (lineView.node != lineView.text)
    { lineView.node.className = "" }
  var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass
  lineView.text.className = textClass || ""
}

function updateLineGutter(cm, lineView, lineN, dims) {
  if (lineView.gutter) {
    lineView.node.removeChild(lineView.gutter)
    lineView.gutter = null
  }
  if (lineView.gutterBackground) {
    lineView.node.removeChild(lineView.gutterBackground)
    lineView.gutterBackground = null
  }
  if (lineView.line.gutterClass) {
    var wrap = ensureLineWrapped(lineView)
    lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                    ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"))
    cm.display.input.setUneditable(lineView.gutterBackground)
    wrap.insertBefore(lineView.gutterBackground, lineView.text)
  }
  var markers = lineView.line.gutterMarkers
  if (cm.options.lineNumbers || markers) {
    var wrap$1 = ensureLineWrapped(lineView)
    var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"))
    cm.display.input.setUneditable(gutterWrap)
    wrap$1.insertBefore(gutterWrap, lineView.text)
    if (lineView.line.gutterClass)
      { gutterWrap.className += " " + lineView.line.gutterClass }
    if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
      { lineView.lineNumber = gutterWrap.appendChild(
        elt("div", lineNumberFor(cm.options, lineN),
            "CodeMirror-linenumber CodeMirror-gutter-elt",
            ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))) }
    if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {
      var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id]
      if (found)
        { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                   ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))) }
    } }
  }
}

function updateLineWidgets(cm, lineView, dims) {
  if (lineView.alignable) { lineView.alignable = null }
  for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
    next = node.nextSibling
    if (node.className == "CodeMirror-linewidget")
      { lineView.node.removeChild(node) }
  }
  insertLineWidgets(cm, lineView, dims)
}

// Build a line's DOM representation from scratch
function buildLineElement(cm, lineView, lineN, dims) {
  var built = getLineContent(cm, lineView)
  lineView.text = lineView.node = built.pre
  if (built.bgClass) { lineView.bgClass = built.bgClass }
  if (built.textClass) { lineView.textClass = built.textClass }

  updateLineClasses(cm, lineView)
  updateLineGutter(cm, lineView, lineN, dims)
  insertLineWidgets(cm, lineView, dims)
  return lineView.node
}

// A lineView may contain multiple logical lines (when merged by
// collapsed spans). The widgets for all of them need to be drawn.
function insertLineWidgets(cm, lineView, dims) {
  insertLineWidgetsFor(cm, lineView.line, lineView, dims, true)
  if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
    { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false) } }
}

function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
  if (!line.widgets) { return }
  var wrap = ensureLineWrapped(lineView)
  for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
    var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget")
    if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true") }
    positionLineWidget(widget, node, lineView, dims)
    cm.display.input.setUneditable(node)
    if (allowAbove && widget.above)
      { wrap.insertBefore(node, lineView.gutter || lineView.text) }
    else
      { wrap.appendChild(node) }
    signalLater(widget, "redraw")
  }
}

function positionLineWidget(widget, node, lineView, dims) {
  if (widget.noHScroll) {
    ;(lineView.alignable || (lineView.alignable = [])).push(node)
    var width = dims.wrapperWidth
    node.style.left = dims.fixedPos + "px"
    if (!widget.coverGutter) {
      width -= dims.gutterTotalWidth
      node.style.paddingLeft = dims.gutterTotalWidth + "px"
    }
    node.style.width = width + "px"
  }
  if (widget.coverGutter) {
    node.style.zIndex = 5
    node.style.position = "relative"
    if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px" }
  }
}

function widgetHeight(widget) {
  if (widget.height != null) { return widget.height }
  var cm = widget.doc.cm
  if (!cm) { return 0 }
  if (!contains(document.body, widget.node)) {
    var parentStyle = "position: relative;"
    if (widget.coverGutter)
      { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;" }
    if (widget.noHScroll)
      { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;" }
    removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle))
  }
  return widget.height = widget.node.parentNode.offsetHeight
}

// Return true when the given mouse event happened in a widget
function eventInWidget(display, e) {
  for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
    if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
        (n.parentNode == display.sizer && n != display.mover))
      { return true }
  }
}

// POSITION MEASUREMENT

function paddingTop(display) {return display.lineSpace.offsetTop}
function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
function paddingH(display) {
  if (display.cachedPaddingH) { return display.cachedPaddingH }
  var e = removeChildrenAndAdd(display.measure, elt("pre", "x"))
  var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle
  var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)}
  if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data }
  return data
}

function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
function displayWidth(cm) {
  return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
}
function displayHeight(cm) {
  return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
}

// Ensure the lineView.wrapping.heights array is populated. This is
// an array of bottom offsets for the lines that make up a drawn
// line. When lineWrapping is on, there might be more than one
// height.
function ensureLineHeights(cm, lineView, rect) {
  var wrapping = cm.options.lineWrapping
  var curWidth = wrapping && displayWidth(cm)
  if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
    var heights = lineView.measure.heights = []
    if (wrapping) {
      lineView.measure.width = curWidth
      var rects = lineView.text.firstChild.getClientRects()
      for (var i = 0; i < rects.length - 1; i++) {
        var cur = rects[i], next = rects[i + 1]
        if (Math.abs(cur.bottom - next.bottom) > 2)
          { heights.push((cur.bottom + next.top) / 2 - rect.top) }
      }
    }
    heights.push(rect.bottom - rect.top)
  }
}

// Find a line map (mapping character offsets to text nodes) and a
// measurement cache for the given line number. (A line view might
// contain multiple lines when collapsed ranges are present.)
function mapFromLineView(lineView, line, lineN) {
  if (lineView.line == line)
    { return {map: lineView.measure.map, cache: lineView.measure.cache} }
  for (var i = 0; i < lineView.rest.length; i++)
    { if (lineView.rest[i] == line)
      { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
  for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
    { if (lineNo(lineView.rest[i$1]) > lineN)
      { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
}

// Render a line into the hidden node display.externalMeasured. Used
// when measurement is needed for a line that's not in the viewport.
function updateExternalMeasurement(cm, line) {
  line = visualLine(line)
  var lineN = lineNo(line)
  var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN)
  view.lineN = lineN
  var built = view.built = buildLineContent(cm, view)
  view.text = built.pre
  removeChildrenAndAdd(cm.display.lineMeasure, built.pre)
  return view
}

// Get a {top, bottom, left, right} box (in line-local coordinates)
// for a given character.
function measureChar(cm, line, ch, bias) {
  return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
}

// Find a line view that corresponds to the given line number.
function findViewForLine(cm, lineN) {
  if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
    { return cm.display.view[findViewIndex(cm, lineN)] }
  var ext = cm.display.externalMeasured
  if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
    { return ext }
}

// Measurement can be split in two steps, the set-up work that
// applies to the whole line, and the measurement of the actual
// character. Functions like coordsChar, that need to do a lot of
// measurements in a row, can thus ensure that the set-up work is
// only done once.
function prepareMeasureForLine(cm, line) {
  var lineN = lineNo(line)
  var view = findViewForLine(cm, lineN)
  if (view && !view.text) {
    view = null
  } else if (view && view.changes) {
    updateLineForChanges(cm, view, lineN, getDimensions(cm))
    cm.curOp.forceUpdate = true
  }
  if (!view)
    { view = updateExternalMeasurement(cm, line) }

  var info = mapFromLineView(view, line, lineN)
  return {
    line: line, view: view, rect: null,
    map: info.map, cache: info.cache, before: info.before,
    hasHeights: false
  }
}

// Given a prepared measurement object, measures the position of an
// actual character (or fetches it from the cache).
function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
  if (prepared.before) { ch = -1 }
  var key = ch + (bias || ""), found
  if (prepared.cache.hasOwnProperty(key)) {
    found = prepared.cache[key]
  } else {
    if (!prepared.rect)
      { prepared.rect = prepared.view.text.getBoundingClientRect() }
    if (!prepared.hasHeights) {
      ensureLineHeights(cm, prepared.view, prepared.rect)
      prepared.hasHeights = true
    }
    found = measureCharInner(cm, prepared, ch, bias)
    if (!found.bogus) { prepared.cache[key] = found }
  }
  return {left: found.left, right: found.right,
          top: varHeight ? found.rtop : found.top,
          bottom: varHeight ? found.rbottom : found.bottom}
}

var nullRect = {left: 0, right: 0, top: 0, bottom: 0}

function nodeAndOffsetInLineMap(map, ch, bias) {
  var node, start, end, collapse, mStart, mEnd
  // First, search the line map for the text node corresponding to,
  // or closest to, the target character.
  for (var i = 0; i < map.length; i += 3) {
    mStart = map[i]
    mEnd = map[i + 1]
    if (ch < mStart) {
      start = 0; end = 1
      collapse = "left"
    } else if (ch < mEnd) {
      start = ch - mStart
      end = start + 1
    } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
      end = mEnd - mStart
      start = end - 1
      if (ch >= mEnd) { collapse = "right" }
    }
    if (start != null) {
      node = map[i + 2]
      if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
        { collapse = bias }
      if (bias == "left" && start == 0)
        { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
          node = map[(i -= 3) + 2]
          collapse = "left"
        } }
      if (bias == "right" && start == mEnd - mStart)
        { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
          node = map[(i += 3) + 2]
          collapse = "right"
        } }
      break
    }
  }
  return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
}

function getUsefulRect(rects, bias) {
  var rect = nullRect
  if (bias == "left") { for (var i = 0; i < rects.length; i++) {
    if ((rect = rects[i]).left != rect.right) { break }
  } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
    if ((rect = rects[i$1]).left != rect.right) { break }
  } }
  return rect
}

function measureCharInner(cm, prepared, ch, bias) {
  var place = nodeAndOffsetInLineMap(prepared.map, ch, bias)
  var node = place.node, start = place.start, end = place.end, collapse = place.collapse

  var rect
  if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
    for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
      while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start }
      while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end }
      if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
        { rect = node.parentNode.getBoundingClientRect() }
      else
        { rect = getUsefulRect(range(node, start, end).getClientRects(), bias) }
      if (rect.left || rect.right || start == 0) { break }
      end = start
      start = start - 1
      collapse = "right"
    }
    if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect) }
  } else { // If it is a widget, simply get the box for the whole widget.
    if (start > 0) { collapse = bias = "right" }
    var rects
    if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
      { rect = rects[bias == "right" ? rects.length - 1 : 0] }
    else
      { rect = node.getBoundingClientRect() }
  }
  if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
    var rSpan = node.parentNode.getClientRects()[0]
    if (rSpan)
      { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom} }
    else
      { rect = nullRect }
  }

  var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top
  var mid = (rtop + rbot) / 2
  var heights = prepared.view.measure.heights
  var i = 0
  for (; i < heights.length - 1; i++)
    { if (mid < heights[i]) { break } }
  var top = i ? heights[i - 1] : 0, bot = heights[i]
  var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                top: top, bottom: bot}
  if (!rect.left && !rect.right) { result.bogus = true }
  if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot }

  return result
}

// Work around problem with bounding client rects on ranges being
// returned incorrectly when zoomed on IE10 and below.
function maybeUpdateRectForZooming(measure, rect) {
  if (!window.screen || screen.logicalXDPI == null ||
      screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
    { return rect }
  var scaleX = screen.logicalXDPI / screen.deviceXDPI
  var scaleY = screen.logicalYDPI / screen.deviceYDPI
  return {left: rect.left * scaleX, right: rect.right * scaleX,
          top: rect.top * scaleY, bottom: rect.bottom * scaleY}
}

function clearLineMeasurementCacheFor(lineView) {
  if (lineView.measure) {
    lineView.measure.cache = {}
    lineView.measure.heights = null
    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
      { lineView.measure.caches[i] = {} } }
  }
}

function clearLineMeasurementCache(cm) {
  cm.display.externalMeasure = null
  removeChildren(cm.display.lineMeasure)
  for (var i = 0; i < cm.display.view.length; i++)
    { clearLineMeasurementCacheFor(cm.display.view[i]) }
}

function clearCaches(cm) {
  clearLineMeasurementCache(cm)
  cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null
  if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true }
  cm.display.lineNumChars = null
}

function pageScrollX() {
  // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
  // which causes page_Offset and bounding client rects to use
  // different reference viewports and invalidate our calculations.
  if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
  return window.pageXOffset || (document.documentElement || document.body).scrollLeft
}
function pageScrollY() {
  if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
  return window.pageYOffset || (document.documentElement || document.body).scrollTop
}

function widgetTopHeight(lineObj) {
  var height = 0
  if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
    { height += widgetHeight(lineObj.widgets[i]) } } }
  return height
}

// Converts a {top, bottom, left, right} box from line-local
// coordinates into another coordinate system. Context may be one of
// "line", "div" (display.lineDiv), "local"./null (editor), "window",
// or "page".
function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
  if (!includeWidgets) {
    var height = widgetTopHeight(lineObj)
    rect.top += height; rect.bottom += height
  }
  if (context == "line") { return rect }
  if (!context) { context = "local" }
  var yOff = heightAtLine(lineObj)
  if (context == "local") { yOff += paddingTop(cm.display) }
  else { yOff -= cm.display.viewOffset }
  if (context == "page" || context == "window") {
    var lOff = cm.display.lineSpace.getBoundingClientRect()
    yOff += lOff.top + (context == "window" ? 0 : pageScrollY())
    var xOff = lOff.left + (context == "window" ? 0 : pageScrollX())
    rect.left += xOff; rect.right += xOff
  }
  rect.top += yOff; rect.bottom += yOff
  return rect
}

// Coverts a box from "div" coords to another coordinate system.
// Context may be "window", "page", "div", or "local"./null.
function fromCoordSystem(cm, coords, context) {
  if (context == "div") { return coords }
  var left = coords.left, top = coords.top
  // First move into "page" coordinate system
  if (context == "page") {
    left -= pageScrollX()
    top -= pageScrollY()
  } else if (context == "local" || !context) {
    var localBox = cm.display.sizer.getBoundingClientRect()
    left += localBox.left
    top += localBox.top
  }

  var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect()
  return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
}

function charCoords(cm, pos, context, lineObj, bias) {
  if (!lineObj) { lineObj = getLine(cm.doc, pos.line) }
  return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
}

// Returns a box for a given cursor position, which may have an
// 'other' property containing the position of the secondary cursor
// on a bidi boundary.
// A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
// and after `char - 1` in writing order of `char - 1`
// A cursor Pos(line, char, "after") is on the same visual line as `char`
// and before `char` in writing order of `char`
// Examples (upper-case letters are RTL, lower-case are LTR):
//     Pos(0, 1, ...)
//     before   after
// ab     a|b     a|b
// aB     a|B     aB|
// Ab     |Ab     A|b
// AB     B|A     B|A
// Every position after the last character on a line is considered to stick
// to the last character on the line.
function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
  lineObj = lineObj || getLine(cm.doc, pos.line)
  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj) }
  function get(ch, right) {
    var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight)
    if (right) { m.left = m.right; } else { m.right = m.left }
    return intoCoordSystem(cm, lineObj, m, context)
  }
  var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky
  if (ch >= lineObj.text.length) {
    ch = lineObj.text.length
    sticky = "before"
  } else if (ch <= 0) {
    ch = 0
    sticky = "after"
  }
  if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

  function getBidi(ch, partPos, invert) {
    var part = order[partPos], right = part.level == 1
    return get(invert ? ch - 1 : ch, right != invert)
  }
  var partPos = getBidiPartAt(order, ch, sticky)
  var other = bidiOther
  var val = getBidi(ch, partPos, sticky == "before")
  if (other != null) { val.other = getBidi(ch, other, sticky != "before") }
  return val
}

// Used to cheaply estimate the coordinates for a position. Used for
// intermediate scroll updates.
function estimateCoords(cm, pos) {
  var left = 0
  pos = clipPos(cm.doc, pos)
  if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch }
  var lineObj = getLine(cm.doc, pos.line)
  var top = heightAtLine(lineObj) + paddingTop(cm.display)
  return {left: left, right: left, top: top, bottom: top + lineObj.height}
}

// Positions returned by coordsChar contain some extra information.
// xRel is the relative x position of the input coordinates compared
// to the found position (so xRel > 0 means the coordinates are to
// the right of the character position, for example). When outside
// is true, that means the coordinates lie outside the line's
// vertical range.
function PosWithInfo(line, ch, sticky, outside, xRel) {
  var pos = Pos(line, ch, sticky)
  pos.xRel = xRel
  if (outside) { pos.outside = true }
  return pos
}

// Compute the character position closest to the given coordinates.
// Input must be lineSpace-local ("div" coordinate system).
function coordsChar(cm, x, y) {
  var doc = cm.doc
  y += cm.display.viewOffset
  if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }
  var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1
  if (lineN > last)
    { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }
  if (x < 0) { x = 0 }

  var lineObj = getLine(doc, lineN)
  for (;;) {
    var found = coordsCharInner(cm, lineObj, lineN, x, y)
    var merged = collapsedSpanAtEnd(lineObj)
    var mergedPos = merged && merged.find(0, true)
    if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))
      { lineN = lineNo(lineObj = mergedPos.to.line) }
    else
      { return found }
  }
}

function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
  y -= widgetTopHeight(lineObj)
  var end = lineObj.text.length
  var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0)
  end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end)
  return {begin: begin, end: end}
}

function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
  if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj) }
  var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top
  return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
}

// Returns true if the given side of a box is after the given
// coordinates, in top-to-bottom, left-to-right order.
function boxIsAfter(box, x, y, left) {
  return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
}

function coordsCharInner(cm, lineObj, lineNo, x, y) {
  // Move y into line-local coordinate space
  y -= heightAtLine(lineObj)
  var preparedMeasure = prepareMeasureForLine(cm, lineObj)
  // When directly calling `measureCharPrepared`, we have to adjust
  // for the widgets at this line.
  var widgetHeight = widgetTopHeight(lineObj)
  var begin = 0, end = lineObj.text.length, ltr = true

  var order = getOrder(lineObj, cm.doc.direction)
  // If the line isn't plain left-to-right text, first figure out
  // which bidi section the coordinates fall into.
  if (order) {
    var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                 (cm, lineObj, lineNo, preparedMeasure, order, x, y)
    ltr = part.level != 1
    // The awkward -1 offsets are needed because findFirst (called
    // on these below) will treat its first bound as inclusive,
    // second as exclusive, but we want to actually address the
    // characters in the part's range
    begin = ltr ? part.from : part.to - 1
    end = ltr ? part.to : part.from - 1
  }

  // A binary search to find the first character whose bounding box
  // starts after the coordinates. If we run across any whose box wrap
  // the coordinates, store that.
  var chAround = null, boxAround = null
  var ch = findFirst(function (ch) {
    var box = measureCharPrepared(cm, preparedMeasure, ch)
    box.top += widgetHeight; box.bottom += widgetHeight
    if (!boxIsAfter(box, x, y, false)) { return false }
    if (box.top <= y && box.left <= x) {
      chAround = ch
      boxAround = box
    }
    return true
  }, begin, end)

  var baseX, sticky, outside = false
  // If a box around the coordinates was found, use that
  if (boxAround) {
    // Distinguish coordinates nearer to the left or right side of the box
    var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr
    ch = chAround + (atStart ? 0 : 1)
    sticky = atStart ? "after" : "before"
    baseX = atLeft ? boxAround.left : boxAround.right
  } else {
    // (Adjust for extended bound, if necessary.)
    if (!ltr && (ch == end || ch == begin)) { ch++ }
    // To determine which side to associate with, get the box to the
    // left of the character and compare it's vertical position to the
    // coordinates
    sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
      (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?
      "after" : "before"
    // Now get accurate coordinates for this place, in order to get a
    // base X position
    var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure)
    baseX = coords.left
    outside = y < coords.top || y >= coords.bottom
  }

  ch = skipExtendingChars(lineObj.text, ch, 1)
  return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)
}

function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
  // Bidi parts are sorted left-to-right, and in a non-line-wrapping
  // situation, we can take this ordering to correspond to the visual
  // ordering. This finds the first part whose end is after the given
  // coordinates.
  var index = findFirst(function (i) {
    var part = order[i], ltr = part.level != 1
    return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                   "line", lineObj, preparedMeasure), x, y, true)
  }, 0, order.length - 1)
  var part = order[index]
  // If this isn't the first part, the part's start is also after
  // the coordinates, and the coordinates aren't on the same line as
  // that start, move one part back.
  if (index > 0) {
    var ltr = part.level != 1
    var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"),
                             "line", lineObj, preparedMeasure)
    if (boxIsAfter(start, x, y, true) && start.top > y)
      { part = order[index - 1] }
  }
  return part
}

function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
  // In a wrapped line, rtl text on wrapping boundaries can do things
  // that don't correspond to the ordering in our `order` array at
  // all, so a binary search doesn't work, and we want to return a
  // part that only spans one line so that the binary search in
  // coordsCharInner is safe. As such, we first find the extent of the
  // wrapped line, and then do a flat search in which we discard any
  // spans that aren't on the line.
  var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
  var begin = ref.begin;
  var end = ref.end;
  var part = null, closestDist = null
  for (var i = 0; i < order.length; i++) {
    var p = order[i]
    if (p.from >= end || p.to <= begin) { continue }
    var ltr = p.level != 1
    var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right
    // Weigh against spans ending before this, so that they are only
    // picked if nothing ends after
    var dist = endX < x ? x - endX + 1e9 : endX - x
    if (!part || closestDist > dist) {
      part = p
      closestDist = dist
    }
  }
  if (!part) { part = order[order.length - 1] }
  // Clip the part to the wrapped line.
  if (part.from < begin) { part = {from: begin, to: part.to, level: part.level} }
  if (part.to > end) { part = {from: part.from, to: end, level: part.level} }
  return part
}

var measureText
// Compute the default text height.
function textHeight(display) {
  if (display.cachedTextHeight != null) { return display.cachedTextHeight }
  if (measureText == null) {
    measureText = elt("pre")
    // Measure a bunch of lines, for browsers that compute
    // fractional heights.
    for (var i = 0; i < 49; ++i) {
      measureText.appendChild(document.createTextNode("x"))
      measureText.appendChild(elt("br"))
    }
    measureText.appendChild(document.createTextNode("x"))
  }
  removeChildrenAndAdd(display.measure, measureText)
  var height = measureText.offsetHeight / 50
  if (height > 3) { display.cachedTextHeight = height }
  removeChildren(display.measure)
  return height || 1
}

// Compute the default character width.
function charWidth(display) {
  if (display.cachedCharWidth != null) { return display.cachedCharWidth }
  var anchor = elt("span", "xxxxxxxxxx")
  var pre = elt("pre", [anchor])
  removeChildrenAndAdd(display.measure, pre)
  var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10
  if (width > 2) { display.cachedCharWidth = width }
  return width || 10
}

// Do a bulk-read of the DOM positions and sizes needed to draw the
// view, so that we don't interleave reading and writing to the DOM.
function getDimensions(cm) {
  var d = cm.display, left = {}, width = {}
  var gutterLeft = d.gutters.clientLeft
  for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
    left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft
    width[cm.options.gutters[i]] = n.clientWidth
  }
  return {fixedPos: compensateForHScroll(d),
          gutterTotalWidth: d.gutters.offsetWidth,
          gutterLeft: left,
          gutterWidth: width,
          wrapperWidth: d.wrapper.clientWidth}
}

// Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
// but using getBoundingClientRect to get a sub-pixel-accurate
// result.
function compensateForHScroll(display) {
  return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
}

// Returns a function that estimates the height of a line, to use as
// first approximation until the line becomes visible (and is thus
// properly measurable).
function estimateHeight(cm) {
  var th = textHeight(cm.display), wrapping = cm.options.lineWrapping
  var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3)
  return function (line) {
    if (lineIsHidden(cm.doc, line)) { return 0 }

    var widgetsHeight = 0
    if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
      if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height }
    } }

    if (wrapping)
      { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
    else
      { return widgetsHeight + th }
  }
}

function estimateLineHeights(cm) {
  var doc = cm.doc, est = estimateHeight(cm)
  doc.iter(function (line) {
    var estHeight = est(line)
    if (estHeight != line.height) { updateLineHeight(line, estHeight) }
  })
}

// Given a mouse event, find the corresponding position. If liberal
// is false, it checks whether a gutter or scrollbar was clicked,
// and returns null if it was. forRect is used by rectangular
// selections, and tries to estimate a character position even for
// coordinates beyond the right of the text.
function posFromMouse(cm, e, liberal, forRect) {
  var display = cm.display
  if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

  var x, y, space = display.lineSpace.getBoundingClientRect()
  // Fails unpredictably on IE[67] when mouse is dragged around quickly.
  try { x = e.clientX - space.left; y = e.clientY - space.top }
  catch (e) { return null }
  var coords = coordsChar(cm, x, y), line
  if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
    var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length
    coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff))
  }
  return coords
}

// Find the view element corresponding to a given line. Return null
// when the line isn't visible.
function findViewIndex(cm, n) {
  if (n >= cm.display.viewTo) { return null }
  n -= cm.display.viewFrom
  if (n < 0) { return null }
  var view = cm.display.view
  for (var i = 0; i < view.length; i++) {
    n -= view[i].size
    if (n < 0) { return i }
  }
}

function updateSelection(cm) {
  cm.display.input.showSelection(cm.display.input.prepareSelection())
}

function prepareSelection(cm, primary) {
  if ( primary === void 0 ) primary = true;

  var doc = cm.doc, result = {}
  var curFragment = result.cursors = document.createDocumentFragment()
  var selFragment = result.selection = document.createDocumentFragment()

  for (var i = 0; i < doc.sel.ranges.length; i++) {
    if (!primary && i == doc.sel.primIndex) { continue }
    var range = doc.sel.ranges[i]
    if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }
    var collapsed = range.empty()
    if (collapsed || cm.options.showCursorWhenSelecting)
      { drawSelectionCursor(cm, range.head, curFragment) }
    if (!collapsed)
      { drawSelectionRange(cm, range, selFragment) }
  }
  return result
}

// Draws a cursor for the given range
function drawSelectionCursor(cm, head, output) {
  var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine)

  var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"))
  cursor.style.left = pos.left + "px"
  cursor.style.top = pos.top + "px"
  cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px"

  if (pos.other) {
    // Secondary cursor, shown when on a 'jump' in bi-directional text
    var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"))
    otherCursor.style.display = ""
    otherCursor.style.left = pos.other.left + "px"
    otherCursor.style.top = pos.other.top + "px"
    otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px"
  }
}

function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

// Draws the given range as a highlighted selection
function drawSelectionRange(cm, range, output) {
  var display = cm.display, doc = cm.doc
  var fragment = document.createDocumentFragment()
  var padding = paddingH(cm.display), leftSide = padding.left
  var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right

  function add(left, top, width, bottom) {
    if (top < 0) { top = 0 }
    top = Math.round(top)
    bottom = Math.round(bottom)
    fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")))
  }

  function drawForLine(line, fromArg, toArg) {
    var lineObj = getLine(doc, line)
    var lineLen = lineObj.text.length
    var start, end
    function coords(ch, bias) {
      return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
    }

    var order = getOrder(lineObj, doc.direction)
    iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
      var fromPos = coords(from, dir == "ltr" ? "left" : "right")
      var toPos = coords(to - 1, dir == "ltr" ? "right" : "left")
      if (dir == "ltr") {
        var fromLeft = fromArg == null && from == 0 ? leftSide : fromPos.left
        var toRight = toArg == null && to == lineLen ? rightSide : toPos.right
        if (toPos.top - fromPos.top <= 3) { // Single line
          add(fromLeft, toPos.top, toRight - fromLeft, toPos.bottom)
        } else { // Multiple lines
          add(fromLeft, fromPos.top, null, fromPos.bottom)
          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top) }
          add(leftSide, toPos.top, toPos.right, toPos.bottom)
        }
      } else if (from < to) { // RTL
        var fromRight = fromArg == null && from == 0 ? rightSide : fromPos.right
        var toLeft = toArg == null && to == lineLen ? leftSide : toPos.left
        if (toPos.top - fromPos.top <= 3) { // Single line
          add(toLeft, toPos.top, fromRight - toLeft, toPos.bottom)
        } else { // Multiple lines
          var topLeft = leftSide
          if (i) {
            var topEnd = wrappedLineExtentChar(cm, lineObj, null, from).end
            // The coordinates returned for an RTL wrapped space tend to
            // be complete bogus, so try to skip that here.
            topLeft = coords(topEnd - (/\s/.test(lineObj.text.charAt(topEnd - 1)) ? 2 : 1), "left").left
          }
          add(topLeft, fromPos.top, fromRight - topLeft, fromPos.bottom)
          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top) }
          var botWidth = null
          if (i < order.length  - 1 || true) {
            var botStart = wrappedLineExtentChar(cm, lineObj, null, to).begin
            botWidth = coords(botStart, "right").right - toLeft
          }
          add(toLeft, toPos.top, botWidth, toPos.bottom)
        }
      }

      if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos }
      if (cmpCoords(toPos, start) < 0) { start = toPos }
      if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos }
      if (cmpCoords(toPos, end) < 0) { end = toPos }
    })
    return {start: start, end: end}
  }

  var sFrom = range.from(), sTo = range.to()
  if (sFrom.line == sTo.line) {
    drawForLine(sFrom.line, sFrom.ch, sTo.ch)
  } else {
    var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line)
    var singleVLine = visualLine(fromLine) == visualLine(toLine)
    var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end
    var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start
    if (singleVLine) {
      if (leftEnd.top < rightStart.top - 2) {
        add(leftEnd.right, leftEnd.top, null, leftEnd.bottom)
        add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)
      } else {
        add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)
      }
    }
    if (leftEnd.bottom < rightStart.top)
      { add(leftSide, leftEnd.bottom, null, rightStart.top) }
  }

  output.appendChild(fragment)
}

// Cursor-blinking
function restartBlink(cm) {
  if (!cm.state.focused) { return }
  var display = cm.display
  clearInterval(display.blinker)
  var on = true
  display.cursorDiv.style.visibility = ""
  if (cm.options.cursorBlinkRate > 0)
    { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"; },
      cm.options.cursorBlinkRate) }
  else if (cm.options.cursorBlinkRate < 0)
    { display.cursorDiv.style.visibility = "hidden" }
}

function ensureFocus(cm) {
  if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm) }
}

function delayBlurEvent(cm) {
  cm.state.delayingBlurEvent = true
  setTimeout(function () { if (cm.state.delayingBlurEvent) {
    cm.state.delayingBlurEvent = false
    onBlur(cm)
  } }, 100)
}

function onFocus(cm, e) {
  if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false }

  if (cm.options.readOnly == "nocursor") { return }
  if (!cm.state.focused) {
    signal(cm, "focus", cm, e)
    cm.state.focused = true
    addClass(cm.display.wrapper, "CodeMirror-focused")
    // This test prevents this from firing when a context
    // menu is closed (since the input reset would kill the
    // select-all detection hack)
    if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
      cm.display.input.reset()
      if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20) } // Issue #1730
    }
    cm.display.input.receivedFocus()
  }
  restartBlink(cm)
}
function onBlur(cm, e) {
  if (cm.state.delayingBlurEvent) { return }

  if (cm.state.focused) {
    signal(cm, "blur", cm, e)
    cm.state.focused = false
    rmClass(cm.display.wrapper, "CodeMirror-focused")
  }
  clearInterval(cm.display.blinker)
  setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false } }, 150)
}

// Read the actual heights of the rendered lines, and update their
// stored heights to match.
function updateHeightsInViewport(cm) {
  var display = cm.display
  var prevBottom = display.lineDiv.offsetTop
  for (var i = 0; i < display.view.length; i++) {
    var cur = display.view[i], height = (void 0)
    if (cur.hidden) { continue }
    if (ie && ie_version < 8) {
      var bot = cur.node.offsetTop + cur.node.offsetHeight
      height = bot - prevBottom
      prevBottom = bot
    } else {
      var box = cur.node.getBoundingClientRect()
      height = box.bottom - box.top
    }
    var diff = cur.line.height - height
    if (height < 2) { height = textHeight(display) }
    if (diff > .005 || diff < -.005) {
      updateLineHeight(cur.line, height)
      updateWidgetHeight(cur.line)
      if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
        { updateWidgetHeight(cur.rest[j]) } }
    }
  }
}

// Read and store the height of line widgets associated with the
// given line.
function updateWidgetHeight(line) {
  if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i)
    { line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight } }
}

// Compute the lines that are visible in a given viewport (defaults
// the the current scroll position). viewport may contain top,
// height, and ensure (see op.scrollToPos) properties.
function visibleLines(display, doc, viewport) {
  var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop
  top = Math.floor(top - paddingTop(display))
  var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight

  var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom)
  // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
  // forces those lines into the viewport (if possible).
  if (viewport && viewport.ensure) {
    var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line
    if (ensureFrom < from) {
      from = ensureFrom
      to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)
    } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
      from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight)
      to = ensureTo
    }
  }
  return {from: from, to: Math.max(to, from + 1)}
}

// Re-align line numbers and gutter marks to compensate for
// horizontal scrolling.
function alignHorizontally(cm) {
  var display = cm.display, view = display.view
  if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
  var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft
  var gutterW = display.gutters.offsetWidth, left = comp + "px"
  for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
    if (cm.options.fixedGutter) {
      if (view[i].gutter)
        { view[i].gutter.style.left = left }
      if (view[i].gutterBackground)
        { view[i].gutterBackground.style.left = left }
    }
    var align = view[i].alignable
    if (align) { for (var j = 0; j < align.length; j++)
      { align[j].style.left = left } }
  } }
  if (cm.options.fixedGutter)
    { display.gutters.style.left = (comp + gutterW) + "px" }
}

// Used to ensure that the line number gutter is still the right
// size for the current document size. Returns true when an update
// is needed.
function maybeUpdateLineNumberWidth(cm) {
  if (!cm.options.lineNumbers) { return false }
  var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display
  if (last.length != display.lineNumChars) {
    var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                               "CodeMirror-linenumber CodeMirror-gutter-elt"))
    var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW
    display.lineGutter.style.width = ""
    display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1
    display.lineNumWidth = display.lineNumInnerWidth + padding
    display.lineNumChars = display.lineNumInnerWidth ? last.length : -1
    display.lineGutter.style.width = display.lineNumWidth + "px"
    updateGutterSpace(cm)
    return true
  }
  return false
}

// SCROLLING THINGS INTO VIEW

// If an editor sits on the top or bottom of the window, partially
// scrolled out of view, this ensures that the cursor is visible.
function maybeScrollWindow(cm, rect) {
  if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

  var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null
  if (rect.top + box.top < 0) { doScroll = true }
  else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false }
  if (doScroll != null && !phantom) {
    var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"))
    cm.display.lineSpace.appendChild(scrollNode)
    scrollNode.scrollIntoView(doScroll)
    cm.display.lineSpace.removeChild(scrollNode)
  }
}

// Scroll a given position into view (immediately), verifying that
// it actually became visible (as line heights are accurately
// measured, the position of something may 'drift' during drawing).
function scrollPosIntoView(cm, pos, end, margin) {
  if (margin == null) { margin = 0 }
  var rect
  if (!cm.options.lineWrapping && pos == end) {
    // Set pos and end to the cursor positions around the character pos sticks to
    // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
    // If pos == Pos(_, 0, "before"), pos and end are unchanged
    pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos
    end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos
  }
  for (var limit = 0; limit < 5; limit++) {
    var changed = false
    var coords = cursorCoords(cm, pos)
    var endCoords = !end || end == pos ? coords : cursorCoords(cm, end)
    rect = {left: Math.min(coords.left, endCoords.left),
            top: Math.min(coords.top, endCoords.top) - margin,
            right: Math.max(coords.left, endCoords.left),
            bottom: Math.max(coords.bottom, endCoords.bottom) + margin}
    var scrollPos = calculateScrollPos(cm, rect)
    var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft
    if (scrollPos.scrollTop != null) {
      updateScrollTop(cm, scrollPos.scrollTop)
      if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true }
    }
    if (scrollPos.scrollLeft != null) {
      setScrollLeft(cm, scrollPos.scrollLeft)
      if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true }
    }
    if (!changed) { break }
  }
  return rect
}

// Scroll a given set of coordinates into view (immediately).
function scrollIntoView(cm, rect) {
  var scrollPos = calculateScrollPos(cm, rect)
  if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop) }
  if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft) }
}

// Calculate a new scroll position needed to scroll the given
// rectangle into view. Returns an object with scrollTop and
// scrollLeft properties. When these are undefined, the
// vertical/horizontal position does not need to be adjusted.
function calculateScrollPos(cm, rect) {
  var display = cm.display, snapMargin = textHeight(cm.display)
  if (rect.top < 0) { rect.top = 0 }
  var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop
  var screen = displayHeight(cm), result = {}
  if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen }
  var docBottom = cm.doc.height + paddingVert(display)
  var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin
  if (rect.top < screentop) {
    result.scrollTop = atTop ? 0 : rect.top
  } else if (rect.bottom > screentop + screen) {
    var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen)
    if (newTop != screentop) { result.scrollTop = newTop }
  }

  var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft
  var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0)
  var tooWide = rect.right - rect.left > screenw
  if (tooWide) { rect.right = rect.left + screenw }
  if (rect.left < 10)
    { result.scrollLeft = 0 }
  else if (rect.left < screenleft)
    { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)) }
  else if (rect.right > screenw + screenleft - 3)
    { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw }
  return result
}

// Store a relative adjustment to the scroll position in the current
// operation (to be applied when the operation finishes).
function addToScrollTop(cm, top) {
  if (top == null) { return }
  resolveScrollToPos(cm)
  cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top
}

// Make sure that at the end of the operation the current cursor is
// shown.
function ensureCursorVisible(cm) {
  resolveScrollToPos(cm)
  var cur = cm.getCursor()
  cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin}
}

function scrollToCoords(cm, x, y) {
  if (x != null || y != null) { resolveScrollToPos(cm) }
  if (x != null) { cm.curOp.scrollLeft = x }
  if (y != null) { cm.curOp.scrollTop = y }
}

function scrollToRange(cm, range) {
  resolveScrollToPos(cm)
  cm.curOp.scrollToPos = range
}

// When an operation has its scrollToPos property set, and another
// scroll action is applied before the end of the operation, this
// 'simulates' scrolling that position into view in a cheap way, so
// that the effect of intermediate scroll commands is not ignored.
function resolveScrollToPos(cm) {
  var range = cm.curOp.scrollToPos
  if (range) {
    cm.curOp.scrollToPos = null
    var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to)
    scrollToCoordsRange(cm, from, to, range.margin)
  }
}

function scrollToCoordsRange(cm, from, to, margin) {
  var sPos = calculateScrollPos(cm, {
    left: Math.min(from.left, to.left),
    top: Math.min(from.top, to.top) - margin,
    right: Math.max(from.right, to.right),
    bottom: Math.max(from.bottom, to.bottom) + margin
  })
  scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop)
}

// Sync the scrollable area and scrollbars, ensure the viewport
// covers the visible area.
function updateScrollTop(cm, val) {
  if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
  if (!gecko) { updateDisplaySimple(cm, {top: val}) }
  setScrollTop(cm, val, true)
  if (gecko) { updateDisplaySimple(cm) }
  startWorker(cm, 100)
}

function setScrollTop(cm, val, forceScroll) {
  val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val)
  if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
  cm.doc.scrollTop = val
  cm.display.scrollbars.setScrollTop(val)
  if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val }
}

// Sync scroller and scrollbar, ensure the gutter elements are
// aligned.
function setScrollLeft(cm, val, isScroller, forceScroll) {
  val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth)
  if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
  cm.doc.scrollLeft = val
  alignHorizontally(cm)
  if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val }
  cm.display.scrollbars.setScrollLeft(val)
}

// SCROLLBARS

// Prepare DOM reads needed to update the scrollbars. Done in one
// shot to minimize update/measure roundtrips.
function measureForScrollbars(cm) {
  var d = cm.display, gutterW = d.gutters.offsetWidth
  var docH = Math.round(cm.doc.height + paddingVert(cm.display))
  return {
    clientHeight: d.scroller.clientHeight,
    viewHeight: d.wrapper.clientHeight,
    scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
    viewWidth: d.wrapper.clientWidth,
    barLeft: cm.options.fixedGutter ? gutterW : 0,
    docHeight: docH,
    scrollHeight: docH + scrollGap(cm) + d.barHeight,
    nativeBarWidth: d.nativeBarWidth,
    gutterWidth: gutterW
  }
}

var NativeScrollbars = function(place, scroll, cm) {
  this.cm = cm
  var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar")
  var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar")
  place(vert); place(horiz)

  on(vert, "scroll", function () {
    if (vert.clientHeight) { scroll(vert.scrollTop, "vertical") }
  })
  on(horiz, "scroll", function () {
    if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal") }
  })

  this.checkedZeroWidth = false
  // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
  if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px" }
};

NativeScrollbars.prototype.update = function (measure) {
  var needsH = measure.scrollWidth > measure.clientWidth + 1
  var needsV = measure.scrollHeight > measure.clientHeight + 1
  var sWidth = measure.nativeBarWidth

  if (needsV) {
    this.vert.style.display = "block"
    this.vert.style.bottom = needsH ? sWidth + "px" : "0"
    var totalHeight = measure.viewHeight - (needsH ? sWidth : 0)
    // A bug in IE8 can cause this value to be negative, so guard it.
    this.vert.firstChild.style.height =
      Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px"
  } else {
    this.vert.style.display = ""
    this.vert.firstChild.style.height = "0"
  }

  if (needsH) {
    this.horiz.style.display = "block"
    this.horiz.style.right = needsV ? sWidth + "px" : "0"
    this.horiz.style.left = measure.barLeft + "px"
    var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0)
    this.horiz.firstChild.style.width =
      Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px"
  } else {
    this.horiz.style.display = ""
    this.horiz.firstChild.style.width = "0"
  }

  if (!this.checkedZeroWidth && measure.clientHeight > 0) {
    if (sWidth == 0) { this.zeroWidthHack() }
    this.checkedZeroWidth = true
  }

  return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
};

NativeScrollbars.prototype.setScrollLeft = function (pos) {
  if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos }
  if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz") }
};

NativeScrollbars.prototype.setScrollTop = function (pos) {
  if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos }
  if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert") }
};

NativeScrollbars.prototype.zeroWidthHack = function () {
  var w = mac && !mac_geMountainLion ? "12px" : "18px"
  this.horiz.style.height = this.vert.style.width = w
  this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none"
  this.disableHoriz = new Delayed
  this.disableVert = new Delayed
};

NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
  bar.style.pointerEvents = "auto"
  function maybeDisable() {
    // To find out whether the scrollbar is still visible, we
    // check whether the element under the pixel in the bottom
    // right corner of the scrollbar box is the scrollbar box
    // itself (when the bar is still visible) or its filler child
    // (when the bar is hidden). If it is still visible, we keep
    // it enabled, if it's hidden, we disable pointer events.
    var box = bar.getBoundingClientRect()
    var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
        : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1)
    if (elt != bar) { bar.style.pointerEvents = "none" }
    else { delay.set(1000, maybeDisable) }
  }
  delay.set(1000, maybeDisable)
};

NativeScrollbars.prototype.clear = function () {
  var parent = this.horiz.parentNode
  parent.removeChild(this.horiz)
  parent.removeChild(this.vert)
};

var NullScrollbars = function () {};

NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
NullScrollbars.prototype.setScrollLeft = function () {};
NullScrollbars.prototype.setScrollTop = function () {};
NullScrollbars.prototype.clear = function () {};

function updateScrollbars(cm, measure) {
  if (!measure) { measure = measureForScrollbars(cm) }
  var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight
  updateScrollbarsInner(cm, measure)
  for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
    if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
      { updateHeightsInViewport(cm) }
    updateScrollbarsInner(cm, measureForScrollbars(cm))
    startWidth = cm.display.barWidth; startHeight = cm.display.barHeight
  }
}

// Re-synchronize the fake scrollbars with the actual size of the
// content.
function updateScrollbarsInner(cm, measure) {
  var d = cm.display
  var sizes = d.scrollbars.update(measure)

  d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px"
  d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px"
  d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent"

  if (sizes.right && sizes.bottom) {
    d.scrollbarFiller.style.display = "block"
    d.scrollbarFiller.style.height = sizes.bottom + "px"
    d.scrollbarFiller.style.width = sizes.right + "px"
  } else { d.scrollbarFiller.style.display = "" }
  if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
    d.gutterFiller.style.display = "block"
    d.gutterFiller.style.height = sizes.bottom + "px"
    d.gutterFiller.style.width = measure.gutterWidth + "px"
  } else { d.gutterFiller.style.display = "" }
}

var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars}

function initScrollbars(cm) {
  if (cm.display.scrollbars) {
    cm.display.scrollbars.clear()
    if (cm.display.scrollbars.addClass)
      { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass) }
  }

  cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
    cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller)
    // Prevent clicks in the scrollbars from killing focus
    on(node, "mousedown", function () {
      if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0) }
    })
    node.setAttribute("cm-not-content", "true")
  }, function (pos, axis) {
    if (axis == "horizontal") { setScrollLeft(cm, pos) }
    else { updateScrollTop(cm, pos) }
  }, cm)
  if (cm.display.scrollbars.addClass)
    { addClass(cm.display.wrapper, cm.display.scrollbars.addClass) }
}

// Operations are used to wrap a series of changes to the editor
// state in such a way that each change won't have to update the
// cursor and display (which would be awkward, slow, and
// error-prone). Instead, display updates are batched and then all
// combined and executed at once.

var nextOpId = 0
// Start a new operation.
function startOperation(cm) {
  cm.curOp = {
    cm: cm,
    viewChanged: false,      // Flag that indicates that lines might need to be redrawn
    startHeight: cm.doc.height, // Used to detect need to update scrollbar
    forceUpdate: false,      // Used to force a redraw
    updateInput: null,       // Whether to reset the input textarea
    typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
    changeObjs: null,        // Accumulated changes, for firing change events
    cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
    cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
    selectionChanged: false, // Whether the selection needs to be redrawn
    updateMaxLine: false,    // Set when the widest line needs to be determined anew
    scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
    scrollToPos: null,       // Used to scroll to a specific position
    focus: false,
    id: ++nextOpId           // Unique ID
  }
  pushOperation(cm.curOp)
}

// Finish an operation, updating the display and signalling delayed events
function endOperation(cm) {
  var op = cm.curOp
  finishOperation(op, function (group) {
    for (var i = 0; i < group.ops.length; i++)
      { group.ops[i].cm.curOp = null }
    endOperations(group)
  })
}

// The DOM updates done when an operation finishes are batched so
// that the minimum number of relayouts are required.
function endOperations(group) {
  var ops = group.ops
  for (var i = 0; i < ops.length; i++) // Read DOM
    { endOperation_R1(ops[i]) }
  for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
    { endOperation_W1(ops[i$1]) }
  for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
    { endOperation_R2(ops[i$2]) }
  for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
    { endOperation_W2(ops[i$3]) }
  for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
    { endOperation_finish(ops[i$4]) }
}

function endOperation_R1(op) {
  var cm = op.cm, display = cm.display
  maybeClipScrollbars(cm)
  if (op.updateMaxLine) { findMaxLine(cm) }

  op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
    op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                       op.scrollToPos.to.line >= display.viewTo) ||
    display.maxLineChanged && cm.options.lineWrapping
  op.update = op.mustUpdate &&
    new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate)
}

function endOperation_W1(op) {
  op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update)
}

function endOperation_R2(op) {
  var cm = op.cm, display = cm.display
  if (op.updatedDisplay) { updateHeightsInViewport(cm) }

  op.barMeasure = measureForScrollbars(cm)

  // If the max line changed since it was last measured, measure it,
  // and ensure the document's width matches it.
  // updateDisplay_W2 will use these properties to do the actual resizing
  if (display.maxLineChanged && !cm.options.lineWrapping) {
    op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3
    cm.display.sizerWidth = op.adjustWidthTo
    op.barMeasure.scrollWidth =
      Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth)
    op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))
  }

  if (op.updatedDisplay || op.selectionChanged)
    { op.preparedSelection = display.input.prepareSelection() }
}

function endOperation_W2(op) {
  var cm = op.cm

  if (op.adjustWidthTo != null) {
    cm.display.sizer.style.minWidth = op.adjustWidthTo + "px"
    if (op.maxScrollLeft < cm.doc.scrollLeft)
      { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true) }
    cm.display.maxLineChanged = false
  }

  var takeFocus = op.focus && op.focus == activeElt()
  if (op.preparedSelection)
    { cm.display.input.showSelection(op.preparedSelection, takeFocus) }
  if (op.updatedDisplay || op.startHeight != cm.doc.height)
    { updateScrollbars(cm, op.barMeasure) }
  if (op.updatedDisplay)
    { setDocumentHeight(cm, op.barMeasure) }

  if (op.selectionChanged) { restartBlink(cm) }

  if (cm.state.focused && op.updateInput)
    { cm.display.input.reset(op.typing) }
  if (takeFocus) { ensureFocus(op.cm) }
}

function endOperation_finish(op) {
  var cm = op.cm, display = cm.display, doc = cm.doc

  if (op.updatedDisplay) { postUpdateDisplay(cm, op.update) }

  // Abort mouse wheel delta measurement, when scrolling explicitly
  if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
    { display.wheelStartX = display.wheelStartY = null }

  // Propagate the scroll position to the actual DOM scroller
  if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll) }

  if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true) }
  // If we need to scroll a specific position into view, do so.
  if (op.scrollToPos) {
    var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                 clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin)
    maybeScrollWindow(cm, rect)
  }

  // Fire events for markers that are hidden/unidden by editing or
  // undoing
  var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers
  if (hidden) { for (var i = 0; i < hidden.length; ++i)
    { if (!hidden[i].lines.length) { signal(hidden[i], "hide") } } }
  if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
    { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide") } } }

  if (display.wrapper.offsetHeight)
    { doc.scrollTop = cm.display.scroller.scrollTop }

  // Fire change events, and delayed event handlers
  if (op.changeObjs)
    { signal(cm, "changes", cm, op.changeObjs) }
  if (op.update)
    { op.update.finish() }
}

// Run the given function in an operation
function runInOp(cm, f) {
  if (cm.curOp) { return f() }
  startOperation(cm)
  try { return f() }
  finally { endOperation(cm) }
}
// Wraps a function in an operation. Returns the wrapped function.
function operation(cm, f) {
  return function() {
    if (cm.curOp) { return f.apply(cm, arguments) }
    startOperation(cm)
    try { return f.apply(cm, arguments) }
    finally { endOperation(cm) }
  }
}
// Used to add methods to editor and doc instances, wrapping them in
// operations.
function methodOp(f) {
  return function() {
    if (this.curOp) { return f.apply(this, arguments) }
    startOperation(this)
    try { return f.apply(this, arguments) }
    finally { endOperation(this) }
  }
}
function docMethodOp(f) {
  return function() {
    var cm = this.cm
    if (!cm || cm.curOp) { return f.apply(this, arguments) }
    startOperation(cm)
    try { return f.apply(this, arguments) }
    finally { endOperation(cm) }
  }
}

// Updates the display.view data structure for a given change to the
// document. From and to are in pre-change coordinates. Lendiff is
// the amount of lines added or subtracted by the change. This is
// used for changes that span multiple lines, or change the way
// lines are divided into visual lines. regLineChange (below)
// registers single-line changes.
function regChange(cm, from, to, lendiff) {
  if (from == null) { from = cm.doc.first }
  if (to == null) { to = cm.doc.first + cm.doc.size }
  if (!lendiff) { lendiff = 0 }

  var display = cm.display
  if (lendiff && to < display.viewTo &&
      (display.updateLineNumbers == null || display.updateLineNumbers > from))
    { display.updateLineNumbers = from }

  cm.curOp.viewChanged = true

  if (from >= display.viewTo) { // Change after
    if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
      { resetView(cm) }
  } else if (to <= display.viewFrom) { // Change before
    if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
      resetView(cm)
    } else {
      display.viewFrom += lendiff
      display.viewTo += lendiff
    }
  } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
    resetView(cm)
  } else if (from <= display.viewFrom) { // Top overlap
    var cut = viewCuttingPoint(cm, to, to + lendiff, 1)
    if (cut) {
      display.view = display.view.slice(cut.index)
      display.viewFrom = cut.lineN
      display.viewTo += lendiff
    } else {
      resetView(cm)
    }
  } else if (to >= display.viewTo) { // Bottom overlap
    var cut$1 = viewCuttingPoint(cm, from, from, -1)
    if (cut$1) {
      display.view = display.view.slice(0, cut$1.index)
      display.viewTo = cut$1.lineN
    } else {
      resetView(cm)
    }
  } else { // Gap in the middle
    var cutTop = viewCuttingPoint(cm, from, from, -1)
    var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1)
    if (cutTop && cutBot) {
      display.view = display.view.slice(0, cutTop.index)
        .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
        .concat(display.view.slice(cutBot.index))
      display.viewTo += lendiff
    } else {
      resetView(cm)
    }
  }

  var ext = display.externalMeasured
  if (ext) {
    if (to < ext.lineN)
      { ext.lineN += lendiff }
    else if (from < ext.lineN + ext.size)
      { display.externalMeasured = null }
  }
}

// Register a change to a single line. Type must be one of "text",
// "gutter", "class", "widget"
function regLineChange(cm, line, type) {
  cm.curOp.viewChanged = true
  var display = cm.display, ext = cm.display.externalMeasured
  if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
    { display.externalMeasured = null }

  if (line < display.viewFrom || line >= display.viewTo) { return }
  var lineView = display.view[findViewIndex(cm, line)]
  if (lineView.node == null) { return }
  var arr = lineView.changes || (lineView.changes = [])
  if (indexOf(arr, type) == -1) { arr.push(type) }
}

// Clear the view.
function resetView(cm) {
  cm.display.viewFrom = cm.display.viewTo = cm.doc.first
  cm.display.view = []
  cm.display.viewOffset = 0
}

function viewCuttingPoint(cm, oldN, newN, dir) {
  var index = findViewIndex(cm, oldN), diff, view = cm.display.view
  if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
    { return {index: index, lineN: newN} }
  var n = cm.display.viewFrom
  for (var i = 0; i < index; i++)
    { n += view[i].size }
  if (n != oldN) {
    if (dir > 0) {
      if (index == view.length - 1) { return null }
      diff = (n + view[index].size) - oldN
      index++
    } else {
      diff = n - oldN
    }
    oldN += diff; newN += diff
  }
  while (visualLineNo(cm.doc, newN) != newN) {
    if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
    newN += dir * view[index - (dir < 0 ? 1 : 0)].size
    index += dir
  }
  return {index: index, lineN: newN}
}

// Force the view to cover a given range, adding empty view element
// or clipping off existing ones as needed.
function adjustView(cm, from, to) {
  var display = cm.display, view = display.view
  if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
    display.view = buildViewArray(cm, from, to)
    display.viewFrom = from
  } else {
    if (display.viewFrom > from)
      { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) }
    else if (display.viewFrom < from)
      { display.view = display.view.slice(findViewIndex(cm, from)) }
    display.viewFrom = from
    if (display.viewTo < to)
      { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) }
    else if (display.viewTo > to)
      { display.view = display.view.slice(0, findViewIndex(cm, to)) }
  }
  display.viewTo = to
}

// Count the number of lines in the view whose DOM representation is
// out of date (or nonexistent).
function countDirtyView(cm) {
  var view = cm.display.view, dirty = 0
  for (var i = 0; i < view.length; i++) {
    var lineView = view[i]
    if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty }
  }
  return dirty
}

// HIGHLIGHT WORKER

function startWorker(cm, time) {
  if (cm.doc.highlightFrontier < cm.display.viewTo)
    { cm.state.highlight.set(time, bind(highlightWorker, cm)) }
}

function highlightWorker(cm) {
  var doc = cm.doc
  if (doc.highlightFrontier >= cm.display.viewTo) { return }
  var end = +new Date + cm.options.workTime
  var context = getContextBefore(cm, doc.highlightFrontier)
  var changedLines = []

  doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
    if (context.line >= cm.display.viewFrom) { // Visible
      var oldStyles = line.styles
      var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null
      var highlighted = highlightLine(cm, line, context, true)
      if (resetState) { context.state = resetState }
      line.styles = highlighted.styles
      var oldCls = line.styleClasses, newCls = highlighted.classes
      if (newCls) { line.styleClasses = newCls }
      else if (oldCls) { line.styleClasses = null }
      var ischange = !oldStyles || oldStyles.length != line.styles.length ||
        oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass)
      for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i] }
      if (ischange) { changedLines.push(context.line) }
      line.stateAfter = context.save()
      context.nextLine()
    } else {
      if (line.text.length <= cm.options.maxHighlightLength)
        { processLine(cm, line.text, context) }
      line.stateAfter = context.line % 5 == 0 ? context.save() : null
      context.nextLine()
    }
    if (+new Date > end) {
      startWorker(cm, cm.options.workDelay)
      return true
    }
  })
  doc.highlightFrontier = context.line
  doc.modeFrontier = Math.max(doc.modeFrontier, context.line)
  if (changedLines.length) { runInOp(cm, function () {
    for (var i = 0; i < changedLines.length; i++)
      { regLineChange(cm, changedLines[i], "text") }
  }) }
}

// DISPLAY DRAWING

var DisplayUpdate = function(cm, viewport, force) {
  var display = cm.display

  this.viewport = viewport
  // Store some values that we'll need later (but don't want to force a relayout for)
  this.visible = visibleLines(display, cm.doc, viewport)
  this.editorIsHidden = !display.wrapper.offsetWidth
  this.wrapperHeight = display.wrapper.clientHeight
  this.wrapperWidth = display.wrapper.clientWidth
  this.oldDisplayWidth = displayWidth(cm)
  this.force = force
  this.dims = getDimensions(cm)
  this.events = []
};

DisplayUpdate.prototype.signal = function (emitter, type) {
  if (hasHandler(emitter, type))
    { this.events.push(arguments) }
};
DisplayUpdate.prototype.finish = function () {
    var this$1 = this;

  for (var i = 0; i < this.events.length; i++)
    { signal.apply(null, this$1.events[i]) }
};

function maybeClipScrollbars(cm) {
  var display = cm.display
  if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
    display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth
    display.heightForcer.style.height = scrollGap(cm) + "px"
    display.sizer.style.marginBottom = -display.nativeBarWidth + "px"
    display.sizer.style.borderRightWidth = scrollGap(cm) + "px"
    display.scrollbarsClipped = true
  }
}

function selectionSnapshot(cm) {
  if (cm.hasFocus()) { return null }
  var active = activeElt()
  if (!active || !contains(cm.display.lineDiv, active)) { return null }
  var result = {activeElt: active}
  if (window.getSelection) {
    var sel = window.getSelection()
    if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
      result.anchorNode = sel.anchorNode
      result.anchorOffset = sel.anchorOffset
      result.focusNode = sel.focusNode
      result.focusOffset = sel.focusOffset
    }
  }
  return result
}

function restoreSelection(snapshot) {
  if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
  snapshot.activeElt.focus()
  if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
    var sel = window.getSelection(), range = document.createRange()
    range.setEnd(snapshot.anchorNode, snapshot.anchorOffset)
    range.collapse(false)
    sel.removeAllRanges()
    sel.addRange(range)
    sel.extend(snapshot.focusNode, snapshot.focusOffset)
  }
}

// Does the actual updating of the line display. Bails out
// (returning false) when there is nothing to be done and forced is
// false.
function updateDisplayIfNeeded(cm, update) {
  var display = cm.display, doc = cm.doc

  if (update.editorIsHidden) {
    resetView(cm)
    return false
  }

  // Bail out if the visible area is already rendered and nothing changed.
  if (!update.force &&
      update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
      display.renderedView == display.view && countDirtyView(cm) == 0)
    { return false }

  if (maybeUpdateLineNumberWidth(cm)) {
    resetView(cm)
    update.dims = getDimensions(cm)
  }

  // Compute a suitable new viewport (from & to)
  var end = doc.first + doc.size
  var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first)
  var to = Math.min(end, update.visible.to + cm.options.viewportMargin)
  if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom) }
  if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo) }
  if (sawCollapsedSpans) {
    from = visualLineNo(cm.doc, from)
    to = visualLineEndNo(cm.doc, to)
  }

  var different = from != display.viewFrom || to != display.viewTo ||
    display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth
  adjustView(cm, from, to)

  display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom))
  // Position the mover div to align with the current scroll position
  cm.display.mover.style.top = display.viewOffset + "px"

  var toUpdate = countDirtyView(cm)
  if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
      (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
    { return false }

  // For big changes, we hide the enclosing element during the
  // update, since that speeds up the operations on most browsers.
  var selSnapshot = selectionSnapshot(cm)
  if (toUpdate > 4) { display.lineDiv.style.display = "none" }
  patchDisplay(cm, display.updateLineNumbers, update.dims)
  if (toUpdate > 4) { display.lineDiv.style.display = "" }
  display.renderedView = display.view
  // There might have been a widget with a focused element that got
  // hidden or updated, if so re-focus it.
  restoreSelection(selSnapshot)

  // Prevent selection and cursors from interfering with the scroll
  // width and height.
  removeChildren(display.cursorDiv)
  removeChildren(display.selectionDiv)
  display.gutters.style.height = display.sizer.style.minHeight = 0

  if (different) {
    display.lastWrapHeight = update.wrapperHeight
    display.lastWrapWidth = update.wrapperWidth
    startWorker(cm, 400)
  }

  display.updateLineNumbers = null

  return true
}

function postUpdateDisplay(cm, update) {
  var viewport = update.viewport

  for (var first = true;; first = false) {
    if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
      // Clip forced viewport to actual scrollable area.
      if (viewport && viewport.top != null)
        { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)} }
      // Updated line heights might result in the drawn area not
      // actually covering the viewport. Keep looping until it does.
      update.visible = visibleLines(cm.display, cm.doc, viewport)
      if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
        { break }
    }
    if (!updateDisplayIfNeeded(cm, update)) { break }
    updateHeightsInViewport(cm)
    var barMeasure = measureForScrollbars(cm)
    updateSelection(cm)
    updateScrollbars(cm, barMeasure)
    setDocumentHeight(cm, barMeasure)
    update.force = false
  }

  update.signal(cm, "update", cm)
  if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
    update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo)
    cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo
  }
}

function updateDisplaySimple(cm, viewport) {
  var update = new DisplayUpdate(cm, viewport)
  if (updateDisplayIfNeeded(cm, update)) {
    updateHeightsInViewport(cm)
    postUpdateDisplay(cm, update)
    var barMeasure = measureForScrollbars(cm)
    updateSelection(cm)
    updateScrollbars(cm, barMeasure)
    setDocumentHeight(cm, barMeasure)
    update.finish()
  }
}

// Sync the actual display DOM structure with display.view, removing
// nodes for lines that are no longer in view, and creating the ones
// that are not there yet, and updating the ones that are out of
// date.
function patchDisplay(cm, updateNumbersFrom, dims) {
  var display = cm.display, lineNumbers = cm.options.lineNumbers
  var container = display.lineDiv, cur = container.firstChild

  function rm(node) {
    var next = node.nextSibling
    // Works around a throw-scroll bug in OS X Webkit
    if (webkit && mac && cm.display.currentWheelTarget == node)
      { node.style.display = "none" }
    else
      { node.parentNode.removeChild(node) }
    return next
  }

  var view = display.view, lineN = display.viewFrom
  // Loop over the elements in the view, syncing cur (the DOM nodes
  // in display.lineDiv) with the view as we go.
  for (var i = 0; i < view.length; i++) {
    var lineView = view[i]
    if (lineView.hidden) {
    } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
      var node = buildLineElement(cm, lineView, lineN, dims)
      container.insertBefore(node, cur)
    } else { // Already drawn
      while (cur != lineView.node) { cur = rm(cur) }
      var updateNumber = lineNumbers && updateNumbersFrom != null &&
        updateNumbersFrom <= lineN && lineView.lineNumber
      if (lineView.changes) {
        if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false }
        updateLineForChanges(cm, lineView, lineN, dims)
      }
      if (updateNumber) {
        removeChildren(lineView.lineNumber)
        lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))
      }
      cur = lineView.node.nextSibling
    }
    lineN += lineView.size
  }
  while (cur) { cur = rm(cur) }
}

function updateGutterSpace(cm) {
  var width = cm.display.gutters.offsetWidth
  cm.display.sizer.style.marginLeft = width + "px"
}

function setDocumentHeight(cm, measure) {
  cm.display.sizer.style.minHeight = measure.docHeight + "px"
  cm.display.heightForcer.style.top = measure.docHeight + "px"
  cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px"
}

// Rebuild the gutter elements, ensure the margin to the left of the
// code matches their width.
function updateGutters(cm) {
  var gutters = cm.display.gutters, specs = cm.options.gutters
  removeChildren(gutters)
  var i = 0
  for (; i < specs.length; ++i) {
    var gutterClass = specs[i]
    var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass))
    if (gutterClass == "CodeMirror-linenumbers") {
      cm.display.lineGutter = gElt
      gElt.style.width = (cm.display.lineNumWidth || 1) + "px"
    }
  }
  gutters.style.display = i ? "" : "none"
  updateGutterSpace(cm)
}

// Make sure the gutters options contains the element
// "CodeMirror-linenumbers" when the lineNumbers option is true.
function setGuttersForLineNumbers(options) {
  var found = indexOf(options.gutters, "CodeMirror-linenumbers")
  if (found == -1 && options.lineNumbers) {
    options.gutters = options.gutters.concat(["CodeMirror-linenumbers"])
  } else if (found > -1 && !options.lineNumbers) {
    options.gutters = options.gutters.slice(0)
    options.gutters.splice(found, 1)
  }
}

var wheelSamples = 0;
var wheelPixelsPerUnit = null;
// Fill in a browser-detected starting value on browsers where we
// know one. These don't have to be accurate -- the result of them
// being wrong would just be a slight flicker on the first wheel
// scroll (if it is large enough).
if (ie) { wheelPixelsPerUnit = -.53 }
else if (gecko) { wheelPixelsPerUnit = 15 }
else if (chrome) { wheelPixelsPerUnit = -.7 }
else if (safari) { wheelPixelsPerUnit = -1/3 }

function wheelEventDelta(e) {
  var dx = e.wheelDeltaX, dy = e.wheelDeltaY
  if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail }
  if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail }
  else if (dy == null) { dy = e.wheelDelta }
  return {x: dx, y: dy}
}
function wheelEventPixels(e) {
  var delta = wheelEventDelta(e)
  delta.x *= wheelPixelsPerUnit
  delta.y *= wheelPixelsPerUnit
  return delta
}

function onScrollWheel(cm, e) {
  var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y

  var display = cm.display, scroll = display.scroller
  // Quit if there's nothing to scroll here
  var canScrollX = scroll.scrollWidth > scroll.clientWidth
  var canScrollY = scroll.scrollHeight > scroll.clientHeight
  if (!(dx && canScrollX || dy && canScrollY)) { return }

  // Webkit browsers on OS X abort momentum scrolls when the target
  // of the scroll event is removed from the scrollable element.
  // This hack (see related code in patchDisplay) makes sure the
  // element is kept around.
  if (dy && mac && webkit) {
    outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
      for (var i = 0; i < view.length; i++) {
        if (view[i].node == cur) {
          cm.display.currentWheelTarget = cur
          break outer
        }
      }
    }
  }

  // On some browsers, horizontal scrolling will cause redraws to
  // happen before the gutter has been realigned, causing it to
  // wriggle around in a most unseemly way. When we have an
  // estimated pixels/delta value, we just handle horizontal
  // scrolling entirely here. It'll be slightly off from native, but
  // better than glitching out.
  if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
    if (dy && canScrollY)
      { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)) }
    setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit))
    // Only prevent default scrolling if vertical scrolling is
    // actually possible. Otherwise, it causes vertical scroll
    // jitter on OSX trackpads when deltaX is small and deltaY
    // is large (issue #3579)
    if (!dy || (dy && canScrollY))
      { e_preventDefault(e) }
    display.wheelStartX = null // Abort measurement, if in progress
    return
  }

  // 'Project' the visible viewport to cover the area that is being
  // scrolled into view (if we know enough to estimate it).
  if (dy && wheelPixelsPerUnit != null) {
    var pixels = dy * wheelPixelsPerUnit
    var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight
    if (pixels < 0) { top = Math.max(0, top + pixels - 50) }
    else { bot = Math.min(cm.doc.height, bot + pixels + 50) }
    updateDisplaySimple(cm, {top: top, bottom: bot})
  }

  if (wheelSamples < 20) {
    if (display.wheelStartX == null) {
      display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop
      display.wheelDX = dx; display.wheelDY = dy
      setTimeout(function () {
        if (display.wheelStartX == null) { return }
        var movedX = scroll.scrollLeft - display.wheelStartX
        var movedY = scroll.scrollTop - display.wheelStartY
        var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
          (movedX && display.wheelDX && movedX / display.wheelDX)
        display.wheelStartX = display.wheelStartY = null
        if (!sample) { return }
        wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1)
        ++wheelSamples
      }, 200)
    } else {
      display.wheelDX += dx; display.wheelDY += dy
    }
  }
}

// Selection objects are immutable. A new one is created every time
// the selection changes. A selection is one or more non-overlapping
// (and non-touching) ranges, sorted, and an integer that indicates
// which one is the primary selection (the one that's scrolled into
// view, that getCursor returns, etc).
var Selection = function(ranges, primIndex) {
  this.ranges = ranges
  this.primIndex = primIndex
};

Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

Selection.prototype.equals = function (other) {
    var this$1 = this;

  if (other == this) { return true }
  if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
  for (var i = 0; i < this.ranges.length; i++) {
    var here = this$1.ranges[i], there = other.ranges[i]
    if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
  }
  return true
};

Selection.prototype.deepCopy = function () {
    var this$1 = this;

  var out = []
  for (var i = 0; i < this.ranges.length; i++)
    { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)) }
  return new Selection(out, this.primIndex)
};

Selection.prototype.somethingSelected = function () {
    var this$1 = this;

  for (var i = 0; i < this.ranges.length; i++)
    { if (!this$1.ranges[i].empty()) { return true } }
  return false
};

Selection.prototype.contains = function (pos, end) {
    var this$1 = this;

  if (!end) { end = pos }
  for (var i = 0; i < this.ranges.length; i++) {
    var range = this$1.ranges[i]
    if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
      { return i }
  }
  return -1
};

var Range = function(anchor, head) {
  this.anchor = anchor; this.head = head
};

Range.prototype.from = function () { return minPos(this.anchor, this.head) };
Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

// Take an unsorted, potentially overlapping set of ranges, and
// build a selection out of it. 'Consumes' ranges array (modifying
// it).
function normalizeSelection(ranges, primIndex) {
  var prim = ranges[primIndex]
  ranges.sort(function (a, b) { return cmp(a.from(), b.from()); })
  primIndex = indexOf(ranges, prim)
  for (var i = 1; i < ranges.length; i++) {
    var cur = ranges[i], prev = ranges[i - 1]
    if (cmp(prev.to(), cur.from()) >= 0) {
      var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to())
      var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head
      if (i <= primIndex) { --primIndex }
      ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to))
    }
  }
  return new Selection(ranges, primIndex)
}

function simpleSelection(anchor, head) {
  return new Selection([new Range(anchor, head || anchor)], 0)
}

// Compute the position of the end of a change (its 'to' property
// refers to the pre-change end).
function changeEnd(change) {
  if (!change.text) { return change.to }
  return Pos(change.from.line + change.text.length - 1,
             lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
}

// Adjust a position to refer to the post-change position of the
// same text, or the end of the change if the change covers it.
function adjustForChange(pos, change) {
  if (cmp(pos, change.from) < 0) { return pos }
  if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

  var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch
  if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch }
  return Pos(line, ch)
}

function computeSelAfterChange(doc, change) {
  var out = []
  for (var i = 0; i < doc.sel.ranges.length; i++) {
    var range = doc.sel.ranges[i]
    out.push(new Range(adjustForChange(range.anchor, change),
                       adjustForChange(range.head, change)))
  }
  return normalizeSelection(out, doc.sel.primIndex)
}

function offsetPos(pos, old, nw) {
  if (pos.line == old.line)
    { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
  else
    { return Pos(nw.line + (pos.line - old.line), pos.ch) }
}

// Used by replaceSelections to allow moving the selection to the
// start or around the replaced test. Hint may be "start" or "around".
function computeReplacedSel(doc, changes, hint) {
  var out = []
  var oldPrev = Pos(doc.first, 0), newPrev = oldPrev
  for (var i = 0; i < changes.length; i++) {
    var change = changes[i]
    var from = offsetPos(change.from, oldPrev, newPrev)
    var to = offsetPos(changeEnd(change), oldPrev, newPrev)
    oldPrev = change.to
    newPrev = to
    if (hint == "around") {
      var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0
      out[i] = new Range(inv ? to : from, inv ? from : to)
    } else {
      out[i] = new Range(from, from)
    }
  }
  return new Selection(out, doc.sel.primIndex)
}

// Used to get the editor into a consistent state again when options change.

function loadMode(cm) {
  cm.doc.mode = getMode(cm.options, cm.doc.modeOption)
  resetModeState(cm)
}

function resetModeState(cm) {
  cm.doc.iter(function (line) {
    if (line.stateAfter) { line.stateAfter = null }
    if (line.styles) { line.styles = null }
  })
  cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first
  startWorker(cm, 100)
  cm.state.modeGen++
  if (cm.curOp) { regChange(cm) }
}

// DOCUMENT DATA STRUCTURE

// By default, updates that start and end at the beginning of a line
// are treated specially, in order to make the association of line
// widgets and marker elements with the text behave more intuitive.
function isWholeLineUpdate(doc, change) {
  return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
    (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
}

// Perform a change on the document data structure.
function updateDoc(doc, change, markedSpans, estimateHeight) {
  function spansFor(n) {return markedSpans ? markedSpans[n] : null}
  function update(line, text, spans) {
    updateLine(line, text, spans, estimateHeight)
    signalLater(line, "change", line, change)
  }
  function linesFor(start, end) {
    var result = []
    for (var i = start; i < end; ++i)
      { result.push(new Line(text[i], spansFor(i), estimateHeight)) }
    return result
  }

  var from = change.from, to = change.to, text = change.text
  var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line)
  var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line

  // Adjust the line structure
  if (change.full) {
    doc.insert(0, linesFor(0, text.length))
    doc.remove(text.length, doc.size - text.length)
  } else if (isWholeLineUpdate(doc, change)) {
    // This is a whole-line replace. Treated specially to make
    // sure line objects move the way they are supposed to.
    var added = linesFor(0, text.length - 1)
    update(lastLine, lastLine.text, lastSpans)
    if (nlines) { doc.remove(from.line, nlines) }
    if (added.length) { doc.insert(from.line, added) }
  } else if (firstLine == lastLine) {
    if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans)
    } else {
      var added$1 = linesFor(1, text.length - 1)
      added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight))
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))
      doc.insert(from.line + 1, added$1)
    }
  } else if (text.length == 1) {
    update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0))
    doc.remove(from.line + 1, nlines)
  } else {
    update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0))
    update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans)
    var added$2 = linesFor(1, text.length - 1)
    if (nlines > 1) { doc.remove(from.line + 1, nlines - 1) }
    doc.insert(from.line + 1, added$2)
  }

  signalLater(doc, "change", doc, change)
}

// Call f for all linked documents.
function linkedDocs(doc, f, sharedHistOnly) {
  function propagate(doc, skip, sharedHist) {
    if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
      var rel = doc.linked[i]
      if (rel.doc == skip) { continue }
      var shared = sharedHist && rel.sharedHist
      if (sharedHistOnly && !shared) { continue }
      f(rel.doc, shared)
      propagate(rel.doc, doc, shared)
    } }
  }
  propagate(doc, null, true)
}

// Attach a document to an editor.
function attachDoc(cm, doc) {
  if (doc.cm) { throw new Error("This document is already in use.") }
  cm.doc = doc
  doc.cm = cm
  estimateLineHeights(cm)
  loadMode(cm)
  setDirectionClass(cm)
  if (!cm.options.lineWrapping) { findMaxLine(cm) }
  cm.options.mode = doc.modeOption
  regChange(cm)
}

function setDirectionClass(cm) {
  ;(cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl")
}

function directionChanged(cm) {
  runInOp(cm, function () {
    setDirectionClass(cm)
    regChange(cm)
  })
}

function History(startGen) {
  // Arrays of change events and selections. Doing something adds an
  // event to done and clears undo. Undoing moves events from done
  // to undone, redoing moves them in the other direction.
  this.done = []; this.undone = []
  this.undoDepth = Infinity
  // Used to track when changes can be merged into a single undo
  // event
  this.lastModTime = this.lastSelTime = 0
  this.lastOp = this.lastSelOp = null
  this.lastOrigin = this.lastSelOrigin = null
  // Used by the isClean() method
  this.generation = this.maxGeneration = startGen || 1
}

// Create a history change event from an updateDoc-style change
// object.
function historyChangeFromChange(doc, change) {
  var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)}
  attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1)
  linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true)
  return histChange
}

// Pop all selection events off the end of a history array. Stop at
// a change event.
function clearSelectionEvents(array) {
  while (array.length) {
    var last = lst(array)
    if (last.ranges) { array.pop() }
    else { break }
  }
}

// Find the top change event in the history. Pop off selection
// events that are in the way.
function lastChangeEvent(hist, force) {
  if (force) {
    clearSelectionEvents(hist.done)
    return lst(hist.done)
  } else if (hist.done.length && !lst(hist.done).ranges) {
    return lst(hist.done)
  } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
    hist.done.pop()
    return lst(hist.done)
  }
}

// Register a change in the history. Merges changes that are within
// a single operation, or are close together with an origin that
// allows merging (starting with "+") into a single event.
function addChangeToHistory(doc, change, selAfter, opId) {
  var hist = doc.history
  hist.undone.length = 0
  var time = +new Date, cur
  var last

  if ((hist.lastOp == opId ||
       hist.lastOrigin == change.origin && change.origin &&
       ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||
        change.origin.charAt(0) == "*")) &&
      (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
    // Merge this change into the last event
    last = lst(cur.changes)
    if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
      // Optimized case for simple insertion -- don't want to add
      // new changesets for every character typed
      last.to = changeEnd(change)
    } else {
      // Add new sub-event
      cur.changes.push(historyChangeFromChange(doc, change))
    }
  } else {
    // Can not be merged, start a new event.
    var before = lst(hist.done)
    if (!before || !before.ranges)
      { pushSelectionToHistory(doc.sel, hist.done) }
    cur = {changes: [historyChangeFromChange(doc, change)],
           generation: hist.generation}
    hist.done.push(cur)
    while (hist.done.length > hist.undoDepth) {
      hist.done.shift()
      if (!hist.done[0].ranges) { hist.done.shift() }
    }
  }
  hist.done.push(selAfter)
  hist.generation = ++hist.maxGeneration
  hist.lastModTime = hist.lastSelTime = time
  hist.lastOp = hist.lastSelOp = opId
  hist.lastOrigin = hist.lastSelOrigin = change.origin

  if (!last) { signal(doc, "historyAdded") }
}

function selectionEventCanBeMerged(doc, origin, prev, sel) {
  var ch = origin.charAt(0)
  return ch == "*" ||
    ch == "+" &&
    prev.ranges.length == sel.ranges.length &&
    prev.somethingSelected() == sel.somethingSelected() &&
    new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
}

// Called whenever the selection changes, sets the new selection as
// the pending selection in the history, and pushes the old pending
// selection into the 'done' array when it was significantly
// different (in number of selected ranges, emptiness, or time).
function addSelectionToHistory(doc, sel, opId, options) {
  var hist = doc.history, origin = options && options.origin

  // A new event is started when the previous origin does not match
  // the current, or the origins don't allow matching. Origins
  // starting with * are always merged, those starting with + are
  // merged when similar and close together in time.
  if (opId == hist.lastSelOp ||
      (origin && hist.lastSelOrigin == origin &&
       (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
        selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
    { hist.done[hist.done.length - 1] = sel }
  else
    { pushSelectionToHistory(sel, hist.done) }

  hist.lastSelTime = +new Date
  hist.lastSelOrigin = origin
  hist.lastSelOp = opId
  if (options && options.clearRedo !== false)
    { clearSelectionEvents(hist.undone) }
}

function pushSelectionToHistory(sel, dest) {
  var top = lst(dest)
  if (!(top && top.ranges && top.equals(sel)))
    { dest.push(sel) }
}

// Used to store marked span information in the history.
function attachLocalSpans(doc, change, from, to) {
  var existing = change["spans_" + doc.id], n = 0
  doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
    if (line.markedSpans)
      { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans }
    ++n
  })
}

// When un/re-doing restores text containing marked spans, those
// that have been explicitly cleared should not be restored.
function removeClearedSpans(spans) {
  if (!spans) { return null }
  var out
  for (var i = 0; i < spans.length; ++i) {
    if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i) } }
    else if (out) { out.push(spans[i]) }
  }
  return !out ? spans : out.length ? out : null
}

// Retrieve and filter the old marked spans stored in a change event.
function getOldSpans(doc, change) {
  var found = change["spans_" + doc.id]
  if (!found) { return null }
  var nw = []
  for (var i = 0; i < change.text.length; ++i)
    { nw.push(removeClearedSpans(found[i])) }
  return nw
}

// Used for un/re-doing changes from the history. Combines the
// result of computing the existing spans with the set of spans that
// existed in the history (so that deleting around a span and then
// undoing brings back the span).
function mergeOldSpans(doc, change) {
  var old = getOldSpans(doc, change)
  var stretched = stretchSpansOverChange(doc, change)
  if (!old) { return stretched }
  if (!stretched) { return old }

  for (var i = 0; i < old.length; ++i) {
    var oldCur = old[i], stretchCur = stretched[i]
    if (oldCur && stretchCur) {
      spans: for (var j = 0; j < stretchCur.length; ++j) {
        var span = stretchCur[j]
        for (var k = 0; k < oldCur.length; ++k)
          { if (oldCur[k].marker == span.marker) { continue spans } }
        oldCur.push(span)
      }
    } else if (stretchCur) {
      old[i] = stretchCur
    }
  }
  return old
}

// Used both to provide a JSON-safe object in .getHistory, and, when
// detaching a document, to split the history in two
function copyHistoryArray(events, newGroup, instantiateSel) {
  var copy = []
  for (var i = 0; i < events.length; ++i) {
    var event = events[i]
    if (event.ranges) {
      copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event)
      continue
    }
    var changes = event.changes, newChanges = []
    copy.push({changes: newChanges})
    for (var j = 0; j < changes.length; ++j) {
      var change = changes[j], m = (void 0)
      newChanges.push({from: change.from, to: change.to, text: change.text})
      if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
        if (indexOf(newGroup, Number(m[1])) > -1) {
          lst(newChanges)[prop] = change[prop]
          delete change[prop]
        }
      } } }
    }
  }
  return copy
}

// The 'scroll' parameter given to many of these indicated whether
// the new cursor position should be scrolled into view after
// modifying the selection.

// If shift is held or the extend flag is set, extends a range to
// include a given position (and optionally a second position).
// Otherwise, simply returns the range between the given positions.
// Used for cursor motion and such.
function extendRange(range, head, other, extend) {
  if (extend) {
    var anchor = range.anchor
    if (other) {
      var posBefore = cmp(head, anchor) < 0
      if (posBefore != (cmp(other, anchor) < 0)) {
        anchor = head
        head = other
      } else if (posBefore != (cmp(head, other) < 0)) {
        head = other
      }
    }
    return new Range(anchor, head)
  } else {
    return new Range(other || head, head)
  }
}

// Extend the primary selection range, discard the rest.
function extendSelection(doc, head, other, options, extend) {
  if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend) }
  setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options)
}

// Extend all selections (pos is an array of selections with length
// equal the number of selections)
function extendSelections(doc, heads, options) {
  var out = []
  var extend = doc.cm && (doc.cm.display.shift || doc.extend)
  for (var i = 0; i < doc.sel.ranges.length; i++)
    { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend) }
  var newSel = normalizeSelection(out, doc.sel.primIndex)
  setSelection(doc, newSel, options)
}

// Updates a single range in the selection.
function replaceOneSelection(doc, i, range, options) {
  var ranges = doc.sel.ranges.slice(0)
  ranges[i] = range
  setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options)
}

// Reset the selection to a single range.
function setSimpleSelection(doc, anchor, head, options) {
  setSelection(doc, simpleSelection(anchor, head), options)
}

// Give beforeSelectionChange handlers a change to influence a
// selection update.
function filterSelectionChange(doc, sel, options) {
  var obj = {
    ranges: sel.ranges,
    update: function(ranges) {
      var this$1 = this;

      this.ranges = []
      for (var i = 0; i < ranges.length; i++)
        { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                   clipPos(doc, ranges[i].head)) }
    },
    origin: options && options.origin
  }
  signal(doc, "beforeSelectionChange", doc, obj)
  if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj) }
  if (obj.ranges != sel.ranges) { return normalizeSelection(obj.ranges, obj.ranges.length - 1) }
  else { return sel }
}

function setSelectionReplaceHistory(doc, sel, options) {
  var done = doc.history.done, last = lst(done)
  if (last && last.ranges) {
    done[done.length - 1] = sel
    setSelectionNoUndo(doc, sel, options)
  } else {
    setSelection(doc, sel, options)
  }
}

// Set a new selection.
function setSelection(doc, sel, options) {
  setSelectionNoUndo(doc, sel, options)
  addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options)
}

function setSelectionNoUndo(doc, sel, options) {
  if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
    { sel = filterSelectionChange(doc, sel, options) }

  var bias = options && options.bias ||
    (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1)
  setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true))

  if (!(options && options.scroll === false) && doc.cm)
    { ensureCursorVisible(doc.cm) }
}

function setSelectionInner(doc, sel) {
  if (sel.equals(doc.sel)) { return }

  doc.sel = sel

  if (doc.cm) {
    doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true
    signalCursorActivity(doc.cm)
  }
  signalLater(doc, "cursorActivity", doc)
}

// Verify that the selection does not partially select any atomic
// marked ranges.
function reCheckSelection(doc) {
  setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false))
}

// Return a selection that does not partially select any atomic
// ranges.
function skipAtomicInSelection(doc, sel, bias, mayClear) {
  var out
  for (var i = 0; i < sel.ranges.length; i++) {
    var range = sel.ranges[i]
    var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i]
    var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear)
    var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear)
    if (out || newAnchor != range.anchor || newHead != range.head) {
      if (!out) { out = sel.ranges.slice(0, i) }
      out[i] = new Range(newAnchor, newHead)
    }
  }
  return out ? normalizeSelection(out, sel.primIndex) : sel
}

function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
  var line = getLine(doc, pos.line)
  if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
    var sp = line.markedSpans[i], m = sp.marker
    if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
        (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
      if (mayClear) {
        signal(m, "beforeCursorEnter")
        if (m.explicitlyCleared) {
          if (!line.markedSpans) { break }
          else {--i; continue}
        }
      }
      if (!m.atomic) { continue }

      if (oldPos) {
        var near = m.find(dir < 0 ? 1 : -1), diff = (void 0)
        if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)
          { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null) }
        if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
          { return skipAtomicInner(doc, near, pos, dir, mayClear) }
      }

      var far = m.find(dir < 0 ? -1 : 1)
      if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)
        { far = movePos(doc, far, dir, far.line == pos.line ? line : null) }
      return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
    }
  } }
  return pos
}

// Ensure a given position is not inside an atomic range.
function skipAtomic(doc, pos, oldPos, bias, mayClear) {
  var dir = bias || 1
  var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
      (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
      skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
      (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true))
  if (!found) {
    doc.cantEdit = true
    return Pos(doc.first, 0)
  }
  return found
}

function movePos(doc, pos, dir, line) {
  if (dir < 0 && pos.ch == 0) {
    if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
    else { return null }
  } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
    if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
    else { return null }
  } else {
    return new Pos(pos.line, pos.ch + dir)
  }
}

function selectAll(cm) {
  cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll)
}

// UPDATING

// Allow "beforeChange" event handlers to influence a change
function filterChange(doc, change, update) {
  var obj = {
    canceled: false,
    from: change.from,
    to: change.to,
    text: change.text,
    origin: change.origin,
    cancel: function () { return obj.canceled = true; }
  }
  if (update) { obj.update = function (from, to, text, origin) {
    if (from) { obj.from = clipPos(doc, from) }
    if (to) { obj.to = clipPos(doc, to) }
    if (text) { obj.text = text }
    if (origin !== undefined) { obj.origin = origin }
  } }
  signal(doc, "beforeChange", doc, obj)
  if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj) }

  if (obj.canceled) { return null }
  return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
}

// Apply a change to a document, and add it to the document's
// history, and propagating it to all linked documents.
function makeChange(doc, change, ignoreReadOnly) {
  if (doc.cm) {
    if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
    if (doc.cm.state.suppressEdits) { return }
  }

  if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
    change = filterChange(doc, change, true)
    if (!change) { return }
  }

  // Possibly split or suppress the update based on the presence
  // of read-only spans in its range.
  var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to)
  if (split) {
    for (var i = split.length - 1; i >= 0; --i)
      { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}) }
  } else {
    makeChangeInner(doc, change)
  }
}

function makeChangeInner(doc, change) {
  if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
  var selAfter = computeSelAfterChange(doc, change)
  addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN)

  makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change))
  var rebased = []

  linkedDocs(doc, function (doc, sharedHist) {
    if (!sharedHist && indexOf(rebased, doc.history) == -1) {
      rebaseHist(doc.history, change)
      rebased.push(doc.history)
    }
    makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change))
  })
}

// Revert a change stored in a document's history.
function makeChangeFromHistory(doc, type, allowSelectionOnly) {
  if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) { return }

  var hist = doc.history, event, selAfter = doc.sel
  var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done

  // Verify that there is a useable event (so that ctrl-z won't
  // needlessly clear selection events)
  var i = 0
  for (; i < source.length; i++) {
    event = source[i]
    if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
      { break }
  }
  if (i == source.length) { return }
  hist.lastOrigin = hist.lastSelOrigin = null

  for (;;) {
    event = source.pop()
    if (event.ranges) {
      pushSelectionToHistory(event, dest)
      if (allowSelectionOnly && !event.equals(doc.sel)) {
        setSelection(doc, event, {clearRedo: false})
        return
      }
      selAfter = event
    }
    else { break }
  }

  // Build up a reverse change object to add to the opposite history
  // stack (redo when undoing, and vice versa).
  var antiChanges = []
  pushSelectionToHistory(selAfter, dest)
  dest.push({changes: antiChanges, generation: hist.generation})
  hist.generation = event.generation || ++hist.maxGeneration

  var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")

  var loop = function ( i ) {
    var change = event.changes[i]
    change.origin = type
    if (filter && !filterChange(doc, change, false)) {
      source.length = 0
      return {}
    }

    antiChanges.push(historyChangeFromChange(doc, change))

    var after = i ? computeSelAfterChange(doc, change) : lst(source)
    makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change))
    if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}) }
    var rebased = []

    // Propagate to the linked documents
    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change)
        rebased.push(doc.history)
      }
      makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change))
    })
  };

  for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
    var returned = loop( i$1 );

    if ( returned ) return returned.v;
  }
}

// Sub-views need their line numbers shifted when text is added
// above or below them in the parent document.
function shiftDoc(doc, distance) {
  if (distance == 0) { return }
  doc.first += distance
  doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
    Pos(range.anchor.line + distance, range.anchor.ch),
    Pos(range.head.line + distance, range.head.ch)
  ); }), doc.sel.primIndex)
  if (doc.cm) {
    regChange(doc.cm, doc.first, doc.first - distance, distance)
    for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
      { regLineChange(doc.cm, l, "gutter") }
  }
}

// More lower-level change function, handling only a single document
// (not linked ones).
function makeChangeSingleDoc(doc, change, selAfter, spans) {
  if (doc.cm && !doc.cm.curOp)
    { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

  if (change.to.line < doc.first) {
    shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line))
    return
  }
  if (change.from.line > doc.lastLine()) { return }

  // Clip the change to the size of this doc
  if (change.from.line < doc.first) {
    var shift = change.text.length - 1 - (doc.first - change.from.line)
    shiftDoc(doc, shift)
    change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
              text: [lst(change.text)], origin: change.origin}
  }
  var last = doc.lastLine()
  if (change.to.line > last) {
    change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
              text: [change.text[0]], origin: change.origin}
  }

  change.removed = getBetween(doc, change.from, change.to)

  if (!selAfter) { selAfter = computeSelAfterChange(doc, change) }
  if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans) }
  else { updateDoc(doc, change, spans) }
  setSelectionNoUndo(doc, selAfter, sel_dontScroll)
}

// Handle the interaction of a change to a document with the editor
// that this document is part of.
function makeChangeSingleDocInEditor(cm, change, spans) {
  var doc = cm.doc, display = cm.display, from = change.from, to = change.to

  var recomputeMaxLength = false, checkWidthStart = from.line
  if (!cm.options.lineWrapping) {
    checkWidthStart = lineNo(visualLine(getLine(doc, from.line)))
    doc.iter(checkWidthStart, to.line + 1, function (line) {
      if (line == display.maxLine) {
        recomputeMaxLength = true
        return true
      }
    })
  }

  if (doc.sel.contains(change.from, change.to) > -1)
    { signalCursorActivity(cm) }

  updateDoc(doc, change, spans, estimateHeight(cm))

  if (!cm.options.lineWrapping) {
    doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
      var len = lineLength(line)
      if (len > display.maxLineLength) {
        display.maxLine = line
        display.maxLineLength = len
        display.maxLineChanged = true
        recomputeMaxLength = false
      }
    })
    if (recomputeMaxLength) { cm.curOp.updateMaxLine = true }
  }

  retreatFrontier(doc, from.line)
  startWorker(cm, 400)

  var lendiff = change.text.length - (to.line - from.line) - 1
  // Remember that these lines changed, for updating the display
  if (change.full)
    { regChange(cm) }
  else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
    { regLineChange(cm, from.line, "text") }
  else
    { regChange(cm, from.line, to.line + 1, lendiff) }

  var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change")
  if (changeHandler || changesHandler) {
    var obj = {
      from: from, to: to,
      text: change.text,
      removed: change.removed,
      origin: change.origin
    }
    if (changeHandler) { signalLater(cm, "change", cm, obj) }
    if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj) }
  }
  cm.display.selForContextMenu = null
}

function replaceRange(doc, code, from, to, origin) {
  if (!to) { to = from }
  if (cmp(to, from) < 0) { var assign;
    (assign = [to, from], from = assign[0], to = assign[1], assign) }
  if (typeof code == "string") { code = doc.splitLines(code) }
  makeChange(doc, {from: from, to: to, text: code, origin: origin})
}

// Rebasing/resetting history to deal with externally-sourced changes

function rebaseHistSelSingle(pos, from, to, diff) {
  if (to < pos.line) {
    pos.line += diff
  } else if (from < pos.line) {
    pos.line = from
    pos.ch = 0
  }
}

// Tries to rebase an array of history events given a change in the
// document. If the change touches the same lines as the event, the
// event, and everything 'behind' it, is discarded. If the change is
// before the event, the event's positions are updated. Uses a
// copy-on-write scheme for the positions, to avoid having to
// reallocate them all on every rebase, but also avoid problems with
// shared position objects being unsafely updated.
function rebaseHistArray(array, from, to, diff) {
  for (var i = 0; i < array.length; ++i) {
    var sub = array[i], ok = true
    if (sub.ranges) {
      if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true }
      for (var j = 0; j < sub.ranges.length; j++) {
        rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff)
        rebaseHistSelSingle(sub.ranges[j].head, from, to, diff)
      }
      continue
    }
    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
      var cur = sub.changes[j$1]
      if (to < cur.from.line) {
        cur.from = Pos(cur.from.line + diff, cur.from.ch)
        cur.to = Pos(cur.to.line + diff, cur.to.ch)
      } else if (from <= cur.to.line) {
        ok = false
        break
      }
    }
    if (!ok) {
      array.splice(0, i + 1)
      i = 0
    }
  }
}

function rebaseHist(hist, change) {
  var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1
  rebaseHistArray(hist.done, from, to, diff)
  rebaseHistArray(hist.undone, from, to, diff)
}

// Utility for applying a change to a line by handle or number,
// returning the number and optionally registering the line as
// changed.
function changeLine(doc, handle, changeType, op) {
  var no = handle, line = handle
  if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)) }
  else { no = lineNo(handle) }
  if (no == null) { return null }
  if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType) }
  return line
}

// The document is represented as a BTree consisting of leaves, with
// chunk of lines in them, and branches, with up to ten leaves or
// other branch nodes below them. The top node is always a branch
// node, and is the document object itself (meaning it has
// additional methods and properties).
//
// All nodes have parent links. The tree is used both to go from
// line numbers to line objects, and to go from objects to numbers.
// It also indexes by height, and is used to convert between height
// and line object, and to find the total height of the document.
//
// See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

function LeafChunk(lines) {
  var this$1 = this;

  this.lines = lines
  this.parent = null
  var height = 0
  for (var i = 0; i < lines.length; ++i) {
    lines[i].parent = this$1
    height += lines[i].height
  }
  this.height = height
}

LeafChunk.prototype = {
  chunkSize: function chunkSize() { return this.lines.length },

  // Remove the n lines at offset 'at'.
  removeInner: function removeInner(at, n) {
    var this$1 = this;

    for (var i = at, e = at + n; i < e; ++i) {
      var line = this$1.lines[i]
      this$1.height -= line.height
      cleanUpLine(line)
      signalLater(line, "delete")
    }
    this.lines.splice(at, n)
  },

  // Helper used to collapse a small branch into a single leaf.
  collapse: function collapse(lines) {
    lines.push.apply(lines, this.lines)
  },

  // Insert the given array of lines at offset 'at', count them as
  // having the given height.
  insertInner: function insertInner(at, lines, height) {
    var this$1 = this;

    this.height += height
    this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at))
    for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1 }
  },

  // Used to iterate over a part of the tree.
  iterN: function iterN(at, n, op) {
    var this$1 = this;

    for (var e = at + n; at < e; ++at)
      { if (op(this$1.lines[at])) { return true } }
  }
}

function BranchChunk(children) {
  var this$1 = this;

  this.children = children
  var size = 0, height = 0
  for (var i = 0; i < children.length; ++i) {
    var ch = children[i]
    size += ch.chunkSize(); height += ch.height
    ch.parent = this$1
  }
  this.size = size
  this.height = height
  this.parent = null
}

BranchChunk.prototype = {
  chunkSize: function chunkSize() { return this.size },

  removeInner: function removeInner(at, n) {
    var this$1 = this;

    this.size -= n
    for (var i = 0; i < this.children.length; ++i) {
      var child = this$1.children[i], sz = child.chunkSize()
      if (at < sz) {
        var rm = Math.min(n, sz - at), oldHeight = child.height
        child.removeInner(at, rm)
        this$1.height -= oldHeight - child.height
        if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null }
        if ((n -= rm) == 0) { break }
        at = 0
      } else { at -= sz }
    }
    // If the result is smaller than 25 lines, ensure that it is a
    // single leaf node.
    if (this.size - n < 25 &&
        (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
      var lines = []
      this.collapse(lines)
      this.children = [new LeafChunk(lines)]
      this.children[0].parent = this
    }
  },

  collapse: function collapse(lines) {
    var this$1 = this;

    for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines) }
  },

  insertInner: function insertInner(at, lines, height) {
    var this$1 = this;

    this.size += lines.length
    this.height += height
    for (var i = 0; i < this.children.length; ++i) {
      var child = this$1.children[i], sz = child.chunkSize()
      if (at <= sz) {
        child.insertInner(at, lines, height)
        if (child.lines && child.lines.length > 50) {
          // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
          // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
          var remaining = child.lines.length % 25 + 25
          for (var pos = remaining; pos < child.lines.length;) {
            var leaf = new LeafChunk(child.lines.slice(pos, pos += 25))
            child.height -= leaf.height
            this$1.children.splice(++i, 0, leaf)
            leaf.parent = this$1
          }
          child.lines = child.lines.slice(0, remaining)
          this$1.maybeSpill()
        }
        break
      }
      at -= sz
    }
  },

  // When a node has grown, check whether it should be split.
  maybeSpill: function maybeSpill() {
    if (this.children.length <= 10) { return }
    var me = this
    do {
      var spilled = me.children.splice(me.children.length - 5, 5)
      var sibling = new BranchChunk(spilled)
      if (!me.parent) { // Become the parent node
        var copy = new BranchChunk(me.children)
        copy.parent = me
        me.children = [copy, sibling]
        me = copy
     } else {
        me.size -= sibling.size
        me.height -= sibling.height
        var myIndex = indexOf(me.parent.children, me)
        me.parent.children.splice(myIndex + 1, 0, sibling)
      }
      sibling.parent = me.parent
    } while (me.children.length > 10)
    me.parent.maybeSpill()
  },

  iterN: function iterN(at, n, op) {
    var this$1 = this;

    for (var i = 0; i < this.children.length; ++i) {
      var child = this$1.children[i], sz = child.chunkSize()
      if (at < sz) {
        var used = Math.min(n, sz - at)
        if (child.iterN(at, used, op)) { return true }
        if ((n -= used) == 0) { break }
        at = 0
      } else { at -= sz }
    }
  }
}

// Line widgets are block elements displayed above or below a line.

var LineWidget = function(doc, node, options) {
  var this$1 = this;

  if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
    { this$1[opt] = options[opt] } } }
  this.doc = doc
  this.node = node
};

LineWidget.prototype.clear = function () {
    var this$1 = this;

  var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line)
  if (no == null || !ws) { return }
  for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1) } }
  if (!ws.length) { line.widgets = null }
  var height = widgetHeight(this)
  updateLineHeight(line, Math.max(0, line.height - height))
  if (cm) {
    runInOp(cm, function () {
      adjustScrollWhenAboveVisible(cm, line, -height)
      regLineChange(cm, no, "widget")
    })
    signalLater(cm, "lineWidgetCleared", cm, this, no)
  }
};

LineWidget.prototype.changed = function () {
    var this$1 = this;

  var oldH = this.height, cm = this.doc.cm, line = this.line
  this.height = null
  var diff = widgetHeight(this) - oldH
  if (!diff) { return }
  updateLineHeight(line, line.height + diff)
  if (cm) {
    runInOp(cm, function () {
      cm.curOp.forceUpdate = true
      adjustScrollWhenAboveVisible(cm, line, diff)
      signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line))
    })
  }
};
eventMixin(LineWidget)

function adjustScrollWhenAboveVisible(cm, line, diff) {
  if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
    { addToScrollTop(cm, diff) }
}

function addLineWidget(doc, handle, node, options) {
  var widget = new LineWidget(doc, node, options)
  var cm = doc.cm
  if (cm && widget.noHScroll) { cm.display.alignWidgets = true }
  changeLine(doc, handle, "widget", function (line) {
    var widgets = line.widgets || (line.widgets = [])
    if (widget.insertAt == null) { widgets.push(widget) }
    else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget) }
    widget.line = line
    if (cm && !lineIsHidden(doc, line)) {
      var aboveVisible = heightAtLine(line) < doc.scrollTop
      updateLineHeight(line, line.height + widgetHeight(widget))
      if (aboveVisible) { addToScrollTop(cm, widget.height) }
      cm.curOp.forceUpdate = true
    }
    return true
  })
  signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle))
  return widget
}

// TEXTMARKERS

// Created with markText and setBookmark methods. A TextMarker is a
// handle that can be used to clear or find a marked position in the
// document. Line objects hold arrays (markedSpans) containing
// {from, to, marker} object pointing to such marker objects, and
// indicating that such a marker is present on that line. Multiple
// lines may point to the same marker when it spans across lines.
// The spans will have null for their from/to properties when the
// marker continues beyond the start/end of the line. Markers have
// links back to the lines they currently touch.

// Collapsed markers have unique ids, in order to be able to order
// them, which is needed for uniquely determining an outer marker
// when they overlap (they may nest, but not partially overlap).
var nextMarkerId = 0

var TextMarker = function(doc, type) {
  this.lines = []
  this.type = type
  this.doc = doc
  this.id = ++nextMarkerId
};

// Clear the marker.
TextMarker.prototype.clear = function () {
    var this$1 = this;

  if (this.explicitlyCleared) { return }
  var cm = this.doc.cm, withOp = cm && !cm.curOp
  if (withOp) { startOperation(cm) }
  if (hasHandler(this, "clear")) {
    var found = this.find()
    if (found) { signalLater(this, "clear", found.from, found.to) }
  }
  var min = null, max = null
  for (var i = 0; i < this.lines.length; ++i) {
    var line = this$1.lines[i]
    var span = getMarkedSpanFor(line.markedSpans, this$1)
    if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), "text") }
    else if (cm) {
      if (span.to != null) { max = lineNo(line) }
      if (span.from != null) { min = lineNo(line) }
    }
    line.markedSpans = removeMarkedSpan(line.markedSpans, span)
    if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)
      { updateLineHeight(line, textHeight(cm.display)) }
  }
  if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
    var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual)
    if (len > cm.display.maxLineLength) {
      cm.display.maxLine = visual
      cm.display.maxLineLength = len
      cm.display.maxLineChanged = true
    }
  } }

  if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1) }
  this.lines.length = 0
  this.explicitlyCleared = true
  if (this.atomic && this.doc.cantEdit) {
    this.doc.cantEdit = false
    if (cm) { reCheckSelection(cm.doc) }
  }
  if (cm) { signalLater(cm, "markerCleared", cm, this, min, max) }
  if (withOp) { endOperation(cm) }
  if (this.parent) { this.parent.clear() }
};

// Find the position of the marker in the document. Returns a {from,
// to} object by default. Side can be passed to get a specific side
// -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
// Pos objects returned contain a line object, rather than a line
// number (used to prevent looking up the same line twice).
TextMarker.prototype.find = function (side, lineObj) {
    var this$1 = this;

  if (side == null && this.type == "bookmark") { side = 1 }
  var from, to
  for (var i = 0; i < this.lines.length; ++i) {
    var line = this$1.lines[i]
    var span = getMarkedSpanFor(line.markedSpans, this$1)
    if (span.from != null) {
      from = Pos(lineObj ? line : lineNo(line), span.from)
      if (side == -1) { return from }
    }
    if (span.to != null) {
      to = Pos(lineObj ? line : lineNo(line), span.to)
      if (side == 1) { return to }
    }
  }
  return from && {from: from, to: to}
};

// Signals that the marker's widget changed, and surrounding layout
// should be recomputed.
TextMarker.prototype.changed = function () {
    var this$1 = this;

  var pos = this.find(-1, true), widget = this, cm = this.doc.cm
  if (!pos || !cm) { return }
  runInOp(cm, function () {
    var line = pos.line, lineN = lineNo(pos.line)
    var view = findViewForLine(cm, lineN)
    if (view) {
      clearLineMeasurementCacheFor(view)
      cm.curOp.selectionChanged = cm.curOp.forceUpdate = true
    }
    cm.curOp.updateMaxLine = true
    if (!lineIsHidden(widget.doc, line) && widget.height != null) {
      var oldHeight = widget.height
      widget.height = null
      var dHeight = widgetHeight(widget) - oldHeight
      if (dHeight)
        { updateLineHeight(line, line.height + dHeight) }
    }
    signalLater(cm, "markerChanged", cm, this$1)
  })
};

TextMarker.prototype.attachLine = function (line) {
  if (!this.lines.length && this.doc.cm) {
    var op = this.doc.cm.curOp
    if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
      { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this) }
  }
  this.lines.push(line)
};

TextMarker.prototype.detachLine = function (line) {
  this.lines.splice(indexOf(this.lines, line), 1)
  if (!this.lines.length && this.doc.cm) {
    var op = this.doc.cm.curOp
    ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this)
  }
};
eventMixin(TextMarker)

// Create a marker, wire it up to the right lines, and
function markText(doc, from, to, options, type) {
  // Shared markers (across linked documents) are handled separately
  // (markTextShared will call out to this again, once per
  // document).
  if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
  // Ensure we are in an operation.
  if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

  var marker = new TextMarker(doc, type), diff = cmp(from, to)
  if (options) { copyObj(options, marker, false) }
  // Don't connect empty markers unless clearWhenEmpty is false
  if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
    { return marker }
  if (marker.replacedWith) {
    // Showing up as a widget implies collapsed (widget replaces text)
    marker.collapsed = true
    marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget")
    if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true") }
    if (options.insertLeft) { marker.widgetNode.insertLeft = true }
  }
  if (marker.collapsed) {
    if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
        from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
      { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
    seeCollapsedSpans()
  }

  if (marker.addToHistory)
    { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN) }

  var curLine = from.line, cm = doc.cm, updateMaxLine
  doc.iter(curLine, to.line + 1, function (line) {
    if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
      { updateMaxLine = true }
    if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0) }
    addMarkedSpan(line, new MarkedSpan(marker,
                                       curLine == from.line ? from.ch : null,
                                       curLine == to.line ? to.ch : null))
    ++curLine
  })
  // lineIsHidden depends on the presence of the spans, so needs a second pass
  if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
    if (lineIsHidden(doc, line)) { updateLineHeight(line, 0) }
  }) }

  if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }) }

  if (marker.readOnly) {
    seeReadOnlySpans()
    if (doc.history.done.length || doc.history.undone.length)
      { doc.clearHistory() }
  }
  if (marker.collapsed) {
    marker.id = ++nextMarkerId
    marker.atomic = true
  }
  if (cm) {
    // Sync editor state
    if (updateMaxLine) { cm.curOp.updateMaxLine = true }
    if (marker.collapsed)
      { regChange(cm, from.line, to.line + 1) }
    else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
      { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text") } }
    if (marker.atomic) { reCheckSelection(cm.doc) }
    signalLater(cm, "markerAdded", cm, marker)
  }
  return marker
}

// SHARED TEXTMARKERS

// A shared marker spans multiple linked documents. It is
// implemented as a meta-marker-object controlling multiple normal
// markers.
var SharedTextMarker = function(markers, primary) {
  var this$1 = this;

  this.markers = markers
  this.primary = primary
  for (var i = 0; i < markers.length; ++i)
    { markers[i].parent = this$1 }
};

SharedTextMarker.prototype.clear = function () {
    var this$1 = this;

  if (this.explicitlyCleared) { return }
  this.explicitlyCleared = true
  for (var i = 0; i < this.markers.length; ++i)
    { this$1.markers[i].clear() }
  signalLater(this, "clear")
};

SharedTextMarker.prototype.find = function (side, lineObj) {
  return this.primary.find(side, lineObj)
};
eventMixin(SharedTextMarker)

function markTextShared(doc, from, to, options, type) {
  options = copyObj(options)
  options.shared = false
  var markers = [markText(doc, from, to, options, type)], primary = markers[0]
  var widget = options.widgetNode
  linkedDocs(doc, function (doc) {
    if (widget) { options.widgetNode = widget.cloneNode(true) }
    markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type))
    for (var i = 0; i < doc.linked.length; ++i)
      { if (doc.linked[i].isParent) { return } }
    primary = lst(markers)
  })
  return new SharedTextMarker(markers, primary)
}

function findSharedMarkers(doc) {
  return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
}

function copySharedMarkers(doc, markers) {
  for (var i = 0; i < markers.length; i++) {
    var marker = markers[i], pos = marker.find()
    var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to)
    if (cmp(mFrom, mTo)) {
      var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type)
      marker.markers.push(subMark)
      subMark.parent = marker
    }
  }
}

function detachSharedMarkers(markers) {
  var loop = function ( i ) {
    var marker = markers[i], linked = [marker.primary.doc]
    linkedDocs(marker.primary.doc, function (d) { return linked.push(d); })
    for (var j = 0; j < marker.markers.length; j++) {
      var subMarker = marker.markers[j]
      if (indexOf(linked, subMarker.doc) == -1) {
        subMarker.parent = null
        marker.markers.splice(j--, 1)
      }
    }
  };

  for (var i = 0; i < markers.length; i++) loop( i );
}

var nextDocId = 0
var Doc = function(text, mode, firstLine, lineSep, direction) {
  if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
  if (firstLine == null) { firstLine = 0 }

  BranchChunk.call(this, [new LeafChunk([new Line("", null)])])
  this.first = firstLine
  this.scrollTop = this.scrollLeft = 0
  this.cantEdit = false
  this.cleanGeneration = 1
  this.modeFrontier = this.highlightFrontier = firstLine
  var start = Pos(firstLine, 0)
  this.sel = simpleSelection(start)
  this.history = new History(null)
  this.id = ++nextDocId
  this.modeOption = mode
  this.lineSep = lineSep
  this.direction = (direction == "rtl") ? "rtl" : "ltr"
  this.extend = false

  if (typeof text == "string") { text = this.splitLines(text) }
  updateDoc(this, {from: start, to: start, text: text})
  setSelection(this, simpleSelection(start), sel_dontScroll)
}

Doc.prototype = createObj(BranchChunk.prototype, {
  constructor: Doc,
  // Iterate over the document. Supports two forms -- with only one
  // argument, it calls that for each line in the document. With
  // three, it iterates over the range given by the first two (with
  // the second being non-inclusive).
  iter: function(from, to, op) {
    if (op) { this.iterN(from - this.first, to - from, op) }
    else { this.iterN(this.first, this.first + this.size, from) }
  },

  // Non-public interface for adding and removing lines.
  insert: function(at, lines) {
    var height = 0
    for (var i = 0; i < lines.length; ++i) { height += lines[i].height }
    this.insertInner(at - this.first, lines, height)
  },
  remove: function(at, n) { this.removeInner(at - this.first, n) },

  // From here, the methods are part of the public interface. Most
  // are also available from CodeMirror (editor) instances.

  getValue: function(lineSep) {
    var lines = getLines(this, this.first, this.first + this.size)
    if (lineSep === false) { return lines }
    return lines.join(lineSep || this.lineSeparator())
  },
  setValue: docMethodOp(function(code) {
    var top = Pos(this.first, 0), last = this.first + this.size - 1
    makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                      text: this.splitLines(code), origin: "setValue", full: true}, true)
    if (this.cm) { scrollToCoords(this.cm, 0, 0) }
    setSelection(this, simpleSelection(top), sel_dontScroll)
  }),
  replaceRange: function(code, from, to, origin) {
    from = clipPos(this, from)
    to = to ? clipPos(this, to) : from
    replaceRange(this, code, from, to, origin)
  },
  getRange: function(from, to, lineSep) {
    var lines = getBetween(this, clipPos(this, from), clipPos(this, to))
    if (lineSep === false) { return lines }
    return lines.join(lineSep || this.lineSeparator())
  },

  getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

  getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
  getLineNumber: function(line) {return lineNo(line)},

  getLineHandleVisualStart: function(line) {
    if (typeof line == "number") { line = getLine(this, line) }
    return visualLine(line)
  },

  lineCount: function() {return this.size},
  firstLine: function() {return this.first},
  lastLine: function() {return this.first + this.size - 1},

  clipPos: function(pos) {return clipPos(this, pos)},

  getCursor: function(start) {
    var range = this.sel.primary(), pos
    if (start == null || start == "head") { pos = range.head }
    else if (start == "anchor") { pos = range.anchor }
    else if (start == "end" || start == "to" || start === false) { pos = range.to() }
    else { pos = range.from() }
    return pos
  },
  listSelections: function() { return this.sel.ranges },
  somethingSelected: function() {return this.sel.somethingSelected()},

  setCursor: docMethodOp(function(line, ch, options) {
    setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options)
  }),
  setSelection: docMethodOp(function(anchor, head, options) {
    setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options)
  }),
  extendSelection: docMethodOp(function(head, other, options) {
    extendSelection(this, clipPos(this, head), other && clipPos(this, other), options)
  }),
  extendSelections: docMethodOp(function(heads, options) {
    extendSelections(this, clipPosArray(this, heads), options)
  }),
  extendSelectionsBy: docMethodOp(function(f, options) {
    var heads = map(this.sel.ranges, f)
    extendSelections(this, clipPosArray(this, heads), options)
  }),
  setSelections: docMethodOp(function(ranges, primary, options) {
    var this$1 = this;

    if (!ranges.length) { return }
    var out = []
    for (var i = 0; i < ranges.length; i++)
      { out[i] = new Range(clipPos(this$1, ranges[i].anchor),
                         clipPos(this$1, ranges[i].head)) }
    if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex) }
    setSelection(this, normalizeSelection(out, primary), options)
  }),
  addSelection: docMethodOp(function(anchor, head, options) {
    var ranges = this.sel.ranges.slice(0)
    ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)))
    setSelection(this, normalizeSelection(ranges, ranges.length - 1), options)
  }),

  getSelection: function(lineSep) {
    var this$1 = this;

    var ranges = this.sel.ranges, lines
    for (var i = 0; i < ranges.length; i++) {
      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())
      lines = lines ? lines.concat(sel) : sel
    }
    if (lineSep === false) { return lines }
    else { return lines.join(lineSep || this.lineSeparator()) }
  },
  getSelections: function(lineSep) {
    var this$1 = this;

    var parts = [], ranges = this.sel.ranges
    for (var i = 0; i < ranges.length; i++) {
      var sel = getBetween(this$1, ranges[i].from(), ranges[i].to())
      if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()) }
      parts[i] = sel
    }
    return parts
  },
  replaceSelection: function(code, collapse, origin) {
    var dup = []
    for (var i = 0; i < this.sel.ranges.length; i++)
      { dup[i] = code }
    this.replaceSelections(dup, collapse, origin || "+input")
  },
  replaceSelections: docMethodOp(function(code, collapse, origin) {
    var this$1 = this;

    var changes = [], sel = this.sel
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i]
      changes[i] = {from: range.from(), to: range.to(), text: this$1.splitLines(code[i]), origin: origin}
    }
    var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse)
    for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
      { makeChange(this$1, changes[i$1]) }
    if (newSel) { setSelectionReplaceHistory(this, newSel) }
    else if (this.cm) { ensureCursorVisible(this.cm) }
  }),
  undo: docMethodOp(function() {makeChangeFromHistory(this, "undo")}),
  redo: docMethodOp(function() {makeChangeFromHistory(this, "redo")}),
  undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true)}),
  redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true)}),

  setExtending: function(val) {this.extend = val},
  getExtending: function() {return this.extend},

  historySize: function() {
    var hist = this.history, done = 0, undone = 0
    for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done } }
    for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone } }
    return {undo: done, redo: undone}
  },
  clearHistory: function() {this.history = new History(this.history.maxGeneration)},

  markClean: function() {
    this.cleanGeneration = this.changeGeneration(true)
  },
  changeGeneration: function(forceSplit) {
    if (forceSplit)
      { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null }
    return this.history.generation
  },
  isClean: function (gen) {
    return this.history.generation == (gen || this.cleanGeneration)
  },

  getHistory: function() {
    return {done: copyHistoryArray(this.history.done),
            undone: copyHistoryArray(this.history.undone)}
  },
  setHistory: function(histData) {
    var hist = this.history = new History(this.history.maxGeneration)
    hist.done = copyHistoryArray(histData.done.slice(0), null, true)
    hist.undone = copyHistoryArray(histData.undone.slice(0), null, true)
  },

  setGutterMarker: docMethodOp(function(line, gutterID, value) {
    return changeLine(this, line, "gutter", function (line) {
      var markers = line.gutterMarkers || (line.gutterMarkers = {})
      markers[gutterID] = value
      if (!value && isEmpty(markers)) { line.gutterMarkers = null }
      return true
    })
  }),

  clearGutter: docMethodOp(function(gutterID) {
    var this$1 = this;

    this.iter(function (line) {
      if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
        changeLine(this$1, line, "gutter", function () {
          line.gutterMarkers[gutterID] = null
          if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null }
          return true
        })
      }
    })
  }),

  lineInfo: function(line) {
    var n
    if (typeof line == "number") {
      if (!isLine(this, line)) { return null }
      n = line
      line = getLine(this, line)
      if (!line) { return null }
    } else {
      n = lineNo(line)
      if (n == null) { return null }
    }
    return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
            textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
            widgets: line.widgets}
  },

  addLineClass: docMethodOp(function(handle, where, cls) {
    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
      var prop = where == "text" ? "textClass"
               : where == "background" ? "bgClass"
               : where == "gutter" ? "gutterClass" : "wrapClass"
      if (!line[prop]) { line[prop] = cls }
      else if (classTest(cls).test(line[prop])) { return false }
      else { line[prop] += " " + cls }
      return true
    })
  }),
  removeLineClass: docMethodOp(function(handle, where, cls) {
    return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
      var prop = where == "text" ? "textClass"
               : where == "background" ? "bgClass"
               : where == "gutter" ? "gutterClass" : "wrapClass"
      var cur = line[prop]
      if (!cur) { return false }
      else if (cls == null) { line[prop] = null }
      else {
        var found = cur.match(classTest(cls))
        if (!found) { return false }
        var end = found.index + found[0].length
        line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null
      }
      return true
    })
  }),

  addLineWidget: docMethodOp(function(handle, node, options) {
    return addLineWidget(this, handle, node, options)
  }),
  removeLineWidget: function(widget) { widget.clear() },

  markText: function(from, to, options) {
    return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
  },
  setBookmark: function(pos, options) {
    var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                    insertLeft: options && options.insertLeft,
                    clearWhenEmpty: false, shared: options && options.shared,
                    handleMouseEvents: options && options.handleMouseEvents}
    pos = clipPos(this, pos)
    return markText(this, pos, pos, realOpts, "bookmark")
  },
  findMarksAt: function(pos) {
    pos = clipPos(this, pos)
    var markers = [], spans = getLine(this, pos.line).markedSpans
    if (spans) { for (var i = 0; i < spans.length; ++i) {
      var span = spans[i]
      if ((span.from == null || span.from <= pos.ch) &&
          (span.to == null || span.to >= pos.ch))
        { markers.push(span.marker.parent || span.marker) }
    } }
    return markers
  },
  findMarks: function(from, to, filter) {
    from = clipPos(this, from); to = clipPos(this, to)
    var found = [], lineNo = from.line
    this.iter(from.line, to.line + 1, function (line) {
      var spans = line.markedSpans
      if (spans) { for (var i = 0; i < spans.length; i++) {
        var span = spans[i]
        if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
              span.from == null && lineNo != from.line ||
              span.from != null && lineNo == to.line && span.from >= to.ch) &&
            (!filter || filter(span.marker)))
          { found.push(span.marker.parent || span.marker) }
      } }
      ++lineNo
    })
    return found
  },
  getAllMarks: function() {
    var markers = []
    this.iter(function (line) {
      var sps = line.markedSpans
      if (sps) { for (var i = 0; i < sps.length; ++i)
        { if (sps[i].from != null) { markers.push(sps[i].marker) } } }
    })
    return markers
  },

  posFromIndex: function(off) {
    var ch, lineNo = this.first, sepSize = this.lineSeparator().length
    this.iter(function (line) {
      var sz = line.text.length + sepSize
      if (sz > off) { ch = off; return true }
      off -= sz
      ++lineNo
    })
    return clipPos(this, Pos(lineNo, ch))
  },
  indexFromPos: function (coords) {
    coords = clipPos(this, coords)
    var index = coords.ch
    if (coords.line < this.first || coords.ch < 0) { return 0 }
    var sepSize = this.lineSeparator().length
    this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
      index += line.text.length + sepSize
    })
    return index
  },

  copy: function(copyHistory) {
    var doc = new Doc(getLines(this, this.first, this.first + this.size),
                      this.modeOption, this.first, this.lineSep, this.direction)
    doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft
    doc.sel = this.sel
    doc.extend = false
    if (copyHistory) {
      doc.history.undoDepth = this.history.undoDepth
      doc.setHistory(this.getHistory())
    }
    return doc
  },

  linkedDoc: function(options) {
    if (!options) { options = {} }
    var from = this.first, to = this.first + this.size
    if (options.from != null && options.from > from) { from = options.from }
    if (options.to != null && options.to < to) { to = options.to }
    var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction)
    if (options.sharedHist) { copy.history = this.history
    ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist})
    copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}]
    copySharedMarkers(copy, findSharedMarkers(this))
    return copy
  },
  unlinkDoc: function(other) {
    var this$1 = this;

    if (other instanceof CodeMirror) { other = other.doc }
    if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
      var link = this$1.linked[i]
      if (link.doc != other) { continue }
      this$1.linked.splice(i, 1)
      other.unlinkDoc(this$1)
      detachSharedMarkers(findSharedMarkers(this$1))
      break
    } }
    // If the histories were shared, split them again
    if (other.history == this.history) {
      var splitIds = [other.id]
      linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true)
      other.history = new History(null)
      other.history.done = copyHistoryArray(this.history.done, splitIds)
      other.history.undone = copyHistoryArray(this.history.undone, splitIds)
    }
  },
  iterLinkedDocs: function(f) {linkedDocs(this, f)},

  getMode: function() {return this.mode},
  getEditor: function() {return this.cm},

  splitLines: function(str) {
    if (this.lineSep) { return str.split(this.lineSep) }
    return splitLinesAuto(str)
  },
  lineSeparator: function() { return this.lineSep || "\n" },

  setDirection: docMethodOp(function (dir) {
    if (dir != "rtl") { dir = "ltr" }
    if (dir == this.direction) { return }
    this.direction = dir
    this.iter(function (line) { return line.order = null; })
    if (this.cm) { directionChanged(this.cm) }
  })
})

// Public alias.
Doc.prototype.eachLine = Doc.prototype.iter

// Kludge to work around strange IE behavior where it'll sometimes
// re-fire a series of drag-related events right after the drop (#1551)
var lastDrop = 0

function onDrop(e) {
  var cm = this
  clearDragCursor(cm)
  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
    { return }
  e_preventDefault(e)
  if (ie) { lastDrop = +new Date }
  var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files
  if (!pos || cm.isReadOnly()) { return }
  // Might be a file drop, in which case we simply extract the text
  // and insert it.
  if (files && files.length && window.FileReader && window.File) {
    var n = files.length, text = Array(n), read = 0
    var loadFile = function (file, i) {
      if (cm.options.allowDropFileTypes &&
          indexOf(cm.options.allowDropFileTypes, file.type) == -1)
        { return }

      var reader = new FileReader
      reader.onload = operation(cm, function () {
        var content = reader.result
        if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) { content = "" }
        text[i] = content
        if (++read == n) {
          pos = clipPos(cm.doc, pos)
          var change = {from: pos, to: pos,
                        text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                        origin: "paste"}
          makeChange(cm.doc, change)
          setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)))
        }
      })
      reader.readAsText(file)
    }
    for (var i = 0; i < n; ++i) { loadFile(files[i], i) }
  } else { // Normal drop
    // Don't do a replace if the drop happened inside of the selected text.
    if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
      cm.state.draggingText(e)
      // Ensure the editor is re-focused
      setTimeout(function () { return cm.display.input.focus(); }, 20)
      return
    }
    try {
      var text$1 = e.dataTransfer.getData("Text")
      if (text$1) {
        var selected
        if (cm.state.draggingText && !cm.state.draggingText.copy)
          { selected = cm.listSelections() }
        setSelectionNoUndo(cm.doc, simpleSelection(pos, pos))
        if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
          { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag") } }
        cm.replaceSelection(text$1, "around", "paste")
        cm.display.input.focus()
      }
    }
    catch(e){}
  }
}

function onDragStart(cm, e) {
  if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
  if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

  e.dataTransfer.setData("Text", cm.getSelection())
  e.dataTransfer.effectAllowed = "copyMove"

  // Use dummy image instead of default browsers image.
  // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
  if (e.dataTransfer.setDragImage && !safari) {
    var img = elt("img", null, null, "position: fixed; left: 0; top: 0;")
    img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
    if (presto) {
      img.width = img.height = 1
      cm.display.wrapper.appendChild(img)
      // Force a relayout, or Opera won't use our image for some obscure reason
      img._top = img.offsetTop
    }
    e.dataTransfer.setDragImage(img, 0, 0)
    if (presto) { img.parentNode.removeChild(img) }
  }
}

function onDragOver(cm, e) {
  var pos = posFromMouse(cm, e)
  if (!pos) { return }
  var frag = document.createDocumentFragment()
  drawSelectionCursor(cm, pos, frag)
  if (!cm.display.dragCursor) {
    cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors")
    cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)
  }
  removeChildrenAndAdd(cm.display.dragCursor, frag)
}

function clearDragCursor(cm) {
  if (cm.display.dragCursor) {
    cm.display.lineSpace.removeChild(cm.display.dragCursor)
    cm.display.dragCursor = null
  }
}

// These must be handled carefully, because naively registering a
// handler for each editor will cause the editors to never be
// garbage collected.

function forEachCodeMirror(f) {
  if (!document.getElementsByClassName) { return }
  var byClass = document.getElementsByClassName("CodeMirror")
  for (var i = 0; i < byClass.length; i++) {
    var cm = byClass[i].CodeMirror
    if (cm) { f(cm) }
  }
}

var globalsRegistered = false
function ensureGlobalHandlers() {
  if (globalsRegistered) { return }
  registerGlobalHandlers()
  globalsRegistered = true
}
function registerGlobalHandlers() {
  // When the window resizes, we need to refresh active editors.
  var resizeTimer
  on(window, "resize", function () {
    if (resizeTimer == null) { resizeTimer = setTimeout(function () {
      resizeTimer = null
      forEachCodeMirror(onResize)
    }, 100) }
  })
  // When the window loses focus, we want to show the editor as blurred
  on(window, "blur", function () { return forEachCodeMirror(onBlur); })
}
// Called when the window resizes
function onResize(cm) {
  var d = cm.display
  if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)
    { return }
  // Might be a text scaling operation, clear size caches.
  d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null
  d.scrollbarsClipped = false
  cm.setSize()
}

var keyNames = {
  3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
  106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 127: "Delete",
  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
}

// Number keys
for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i) }
// Alphabetic keys
for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1) }
// Function keys
for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2 }

var keyMap = {}

keyMap.basic = {
  "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
  "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
  "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
  "Tab": "defaultTab", "Shift-Tab": "indentAuto",
  "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
  "Esc": "singleSelection"
}
// Note that the save and find-related commands aren't defined by
// default. User code or addons can define them. Unknown commands
// are simply ignored.
keyMap.pcDefault = {
  "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
  "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
  "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
  "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
  "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
  "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
  "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
  fallthrough: "basic"
}
// Very basic readline/emacs-style bindings, which are standard on Mac.
keyMap.emacsy = {
  "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
  "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
  "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
  "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
  "Ctrl-O": "openLine"
}
keyMap.macDefault = {
  "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
  "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
  "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
  "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
  "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
  "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
  "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
  fallthrough: ["basic", "emacsy"]
}
keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault

// KEYMAP DISPATCH

function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/)
  name = parts[parts.length - 1]
  var alt, ctrl, shift, cmd
  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i]
    if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true }
    else if (/^a(lt)?$/i.test(mod)) { alt = true }
    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true }
    else if (/^s(hift)?$/i.test(mod)) { shift = true }
    else { throw new Error("Unrecognized modifier name: " + mod) }
  }
  if (alt) { name = "Alt-" + name }
  if (ctrl) { name = "Ctrl-" + name }
  if (cmd) { name = "Cmd-" + name }
  if (shift) { name = "Shift-" + name }
  return name
}

// This is a kludge to keep keymaps mostly working as raw objects
// (backwards compatibility) while at the same time support features
// like normalization and multi-stroke key bindings. It compiles a
// new normalized keymap, and then updates the old object to reflect
// this.
function normalizeKeyMap(keymap) {
  var copy = {}
  for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
    var value = keymap[keyname]
    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
    if (value == "...") { delete keymap[keyname]; continue }

    var keys = map(keyname.split(" "), normalizeKeyName)
    for (var i = 0; i < keys.length; i++) {
      var val = (void 0), name = (void 0)
      if (i == keys.length - 1) {
        name = keys.join(" ")
        val = value
      } else {
        name = keys.slice(0, i + 1).join(" ")
        val = "..."
      }
      var prev = copy[name]
      if (!prev) { copy[name] = val }
      else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
    }
    delete keymap[keyname]
  } }
  for (var prop in copy) { keymap[prop] = copy[prop] }
  return keymap
}

function lookupKey(key, map, handle, context) {
  map = getKeyMap(map)
  var found = map.call ? map.call(key, context) : map[key]
  if (found === false) { return "nothing" }
  if (found === "...") { return "multi" }
  if (found != null && handle(found)) { return "handled" }

  if (map.fallthrough) {
    if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
      { return lookupKey(key, map.fallthrough, handle, context) }
    for (var i = 0; i < map.fallthrough.length; i++) {
      var result = lookupKey(key, map.fallthrough[i], handle, context)
      if (result) { return result }
    }
  }
}

// Modifier key presses don't count as 'real' key presses for the
// purpose of keymap fallthrough.
function isModifierKey(value) {
  var name = typeof value == "string" ? value : keyNames[value.keyCode]
  return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
}

function addModifierNames(name, event, noShift) {
  var base = name
  if (event.altKey && base != "Alt") { name = "Alt-" + name }
  if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name }
  if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Cmd") { name = "Cmd-" + name }
  if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name }
  return name
}

// Look up the name of a key as indicated by an event object.
function keyName(event, noShift) {
  if (presto && event.keyCode == 34 && event["char"]) { return false }
  var name = keyNames[event.keyCode]
  if (name == null || event.altGraphKey) { return false }
  return addModifierNames(name, event, noShift)
}

function getKeyMap(val) {
  return typeof val == "string" ? keyMap[val] : val
}

// Helper for deleting text near the selection(s), used to implement
// backspace, delete, and similar functionality.
function deleteNearSelection(cm, compute) {
  var ranges = cm.doc.sel.ranges, kill = []
  // Build up a set of ranges to kill first, merging overlapping
  // ranges.
  for (var i = 0; i < ranges.length; i++) {
    var toKill = compute(ranges[i])
    while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
      var replaced = kill.pop()
      if (cmp(replaced.from, toKill.from) < 0) {
        toKill.from = replaced.from
        break
      }
    }
    kill.push(toKill)
  }
  // Next, remove those actual ranges.
  runInOp(cm, function () {
    for (var i = kill.length - 1; i >= 0; i--)
      { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete") }
    ensureCursorVisible(cm)
  })
}

function moveCharLogically(line, ch, dir) {
  var target = skipExtendingChars(line.text, ch + dir, dir)
  return target < 0 || target > line.text.length ? null : target
}

function moveLogically(line, start, dir) {
  var ch = moveCharLogically(line, start.ch, dir)
  return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
}

function endOfLine(visually, cm, lineObj, lineNo, dir) {
  if (visually) {
    var order = getOrder(lineObj, cm.doc.direction)
    if (order) {
      var part = dir < 0 ? lst(order) : order[0]
      var moveInStorageOrder = (dir < 0) == (part.level == 1)
      var sticky = moveInStorageOrder ? "after" : "before"
      var ch
      // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
      // it could be that the last bidi part is not on the last visual line,
      // since visual lines contain content order-consecutive chunks.
      // Thus, in rtl, we are looking for the first (content-order) character
      // in the rtl chunk that is on the last line (that is, the same line
      // as the last (content-order) character).
      if (part.level > 0) {
        var prep = prepareMeasureForLine(cm, lineObj)
        ch = dir < 0 ? lineObj.text.length - 1 : 0
        var targetTop = measureCharPrepared(cm, prep, ch).top
        ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch)
        if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1) }
      } else { ch = dir < 0 ? part.to : part.from }
      return new Pos(lineNo, ch, sticky)
    }
  }
  return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
}

function moveVisually(cm, line, start, dir) {
  var bidi = getOrder(line, cm.doc.direction)
  if (!bidi) { return moveLogically(line, start, dir) }
  if (start.ch >= line.text.length) {
    start.ch = line.text.length
    start.sticky = "before"
  } else if (start.ch <= 0) {
    start.ch = 0
    start.sticky = "after"
  }
  var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos]
  if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
    // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
    // nothing interesting happens.
    return moveLogically(line, start, dir)
  }

  var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); }
  var prep
  var getWrappedLineExtent = function (ch) {
    if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
    prep = prep || prepareMeasureForLine(cm, line)
    return wrappedLineExtentChar(cm, line, prep, ch)
  }
  var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch)

  if (cm.doc.direction == "rtl" || part.level == 1) {
    var moveInStorageOrder = (part.level == 1) == (dir < 0)
    var ch = mv(start, moveInStorageOrder ? 1 : -1)
    if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
      // Case 2: We move within an rtl part or in an rtl editor on the same visual line
      var sticky = moveInStorageOrder ? "before" : "after"
      return new Pos(start.line, ch, sticky)
    }
  }

  // Case 3: Could not move within this bidi part in this visual line, so leave
  // the current bidi part

  var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
    var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
      ? new Pos(start.line, mv(ch, 1), "before")
      : new Pos(start.line, ch, "after"); }

    for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
      var part = bidi[partPos]
      var moveInStorageOrder = (dir > 0) == (part.level != 1)
      var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1)
      if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
      ch = moveInStorageOrder ? part.from : mv(part.to, -1)
      if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
    }
  }

  // Case 3a: Look for other bidi parts on the same visual line
  var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent)
  if (res) { return res }

  // Case 3b: Look for other bidi parts on the next visual line
  var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1)
  if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
    res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh))
    if (res) { return res }
  }

  // Case 4: Nowhere to move
  return null
}

// Commands are parameter-less actions that can be performed on an
// editor, mostly used for keybindings.
var commands = {
  selectAll: selectAll,
  singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
  killLine: function (cm) { return deleteNearSelection(cm, function (range) {
    if (range.empty()) {
      var len = getLine(cm.doc, range.head.line).text.length
      if (range.head.ch == len && range.head.line < cm.lastLine())
        { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
      else
        { return {from: range.head, to: Pos(range.head.line, len)} }
    } else {
      return {from: range.from(), to: range.to()}
    }
  }); },
  deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
    from: Pos(range.from().line, 0),
    to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
  }); }); },
  delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
    from: Pos(range.from().line, 0), to: range.from()
  }); }); },
  delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
    var top = cm.charCoords(range.head, "div").top + 5
    var leftPos = cm.coordsChar({left: 0, top: top}, "div")
    return {from: leftPos, to: range.from()}
  }); },
  delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
    var top = cm.charCoords(range.head, "div").top + 5
    var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
    return {from: range.from(), to: rightPos }
  }); },
  undo: function (cm) { return cm.undo(); },
  redo: function (cm) { return cm.redo(); },
  undoSelection: function (cm) { return cm.undoSelection(); },
  redoSelection: function (cm) { return cm.redoSelection(); },
  goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
  goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
  goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
    {origin: "+move", bias: 1}
  ); },
  goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
    {origin: "+move", bias: 1}
  ); },
  goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
    {origin: "+move", bias: -1}
  ); },
  goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
    var top = cm.cursorCoords(range.head, "div").top + 5
    return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
  }, sel_move); },
  goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
    var top = cm.cursorCoords(range.head, "div").top + 5
    return cm.coordsChar({left: 0, top: top}, "div")
  }, sel_move); },
  goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
    var top = cm.cursorCoords(range.head, "div").top + 5
    var pos = cm.coordsChar({left: 0, top: top}, "div")
    if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
    return pos
  }, sel_move); },
  goLineUp: function (cm) { return cm.moveV(-1, "line"); },
  goLineDown: function (cm) { return cm.moveV(1, "line"); },
  goPageUp: function (cm) { return cm.moveV(-1, "page"); },
  goPageDown: function (cm) { return cm.moveV(1, "page"); },
  goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
  goCharRight: function (cm) { return cm.moveH(1, "char"); },
  goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
  goColumnRight: function (cm) { return cm.moveH(1, "column"); },
  goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
  goGroupRight: function (cm) { return cm.moveH(1, "group"); },
  goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
  goWordRight: function (cm) { return cm.moveH(1, "word"); },
  delCharBefore: function (cm) { return cm.deleteH(-1, "char"); },
  delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
  delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
  delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
  delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
  delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
  indentAuto: function (cm) { return cm.indentSelection("smart"); },
  indentMore: function (cm) { return cm.indentSelection("add"); },
  indentLess: function (cm) { return cm.indentSelection("subtract"); },
  insertTab: function (cm) { return cm.replaceSelection("\t"); },
  insertSoftTab: function (cm) {
    var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize
    for (var i = 0; i < ranges.length; i++) {
      var pos = ranges[i].from()
      var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize)
      spaces.push(spaceStr(tabSize - col % tabSize))
    }
    cm.replaceSelections(spaces)
  },
  defaultTab: function (cm) {
    if (cm.somethingSelected()) { cm.indentSelection("add") }
    else { cm.execCommand("insertTab") }
  },
  // Swap the two chars left and right of each selection's head.
  // Move cursor behind the two swapped characters afterwards.
  //
  // Doesn't consider line feeds a character.
  // Doesn't scan more than one line above to find a character.
  // Doesn't do anything on an empty line.
  // Doesn't do anything with non-empty selections.
  transposeChars: function (cm) { return runInOp(cm, function () {
    var ranges = cm.listSelections(), newSel = []
    for (var i = 0; i < ranges.length; i++) {
      if (!ranges[i].empty()) { continue }
      var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text
      if (line) {
        if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1) }
        if (cur.ch > 0) {
          cur = new Pos(cur.line, cur.ch + 1)
          cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                          Pos(cur.line, cur.ch - 2), cur, "+transpose")
        } else if (cur.line > cm.doc.first) {
          var prev = getLine(cm.doc, cur.line - 1).text
          if (prev) {
            cur = new Pos(cur.line, 1)
            cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                            prev.charAt(prev.length - 1),
                            Pos(cur.line - 1, prev.length - 1), cur, "+transpose")
          }
        }
      }
      newSel.push(new Range(cur, cur))
    }
    cm.setSelections(newSel)
  }); },
  newlineAndIndent: function (cm) { return runInOp(cm, function () {
    var sels = cm.listSelections()
    for (var i = sels.length - 1; i >= 0; i--)
      { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input") }
    sels = cm.listSelections()
    for (var i$1 = 0; i$1 < sels.length; i$1++)
      { cm.indentLine(sels[i$1].from().line, null, true) }
    ensureCursorVisible(cm)
  }); },
  openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
  toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
}


function lineStart(cm, lineN) {
  var line = getLine(cm.doc, lineN)
  var visual = visualLine(line)
  if (visual != line) { lineN = lineNo(visual) }
  return endOfLine(true, cm, visual, lineN, 1)
}
function lineEnd(cm, lineN) {
  var line = getLine(cm.doc, lineN)
  var visual = visualLineEnd(line)
  if (visual != line) { lineN = lineNo(visual) }
  return endOfLine(true, cm, line, lineN, -1)
}
function lineStartSmart(cm, pos) {
  var start = lineStart(cm, pos.line)
  var line = getLine(cm.doc, start.line)
  var order = getOrder(line, cm.doc.direction)
  if (!order || order[0].level == 0) {
    var firstNonWS = Math.max(0, line.text.search(/\S/))
    var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch
    return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
  }
  return start
}

// Run a handler that was bound to a key.
function doHandleBinding(cm, bound, dropShift) {
  if (typeof bound == "string") {
    bound = commands[bound]
    if (!bound) { return false }
  }
  // Ensure previous input has been read, so that the handler sees a
  // consistent view of the document
  cm.display.input.ensurePolled()
  var prevShift = cm.display.shift, done = false
  try {
    if (cm.isReadOnly()) { cm.state.suppressEdits = true }
    if (dropShift) { cm.display.shift = false }
    done = bound(cm) != Pass
  } finally {
    cm.display.shift = prevShift
    cm.state.suppressEdits = false
  }
  return done
}

function lookupKeyForEditor(cm, name, handle) {
  for (var i = 0; i < cm.state.keyMaps.length; i++) {
    var result = lookupKey(name, cm.state.keyMaps[i], handle, cm)
    if (result) { return result }
  }
  return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
    || lookupKey(name, cm.options.keyMap, handle, cm)
}

// Note that, despite the name, this function is also used to check
// for bound mouse clicks.

var stopSeq = new Delayed
function dispatchKey(cm, name, e, handle) {
  var seq = cm.state.keySeq
  if (seq) {
    if (isModifierKey(name)) { return "handled" }
    stopSeq.set(50, function () {
      if (cm.state.keySeq == seq) {
        cm.state.keySeq = null
        cm.display.input.reset()
      }
    })
    name = seq + " " + name
  }
  var result = lookupKeyForEditor(cm, name, handle)

  if (result == "multi")
    { cm.state.keySeq = name }
  if (result == "handled")
    { signalLater(cm, "keyHandled", cm, name, e) }

  if (result == "handled" || result == "multi") {
    e_preventDefault(e)
    restartBlink(cm)
  }

  if (seq && !result && /\'$/.test(name)) {
    e_preventDefault(e)
    return true
  }
  return !!result
}

// Handle a key from the keydown event.
function handleKeyBinding(cm, e) {
  var name = keyName(e, true)
  if (!name) { return false }

  if (e.shiftKey && !cm.state.keySeq) {
    // First try to resolve full name (including 'Shift-'). Failing
    // that, see if there is a cursor-motion command (starting with
    // 'go') bound to the keyname without 'Shift-'.
    return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
        || dispatchKey(cm, name, e, function (b) {
             if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
               { return doHandleBinding(cm, b) }
           })
  } else {
    return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
  }
}

// Handle a key from the keypress event
function handleCharBinding(cm, e, ch) {
  return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
}

var lastStoppedKey = null
function onKeyDown(e) {
  var cm = this
  cm.curOp.focus = activeElt()
  if (signalDOMEvent(cm, e)) { return }
  // IE does strange things with escape.
  if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false }
  var code = e.keyCode
  cm.display.shift = code == 16 || e.shiftKey
  var handled = handleKeyBinding(cm, e)
  if (presto) {
    lastStoppedKey = handled ? code : null
    // Opera has no cut event... we try to at least catch the key combo
    if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
      { cm.replaceSelection("", null, "cut") }
  }

  // Turn mouse into crosshair when Alt is held on Mac.
  if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
    { showCrossHair(cm) }
}

function showCrossHair(cm) {
  var lineDiv = cm.display.lineDiv
  addClass(lineDiv, "CodeMirror-crosshair")

  function up(e) {
    if (e.keyCode == 18 || !e.altKey) {
      rmClass(lineDiv, "CodeMirror-crosshair")
      off(document, "keyup", up)
      off(document, "mouseover", up)
    }
  }
  on(document, "keyup", up)
  on(document, "mouseover", up)
}

function onKeyUp(e) {
  if (e.keyCode == 16) { this.doc.sel.shift = false }
  signalDOMEvent(this, e)
}

function onKeyPress(e) {
  var cm = this
  if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
  var keyCode = e.keyCode, charCode = e.charCode
  if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
  if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
  var ch = String.fromCharCode(charCode == null ? keyCode : charCode)
  // Some browsers fire keypress events for backspace
  if (ch == "\x08") { return }
  if (handleCharBinding(cm, e, ch)) { return }
  cm.display.input.onKeyPress(e)
}

var DOUBLECLICK_DELAY = 400

var PastClick = function(time, pos, button) {
  this.time = time
  this.pos = pos
  this.button = button
};

PastClick.prototype.compare = function (time, pos, button) {
  return this.time + DOUBLECLICK_DELAY > time &&
    cmp(pos, this.pos) == 0 && button == this.button
};

var lastClick;
var lastDoubleClick;
function clickRepeat(pos, button) {
  var now = +new Date
  if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
    lastClick = lastDoubleClick = null
    return "triple"
  } else if (lastClick && lastClick.compare(now, pos, button)) {
    lastDoubleClick = new PastClick(now, pos, button)
    lastClick = null
    return "double"
  } else {
    lastClick = new PastClick(now, pos, button)
    lastDoubleClick = null
    return "single"
  }
}

// A mouse down can be a single click, double click, triple click,
// start of selection drag, start of text drag, new cursor
// (ctrl-click), rectangle drag (alt-drag), or xwin
// middle-click-paste. Or it might be a click on something we should
// not interfere with, such as a scrollbar or widget.
function onMouseDown(e) {
  var cm = this, display = cm.display
  if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
  display.input.ensurePolled()
  display.shift = e.shiftKey

  if (eventInWidget(display, e)) {
    if (!webkit) {
      // Briefly turn off draggability, to allow widgets to do
      // normal dragging things.
      display.scroller.draggable = false
      setTimeout(function () { return display.scroller.draggable = true; }, 100)
    }
    return
  }
  if (clickInGutter(cm, e)) { return }
  var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single"
  window.focus()

  // #3261: make sure, that we're not starting a second selection
  if (button == 1 && cm.state.selectingText)
    { cm.state.selectingText(e) }

  if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

  if (button == 1) {
    if (pos) { leftButtonDown(cm, pos, repeat, e) }
    else if (e_target(e) == display.scroller) { e_preventDefault(e) }
  } else if (button == 2) {
    if (pos) { extendSelection(cm.doc, pos) }
    setTimeout(function () { return display.input.focus(); }, 20)
  } else if (button == 3) {
    if (captureRightClick) { onContextMenu(cm, e) }
    else { delayBlurEvent(cm) }
  }
}

function handleMappedButton(cm, button, pos, repeat, event) {
  var name = "Click"
  if (repeat == "double") { name = "Double" + name }
  else if (repeat == "triple") { name = "Triple" + name }
  name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name

  return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
    if (typeof bound == "string") { bound = commands[bound] }
    if (!bound) { return false }
    var done = false
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true }
      done = bound(cm, pos) != Pass
    } finally {
      cm.state.suppressEdits = false
    }
    return done
  })
}

function configureMouse(cm, repeat, event) {
  var option = cm.getOption("configureMouse")
  var value = option ? option(cm, repeat, event) : {}
  if (value.unit == null) {
    var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey
    value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line"
  }
  if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey }
  if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey }
  if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey) }
  return value
}

function leftButtonDown(cm, pos, repeat, event) {
  if (ie) { setTimeout(bind(ensureFocus, cm), 0) }
  else { cm.curOp.focus = activeElt() }

  var behavior = configureMouse(cm, repeat, event)

  var sel = cm.doc.sel, contained
  if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
      repeat == "single" && (contained = sel.contains(pos)) > -1 &&
      (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
      (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
    { leftButtonStartDrag(cm, event, pos, behavior) }
  else
    { leftButtonSelect(cm, event, pos, behavior) }
}

// Start a text drag. When it ends, see if any dragging actually
// happen, and treat as a click if it didn't.
function leftButtonStartDrag(cm, event, pos, behavior) {
  var display = cm.display, moved = false
  var dragEnd = operation(cm, function (e) {
    if (webkit) { display.scroller.draggable = false }
    cm.state.draggingText = false
    off(document, "mouseup", dragEnd)
    off(document, "mousemove", mouseMove)
    off(display.scroller, "dragstart", dragStart)
    off(display.scroller, "drop", dragEnd)
    if (!moved) {
      e_preventDefault(e)
      if (!behavior.addNew)
        { extendSelection(cm.doc, pos, null, null, behavior.extend) }
      // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
      if (webkit || ie && ie_version == 9)
        { setTimeout(function () {document.body.focus(); display.input.focus()}, 20) }
      else
        { display.input.focus() }
    }
  })
  var mouseMove = function(e2) {
    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10
  }
  var dragStart = function () { return moved = true; }
  // Let the drag handler handle this.
  if (webkit) { display.scroller.draggable = true }
  cm.state.draggingText = dragEnd
  dragEnd.copy = !behavior.moveOnDrag
  // IE's approach to draggable
  if (display.scroller.dragDrop) { display.scroller.dragDrop() }
  on(document, "mouseup", dragEnd)
  on(document, "mousemove", mouseMove)
  on(display.scroller, "dragstart", dragStart)
  on(display.scroller, "drop", dragEnd)

  delayBlurEvent(cm)
  setTimeout(function () { return display.input.focus(); }, 20)
}

function rangeForUnit(cm, pos, unit) {
  if (unit == "char") { return new Range(pos, pos) }
  if (unit == "word") { return cm.findWordAt(pos) }
  if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
  var result = unit(cm, pos)
  return new Range(result.from, result.to)
}

// Normal selection, as opposed to text dragging.
function leftButtonSelect(cm, event, start, behavior) {
  var display = cm.display, doc = cm.doc
  e_preventDefault(event)

  var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges
  if (behavior.addNew && !behavior.extend) {
    ourIndex = doc.sel.contains(start)
    if (ourIndex > -1)
      { ourRange = ranges[ourIndex] }
    else
      { ourRange = new Range(start, start) }
  } else {
    ourRange = doc.sel.primary()
    ourIndex = doc.sel.primIndex
  }

  if (behavior.unit == "rectangle") {
    if (!behavior.addNew) { ourRange = new Range(start, start) }
    start = posFromMouse(cm, event, true, true)
    ourIndex = -1
  } else {
    var range = rangeForUnit(cm, start, behavior.unit)
    if (behavior.extend)
      { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend) }
    else
      { ourRange = range }
  }

  if (!behavior.addNew) {
    ourIndex = 0
    setSelection(doc, new Selection([ourRange], 0), sel_mouse)
    startSel = doc.sel
  } else if (ourIndex == -1) {
    ourIndex = ranges.length
    setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),
                 {scroll: false, origin: "*mouse"})
  } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
    setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                 {scroll: false, origin: "*mouse"})
    startSel = doc.sel
  } else {
    replaceOneSelection(doc, ourIndex, ourRange, sel_mouse)
  }

  var lastPos = start
  function extendTo(pos) {
    if (cmp(lastPos, pos) == 0) { return }
    lastPos = pos

    if (behavior.unit == "rectangle") {
      var ranges = [], tabSize = cm.options.tabSize
      var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize)
      var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize)
      var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol)
      for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
           line <= end; line++) {
        var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize)
        if (left == right)
          { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) }
        else if (text.length > leftPos)
          { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))) }
      }
      if (!ranges.length) { ranges.push(new Range(start, start)) }
      setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                   {origin: "*mouse", scroll: false})
      cm.scrollIntoView(pos)
    } else {
      var oldRange = ourRange
      var range = rangeForUnit(cm, pos, behavior.unit)
      var anchor = oldRange.anchor, head
      if (cmp(range.anchor, anchor) > 0) {
        head = range.head
        anchor = minPos(oldRange.from(), range.anchor)
      } else {
        head = range.anchor
        anchor = maxPos(oldRange.to(), range.head)
      }
      var ranges$1 = startSel.ranges.slice(0)
      ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head))
      setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse)
    }
  }

  var editorSize = display.wrapper.getBoundingClientRect()
  // Used to ensure timeout re-tries don't fire when another extend
  // happened in the meantime (clearTimeout isn't reliable -- at
  // least on Chrome, the timeouts still happen even when cleared,
  // if the clear happens after their scheduled firing time).
  var counter = 0

  function extend(e) {
    var curCount = ++counter
    var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle")
    if (!cur) { return }
    if (cmp(cur, lastPos) != 0) {
      cm.curOp.focus = activeElt()
      extendTo(cur)
      var visible = visibleLines(display, doc)
      if (cur.line >= visible.to || cur.line < visible.from)
        { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e) }}), 150) }
    } else {
      var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0
      if (outside) { setTimeout(operation(cm, function () {
        if (counter != curCount) { return }
        display.scroller.scrollTop += outside
        extend(e)
      }), 50) }
    }
  }

  function done(e) {
    cm.state.selectingText = false
    counter = Infinity
    e_preventDefault(e)
    display.input.focus()
    off(document, "mousemove", move)
    off(document, "mouseup", up)
    doc.history.lastSelOrigin = null
  }

  var move = operation(cm, function (e) {
    if (!e_button(e)) { done(e) }
    else { extend(e) }
  })
  var up = operation(cm, done)
  cm.state.selectingText = up
  on(document, "mousemove", move)
  on(document, "mouseup", up)
}

// Used when mouse-selecting to adjust the anchor to the proper side
// of a bidi jump depending on the visual position of the head.
function bidiSimplify(cm, range) {
  var anchor = range.anchor;
  var head = range.head;
  var anchorLine = getLine(cm.doc, anchor.line)
  if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }
  var order = getOrder(anchorLine)
  if (!order) { return range }
  var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index]
  if (part.from != anchor.ch && part.to != anchor.ch) { return range }
  var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1)
  if (boundary == 0 || boundary == order.length) { return range }

  // Compute the relative visual position of the head compared to the
  // anchor (<0 is to the left, >0 to the right)
  var leftSide
  if (head.line != anchor.line) {
    leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0
  } else {
    var headIndex = getBidiPartAt(order, head.ch, head.sticky)
    var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1)
    if (headIndex == boundary - 1 || headIndex == boundary)
      { leftSide = dir < 0 }
    else
      { leftSide = dir > 0 }
  }

  var usePart = order[boundary + (leftSide ? -1 : 0)]
  var from = leftSide == (usePart.level == 1)
  var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before"
  return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)
}


// Determines whether an event happened in the gutter, and fires the
// handlers for the corresponding event.
function gutterEvent(cm, e, type, prevent) {
  var mX, mY
  if (e.touches) {
    mX = e.touches[0].clientX
    mY = e.touches[0].clientY
  } else {
    try { mX = e.clientX; mY = e.clientY }
    catch(e) { return false }
  }
  if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
  if (prevent) { e_preventDefault(e) }

  var display = cm.display
  var lineBox = display.lineDiv.getBoundingClientRect()

  if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
  mY -= lineBox.top - display.viewOffset

  for (var i = 0; i < cm.options.gutters.length; ++i) {
    var g = display.gutters.childNodes[i]
    if (g && g.getBoundingClientRect().right >= mX) {
      var line = lineAtHeight(cm.doc, mY)
      var gutter = cm.options.gutters[i]
      signal(cm, type, cm, line, gutter, e)
      return e_defaultPrevented(e)
    }
  }
}

function clickInGutter(cm, e) {
  return gutterEvent(cm, e, "gutterClick", true)
}

// CONTEXT MENU HANDLING

// To make the context menu work, we need to briefly unhide the
// textarea (making it as unobtrusive as possible) to let the
// right-click take effect on it.
function onContextMenu(cm, e) {
  if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
  if (signalDOMEvent(cm, e, "contextmenu")) { return }
  cm.display.input.onContextMenu(e)
}

function contextMenuInGutter(cm, e) {
  if (!hasHandler(cm, "gutterContextMenu")) { return false }
  return gutterEvent(cm, e, "gutterContextMenu", false)
}

function themeChanged(cm) {
  cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
    cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-")
  clearCaches(cm)
}

var Init = {toString: function(){return "CodeMirror.Init"}}

var defaults = {}
var optionHandlers = {}

function defineOptions(CodeMirror) {
  var optionHandlers = CodeMirror.optionHandlers

  function option(name, deflt, handle, notOnInit) {
    CodeMirror.defaults[name] = deflt
    if (handle) { optionHandlers[name] =
      notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old) }} : handle }
  }

  CodeMirror.defineOption = option

  // Passed to option handlers when there is no old value.
  CodeMirror.Init = Init

  // These two are, on init, called from the constructor because they
  // have to be initialized before the editor can start at all.
  option("value", "", function (cm, val) { return cm.setValue(val); }, true)
  option("mode", null, function (cm, val) {
    cm.doc.modeOption = val
    loadMode(cm)
  }, true)

  option("indentUnit", 2, loadMode, true)
  option("indentWithTabs", false)
  option("smartIndent", true)
  option("tabSize", 4, function (cm) {
    resetModeState(cm)
    clearCaches(cm)
    regChange(cm)
  }, true)
  option("lineSeparator", null, function (cm, val) {
    cm.doc.lineSep = val
    if (!val) { return }
    var newBreaks = [], lineNo = cm.doc.first
    cm.doc.iter(function (line) {
      for (var pos = 0;;) {
        var found = line.text.indexOf(val, pos)
        if (found == -1) { break }
        pos = found + val.length
        newBreaks.push(Pos(lineNo, found))
      }
      lineNo++
    })
    for (var i = newBreaks.length - 1; i >= 0; i--)
      { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)) }
  })
  option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function (cm, val, old) {
    cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g")
    if (old != Init) { cm.refresh() }
  })
  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true)
  option("electricChars", true)
  option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
    throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
  }, true)
  option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true)
  option("rtlMoveVisually", !windows)
  option("wholeLineUpdateBefore", true)

  option("theme", "default", function (cm) {
    themeChanged(cm)
    guttersChanged(cm)
  }, true)
  option("keyMap", "default", function (cm, val, old) {
    var next = getKeyMap(val)
    var prev = old != Init && getKeyMap(old)
    if (prev && prev.detach) { prev.detach(cm, next) }
    if (next.attach) { next.attach(cm, prev || null) }
  })
  option("extraKeys", null)
  option("configureMouse", null)

  option("lineWrapping", false, wrappingChanged, true)
  option("gutters", [], function (cm) {
    setGuttersForLineNumbers(cm.options)
    guttersChanged(cm)
  }, true)
  option("fixedGutter", true, function (cm, val) {
    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0"
    cm.refresh()
  }, true)
  option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true)
  option("scrollbarStyle", "native", function (cm) {
    initScrollbars(cm)
    updateScrollbars(cm)
    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop)
    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft)
  }, true)
  option("lineNumbers", false, function (cm) {
    setGuttersForLineNumbers(cm.options)
    guttersChanged(cm)
  }, true)
  option("firstLineNumber", 1, guttersChanged, true)
  option("lineNumberFormatter", function (integer) { return integer; }, guttersChanged, true)
  option("showCursorWhenSelecting", false, updateSelection, true)

  option("resetSelectionOnContextMenu", true)
  option("lineWiseCopyCut", true)
  option("pasteLinesPerSelection", true)

  option("readOnly", false, function (cm, val) {
    if (val == "nocursor") {
      onBlur(cm)
      cm.display.input.blur()
    }
    cm.display.input.readOnlyChanged(val)
  })
  option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset() }}, true)
  option("dragDrop", true, dragDropChanged)
  option("allowDropFileTypes", null)

  option("cursorBlinkRate", 530)
  option("cursorScrollMargin", 0)
  option("cursorHeight", 1, updateSelection, true)
  option("singleCursorHeightPerLine", true, updateSelection, true)
  option("workTime", 100)
  option("workDelay", 100)
  option("flattenSpans", true, resetModeState, true)
  option("addModeClass", false, resetModeState, true)
  option("pollInterval", 100)
  option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; })
  option("historyEventDelay", 1250)
  option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true)
  option("maxHighlightLength", 10000, resetModeState, true)
  option("moveInputWithCursor", true, function (cm, val) {
    if (!val) { cm.display.input.resetPosition() }
  })

  option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; })
  option("autofocus", null)
  option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true)
}

function guttersChanged(cm) {
  updateGutters(cm)
  regChange(cm)
  alignHorizontally(cm)
}

function dragDropChanged(cm, value, old) {
  var wasOn = old && old != Init
  if (!value != !wasOn) {
    var funcs = cm.display.dragFunctions
    var toggle = value ? on : off
    toggle(cm.display.scroller, "dragstart", funcs.start)
    toggle(cm.display.scroller, "dragenter", funcs.enter)
    toggle(cm.display.scroller, "dragover", funcs.over)
    toggle(cm.display.scroller, "dragleave", funcs.leave)
    toggle(cm.display.scroller, "drop", funcs.drop)
  }
}

function wrappingChanged(cm) {
  if (cm.options.lineWrapping) {
    addClass(cm.display.wrapper, "CodeMirror-wrap")
    cm.display.sizer.style.minWidth = ""
    cm.display.sizerWidth = null
  } else {
    rmClass(cm.display.wrapper, "CodeMirror-wrap")
    findMaxLine(cm)
  }
  estimateLineHeights(cm)
  regChange(cm)
  clearCaches(cm)
  setTimeout(function () { return updateScrollbars(cm); }, 100)
}

// A CodeMirror instance represents an editor. This is the object
// that user code is usually dealing with.

function CodeMirror(place, options) {
  var this$1 = this;

  if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

  this.options = options = options ? copyObj(options) : {}
  // Determine effective options based on given values and defaults.
  copyObj(defaults, options, false)
  setGuttersForLineNumbers(options)

  var doc = options.value
  if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction) }
  this.doc = doc

  var input = new CodeMirror.inputStyles[options.inputStyle](this)
  var display = this.display = new Display(place, doc, input)
  display.wrapper.CodeMirror = this
  updateGutters(this)
  themeChanged(this)
  if (options.lineWrapping)
    { this.display.wrapper.className += " CodeMirror-wrap" }
  initScrollbars(this)

  this.state = {
    keyMaps: [],  // stores maps added by addKeyMap
    overlays: [], // highlighting overlays, as added by addOverlay
    modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
    overwrite: false,
    delayingBlurEvent: false,
    focused: false,
    suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
    pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll
    selectingText: false,
    draggingText: false,
    highlight: new Delayed(), // stores highlight worker timeout
    keySeq: null,  // Unfinished key sequence
    specialChars: null
  }

  if (options.autofocus && !mobile) { display.input.focus() }

  // Override magic textarea content restore that IE sometimes does
  // on our hidden textarea on reload
  if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20) }

  registerEventHandlers(this)
  ensureGlobalHandlers()

  startOperation(this)
  this.curOp.forceUpdate = true
  attachDoc(this, doc)

  if ((options.autofocus && !mobile) || this.hasFocus())
    { setTimeout(bind(onFocus, this), 20) }
  else
    { onBlur(this) }

  for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
    { optionHandlers[opt](this$1, options[opt], Init) } }
  maybeUpdateLineNumberWidth(this)
  if (options.finishInit) { options.finishInit(this) }
  for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1) }
  endOperation(this)
  // Suppress optimizelegibility in Webkit, since it breaks text
  // measuring on line wrapping boundaries.
  if (webkit && options.lineWrapping &&
      getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
    { display.lineDiv.style.textRendering = "auto" }
}

// The default configuration options.
CodeMirror.defaults = defaults
// Functions to run when options are changed.
CodeMirror.optionHandlers = optionHandlers

// Attach the necessary event handlers when initializing the editor
function registerEventHandlers(cm) {
  var d = cm.display
  on(d.scroller, "mousedown", operation(cm, onMouseDown))
  // Older IE's will not fire a second mousedown for a double click
  if (ie && ie_version < 11)
    { on(d.scroller, "dblclick", operation(cm, function (e) {
      if (signalDOMEvent(cm, e)) { return }
      var pos = posFromMouse(cm, e)
      if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
      e_preventDefault(e)
      var word = cm.findWordAt(pos)
      extendSelection(cm.doc, word.anchor, word.head)
    })) }
  else
    { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }) }
  // Some browsers fire contextmenu *after* opening the menu, at
  // which point we can't mess with it anymore. Context menu is
  // handled in onMouseDown for these browsers.
  if (!captureRightClick) { on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); }) }

  // Used to suppress mouse event handling when a touch happens
  var touchFinished, prevTouch = {end: 0}
  function finishTouch() {
    if (d.activeTouch) {
      touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000)
      prevTouch = d.activeTouch
      prevTouch.end = +new Date
    }
  }
  function isMouseLikeTouchEvent(e) {
    if (e.touches.length != 1) { return false }
    var touch = e.touches[0]
    return touch.radiusX <= 1 && touch.radiusY <= 1
  }
  function farAway(touch, other) {
    if (other.left == null) { return true }
    var dx = other.left - touch.left, dy = other.top - touch.top
    return dx * dx + dy * dy > 20 * 20
  }
  on(d.scroller, "touchstart", function (e) {
    if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
      d.input.ensurePolled()
      clearTimeout(touchFinished)
      var now = +new Date
      d.activeTouch = {start: now, moved: false,
                       prev: now - prevTouch.end <= 300 ? prevTouch : null}
      if (e.touches.length == 1) {
        d.activeTouch.left = e.touches[0].pageX
        d.activeTouch.top = e.touches[0].pageY
      }
    }
  })
  on(d.scroller, "touchmove", function () {
    if (d.activeTouch) { d.activeTouch.moved = true }
  })
  on(d.scroller, "touchend", function (e) {
    var touch = d.activeTouch
    if (touch && !eventInWidget(d, e) && touch.left != null &&
        !touch.moved && new Date - touch.start < 300) {
      var pos = cm.coordsChar(d.activeTouch, "page"), range
      if (!touch.prev || farAway(touch, touch.prev)) // Single tap
        { range = new Range(pos, pos) }
      else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
        { range = cm.findWordAt(pos) }
      else // Triple tap
        { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
      cm.setSelection(range.anchor, range.head)
      cm.focus()
      e_preventDefault(e)
    }
    finishTouch()
  })
  on(d.scroller, "touchcancel", finishTouch)

  // Sync scrolling between fake scrollbars and real scrollable
  // area, ensure viewport is updated when scrolling.
  on(d.scroller, "scroll", function () {
    if (d.scroller.clientHeight) {
      updateScrollTop(cm, d.scroller.scrollTop)
      setScrollLeft(cm, d.scroller.scrollLeft, true)
      signal(cm, "scroll", cm)
    }
  })

  // Listen to wheel events in order to try and update the viewport on time.
  on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); })
  on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); })

  // Prevent wrapper from ever scrolling
  on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; })

  d.dragFunctions = {
    enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e) }},
    over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e) }},
    start: function (e) { return onDragStart(cm, e); },
    drop: operation(cm, onDrop),
    leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm) }}
  }

  var inp = d.input.getField()
  on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); })
  on(inp, "keydown", operation(cm, onKeyDown))
  on(inp, "keypress", operation(cm, onKeyPress))
  on(inp, "focus", function (e) { return onFocus(cm, e); })
  on(inp, "blur", function (e) { return onBlur(cm, e); })
}

var initHooks = []
CodeMirror.defineInitHook = function (f) { return initHooks.push(f); }

// Indent the given line. The how parameter can be "smart",
// "add"/null, "subtract", or "prev". When aggressive is false
// (typically set to true for forced single-line indents), empty
// lines are not indented, and places where the mode returns Pass
// are left alone.
function indentLine(cm, n, how, aggressive) {
  var doc = cm.doc, state
  if (how == null) { how = "add" }
  if (how == "smart") {
    // Fall back to "prev" when the mode doesn't have an indentation
    // method.
    if (!doc.mode.indent) { how = "prev" }
    else { state = getContextBefore(cm, n).state }
  }

  var tabSize = cm.options.tabSize
  var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize)
  if (line.stateAfter) { line.stateAfter = null }
  var curSpaceString = line.text.match(/^\s*/)[0], indentation
  if (!aggressive && !/\S/.test(line.text)) {
    indentation = 0
    how = "not"
  } else if (how == "smart") {
    indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text)
    if (indentation == Pass || indentation > 150) {
      if (!aggressive) { return }
      how = "prev"
    }
  }
  if (how == "prev") {
    if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize) }
    else { indentation = 0 }
  } else if (how == "add") {
    indentation = curSpace + cm.options.indentUnit
  } else if (how == "subtract") {
    indentation = curSpace - cm.options.indentUnit
  } else if (typeof how == "number") {
    indentation = curSpace + how
  }
  indentation = Math.max(0, indentation)

  var indentString = "", pos = 0
  if (cm.options.indentWithTabs)
    { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t"} }
  if (pos < indentation) { indentString += spaceStr(indentation - pos) }

  if (indentString != curSpaceString) {
    replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input")
    line.stateAfter = null
    return true
  } else {
    // Ensure that, if the cursor was in the whitespace at the start
    // of the line, it is moved to the end of that space.
    for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
      var range = doc.sel.ranges[i$1]
      if (range.head.line == n && range.head.ch < curSpaceString.length) {
        var pos$1 = Pos(n, curSpaceString.length)
        replaceOneSelection(doc, i$1, new Range(pos$1, pos$1))
        break
      }
    }
  }
}

// This will be set to a {lineWise: bool, text: [string]} object, so
// that, when pasting, we know what kind of selections the copied
// text was made out of.
var lastCopied = null

function setLastCopied(newLastCopied) {
  lastCopied = newLastCopied
}

function applyTextInput(cm, inserted, deleted, sel, origin) {
  var doc = cm.doc
  cm.display.shift = false
  if (!sel) { sel = doc.sel }

  var paste = cm.state.pasteIncoming || origin == "paste"
  var textLines = splitLinesAuto(inserted), multiPaste = null
  // When pasing N lines into N selections, insert one line per selection
  if (paste && sel.ranges.length > 1) {
    if (lastCopied && lastCopied.text.join("\n") == inserted) {
      if (sel.ranges.length % lastCopied.text.length == 0) {
        multiPaste = []
        for (var i = 0; i < lastCopied.text.length; i++)
          { multiPaste.push(doc.splitLines(lastCopied.text[i])) }
      }
    } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
      multiPaste = map(textLines, function (l) { return [l]; })
    }
  }

  var updateInput
  // Normal behavior is to insert the new text into every selection
  for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
    var range = sel.ranges[i$1]
    var from = range.from(), to = range.to()
    if (range.empty()) {
      if (deleted && deleted > 0) // Handle deletion
        { from = Pos(from.line, from.ch - deleted) }
      else if (cm.state.overwrite && !paste) // Handle overwrite
        { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) }
      else if (lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted)
        { from = to = Pos(from.line, 0) }
    }
    updateInput = cm.curOp.updateInput
    var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                       origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")}
    makeChange(cm.doc, changeEvent)
    signalLater(cm, "inputRead", cm, changeEvent)
  }
  if (inserted && !paste)
    { triggerElectric(cm, inserted) }

  ensureCursorVisible(cm)
  cm.curOp.updateInput = updateInput
  cm.curOp.typing = true
  cm.state.pasteIncoming = cm.state.cutIncoming = false
}

function handlePaste(e, cm) {
  var pasted = e.clipboardData && e.clipboardData.getData("Text")
  if (pasted) {
    e.preventDefault()
    if (!cm.isReadOnly() && !cm.options.disableInput)
      { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }) }
    return true
  }
}

function triggerElectric(cm, inserted) {
  // When an 'electric' character is inserted, immediately trigger a reindent
  if (!cm.options.electricChars || !cm.options.smartIndent) { return }
  var sel = cm.doc.sel

  for (var i = sel.ranges.length - 1; i >= 0; i--) {
    var range = sel.ranges[i]
    if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }
    var mode = cm.getModeAt(range.head)
    var indented = false
    if (mode.electricChars) {
      for (var j = 0; j < mode.electricChars.length; j++)
        { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
          indented = indentLine(cm, range.head.line, "smart")
          break
        } }
    } else if (mode.electricInput) {
      if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
        { indented = indentLine(cm, range.head.line, "smart") }
    }
    if (indented) { signalLater(cm, "electricInput", cm, range.head.line) }
  }
}

function copyableRanges(cm) {
  var text = [], ranges = []
  for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
    var line = cm.doc.sel.ranges[i].head.line
    var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)}
    ranges.push(lineRange)
    text.push(cm.getRange(lineRange.anchor, lineRange.head))
  }
  return {text: text, ranges: ranges}
}

function disableBrowserMagic(field, spellcheck) {
  field.setAttribute("autocorrect", "off")
  field.setAttribute("autocapitalize", "off")
  field.setAttribute("spellcheck", !!spellcheck)
}

function hiddenTextarea() {
  var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none")
  var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;")
  // The textarea is kept positioned near the cursor to prevent the
  // fact that it'll be scrolled into view on input from scrolling
  // our fake cursor out of view. On webkit, when wrap=off, paste is
  // very slow. So make the area wide instead.
  if (webkit) { te.style.width = "1000px" }
  else { te.setAttribute("wrap", "off") }
  // If border: 0; -- iOS fails to open keyboard (issue #1287)
  if (ios) { te.style.border = "1px solid black" }
  disableBrowserMagic(te)
  return div
}

// The publicly visible API. Note that methodOp(f) means
// 'wrap f in an operation, performed on its `this` parameter'.

// This is not the complete set of editor methods. Most of the
// methods defined on the Doc type are also injected into
// CodeMirror.prototype, for backwards compatibility and
// convenience.

function addEditorMethods(CodeMirror) {
  var optionHandlers = CodeMirror.optionHandlers

  var helpers = CodeMirror.helpers = {}

  CodeMirror.prototype = {
    constructor: CodeMirror,
    focus: function(){window.focus(); this.display.input.focus()},

    setOption: function(option, value) {
      var options = this.options, old = options[option]
      if (options[option] == value && option != "mode") { return }
      options[option] = value
      if (optionHandlers.hasOwnProperty(option))
        { operation(this, optionHandlers[option])(this, value, old) }
      signal(this, "optionChange", this, option)
    },

    getOption: function(option) {return this.options[option]},
    getDoc: function() {return this.doc},

    addKeyMap: function(map, bottom) {
      this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map))
    },
    removeKeyMap: function(map) {
      var maps = this.state.keyMaps
      for (var i = 0; i < maps.length; ++i)
        { if (maps[i] == map || maps[i].name == map) {
          maps.splice(i, 1)
          return true
        } }
    },

    addOverlay: methodOp(function(spec, options) {
      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec)
      if (mode.startState) { throw new Error("Overlays may not be stateful.") }
      insertSorted(this.state.overlays,
                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                    priority: (options && options.priority) || 0},
                   function (overlay) { return overlay.priority; })
      this.state.modeGen++
      regChange(this)
    }),
    removeOverlay: methodOp(function(spec) {
      var this$1 = this;

      var overlays = this.state.overlays
      for (var i = 0; i < overlays.length; ++i) {
        var cur = overlays[i].modeSpec
        if (cur == spec || typeof spec == "string" && cur.name == spec) {
          overlays.splice(i, 1)
          this$1.state.modeGen++
          regChange(this$1)
          return
        }
      }
    }),

    indentLine: methodOp(function(n, dir, aggressive) {
      if (typeof dir != "string" && typeof dir != "number") {
        if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev" }
        else { dir = dir ? "add" : "subtract" }
      }
      if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive) }
    }),
    indentSelection: methodOp(function(how) {
      var this$1 = this;

      var ranges = this.doc.sel.ranges, end = -1
      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i]
        if (!range.empty()) {
          var from = range.from(), to = range.to()
          var start = Math.max(end, from.line)
          end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1
          for (var j = start; j < end; ++j)
            { indentLine(this$1, j, how) }
          var newRanges = this$1.doc.sel.ranges
          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
            { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll) }
        } else if (range.head.line > end) {
          indentLine(this$1, range.head.line, how, true)
          end = range.head.line
          if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1) }
        }
      }
    }),

    // Fetch the parser token for a given character. Useful for hacks
    // that want to inspect the mode state (say, for completion).
    getTokenAt: function(pos, precise) {
      return takeToken(this, pos, precise)
    },

    getLineTokens: function(line, precise) {
      return takeToken(this, Pos(line), precise, true)
    },

    getTokenTypeAt: function(pos) {
      pos = clipPos(this.doc, pos)
      var styles = getLineStyles(this, getLine(this.doc, pos.line))
      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch
      var type
      if (ch == 0) { type = styles[2] }
      else { for (;;) {
        var mid = (before + after) >> 1
        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid }
        else if (styles[mid * 2 + 1] < ch) { before = mid + 1 }
        else { type = styles[mid * 2 + 2]; break }
      } }
      var cut = type ? type.indexOf("overlay ") : -1
      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
    },

    getModeAt: function(pos) {
      var mode = this.doc.mode
      if (!mode.innerMode) { return mode }
      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
    },

    getHelper: function(pos, type) {
      return this.getHelpers(pos, type)[0]
    },

    getHelpers: function(pos, type) {
      var this$1 = this;

      var found = []
      if (!helpers.hasOwnProperty(type)) { return found }
      var help = helpers[type], mode = this.getModeAt(pos)
      if (typeof mode[type] == "string") {
        if (help[mode[type]]) { found.push(help[mode[type]]) }
      } else if (mode[type]) {
        for (var i = 0; i < mode[type].length; i++) {
          var val = help[mode[type][i]]
          if (val) { found.push(val) }
        }
      } else if (mode.helperType && help[mode.helperType]) {
        found.push(help[mode.helperType])
      } else if (help[mode.name]) {
        found.push(help[mode.name])
      }
      for (var i$1 = 0; i$1 < help._global.length; i$1++) {
        var cur = help._global[i$1]
        if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)
          { found.push(cur.val) }
      }
      return found
    },

    getStateAfter: function(line, precise) {
      var doc = this.doc
      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line)
      return getContextBefore(this, line + 1, precise).state
    },

    cursorCoords: function(start, mode) {
      var pos, range = this.doc.sel.primary()
      if (start == null) { pos = range.head }
      else if (typeof start == "object") { pos = clipPos(this.doc, start) }
      else { pos = start ? range.from() : range.to() }
      return cursorCoords(this, pos, mode || "page")
    },

    charCoords: function(pos, mode) {
      return charCoords(this, clipPos(this.doc, pos), mode || "page")
    },

    coordsChar: function(coords, mode) {
      coords = fromCoordSystem(this, coords, mode || "page")
      return coordsChar(this, coords.left, coords.top)
    },

    lineAtHeight: function(height, mode) {
      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top
      return lineAtHeight(this.doc, height + this.display.viewOffset)
    },
    heightAtLine: function(line, mode, includeWidgets) {
      var end = false, lineObj
      if (typeof line == "number") {
        var last = this.doc.first + this.doc.size - 1
        if (line < this.doc.first) { line = this.doc.first }
        else if (line > last) { line = last; end = true }
        lineObj = getLine(this.doc, line)
      } else {
        lineObj = line
      }
      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
        (end ? this.doc.height - heightAtLine(lineObj) : 0)
    },

    defaultTextHeight: function() { return textHeight(this.display) },
    defaultCharWidth: function() { return charWidth(this.display) },

    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

    addWidget: function(pos, node, scroll, vert, horiz) {
      var display = this.display
      pos = cursorCoords(this, clipPos(this.doc, pos))
      var top = pos.bottom, left = pos.left
      node.style.position = "absolute"
      node.setAttribute("cm-ignore-events", "true")
      this.display.input.setUneditable(node)
      display.sizer.appendChild(node)
      if (vert == "over") {
        top = pos.top
      } else if (vert == "above" || vert == "near") {
        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth)
        // Default to positioning above (if specified and possible); otherwise default to positioning below
        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
          { top = pos.top - node.offsetHeight }
        else if (pos.bottom + node.offsetHeight <= vspace)
          { top = pos.bottom }
        if (left + node.offsetWidth > hspace)
          { left = hspace - node.offsetWidth }
      }
      node.style.top = top + "px"
      node.style.left = node.style.right = ""
      if (horiz == "right") {
        left = display.sizer.clientWidth - node.offsetWidth
        node.style.right = "0px"
      } else {
        if (horiz == "left") { left = 0 }
        else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2 }
        node.style.left = left + "px"
      }
      if (scroll)
        { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}) }
    },

    triggerOnKeyDown: methodOp(onKeyDown),
    triggerOnKeyPress: methodOp(onKeyPress),
    triggerOnKeyUp: onKeyUp,
    triggerOnMouseDown: methodOp(onMouseDown),

    execCommand: function(cmd) {
      if (commands.hasOwnProperty(cmd))
        { return commands[cmd].call(null, this) }
    },

    triggerElectric: methodOp(function(text) { triggerElectric(this, text) }),

    findPosH: function(from, amount, unit, visually) {
      var this$1 = this;

      var dir = 1
      if (amount < 0) { dir = -1; amount = -amount }
      var cur = clipPos(this.doc, from)
      for (var i = 0; i < amount; ++i) {
        cur = findPosH(this$1.doc, cur, dir, unit, visually)
        if (cur.hitSide) { break }
      }
      return cur
    },

    moveH: methodOp(function(dir, unit) {
      var this$1 = this;

      this.extendSelectionsBy(function (range) {
        if (this$1.display.shift || this$1.doc.extend || range.empty())
          { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }
        else
          { return dir < 0 ? range.from() : range.to() }
      }, sel_move)
    }),

    deleteH: methodOp(function(dir, unit) {
      var sel = this.doc.sel, doc = this.doc
      if (sel.somethingSelected())
        { doc.replaceSelection("", null, "+delete") }
      else
        { deleteNearSelection(this, function (range) {
          var other = findPosH(doc, range.head, dir, unit, false)
          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}
        }) }
    }),

    findPosV: function(from, amount, unit, goalColumn) {
      var this$1 = this;

      var dir = 1, x = goalColumn
      if (amount < 0) { dir = -1; amount = -amount }
      var cur = clipPos(this.doc, from)
      for (var i = 0; i < amount; ++i) {
        var coords = cursorCoords(this$1, cur, "div")
        if (x == null) { x = coords.left }
        else { coords.left = x }
        cur = findPosV(this$1, coords, dir, unit)
        if (cur.hitSide) { break }
      }
      return cur
    },

    moveV: methodOp(function(dir, unit) {
      var this$1 = this;

      var doc = this.doc, goals = []
      var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected()
      doc.extendSelectionsBy(function (range) {
        if (collapse)
          { return dir < 0 ? range.from() : range.to() }
        var headPos = cursorCoords(this$1, range.head, "div")
        if (range.goalColumn != null) { headPos.left = range.goalColumn }
        goals.push(headPos.left)
        var pos = findPosV(this$1, headPos, dir, unit)
        if (unit == "page" && range == doc.sel.primary())
          { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top) }
        return pos
      }, sel_move)
      if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
        { doc.sel.ranges[i].goalColumn = goals[i] } }
    }),

    // Find the word at the given position (as returned by coordsChar).
    findWordAt: function(pos) {
      var doc = this.doc, line = getLine(doc, pos.line).text
      var start = pos.ch, end = pos.ch
      if (line) {
        var helper = this.getHelper(pos, "wordChars")
        if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end }
        var startChar = line.charAt(start)
        var check = isWordChar(startChar, helper)
          ? function (ch) { return isWordChar(ch, helper); }
          : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
          : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); }
        while (start > 0 && check(line.charAt(start - 1))) { --start }
        while (end < line.length && check(line.charAt(end))) { ++end }
      }
      return new Range(Pos(pos.line, start), Pos(pos.line, end))
    },

    toggleOverwrite: function(value) {
      if (value != null && value == this.state.overwrite) { return }
      if (this.state.overwrite = !this.state.overwrite)
        { addClass(this.display.cursorDiv, "CodeMirror-overwrite") }
      else
        { rmClass(this.display.cursorDiv, "CodeMirror-overwrite") }

      signal(this, "overwriteToggle", this, this.state.overwrite)
    },
    hasFocus: function() { return this.display.input.getField() == activeElt() },
    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

    scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y) }),
    getScrollInfo: function() {
      var scroller = this.display.scroller
      return {left: scroller.scrollLeft, top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
    },

    scrollIntoView: methodOp(function(range, margin) {
      if (range == null) {
        range = {from: this.doc.sel.primary().head, to: null}
        if (margin == null) { margin = this.options.cursorScrollMargin }
      } else if (typeof range == "number") {
        range = {from: Pos(range, 0), to: null}
      } else if (range.from == null) {
        range = {from: range, to: null}
      }
      if (!range.to) { range.to = range.from }
      range.margin = margin || 0

      if (range.from.line != null) {
        scrollToRange(this, range)
      } else {
        scrollToCoordsRange(this, range.from, range.to, range.margin)
      }
    }),

    setSize: methodOp(function(width, height) {
      var this$1 = this;

      var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; }
      if (width != null) { this.display.wrapper.style.width = interpret(width) }
      if (height != null) { this.display.wrapper.style.height = interpret(height) }
      if (this.options.lineWrapping) { clearLineMeasurementCache(this) }
      var lineNo = this.display.viewFrom
      this.doc.iter(lineNo, this.display.viewTo, function (line) {
        if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
          { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, "widget"); break } } }
        ++lineNo
      })
      this.curOp.forceUpdate = true
      signal(this, "refresh", this)
    }),

    operation: function(f){return runInOp(this, f)},
    startOperation: function(){return startOperation(this)},
    endOperation: function(){return endOperation(this)},

    refresh: methodOp(function() {
      var oldHeight = this.display.cachedTextHeight
      regChange(this)
      this.curOp.forceUpdate = true
      clearCaches(this)
      scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop)
      updateGutterSpace(this)
      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)
        { estimateLineHeights(this) }
      signal(this, "refresh", this)
    }),

    swapDoc: methodOp(function(doc) {
      var old = this.doc
      old.cm = null
      attachDoc(this, doc)
      clearCaches(this)
      this.display.input.reset()
      scrollToCoords(this, doc.scrollLeft, doc.scrollTop)
      this.curOp.forceScroll = true
      signalLater(this, "swapDoc", this, old)
      return old
    }),

    getInputField: function(){return this.display.input.getField()},
    getWrapperElement: function(){return this.display.wrapper},
    getScrollerElement: function(){return this.display.scroller},
    getGutterElement: function(){return this.display.gutters}
  }
  eventMixin(CodeMirror)

  CodeMirror.registerHelper = function(type, name, value) {
    if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []} }
    helpers[type][name] = value
  }
  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
    CodeMirror.registerHelper(type, name, value)
    helpers[type]._global.push({pred: predicate, val: value})
  }
}

// Used for horizontal relative motion. Dir is -1 or 1 (left or
// right), unit can be "char", "column" (like char, but doesn't
// cross line boundaries), "word" (across next word), or "group" (to
// the start of next group of word or non-word-non-whitespace
// chars). The visually param controls whether, in right-to-left
// text, direction 1 means to move towards the next index in the
// string, or towards the character to the right of the current
// position. The resulting position will have a hitSide=true
// property if it reached the end of the document.
function findPosH(doc, pos, dir, unit, visually) {
  var oldPos = pos
  var origDir = dir
  var lineObj = getLine(doc, pos.line)
  function findNextLine() {
    var l = pos.line + dir
    if (l < doc.first || l >= doc.first + doc.size) { return false }
    pos = new Pos(l, pos.ch, pos.sticky)
    return lineObj = getLine(doc, l)
  }
  function moveOnce(boundToLine) {
    var next
    if (visually) {
      next = moveVisually(doc.cm, lineObj, pos, dir)
    } else {
      next = moveLogically(lineObj, pos, dir)
    }
    if (next == null) {
      if (!boundToLine && findNextLine())
        { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir) }
      else
        { return false }
    } else {
      pos = next
    }
    return true
  }

  if (unit == "char") {
    moveOnce()
  } else if (unit == "column") {
    moveOnce(true)
  } else if (unit == "word" || unit == "group") {
    var sawType = null, group = unit == "group"
    var helper = doc.cm && doc.cm.getHelper(pos, "wordChars")
    for (var first = true;; first = false) {
      if (dir < 0 && !moveOnce(!first)) { break }
      var cur = lineObj.text.charAt(pos.ch) || "\n"
      var type = isWordChar(cur, helper) ? "w"
        : group && cur == "\n" ? "n"
        : !group || /\s/.test(cur) ? null
        : "p"
      if (group && !first && !type) { type = "s" }
      if (sawType && sawType != type) {
        if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after"}
        break
      }

      if (type) { sawType = type }
      if (dir > 0 && !moveOnce(!first)) { break }
    }
  }
  var result = skipAtomic(doc, pos, oldPos, origDir, true)
  if (equalCursorPos(oldPos, result)) { result.hitSide = true }
  return result
}

// For relative vertical movement. Dir may be -1 or 1. Unit can be
// "page" or "line". The resulting position will have a hitSide=true
// property if it reached the end of the document.
function findPosV(cm, pos, dir, unit) {
  var doc = cm.doc, x = pos.left, y
  if (unit == "page") {
    var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight)
    var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3)
    y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount

  } else if (unit == "line") {
    y = dir > 0 ? pos.bottom + 3 : pos.top - 3
  }
  var target
  for (;;) {
    target = coordsChar(cm, x, y)
    if (!target.outside) { break }
    if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
    y += dir * 5
  }
  return target
}

// CONTENTEDITABLE INPUT STYLE

var ContentEditableInput = function(cm) {
  this.cm = cm
  this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null
  this.polling = new Delayed()
  this.composing = null
  this.gracePeriod = false
  this.readDOMTimeout = null
};

ContentEditableInput.prototype.init = function (display) {
    var this$1 = this;

  var input = this, cm = input.cm
  var div = input.div = display.lineDiv
  disableBrowserMagic(div, cm.options.spellcheck)

  on(div, "paste", function (e) {
    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
    // IE doesn't fire input events, so we schedule a read for the pasted content in this way
    if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20) }
  })

  on(div, "compositionstart", function (e) {
    this$1.composing = {data: e.data, done: false}
  })
  on(div, "compositionupdate", function (e) {
    if (!this$1.composing) { this$1.composing = {data: e.data, done: false} }
  })
  on(div, "compositionend", function (e) {
    if (this$1.composing) {
      if (e.data != this$1.composing.data) { this$1.readFromDOMSoon() }
      this$1.composing.done = true
    }
  })

  on(div, "touchstart", function () { return input.forceCompositionEnd(); })

  on(div, "input", function () {
    if (!this$1.composing) { this$1.readFromDOMSoon() }
  })

  function onCopyCut(e) {
    if (signalDOMEvent(cm, e)) { return }
    if (cm.somethingSelected()) {
      setLastCopied({lineWise: false, text: cm.getSelections()})
      if (e.type == "cut") { cm.replaceSelection("", null, "cut") }
    } else if (!cm.options.lineWiseCopyCut) {
      return
    } else {
      var ranges = copyableRanges(cm)
      setLastCopied({lineWise: true, text: ranges.text})
      if (e.type == "cut") {
        cm.operation(function () {
          cm.setSelections(ranges.ranges, 0, sel_dontScroll)
          cm.replaceSelection("", null, "cut")
        })
      }
    }
    if (e.clipboardData) {
      e.clipboardData.clearData()
      var content = lastCopied.text.join("\n")
      // iOS exposes the clipboard API, but seems to discard content inserted into it
      e.clipboardData.setData("Text", content)
      if (e.clipboardData.getData("Text") == content) {
        e.preventDefault()
        return
      }
    }
    // Old-fashioned briefly-focus-a-textarea hack
    var kludge = hiddenTextarea(), te = kludge.firstChild
    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild)
    te.value = lastCopied.text.join("\n")
    var hadFocus = document.activeElement
    selectInput(te)
    setTimeout(function () {
      cm.display.lineSpace.removeChild(kludge)
      hadFocus.focus()
      if (hadFocus == div) { input.showPrimarySelection() }
    }, 50)
  }
  on(div, "copy", onCopyCut)
  on(div, "cut", onCopyCut)
};

ContentEditableInput.prototype.prepareSelection = function () {
  var result = prepareSelection(this.cm, false)
  result.focus = this.cm.state.focused
  return result
};

ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
  if (!info || !this.cm.display.view.length) { return }
  if (info.focus || takeFocus) { this.showPrimarySelection() }
  this.showMultipleSelections(info)
};

ContentEditableInput.prototype.showPrimarySelection = function () {
  var sel = window.getSelection(), cm = this.cm, prim = cm.doc.sel.primary()
  var from = prim.from(), to = prim.to()

  if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
    sel.removeAllRanges()
    return
  }

  var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset)
  var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset)
  if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
      cmp(minPos(curAnchor, curFocus), from) == 0 &&
      cmp(maxPos(curAnchor, curFocus), to) == 0)
    { return }

  var view = cm.display.view
  var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
      {node: view[0].measure.map[2], offset: 0}
  var end = to.line < cm.display.viewTo && posToDOM(cm, to)
  if (!end) {
    var measure = view[view.length - 1].measure
    var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map
    end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]}
  }

  if (!start || !end) {
    sel.removeAllRanges()
    return
  }

  var old = sel.rangeCount && sel.getRangeAt(0), rng
  try { rng = range(start.node, start.offset, end.offset, end.node) }
  catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
  if (rng) {
    if (!gecko && cm.state.focused) {
      sel.collapse(start.node, start.offset)
      if (!rng.collapsed) {
        sel.removeAllRanges()
        sel.addRange(rng)
      }
    } else {
      sel.removeAllRanges()
      sel.addRange(rng)
    }
    if (old && sel.anchorNode == null) { sel.addRange(old) }
    else if (gecko) { this.startGracePeriod() }
  }
  this.rememberSelection()
};

ContentEditableInput.prototype.startGracePeriod = function () {
    var this$1 = this;

  clearTimeout(this.gracePeriod)
  this.gracePeriod = setTimeout(function () {
    this$1.gracePeriod = false
    if (this$1.selectionChanged())
      { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }) }
  }, 20)
};

ContentEditableInput.prototype.showMultipleSelections = function (info) {
  removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors)
  removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection)
};

ContentEditableInput.prototype.rememberSelection = function () {
  var sel = window.getSelection()
  this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset
  this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset
};

ContentEditableInput.prototype.selectionInEditor = function () {
  var sel = window.getSelection()
  if (!sel.rangeCount) { return false }
  var node = sel.getRangeAt(0).commonAncestorContainer
  return contains(this.div, node)
};

ContentEditableInput.prototype.focus = function () {
  if (this.cm.options.readOnly != "nocursor") {
    if (!this.selectionInEditor())
      { this.showSelection(this.prepareSelection(), true) }
    this.div.focus()
  }
};
ContentEditableInput.prototype.blur = function () { this.div.blur() };
ContentEditableInput.prototype.getField = function () { return this.div };

ContentEditableInput.prototype.supportsTouch = function () { return true };

ContentEditableInput.prototype.receivedFocus = function () {
  var input = this
  if (this.selectionInEditor())
    { this.pollSelection() }
  else
    { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }) }

  function poll() {
    if (input.cm.state.focused) {
      input.pollSelection()
      input.polling.set(input.cm.options.pollInterval, poll)
    }
  }
  this.polling.set(this.cm.options.pollInterval, poll)
};

ContentEditableInput.prototype.selectionChanged = function () {
  var sel = window.getSelection()
  return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
    sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
};

ContentEditableInput.prototype.pollSelection = function () {
  if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
  var sel = window.getSelection(), cm = this.cm
  // On Android Chrome (version 56, at least), backspacing into an
  // uneditable block element will put the cursor in that element,
  // and then, because it's not editable, hide the virtual keyboard.
  // Because Android doesn't allow us to actually detect backspace
  // presses in a sane way, this code checks for when that happens
  // and simulates a backspace press in this case.
  if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {
    this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs})
    this.blur()
    this.focus()
    return
  }
  if (this.composing) { return }
  this.rememberSelection()
  var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset)
  var head = domToPos(cm, sel.focusNode, sel.focusOffset)
  if (anchor && head) { runInOp(cm, function () {
    setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll)
    if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true }
  }) }
};

ContentEditableInput.prototype.pollContent = function () {
  if (this.readDOMTimeout != null) {
    clearTimeout(this.readDOMTimeout)
    this.readDOMTimeout = null
  }

  var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary()
  var from = sel.from(), to = sel.to()
  if (from.ch == 0 && from.line > cm.firstLine())
    { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length) }
  if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
    { to = Pos(to.line + 1, 0) }
  if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

  var fromIndex, fromLine, fromNode
  if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
    fromLine = lineNo(display.view[0].line)
    fromNode = display.view[0].node
  } else {
    fromLine = lineNo(display.view[fromIndex].line)
    fromNode = display.view[fromIndex - 1].node.nextSibling
  }
  var toIndex = findViewIndex(cm, to.line)
  var toLine, toNode
  if (toIndex == display.view.length - 1) {
    toLine = display.viewTo - 1
    toNode = display.lineDiv.lastChild
  } else {
    toLine = lineNo(display.view[toIndex + 1].line) - 1
    toNode = display.view[toIndex + 1].node.previousSibling
  }

  if (!fromNode) { return false }
  var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine))
  var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length))
  while (newText.length > 1 && oldText.length > 1) {
    if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine-- }
    else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++ }
    else { break }
  }

  var cutFront = 0, cutEnd = 0
  var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length)
  while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
    { ++cutFront }
  var newBot = lst(newText), oldBot = lst(oldText)
  var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                           oldBot.length - (oldText.length == 1 ? cutFront : 0))
  while (cutEnd < maxCutEnd &&
         newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
    { ++cutEnd }
  // Try to move start of change to start of selection if ambiguous
  if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
    while (cutFront && cutFront > from.ch &&
           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
      cutFront--
      cutEnd++
    }
  }

  newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "")
  newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "")

  var chFrom = Pos(fromLine, cutFront)
  var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0)
  if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
    replaceRange(cm.doc, newText, chFrom, chTo, "+input")
    return true
  }
};

ContentEditableInput.prototype.ensurePolled = function () {
  this.forceCompositionEnd()
};
ContentEditableInput.prototype.reset = function () {
  this.forceCompositionEnd()
};
ContentEditableInput.prototype.forceCompositionEnd = function () {
  if (!this.composing) { return }
  clearTimeout(this.readDOMTimeout)
  this.composing = null
  this.updateFromDOM()
  this.div.blur()
  this.div.focus()
};
ContentEditableInput.prototype.readFromDOMSoon = function () {
    var this$1 = this;

  if (this.readDOMTimeout != null) { return }
  this.readDOMTimeout = setTimeout(function () {
    this$1.readDOMTimeout = null
    if (this$1.composing) {
      if (this$1.composing.done) { this$1.composing = null }
      else { return }
    }
    this$1.updateFromDOM()
  }, 80)
};

ContentEditableInput.prototype.updateFromDOM = function () {
    var this$1 = this;

  if (this.cm.isReadOnly() || !this.pollContent())
    { runInOp(this.cm, function () { return regChange(this$1.cm); }) }
};

ContentEditableInput.prototype.setUneditable = function (node) {
  node.contentEditable = "false"
};

ContentEditableInput.prototype.onKeyPress = function (e) {
  if (e.charCode == 0) { return }
  e.preventDefault()
  if (!this.cm.isReadOnly())
    { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0) }
};

ContentEditableInput.prototype.readOnlyChanged = function (val) {
  this.div.contentEditable = String(val != "nocursor")
};

ContentEditableInput.prototype.onContextMenu = function () {};
ContentEditableInput.prototype.resetPosition = function () {};

ContentEditableInput.prototype.needsContentAttribute = true

function posToDOM(cm, pos) {
  var view = findViewForLine(cm, pos.line)
  if (!view || view.hidden) { return null }
  var line = getLine(cm.doc, pos.line)
  var info = mapFromLineView(view, line, pos.line)

  var order = getOrder(line, cm.doc.direction), side = "left"
  if (order) {
    var partPos = getBidiPartAt(order, pos.ch)
    side = partPos % 2 ? "right" : "left"
  }
  var result = nodeAndOffsetInLineMap(info.map, pos.ch, side)
  result.offset = result.collapse == "right" ? result.end : result.start
  return result
}

function isInGutter(node) {
  for (var scan = node; scan; scan = scan.parentNode)
    { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
  return false
}

function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

function domTextBetween(cm, from, to, fromLine, toLine) {
  var text = "", closing = false, lineSep = cm.doc.lineSeparator()
  function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
  function close() {
    if (closing) {
      text += lineSep
      closing = false
    }
  }
  function addText(str) {
    if (str) {
      close()
      text += str
    }
  }
  function walk(node) {
    if (node.nodeType == 1) {
      var cmText = node.getAttribute("cm-text")
      if (cmText != null) {
        addText(cmText || node.textContent.replace(/\u200b/g, ""))
        return
      }
      var markerID = node.getAttribute("cm-marker"), range
      if (markerID) {
        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID))
        if (found.length && (range = found[0].find(0)))
          { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)) }
        return
      }
      if (node.getAttribute("contenteditable") == "false") { return }
      var isBlock = /^(pre|div|p)$/i.test(node.nodeName)
      if (isBlock) { close() }
      for (var i = 0; i < node.childNodes.length; i++)
        { walk(node.childNodes[i]) }
      if (isBlock) { closing = true }
    } else if (node.nodeType == 3) {
      addText(node.nodeValue)
    }
  }
  for (;;) {
    walk(from)
    if (from == to) { break }
    from = from.nextSibling
  }
  return text
}

function domToPos(cm, node, offset) {
  var lineNode
  if (node == cm.display.lineDiv) {
    lineNode = cm.display.lineDiv.childNodes[offset]
    if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
    node = null; offset = 0
  } else {
    for (lineNode = node;; lineNode = lineNode.parentNode) {
      if (!lineNode || lineNode == cm.display.lineDiv) { return null }
      if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
    }
  }
  for (var i = 0; i < cm.display.view.length; i++) {
    var lineView = cm.display.view[i]
    if (lineView.node == lineNode)
      { return locateNodeInLineView(lineView, node, offset) }
  }
}

function locateNodeInLineView(lineView, node, offset) {
  var wrapper = lineView.text.firstChild, bad = false
  if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
  if (node == wrapper) {
    bad = true
    node = wrapper.childNodes[offset]
    offset = 0
    if (!node) {
      var line = lineView.rest ? lst(lineView.rest) : lineView.line
      return badPos(Pos(lineNo(line), line.text.length), bad)
    }
  }

  var textNode = node.nodeType == 3 ? node : null, topNode = node
  if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
    textNode = node.firstChild
    if (offset) { offset = textNode.nodeValue.length }
  }
  while (topNode.parentNode != wrapper) { topNode = topNode.parentNode }
  var measure = lineView.measure, maps = measure.maps

  function find(textNode, topNode, offset) {
    for (var i = -1; i < (maps ? maps.length : 0); i++) {
      var map = i < 0 ? measure.map : maps[i]
      for (var j = 0; j < map.length; j += 3) {
        var curNode = map[j + 2]
        if (curNode == textNode || curNode == topNode) {
          var line = lineNo(i < 0 ? lineView.line : lineView.rest[i])
          var ch = map[j] + offset
          if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)] }
          return Pos(line, ch)
        }
      }
    }
  }
  var found = find(textNode, topNode, offset)
  if (found) { return badPos(found, bad) }

  // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
  for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
    found = find(after, after.firstChild, 0)
    if (found)
      { return badPos(Pos(found.line, found.ch - dist), bad) }
    else
      { dist += after.textContent.length }
  }
  for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
    found = find(before, before.firstChild, -1)
    if (found)
      { return badPos(Pos(found.line, found.ch + dist$1), bad) }
    else
      { dist$1 += before.textContent.length }
  }
}

// TEXTAREA INPUT STYLE

var TextareaInput = function(cm) {
  this.cm = cm
  // See input.poll and input.reset
  this.prevInput = ""

  // Flag that indicates whether we expect input to appear real soon
  // now (after some event like 'keypress' or 'input') and are
  // polling intensively.
  this.pollingFast = false
  // Self-resetting timeout for the poller
  this.polling = new Delayed()
  // Used to work around IE issue with selection being forgotten when focus moves away from textarea
  this.hasSelection = false
  this.composing = null
};

TextareaInput.prototype.init = function (display) {
    var this$1 = this;

  var input = this, cm = this.cm

  // Wraps and hides input textarea
  var div = this.wrapper = hiddenTextarea()
  // The semihidden textarea that is focused when the editor is
  // focused, and receives input.
  var te = this.textarea = div.firstChild
  display.wrapper.insertBefore(div, display.wrapper.firstChild)

  // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
  if (ios) { te.style.width = "0px" }

  on(te, "input", function () {
    if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null }
    input.poll()
  })

  on(te, "paste", function (e) {
    if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

    cm.state.pasteIncoming = true
    input.fastPoll()
  })

  function prepareCopyCut(e) {
    if (signalDOMEvent(cm, e)) { return }
    if (cm.somethingSelected()) {
      setLastCopied({lineWise: false, text: cm.getSelections()})
    } else if (!cm.options.lineWiseCopyCut) {
      return
    } else {
      var ranges = copyableRanges(cm)
      setLastCopied({lineWise: true, text: ranges.text})
      if (e.type == "cut") {
        cm.setSelections(ranges.ranges, null, sel_dontScroll)
      } else {
        input.prevInput = ""
        te.value = ranges.text.join("\n")
        selectInput(te)
      }
    }
    if (e.type == "cut") { cm.state.cutIncoming = true }
  }
  on(te, "cut", prepareCopyCut)
  on(te, "copy", prepareCopyCut)

  on(display.scroller, "paste", function (e) {
    if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
    cm.state.pasteIncoming = true
    input.focus()
  })

  // Prevent normal selection in the editor (we handle our own)
  on(display.lineSpace, "selectstart", function (e) {
    if (!eventInWidget(display, e)) { e_preventDefault(e) }
  })

  on(te, "compositionstart", function () {
    var start = cm.getCursor("from")
    if (input.composing) { input.composing.range.clear() }
    input.composing = {
      start: start,
      range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
    }
  })
  on(te, "compositionend", function () {
    if (input.composing) {
      input.poll()
      input.composing.range.clear()
      input.composing = null
    }
  })
};

TextareaInput.prototype.prepareSelection = function () {
  // Redraw the selection and/or cursor
  var cm = this.cm, display = cm.display, doc = cm.doc
  var result = prepareSelection(cm)

  // Move the hidden textarea near the cursor to prevent scrolling artifacts
  if (cm.options.moveInputWithCursor) {
    var headPos = cursorCoords(cm, doc.sel.primary().head, "div")
    var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect()
    result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                        headPos.top + lineOff.top - wrapOff.top))
    result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                         headPos.left + lineOff.left - wrapOff.left))
  }

  return result
};

TextareaInput.prototype.showSelection = function (drawn) {
  var cm = this.cm, display = cm.display
  removeChildrenAndAdd(display.cursorDiv, drawn.cursors)
  removeChildrenAndAdd(display.selectionDiv, drawn.selection)
  if (drawn.teTop != null) {
    this.wrapper.style.top = drawn.teTop + "px"
    this.wrapper.style.left = drawn.teLeft + "px"
  }
};

// Reset the input to correspond to the selection (or to be empty,
// when not typing and nothing is selected)
TextareaInput.prototype.reset = function (typing) {
  if (this.contextMenuPending || this.composing) { return }
  var cm = this.cm
  if (cm.somethingSelected()) {
    this.prevInput = ""
    var content = cm.getSelection()
    this.textarea.value = content
    if (cm.state.focused) { selectInput(this.textarea) }
    if (ie && ie_version >= 9) { this.hasSelection = content }
  } else if (!typing) {
    this.prevInput = this.textarea.value = ""
    if (ie && ie_version >= 9) { this.hasSelection = null }
  }
};

TextareaInput.prototype.getField = function () { return this.textarea };

TextareaInput.prototype.supportsTouch = function () { return false };

TextareaInput.prototype.focus = function () {
  if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
    try { this.textarea.focus() }
    catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
  }
};

TextareaInput.prototype.blur = function () { this.textarea.blur() };

TextareaInput.prototype.resetPosition = function () {
  this.wrapper.style.top = this.wrapper.style.left = 0
};

TextareaInput.prototype.receivedFocus = function () { this.slowPoll() };

// Poll for input changes, using the normal rate of polling. This
// runs as long as the editor is focused.
TextareaInput.prototype.slowPoll = function () {
    var this$1 = this;

  if (this.pollingFast) { return }
  this.polling.set(this.cm.options.pollInterval, function () {
    this$1.poll()
    if (this$1.cm.state.focused) { this$1.slowPoll() }
  })
};

// When an event has just come in that is likely to add or change
// something in the input textarea, we poll faster, to ensure that
// the change appears on the screen quickly.
TextareaInput.prototype.fastPoll = function () {
  var missed = false, input = this
  input.pollingFast = true
  function p() {
    var changed = input.poll()
    if (!changed && !missed) {missed = true; input.polling.set(60, p)}
    else {input.pollingFast = false; input.slowPoll()}
  }
  input.polling.set(20, p)
};

// Read input from the textarea, and update the document to match.
// When something is selected, it is present in the textarea, and
// selected (unless it is huge, in which case a placeholder is
// used). When nothing is selected, the cursor sits after previously
// seen text (can be empty), which is stored in prevInput (we must
// not reset the textarea when typing, because that breaks IME).
TextareaInput.prototype.poll = function () {
    var this$1 = this;

  var cm = this.cm, input = this.textarea, prevInput = this.prevInput
  // Since this is called a *lot*, try to bail out as cheaply as
  // possible when it is clear that nothing happened. hasSelection
  // will be the case when there is a lot of text in the textarea,
  // in which case reading its value would be expensive.
  if (this.contextMenuPending || !cm.state.focused ||
      (hasSelection(input) && !prevInput && !this.composing) ||
      cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
    { return false }

  var text = input.value
  // If nothing changed, bail.
  if (text == prevInput && !cm.somethingSelected()) { return false }
  // Work around nonsensical selection resetting in IE9/10, and
  // inexplicable appearance of private area unicode characters on
  // some key combos in Mac (#2689).
  if (ie && ie_version >= 9 && this.hasSelection === text ||
      mac && /[\uf700-\uf7ff]/.test(text)) {
    cm.display.input.reset()
    return false
  }

  if (cm.doc.sel == cm.display.selForContextMenu) {
    var first = text.charCodeAt(0)
    if (first == 0x200b && !prevInput) { prevInput = "\u200b" }
    if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
  }
  // Find the part of the input that is actually new
  var same = 0, l = Math.min(prevInput.length, text.length)
  while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same }

  runInOp(cm, function () {
    applyTextInput(cm, text.slice(same), prevInput.length - same,
                   null, this$1.composing ? "*compose" : null)

    // Don't leave long text in the textarea, since it makes further polling slow
    if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = "" }
    else { this$1.prevInput = text }

    if (this$1.composing) {
      this$1.composing.range.clear()
      this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                         {className: "CodeMirror-composing"})
    }
  })
  return true
};

TextareaInput.prototype.ensurePolled = function () {
  if (this.pollingFast && this.poll()) { this.pollingFast = false }
};

TextareaInput.prototype.onKeyPress = function () {
  if (ie && ie_version >= 9) { this.hasSelection = null }
  this.fastPoll()
};

TextareaInput.prototype.onContextMenu = function (e) {
  var input = this, cm = input.cm, display = cm.display, te = input.textarea
  var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop
  if (!pos || presto) { return } // Opera is difficult.

  // Reset the current text selection only if the click is done outside of the selection
  // and 'resetSelectionOnContextMenu' option is true.
  var reset = cm.options.resetSelectionOnContextMenu
  if (reset && cm.doc.sel.contains(pos) == -1)
    { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll) }

  var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText
  input.wrapper.style.cssText = "position: absolute"
  var wrapperBox = input.wrapper.getBoundingClientRect()
  te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);"
  var oldScrollY
  if (webkit) { oldScrollY = window.scrollY } // Work around Chrome issue (#2712)
  display.input.focus()
  if (webkit) { window.scrollTo(null, oldScrollY) }
  display.input.reset()
  // Adds "Select all" to context menu in FF
  if (!cm.somethingSelected()) { te.value = input.prevInput = " " }
  input.contextMenuPending = true
  display.selForContextMenu = cm.doc.sel
  clearTimeout(display.detectingSelectAll)

  // Select-all will be greyed out if there's nothing to select, so
  // this adds a zero-width space so that we can later check whether
  // it got selected.
  function prepareSelectAllHack() {
    if (te.selectionStart != null) {
      var selected = cm.somethingSelected()
      var extval = "\u200b" + (selected ? te.value : "")
      te.value = "\u21da" // Used to catch context-menu undo
      te.value = extval
      input.prevInput = selected ? "" : "\u200b"
      te.selectionStart = 1; te.selectionEnd = extval.length
      // Re-set this, in case some other handler touched the
      // selection in the meantime.
      display.selForContextMenu = cm.doc.sel
    }
  }
  function rehide() {
    input.contextMenuPending = false
    input.wrapper.style.cssText = oldWrapperCSS
    te.style.cssText = oldCSS
    if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos) }

    // Try to detect the user choosing select-all
    if (te.selectionStart != null) {
      if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack() }
      var i = 0, poll = function () {
        if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
            te.selectionEnd > 0 && input.prevInput == "\u200b") {
          operation(cm, selectAll)(cm)
        } else if (i++ < 10) {
          display.detectingSelectAll = setTimeout(poll, 500)
        } else {
          display.selForContextMenu = null
          display.input.reset()
        }
      }
      display.detectingSelectAll = setTimeout(poll, 200)
    }
  }

  if (ie && ie_version >= 9) { prepareSelectAllHack() }
  if (captureRightClick) {
    e_stop(e)
    var mouseup = function () {
      off(window, "mouseup", mouseup)
      setTimeout(rehide, 20)
    }
    on(window, "mouseup", mouseup)
  } else {
    setTimeout(rehide, 50)
  }
};

TextareaInput.prototype.readOnlyChanged = function (val) {
  if (!val) { this.reset() }
  this.textarea.disabled = val == "nocursor"
};

TextareaInput.prototype.setUneditable = function () {};

TextareaInput.prototype.needsContentAttribute = false

function fromTextArea(textarea, options) {
  options = options ? copyObj(options) : {}
  options.value = textarea.value
  if (!options.tabindex && textarea.tabIndex)
    { options.tabindex = textarea.tabIndex }
  if (!options.placeholder && textarea.placeholder)
    { options.placeholder = textarea.placeholder }
  // Set autofocus to true if this textarea is focused, or if it has
  // autofocus and no other element is focused.
  if (options.autofocus == null) {
    var hasFocus = activeElt()
    options.autofocus = hasFocus == textarea ||
      textarea.getAttribute("autofocus") != null && hasFocus == document.body
  }

  function save() {textarea.value = cm.getValue()}

  var realSubmit
  if (textarea.form) {
    on(textarea.form, "submit", save)
    // Deplorable hack to make the submit method do the right thing.
    if (!options.leaveSubmitMethodAlone) {
      var form = textarea.form
      realSubmit = form.submit
      try {
        var wrappedSubmit = form.submit = function () {
          save()
          form.submit = realSubmit
          form.submit()
          form.submit = wrappedSubmit
        }
      } catch(e) {}
    }
  }

  options.finishInit = function (cm) {
    cm.save = save
    cm.getTextArea = function () { return textarea; }
    cm.toTextArea = function () {
      cm.toTextArea = isNaN // Prevent this from being ran twice
      save()
      textarea.parentNode.removeChild(cm.getWrapperElement())
      textarea.style.display = ""
      if (textarea.form) {
        off(textarea.form, "submit", save)
        if (typeof textarea.form.submit == "function")
          { textarea.form.submit = realSubmit }
      }
    }
  }

  textarea.style.display = "none"
  var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
    options)
  return cm
}

function addLegacyProps(CodeMirror) {
  CodeMirror.off = off
  CodeMirror.on = on
  CodeMirror.wheelEventPixels = wheelEventPixels
  CodeMirror.Doc = Doc
  CodeMirror.splitLines = splitLinesAuto
  CodeMirror.countColumn = countColumn
  CodeMirror.findColumn = findColumn
  CodeMirror.isWordChar = isWordCharBasic
  CodeMirror.Pass = Pass
  CodeMirror.signal = signal
  CodeMirror.Line = Line
  CodeMirror.changeEnd = changeEnd
  CodeMirror.scrollbarModel = scrollbarModel
  CodeMirror.Pos = Pos
  CodeMirror.cmpPos = cmp
  CodeMirror.modes = modes
  CodeMirror.mimeModes = mimeModes
  CodeMirror.resolveMode = resolveMode
  CodeMirror.getMode = getMode
  CodeMirror.modeExtensions = modeExtensions
  CodeMirror.extendMode = extendMode
  CodeMirror.copyState = copyState
  CodeMirror.startState = startState
  CodeMirror.innerMode = innerMode
  CodeMirror.commands = commands
  CodeMirror.keyMap = keyMap
  CodeMirror.keyName = keyName
  CodeMirror.isModifierKey = isModifierKey
  CodeMirror.lookupKey = lookupKey
  CodeMirror.normalizeKeyMap = normalizeKeyMap
  CodeMirror.StringStream = StringStream
  CodeMirror.SharedTextMarker = SharedTextMarker
  CodeMirror.TextMarker = TextMarker
  CodeMirror.LineWidget = LineWidget
  CodeMirror.e_preventDefault = e_preventDefault
  CodeMirror.e_stopPropagation = e_stopPropagation
  CodeMirror.e_stop = e_stop
  CodeMirror.addClass = addClass
  CodeMirror.contains = contains
  CodeMirror.rmClass = rmClass
  CodeMirror.keyNames = keyNames
}

// EDITOR CONSTRUCTOR

defineOptions(CodeMirror)

addEditorMethods(CodeMirror)

// Set up methods on CodeMirror's prototype to redirect to the editor's document.
var dontDelegate = "iter insert remove copy getEditor constructor".split(" ")
for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
  { CodeMirror.prototype[prop] = (function(method) {
    return function() {return method.apply(this.doc, arguments)}
  })(Doc.prototype[prop]) } }

eventMixin(Doc)

// INPUT HANDLING

CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput}

// MODE DEFINITION AND QUERYING

// Extra arguments are stored as the mode's dependencies, which is
// used by (legacy) mechanisms like loadmode.js to automatically
// load a mode. (Preferred mechanism is the require/define calls.)
CodeMirror.defineMode = function(name/*, mode, */) {
  if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name }
  defineMode.apply(this, arguments)
}

CodeMirror.defineMIME = defineMIME

// Minimal default mode.
CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); })
CodeMirror.defineMIME("text/plain", "null")

// EXTENSIONS

CodeMirror.defineExtension = function (name, func) {
  CodeMirror.prototype[name] = func
}
CodeMirror.defineDocExtension = function (name, func) {
  Doc.prototype[name] = func
}

CodeMirror.fromTextArea = fromTextArea

addLegacyProps(CodeMirror)

CodeMirror.version = "5.30.0"

return CodeMirror;

})));
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

var htmlConfig = {
  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                    'track': true, 'wbr': true, 'menuitem': true},
  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                     'th': true, 'tr': true},
  contextGrabbers: {
    'dd': {'dd': true, 'dt': true},
    'dt': {'dd': true, 'dt': true},
    'li': {'li': true},
    'option': {'option': true, 'optgroup': true},
    'optgroup': {'optgroup': true},
    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
    'rp': {'rp': true, 'rt': true},
    'rt': {'rp': true, 'rt': true},
    'tbody': {'tbody': true, 'tfoot': true},
    'td': {'td': true, 'th': true},
    'tfoot': {'tbody': true},
    'th': {'td': true, 'th': true},
    'thead': {'tbody': true, 'tfoot': true},
    'tr': {'tr': true}
  },
  doNotIndent: {"pre": true},
  allowUnquoted: true,
  allowMissing: true,
  caseFold: true
}

var xmlConfig = {
  autoSelfClosers: {},
  implicitlyClosed: {},
  contextGrabbers: {},
  doNotIndent: {},
  allowUnquoted: false,
  allowMissing: false,
  caseFold: false
}

CodeMirror.defineMode("xml", function(editorConf, config_) {
  var indentUnit = editorConf.indentUnit
  var config = {}
  var defaults = config_.htmlMode ? htmlConfig : xmlConfig
  for (var prop in defaults) config[prop] = defaults[prop]
  for (var prop in config_) config[prop] = config_[prop]

  // Return variables for tokenizers
  var type, setStyle;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "<") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
          else return null;
        } else if (stream.match("--")) {
          return chain(inBlock("comment", "-->"));
        } else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?>");
        return "meta";
      } else {
        type = stream.eat("/") ? "closeTag" : "openTag";
        state.tokenize = inTag;
        return "tag bracket";
      }
    } else if (ch == "&") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
      }
      return ok ? "atom" : "error";
    } else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }
  inText.isInText = true;

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
      state.tokenize = inText;
      type = ch == ">" ? "endTag" : "selfcloseTag";
      return "tag bracket";
    } else if (ch == "=") {
      type = "equals";
      return null;
    } else if (ch == "<") {
      state.tokenize = inText;
      state.state = baseState;
      state.tagName = state.tagStart = null;
      var next = state.tokenize(stream, state);
      return next ? next + " tag error" : "tag error";
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      state.stringStartCol = stream.column();
      return state.tokenize(stream, state);
    } else {
      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
      return "word";
    }
  }

  function inAttribute(quote) {
    var closure = function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
    closure.isInAttribute = true;
    return closure;
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    };
  }
  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "<") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == ">") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  function Context(state, tagName, startOfLine) {
    this.prev = state.context;
    this.tagName = tagName;
    this.indent = state.indented;
    this.startOfLine = startOfLine;
    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
      this.noIndent = true;
  }
  function popContext(state) {
    if (state.context) state.context = state.context.prev;
  }
  function maybePopContext(state, nextTagName) {
    var parentTagName;
    while (true) {
      if (!state.context) {
        return;
      }
      parentTagName = state.context.tagName;
      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext(state);
    }
  }

  function baseState(type, stream, state) {
    if (type == "openTag") {
      state.tagStart = stream.column();
      return tagNameState;
    } else if (type == "closeTag") {
      return closeTagNameState;
    } else {
      return baseState;
    }
  }
  function tagNameState(type, stream, state) {
    if (type == "word") {
      state.tagName = stream.current();
      setStyle = "tag";
      return attrState;
    } else {
      setStyle = "error";
      return tagNameState;
    }
  }
  function closeTagNameState(type, stream, state) {
    if (type == "word") {
      var tagName = stream.current();
      if (state.context && state.context.tagName != tagName &&
          config.implicitlyClosed.hasOwnProperty(state.context.tagName))
        popContext(state);
      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
        setStyle = "tag";
        return closeState;
      } else {
        setStyle = "tag error";
        return closeStateErr;
      }
    } else {
      setStyle = "error";
      return closeStateErr;
    }
  }

  function closeState(type, _stream, state) {
    if (type != "endTag") {
      setStyle = "error";
      return closeState;
    }
    popContext(state);
    return baseState;
  }
  function closeStateErr(type, stream, state) {
    setStyle = "error";
    return closeState(type, stream, state);
  }

  function attrState(type, _stream, state) {
    if (type == "word") {
      setStyle = "attribute";
      return attrEqState;
    } else if (type == "endTag" || type == "selfcloseTag") {
      var tagName = state.tagName, tagStart = state.tagStart;
      state.tagName = state.tagStart = null;
      if (type == "selfcloseTag" ||
          config.autoSelfClosers.hasOwnProperty(tagName)) {
        maybePopContext(state, tagName);
      } else {
        maybePopContext(state, tagName);
        state.context = new Context(state, tagName, tagStart == state.indented);
      }
      return baseState;
    }
    setStyle = "error";
    return attrState;
  }
  function attrEqState(type, stream, state) {
    if (type == "equals") return attrValueState;
    if (!config.allowMissing) setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrValueState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
    setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrContinuedState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    return attrState(type, stream, state);
  }

  return {
    startState: function(baseIndent) {
      var state = {tokenize: inText,
                   state: baseState,
                   indented: baseIndent || 0,
                   tagName: null, tagStart: null,
                   context: null}
      if (baseIndent != null) state.baseIndent = baseIndent
      return state
    },

    token: function(stream, state) {
      if (!state.tagName && stream.sol())
        state.indented = stream.indentation();

      if (stream.eatSpace()) return null;
      type = null;
      var style = state.tokenize(stream, state);
      if ((style || type) && style != "comment") {
        setStyle = null;
        state.state = state.state(type || style, stream, state);
        if (setStyle)
          style = setStyle == "error" ? style + " error" : setStyle;
      }
      return style;
    },

    indent: function(state, textAfter, fullLine) {
      var context = state.context;
      // Indent multi-line strings (e.g. css).
      if (state.tokenize.isInAttribute) {
        if (state.tagStart == state.indented)
          return state.stringStartCol + 1;
        else
          return state.indented + indentUnit;
      }
      if (context && context.noIndent) return CodeMirror.Pass;
      if (state.tokenize != inTag && state.tokenize != inText)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      // Indent the starts of attribute names.
      if (state.tagName) {
        if (config.multilineTagIndentPastTag !== false)
          return state.tagStart + state.tagName.length + 2;
        else
          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
      }
      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
      if (tagAfter && tagAfter[1]) { // Closing tag spotted
        while (context) {
          if (context.tagName == tagAfter[2]) {
            context = context.prev;
            break;
          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
            context = context.prev;
          } else {
            break;
          }
        }
      } else if (tagAfter) { // Opening tag spotted
        while (context) {
          var grabbers = config.contextGrabbers[context.tagName];
          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
            context = context.prev;
          else
            break;
        }
      }
      while (context && context.prev && !context.startOfLine)
        context = context.prev;
      if (context) return context.indent + indentUnit;
      else return state.baseIndent || 0;
    },

    electricInput: /<\/[\s\w:]+>$/,
    blockCommentStart: "<!--",
    blockCommentEnd: "-->",

    configuration: config.htmlMode ? "html" : "xml",
    helperType: config.htmlMode ? "html" : "xml",

    skipAttribute: function(state) {
      if (state.state == attrValueState)
        state.state = attrState
    }
  };
});

CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;
  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    var jsKeywords = {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": C, "break": C, "continue": C, "new": kw("new"), "delete": C, "void": C, "throw": C, "debugger": C,
      "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
      "await": C
    };

    // Extend the 'normal' keywords with the TypeScript language extensions
    if (isTS) {
      var type = {type: "variable", style: "type"};
      var tsKeywords = {
        // object-like things
        "interface": kw("class"),
        "implements": C,
        "namespace": C,
        "module": kw("module"),
        "enum": kw("module"),

        // scope modifiers
        "public": kw("modifier"),
        "private": kw("modifier"),
        "protected": kw("modifier"),
        "abstract": kw("modifier"),
        "readonly": kw("modifier"),

        // types
        "string": type, "number": type, "boolean": type, "any": type
      };

      for (var attr in tsKeywords) {
        jsKeywords[attr] = tsKeywords[attr];
      }
    }

    return jsKeywords;
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.eat(/x/i)) {
      stream.eatWhile(/[\da-f]/i);
      return ret("number", "number");
    } else if (ch == "0" && stream.eat(/o/i)) {
      stream.eatWhile(/[0-7]/i);
      return ret("number", "number");
    } else if (ch == "0" && stream.eat(/b/i)) {
      stream.eatWhile(/[01]/i);
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (expressionAllowed(stream, state, 1)) {
        readRegexp(stream);
        stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/);
        return ret("regexp", "string-2");
      } else {
        stream.eatWhile(isOperatorChar);
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#") {
      stream.skipToEnd();
      return ret("error", "error");
    } else if (isOperatorChar.test(ch)) {
      if (ch != ">" || !state.lexical || state.lexical.type != ">")
        stream.eatWhile(isOperatorChar);
      return ret("operator", "operator", stream.current());
    } else if (wordRE.test(ch)) {
      stream.eatWhile(wordRE);
      var word = stream.current()
      if (state.lastType != ".") {
        if (keywords.propertyIsEnumerable(word)) {
          var kw = keywords[word]
          return ret(kw.type, kw.style, word)
        }
        if (word == "async" && stream.match(/^\s*[\(\w]/, false))
          return ret("async", "keyword", word)
      }
      return ret("variable", "variable", word)
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    if (isTS) { // Try to skip TypeScript return type declarations after the arguments
      var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow))
      if (m) arrow = m.index
    }

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (wordRE.test(ch)) {
        sawSomething = true;
      } else if (/["'\/]/.test(ch)) {
        return;
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function register(varname) {
    function inList(list) {
      for (var v = list; v; v = v.next)
        if (v.name == varname) return true;
      return false;
    }
    var state = cx.state;
    cx.marked = "def";
    if (state.context) {
      if (inList(state.localVars)) return;
      state.localVars = {name: varname, next: state.localVars};
    } else {
      if (inList(state.globalVars)) return;
      if (parserConfig.globalVars)
        state.globalVars = {name: varname, next: state.globalVars};
    }
  }

  // Combinators

  var defaultVars = {name: "this", next: {name: "arguments"}};
  function pushcontext() {
    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};
    cx.state.localVars = defaultVars;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
        indent = outer.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";") return pass();
      else return cont(exp);
    };
    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "{") return cont(pushlex("}"), block, poplex);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
    if (type == "variable") {
      if (isTS && value == "type") {
        cx.marked = "keyword"
        return cont(typeexpr, expect("operator"), typeexpr, expect(";"));
      } if (isTS && value == "declare") {
        cx.marked = "keyword"
        return cont(statement)
      } else {
        return cont(pushlex("stat"), maybelabel);
      }
    }
    if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"),
                                      block, poplex, poplex);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),
                                     statement, poplex, popcontext);
    if (type == "class") return cont(pushlex("form"), className, poplex);
    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
    if (type == "module") return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
    if (type == "async") return cont(statement)
    if (value == "@") return cont(expression, statement)
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function expression(type) {
    return expressionInner(type, false);
  }
  function expressionNoComma(type) {
    return expressionInner(type, true);
  }
  function parenExpr(type) {
    if (type != "(") return pass()
    return cont(pushlex(")"), expression, expect(")"), poplex)
  }
  function expressionInner(type, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "class") return cont(pushlex("form"), classExpression, poplex);
    if (type == "keyword c" || type == "async") return cont(noComma ? maybeexpressionNoComma : maybeexpression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") return pass(quasi, maybeop);
    if (type == "new") return cont(maybeTarget(noComma));
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }
  function maybeexpressionNoComma(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expressionNoComma);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(expression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
    if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }
    if (type == "regexp") {
      cx.state.lastType = cx.marked = "operator"
      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)
      return cont(expr)
    }
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expressionNoComma);
  }
  function maybeTarget(noComma) {
    return function(type) {
      if (type == ".") return cont(noComma ? targetNoComma : target);
      else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)
      else return pass(noComma ? expressionNoComma : expression);
    };
  }
  function target(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
  }
  function targetNoComma(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "async") {
      cx.marked = "property";
      return cont(objprop);
    } else if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params
      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
        cx.state.fatArrowAt = cx.stream.pos + m[0].length
      return cont(afterprop);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (cx.style + " property");
      return cont(afterprop);
    } else if (type == "jsonld-keyword") {
      return cont(afterprop);
    } else if (type == "modifier") {
      return cont(objprop)
    } else if (type == "[") {
      return cont(expression, expect("]"), afterprop);
    } else if (type == "spread") {
      return cont(expression, afterprop);
    } else if (type == ":") {
      return pass(afterprop)
    }
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end, sep) {
    function proceed(type, value) {
      if (sep ? sep.indexOf(type) > -1 : type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(function(type, value) {
          if (type == end || value == end) return pass()
          return pass(what)
        }, proceed);
      }
      if (type == end || value == end) return cont();
      return cont(expect(end));
    }
    return function(type, value) {
      if (type == end || value == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type, value) {
    if (isTS) {
      if (type == ":") return cont(typeexpr);
      if (value == "?") return cont(maybetype);
    }
  }
  function typeexpr(type, value) {
    if (type == "variable") {
      if (value == "keyof") {
        cx.marked = "keyword"
        return cont(typeexpr)
      } else {
        cx.marked = "type"
        return cont(afterType)
      }
    }
    if (type == "string" || type == "number" || type == "atom") return cont(afterType);
    if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)
    if (type == "{") return cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType)
    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType)
  }
  function maybeReturnType(type) {
    if (type == "=>") return cont(typeexpr)
  }
  function typeprop(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property"
      return cont(typeprop)
    } else if (value == "?") {
      return cont(typeprop)
    } else if (type == ":") {
      return cont(typeexpr)
    } else if (type == "[") {
      return cont(expression, maybetype, expect("]"), typeprop)
    }
  }
  function typearg(type) {
    if (type == "variable") return cont(typearg)
    else if (type == ":") return cont(typeexpr)
  }
  function afterType(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
    if (value == "|" || type == ".") return cont(typeexpr)
    if (type == "[") return cont(expect("]"), afterType)
    if (value == "extends") return cont(typeexpr)
  }
  function maybeTypeArgs(_, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
  }
  function vardef() {
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (type == "modifier") return cont(pattern)
    if (type == "variable") { register(value); return cont(); }
    if (type == "spread") return cont(pattern);
    if (type == "[") return contCommasep(pattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    if (type == "spread") return cont(pattern);
    if (type == "}") return pass();
    return cont(expect(":"), pattern, maybeAssign);
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type) {
    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, expect(";"), forspec2);
    if (type == ";") return cont(forspec2);
    if (type == "variable") return cont(formaybeinof);
    return pass(expression, expect(";"), forspec2);
  }
  function formaybeinof(_type, value) {
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return cont(maybeoperatorComma, forspec2);
  }
  function forspec2(type, value) {
    if (type == ";") return cont(forspec3);
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }
    return pass(expression, expect(";"), forspec3);
  }
  function forspec3(type) {
    if (type != ")") cont(expression);
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, maybetype, statement, popcontext);
    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, functiondef)
  }
  function funarg(type, value) {
    if (value == "@") cont(expression, funarg)
    if (type == "spread" || type == "modifier") return cont(funarg);
    return pass(pattern, maybetype, maybeAssign);
  }
  function classExpression(type, value) {
    // Class expressions may have an optional name.
    if (type == "variable") return className(type, value);
    return classNameAfter(type, value);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, classNameAfter)
    if (value == "extends" || value == "implements" || (isTS && type == ","))
      return cont(isTS ? typeexpr : expression, classNameAfter);
    if (type == "{") return cont(pushlex("}"), classBody, poplex);
  }
  function classBody(type, value) {
    if (type == "modifier" || type == "async" ||
        (type == "variable" &&
         (value == "static" || value == "get" || value == "set") &&
         cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))) {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      return cont(isTS ? classfield : functiondef, classBody);
    }
    if (type == "[")
      return cont(expression, expect("]"), isTS ? classfield : functiondef, classBody)
    if (value == "*") {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == ";") return cont(classBody);
    if (type == "}") return cont();
    if (value == "@") return cont(expression, classBody)
  }
  function classfield(type, value) {
    if (value == "?") return cont(classfield)
    if (type == ":") return cont(typeexpr, maybeAssign)
    if (value == "=") return cont(expressionNoComma)
    return pass(functiondef)
  }
  function afterExport(type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
    return pass(statement);
  }
  function exportField(type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
    if (type == "variable") return pass(expressionNoComma, exportField);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    return pass(importSpec, maybeMoreImports, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    if (value == "*") cx.marked = "keyword";
    return cont(maybeAs);
  }
  function maybeMoreImports(type) {
    if (type == ",") return cont(importSpec, maybeMoreImports)
  }
  function maybeAs(_type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(commasep(expressionNoComma, "]"));
  }

  function isContinuedStatement(state, textAfter) {
    return state.lastType == "operator" || state.lastType == "," ||
      isOperatorChar.test(textAfter.charAt(0)) ||
      /[,.]/.test(textAfter.charAt(0));
  }

  function expressionAllowed(stream, state, backUp) {
    return state.tokenize == tokenBase &&
      /^(?:operator|sof|keyword [bc]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
      (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && {vars: parserConfig.localVars},
        indented: basecolumn || 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      while ((lexical.type == "stat" || lexical.type == "form") &&
             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
                                   !/^[,\.=+\-*:?[\(]/.test(textAfter))))
        lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    lineComment: jsonMode ? null : "//",
    fold: "brace",
    closeBrackets: "()[]{}''\"\"``",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode,

    expressionAllowed: expressionAllowed,

    skipExpression: function(state) {
      var top = state.cc[state.cc.length - 1]
      if (top == expression || top == expressionNoComma) state.cc.pop()
    }
  };
});

CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/x-javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});
CodeMirror.defineMIME("application/ld+json", {name: "javascript", jsonld: true});
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
"use strict";

CodeMirror.defineMode("css", function(config, parserConfig) {
  var inline = parserConfig.inline
  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

  var indentUnit = config.indentUnit,
      tokenHooks = parserConfig.tokenHooks,
      documentTypes = parserConfig.documentTypes || {},
      mediaTypes = parserConfig.mediaTypes || {},
      mediaFeatures = parserConfig.mediaFeatures || {},
      mediaValueKeywords = parserConfig.mediaValueKeywords || {},
      propertyKeywords = parserConfig.propertyKeywords || {},
      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
      fontProperties = parserConfig.fontProperties || {},
      counterDescriptors = parserConfig.counterDescriptors || {},
      colorKeywords = parserConfig.colorKeywords || {},
      valueKeywords = parserConfig.valueKeywords || {},
      allowNested = parserConfig.allowNested,
      lineComment = parserConfig.lineComment,
      supportsAtComponent = parserConfig.supportsAtComponent === true;

  var type, override;
  function ret(style, tp) { type = tp; return style; }

  // Tokenizers

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (tokenHooks[ch]) {
      var result = tokenHooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == "@") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("def", stream.current());
    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
      return ret(null, "compare");
    } else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "#") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("atom", "hash");
    } else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    } else if (ch === "-") {
      if (/[\d.]/.test(stream.peek())) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (stream.match(/^-[\w\\\-]+/)) {
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ret("variable-2", "variable-definition");
        return ret("variable-2", "variable");
      } else if (stream.match(/^\w+-/)) {
        return ret("meta", "meta");
      }
    } else if (/[,+>*\/]/.test(ch)) {
      return ret(null, "select-op");
    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
      return ret("qualifier", "qualifier");
    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
      return ret(null, ch);
    } else if ((ch == "u" && stream.match(/rl(-prefix)?\(/)) ||
               (ch == "d" && stream.match("omain(")) ||
               (ch == "r" && stream.match("egexp("))) {
      stream.backUp(1);
      state.tokenize = tokenParenthesized;
      return ret("property", "word");
    } else if (/[\w\\\-]/.test(ch)) {
      stream.eatWhile(/[\w\\\-]/);
      return ret("property", "word");
    } else {
      return ret(null, null);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped) {
          if (quote == ")") stream.backUp(1);
          break;
        }
        escaped = !escaped && ch == "\\";
      }
      if (ch == quote || !escaped && quote != ")") state.tokenize = null;
      return ret("string", "string");
    };
  }

  function tokenParenthesized(stream, state) {
    stream.next(); // Must be '('
    if (!stream.match(/\s*[\"\')]/, false))
      state.tokenize = tokenString(")");
    else
      state.tokenize = null;
    return ret(null, "(");
  }

  // Context management

  function Context(type, indent, prev) {
    this.type = type;
    this.indent = indent;
    this.prev = prev;
  }

  function pushContext(state, stream, type, indent) {
    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
    return type;
  }

  function popContext(state) {
    if (state.context.prev)
      state.context = state.context.prev;
    return state.context.type;
  }

  function pass(type, stream, state) {
    return states[state.context.type](type, stream, state);
  }
  function popAndPass(type, stream, state, n) {
    for (var i = n || 1; i > 0; i--)
      state.context = state.context.prev;
    return pass(type, stream, state);
  }

  // Parser

  function wordAsValue(stream) {
    var word = stream.current().toLowerCase();
    if (valueKeywords.hasOwnProperty(word))
      override = "atom";
    else if (colorKeywords.hasOwnProperty(word))
      override = "keyword";
    else
      override = "variable";
  }

  var states = {};

  states.top = function(type, stream, state) {
    if (type == "{") {
      return pushContext(state, stream, "block");
    } else if (type == "}" && state.context.prev) {
      return popContext(state);
    } else if (supportsAtComponent && /@component/.test(type)) {
      return pushContext(state, stream, "atComponentBlock");
    } else if (/^@(-moz-)?document$/.test(type)) {
      return pushContext(state, stream, "documentTypes");
    } else if (/^@(media|supports|(-moz-)?document|import)$/.test(type)) {
      return pushContext(state, stream, "atBlock");
    } else if (/^@(font-face|counter-style)/.test(type)) {
      state.stateArg = type;
      return "restricted_atBlock_before";
    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/.test(type)) {
      return "keyframes";
    } else if (type && type.charAt(0) == "@") {
      return pushContext(state, stream, "at");
    } else if (type == "hash") {
      override = "builtin";
    } else if (type == "word") {
      override = "tag";
    } else if (type == "variable-definition") {
      return "maybeprop";
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    } else if (type == ":") {
      return "pseudo";
    } else if (allowNested && type == "(") {
      return pushContext(state, stream, "parens");
    }
    return state.context.type;
  };

  states.block = function(type, stream, state) {
    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (propertyKeywords.hasOwnProperty(word)) {
        override = "property";
        return "maybeprop";
      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
        override = "string-2";
        return "maybeprop";
      } else if (allowNested) {
        override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
        return "block";
      } else {
        override += " error";
        return "maybeprop";
      }
    } else if (type == "meta") {
      return "block";
    } else if (!allowNested && (type == "hash" || type == "qualifier")) {
      override = "error";
      return "block";
    } else {
      return states.top(type, stream, state);
    }
  };

  states.maybeprop = function(type, stream, state) {
    if (type == ":") return pushContext(state, stream, "prop");
    return pass(type, stream, state);
  };

  states.prop = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
    if (type == "}" || type == "{") return popAndPass(type, stream, state);
    if (type == "(") return pushContext(state, stream, "parens");

    if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
      override += " error";
    } else if (type == "word") {
      wordAsValue(stream);
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    }
    return "prop";
  };

  states.propBlock = function(type, _stream, state) {
    if (type == "}") return popContext(state);
    if (type == "word") { override = "property"; return "maybeprop"; }
    return state.context.type;
  };

  states.parens = function(type, stream, state) {
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == ")") return popContext(state);
    if (type == "(") return pushContext(state, stream, "parens");
    if (type == "interpolation") return pushContext(state, stream, "interpolation");
    if (type == "word") wordAsValue(stream);
    return "parens";
  };

  states.pseudo = function(type, stream, state) {
    if (type == "meta") return "pseudo";

    if (type == "word") {
      override = "variable-3";
      return state.context.type;
    }
    return pass(type, stream, state);
  };

  states.documentTypes = function(type, stream, state) {
    if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
      override = "tag";
      return state.context.type;
    } else {
      return states.atBlock(type, stream, state);
    }
  };

  states.atBlock = function(type, stream, state) {
    if (type == "(") return pushContext(state, stream, "atBlock_parens");
    if (type == "}" || type == ";") return popAndPass(type, stream, state);
    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

    if (type == "interpolation") return pushContext(state, stream, "interpolation");

    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (word == "only" || word == "not" || word == "and" || word == "or")
        override = "keyword";
      else if (mediaTypes.hasOwnProperty(word))
        override = "attribute";
      else if (mediaFeatures.hasOwnProperty(word))
        override = "property";
      else if (mediaValueKeywords.hasOwnProperty(word))
        override = "keyword";
      else if (propertyKeywords.hasOwnProperty(word))
        override = "property";
      else if (nonStandardPropertyKeywords.hasOwnProperty(word))
        override = "string-2";
      else if (valueKeywords.hasOwnProperty(word))
        override = "atom";
      else if (colorKeywords.hasOwnProperty(word))
        override = "keyword";
      else
        override = "error";
    }
    return state.context.type;
  };

  states.atComponentBlock = function(type, stream, state) {
    if (type == "}")
      return popAndPass(type, stream, state);
    if (type == "{")
      return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
    if (type == "word")
      override = "error";
    return state.context.type;
  };

  states.atBlock_parens = function(type, stream, state) {
    if (type == ")") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
    return states.atBlock(type, stream, state);
  };

  states.restricted_atBlock_before = function(type, stream, state) {
    if (type == "{")
      return pushContext(state, stream, "restricted_atBlock");
    if (type == "word" && state.stateArg == "@counter-style") {
      override = "variable";
      return "restricted_atBlock_before";
    }
    return pass(type, stream, state);
  };

  states.restricted_atBlock = function(type, stream, state) {
    if (type == "}") {
      state.stateArg = null;
      return popContext(state);
    }
    if (type == "word") {
      if ((state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||
          (state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))
        override = "error";
      else
        override = "property";
      return "maybeprop";
    }
    return "restricted_atBlock";
  };

  states.keyframes = function(type, stream, state) {
    if (type == "word") { override = "variable"; return "keyframes"; }
    if (type == "{") return pushContext(state, stream, "top");
    return pass(type, stream, state);
  };

  states.at = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == "word") override = "tag";
    else if (type == "hash") override = "builtin";
    return "at";
  };

  states.interpolation = function(type, stream, state) {
    if (type == "}") return popContext(state);
    if (type == "{" || type == ";") return popAndPass(type, stream, state);
    if (type == "word") override = "variable";
    else if (type != "variable" && type != "(" && type != ")") override = "error";
    return "interpolation";
  };

  return {
    startState: function(base) {
      return {tokenize: null,
              state: inline ? "block" : "top",
              stateArg: null,
              context: new Context(inline ? "block" : "top", base || 0, null)};
    },

    token: function(stream, state) {
      if (!state.tokenize && stream.eatSpace()) return null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style && typeof style == "object") {
        type = style[1];
        style = style[0];
      }
      override = style;
      if (type != "comment")
        state.state = states[state.state](type, stream, state);
      return override;
    },

    indent: function(state, textAfter) {
      var cx = state.context, ch = textAfter && textAfter.charAt(0);
      var indent = cx.indent;
      if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
      if (cx.prev) {
        if (ch == "}" && (cx.type == "block" || cx.type == "top" ||
                          cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
          // Resume indentation from parent context.
          cx = cx.prev;
          indent = cx.indent;
        } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
            ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
          // Dedent relative to current context.
          indent = Math.max(0, cx.indent - indentUnit);
        }
      }
      return indent;
    },

    electricChars: "}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    lineComment: lineComment,
    fold: "brace"
  };
});

  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i].toLowerCase()] = true;
    }
    return keys;
  }

  var documentTypes_ = [
    "domain", "regexp", "url", "url-prefix"
  ], documentTypes = keySet(documentTypes_);

  var mediaTypes_ = [
    "all", "aural", "braille", "handheld", "print", "projection", "screen",
    "tty", "tv", "embossed"
  ], mediaTypes = keySet(mediaTypes_);

  var mediaFeatures_ = [
    "width", "min-width", "max-width", "height", "min-height", "max-height",
    "device-width", "min-device-width", "max-device-width", "device-height",
    "min-device-height", "max-device-height", "aspect-ratio",
    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
    "max-color", "color-index", "min-color-index", "max-color-index",
    "monochrome", "min-monochrome", "max-monochrome", "resolution",
    "min-resolution", "max-resolution", "scan", "grid", "orientation",
    "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio",
    "pointer", "any-pointer", "hover", "any-hover"
  ], mediaFeatures = keySet(mediaFeatures_);

  var mediaValueKeywords_ = [
    "landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover",
    "interlace", "progressive"
  ], mediaValueKeywords = keySet(mediaValueKeywords_);

  var propertyKeywords_ = [
    "align-content", "align-items", "align-self", "alignment-adjust",
    "alignment-baseline", "anchor-point", "animation", "animation-delay",
    "animation-direction", "animation-duration", "animation-fill-mode",
    "animation-iteration-count", "animation-name", "animation-play-state",
    "animation-timing-function", "appearance", "azimuth", "backface-visibility",
    "background", "background-attachment", "background-blend-mode", "background-clip",
    "background-color", "background-image", "background-origin", "background-position",
    "background-repeat", "background-size", "baseline-shift", "binding",
    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",
    "bookmark-target", "border", "border-bottom", "border-bottom-color",
    "border-bottom-left-radius", "border-bottom-right-radius",
    "border-bottom-style", "border-bottom-width", "border-collapse",
    "border-color", "border-image", "border-image-outset",
    "border-image-repeat", "border-image-slice", "border-image-source",
    "border-image-width", "border-left", "border-left-color",
    "border-left-style", "border-left-width", "border-radius", "border-right",
    "border-right-color", "border-right-style", "border-right-width",
    "border-spacing", "border-style", "border-top", "border-top-color",
    "border-top-left-radius", "border-top-right-radius", "border-top-style",
    "border-top-width", "border-width", "bottom", "box-decoration-break",
    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",
    "caption-side", "caret-color", "clear", "clip", "color", "color-profile", "column-count",
    "column-fill", "column-gap", "column-rule", "column-rule-color",
    "column-rule-style", "column-rule-width", "column-span", "column-width",
    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",
    "cue-after", "cue-before", "cursor", "direction", "display",
    "dominant-baseline", "drop-initial-after-adjust",
    "drop-initial-after-align", "drop-initial-before-adjust",
    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",
    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",
    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",
    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",
    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",
    "font-stretch", "font-style", "font-synthesis", "font-variant",
    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",
    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",
    "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow",
    "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap",
    "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap",
    "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns",
    "grid-template-rows", "hanging-punctuation", "height", "hyphens",
    "icon", "image-orientation", "image-rendering", "image-resolution",
    "inline-box-align", "justify-content", "justify-items", "justify-self", "left", "letter-spacing",
    "line-break", "line-height", "line-stacking", "line-stacking-ruby",
    "line-stacking-shift", "line-stacking-strategy", "list-style",
    "list-style-image", "list-style-position", "list-style-type", "margin",
    "margin-bottom", "margin-left", "margin-right", "margin-top",
    "marks", "marquee-direction", "marquee-loop",
    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",
    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",
    "nav-left", "nav-right", "nav-up", "object-fit", "object-position",
    "opacity", "order", "orphans", "outline",
    "outline-color", "outline-offset", "outline-style", "outline-width",
    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",
    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",
    "page", "page-break-after", "page-break-before", "page-break-inside",
    "page-policy", "pause", "pause-after", "pause-before", "perspective",
    "perspective-origin", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "position",
    "presentation-level", "punctuation-trim", "quotes", "region-break-after",
    "region-break-before", "region-break-inside", "region-fragment",
    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",
    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",
    "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin",
    "shape-outside", "size", "speak", "speak-as", "speak-header",
    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",
    "tab-size", "table-layout", "target", "target-name", "target-new",
    "target-position", "text-align", "text-align-last", "text-decoration",
    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
    "text-decoration-style", "text-emphasis", "text-emphasis-color",
    "text-emphasis-position", "text-emphasis-style", "text-height",
    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",
    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",
    "text-wrap", "top", "transform", "transform-origin", "transform-style",
    "transition", "transition-delay", "transition-duration",
    "transition-property", "transition-timing-function", "unicode-bidi",
    "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration",
    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",
    "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break",
    "word-spacing", "word-wrap", "z-index",
    // SVG-specific
    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
    "color-interpolation", "color-interpolation-filters",
    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",
    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
    "glyph-orientation-vertical", "text-anchor", "writing-mode"
  ], propertyKeywords = keySet(propertyKeywords_);

  var nonStandardPropertyKeywords_ = [
    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
    "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside",
    "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button",
    "searchfield-results-decoration", "zoom"
  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);

  var fontProperties_ = [
    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",
    "font-stretch", "font-weight", "font-style"
  ], fontProperties = keySet(fontProperties_);

  var counterDescriptors_ = [
    "additive-symbols", "fallback", "negative", "pad", "prefix", "range",
    "speak-as", "suffix", "symbols", "system"
  ], counterDescriptors = keySet(counterDescriptors_);

  var colorKeywords_ = [
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
    "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
    "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
    "whitesmoke", "yellow", "yellowgreen"
  ], colorKeywords = keySet(colorKeywords_);

  var valueKeywords_ = [
    "above", "absolute", "activeborder", "additive", "activecaption", "afar",
    "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate",
    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
    "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page",
    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",
    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian",
    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
    "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch",
    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
    "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse",
    "compact", "condensed", "contain", "content", "contents",
    "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop",
    "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "dense", "destination-atop",
    "destination-in", "destination-out", "destination-over", "devanagari", "difference",
    "disc", "discard", "disclosure-closed", "disclosure-open", "document",
    "dot-dash", "dot-dot-dash",
    "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig",
    "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed",
    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes",
    "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove",
    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew",
    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
    "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert",
    "italic", "japanese-formal", "japanese-informal", "justify", "kannada",
    "katakana", "katakana-iroha", "keep-all", "khmer",
    "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal",
    "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten",
    "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem",
    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
    "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d",
    "media-controls-background", "media-current-time-display",
    "media-fullscreen-button", "media-mute-button", "media-play-button",
    "media-return-to-realtime-button", "media-rewind-button",
    "media-seek-back-button", "media-seek-forward-button", "media-slider",
    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
    "menu", "menulist", "menulist-button", "menulist-text",
    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize",
    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
    "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote",
    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
    "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter",
    "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d",
    "progress", "push-button", "radial-gradient", "radio", "read-only",
    "read-write", "read-write-plaintext-only", "rectangle", "region",
    "relative", "repeat", "repeating-linear-gradient",
    "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",
    "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY",
    "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running",
    "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen",
    "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield",
    "searchfield-cancel-button", "searchfield-decoration",
    "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end",
    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
    "simp-chinese-formal", "simp-chinese-informal", "single",
    "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
    "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali",
    "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square",
    "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub",
    "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table",
    "table-caption", "table-cell", "table-column", "table-column-group",
    "table-footer-group", "table-header-group", "table-row", "table-row-group",
    "tamil",
    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
    "trad-chinese-formal", "trad-chinese-informal", "transform",
    "translate", "translate3d", "translateX", "translateY", "translateZ",
    "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up",
    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
    "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",
    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
    "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor",
    "xx-large", "xx-small"
  ], valueKeywords = keySet(valueKeywords_);

  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)
    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)
    .concat(valueKeywords_);
  CodeMirror.registerHelper("hintWords", "css", allWords);

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ["comment", "comment"];
  }

  CodeMirror.defineMIME("text/css", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    tokenHooks: {
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css"
  });

  CodeMirror.defineMIME("text/x-scss", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      ":": function(stream) {
        if (stream.match(/\s*\{/, false))
          return [null, null]
        return false;
      },
      "$": function(stream) {
        stream.match(/^[\w-]+/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "#": function(stream) {
        if (!stream.eat("{")) return false;
        return [null, "interpolation"];
      }
    },
    name: "css",
    helperType: "scss"
  });

  CodeMirror.defineMIME("text/x-less", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "@": function(stream) {
        if (stream.eat("{")) return [null, "interpolation"];
        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/, false)) return false;
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "&": function() {
        return ["atom", "atom"];
      }
    },
    name: "css",
    helperType: "less"
  });

  CodeMirror.defineMIME("text/x-gss", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    supportsAtComponent: true,
    tokenHooks: {
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css",
    helperType: "gss"
  });

});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("../xml/xml"), require("../javascript/javascript"), require("../css/css"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var defaultTags = {
    script: [
      ["lang", /(javascript|babel)/i, "javascript"],
      ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
      ["type", /./, "text/plain"],
      [null, null, "javascript"]
    ],
    style:  [
      ["lang", /^css$/i, "css"],
      ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
      ["type", /./, "text/plain"],
      [null, null, "css"]
    ]
  };

  function maybeBackup(stream, pat, style) {
    var cur = stream.current(), close = cur.search(pat);
    if (close > -1) {
      stream.backUp(cur.length - close);
    } else if (cur.match(/<\/?$/)) {
      stream.backUp(cur.length);
      if (!stream.match(pat, false)) stream.match(cur);
    }
    return style;
  }

  var attrRegexpCache = {};
  function getAttrRegexp(attr) {
    var regexp = attrRegexpCache[attr];
    if (regexp) return regexp;
    return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
  }

  function getAttrValue(text, attr) {
    var match = text.match(getAttrRegexp(attr))
    return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : ""
  }

  function getTagRegexp(tagName, anchored) {
    return new RegExp((anchored ? "^" : "") + "<\/\s*" + tagName + "\s*>", "i");
  }

  function addTags(from, to) {
    for (var tag in from) {
      var dest = to[tag] || (to[tag] = []);
      var source = from[tag];
      for (var i = source.length - 1; i >= 0; i--)
        dest.unshift(source[i])
    }
  }

  function findMatchingMode(tagInfo, tagText) {
    for (var i = 0; i < tagInfo.length; i++) {
      var spec = tagInfo[i];
      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
    }
  }

  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
    var htmlMode = CodeMirror.getMode(config, {
      name: "xml",
      htmlMode: true,
      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
    });

    var tags = {};
    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
    addTags(defaultTags, tags);
    if (configTags) addTags(configTags, tags);
    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)
      tags.script.unshift(["type", configScript[i].matches, configScript[i].mode])

    function html(stream, state) {
      var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName
      if (tag && !/[<>\s\/]/.test(stream.current()) &&
          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&
          tags.hasOwnProperty(tagName)) {
        state.inTag = tagName + " "
      } else if (state.inTag && tag && />$/.test(stream.current())) {
        var inTag = /^([\S]+) (.*)/.exec(state.inTag)
        state.inTag = null
        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2])
        var mode = CodeMirror.getMode(config, modeSpec)
        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
        state.token = function (stream, state) {
          if (stream.match(endTagA, false)) {
            state.token = html;
            state.localState = state.localMode = null;
            return null;
          }
          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
        };
        state.localMode = mode;
        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, ""));
      } else if (state.inTag) {
        state.inTag += stream.current()
        if (stream.eol()) state.inTag += " "
      }
      return style;
    };

    return {
      startState: function () {
        var state = CodeMirror.startState(htmlMode);
        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};
      },

      copyState: function (state) {
        var local;
        if (state.localState) {
          local = CodeMirror.copyState(state.localMode, state.localState);
        }
        return {token: state.token, inTag: state.inTag,
                localMode: state.localMode, localState: local,
                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
      },

      token: function (stream, state) {
        return state.token(stream, state);
      },

      indent: function (state, textAfter, line) {
        if (!state.localMode || /^\s*<\//.test(textAfter))
          return htmlMode.indent(state.htmlState, textAfter);
        else if (state.localMode.indent)
          return state.localMode.indent(state.localState, textAfter, line);
        else
          return CodeMirror.Pass;
      },

      innerMode: function (state) {
        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
      }
    };
  }, "xml", "javascript", "css");

  CodeMirror.defineMIME("text/html", "htmlmixed");
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var HINT_ELEMENT_CLASS        = "CodeMirror-hint";
  var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";

  // This is the old interface, kept around for now to stay
  // backwards-compatible.
  CodeMirror.showHint = function(cm, getHints, options) {
    if (!getHints) return cm.showHint(options);
    if (options && options.async) getHints.async = true;
    var newOpts = {hint: getHints};
    if (options) for (var prop in options) newOpts[prop] = options[prop];
    return cm.showHint(newOpts);
  };

  CodeMirror.defineExtension("showHint", function(options) {
    options = parseOptions(this, this.getCursor("start"), options);
    var selections = this.listSelections()
    if (selections.length > 1) return;
    // By default, don't allow completion when something is selected.
    // A hint function can have a `supportsSelection` property to
    // indicate that it can handle selections.
    if (this.somethingSelected()) {
      if (!options.hint.supportsSelection) return;
      // Don't try with cross-line selections
      for (var i = 0; i < selections.length; i++)
        if (selections[i].head.line != selections[i].anchor.line) return;
    }

    if (this.state.completionActive) this.state.completionActive.close();
    var completion = this.state.completionActive = new Completion(this, options);
    if (!completion.options.hint) return;

    CodeMirror.signal(this, "startCompletion", this);
    completion.update(true);
  });

  function Completion(cm, options) {
    this.cm = cm;
    this.options = options;
    this.widget = null;
    this.debounce = 0;
    this.tick = 0;
    this.startPos = this.cm.getCursor("start");
    this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;

    var self = this;
    cm.on("cursorActivity", this.activityFunc = function() { self.cursorActivity(); });
  }

  var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
    return setTimeout(fn, 1000/60);
  };
  var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;

  Completion.prototype = {
    close: function() {
      if (!this.active()) return;
      this.cm.state.completionActive = null;
      this.tick = null;
      this.cm.off("cursorActivity", this.activityFunc);

      if (this.widget && this.data) CodeMirror.signal(this.data, "close");
      if (this.widget) this.widget.close();
      CodeMirror.signal(this.cm, "endCompletion", this.cm);
    },

    active: function() {
      return this.cm.state.completionActive == this;
    },

    pick: function(data, i) {
      var completion = data.list[i];
      if (completion.hint) completion.hint(this.cm, data, completion);
      else this.cm.replaceRange(getText(completion), completion.from || data.from,
                                completion.to || data.to, "complete");
      CodeMirror.signal(data, "pick", completion);
      this.close();
    },

    cursorActivity: function() {
      if (this.debounce) {
        cancelAnimationFrame(this.debounce);
        this.debounce = 0;
      }

      var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
      if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch ||
          pos.ch < this.startPos.ch || this.cm.somethingSelected() ||
          (pos.ch && this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
        this.close();
      } else {
        var self = this;
        this.debounce = requestAnimationFrame(function() {self.update();});
        if (this.widget) this.widget.disable();
      }
    },

    update: function(first) {
      if (this.tick == null) return
      var self = this, myTick = ++this.tick
      fetchHints(this.options.hint, this.cm, this.options, function(data) {
        if (self.tick == myTick) self.finishUpdate(data, first)
      })
    },

    finishUpdate: function(data, first) {
      if (this.data) CodeMirror.signal(this.data, "update");

      var picked = (this.widget && this.widget.picked) || (first && this.options.completeSingle);
      if (this.widget) this.widget.close();

      if (data && this.data && isNewCompletion(this.data, data)) return;
      this.data = data;

      if (data && data.list.length) {
        if (picked && data.list.length == 1) {
          this.pick(data, 0);
        } else {
          this.widget = new Widget(this, data);
          CodeMirror.signal(data, "shown");
        }
      }
    }
  };

  function isNewCompletion(old, nw) {
    var moved = CodeMirror.cmpPos(nw.from, old.from)
    return moved > 0 && old.to.ch - old.from.ch != nw.to.ch - nw.from.ch
  }

  function parseOptions(cm, pos, options) {
    var editor = cm.options.hintOptions;
    var out = {};
    for (var prop in defaultOptions) out[prop] = defaultOptions[prop];
    if (editor) for (var prop in editor)
      if (editor[prop] !== undefined) out[prop] = editor[prop];
    if (options) for (var prop in options)
      if (options[prop] !== undefined) out[prop] = options[prop];
    if (out.hint.resolve) out.hint = out.hint.resolve(cm, pos)
    return out;
  }

  function getText(completion) {
    if (typeof completion == "string") return completion;
    else return completion.text;
  }

  function buildKeyMap(completion, handle) {
    var baseMap = {
      Up: function() {handle.moveFocus(-1);},
      Down: function() {handle.moveFocus(1);},
      PageUp: function() {handle.moveFocus(-handle.menuSize() + 1, true);},
      PageDown: function() {handle.moveFocus(handle.menuSize() - 1, true);},
      Home: function() {handle.setFocus(0);},
      End: function() {handle.setFocus(handle.length - 1);},
      Enter: handle.pick,
      Tab: handle.pick,
      Esc: handle.close
    };
    var custom = completion.options.customKeys;
    var ourMap = custom ? {} : baseMap;
    function addBinding(key, val) {
      var bound;
      if (typeof val != "string")
        bound = function(cm) { return val(cm, handle); };
      // This mechanism is deprecated
      else if (baseMap.hasOwnProperty(val))
        bound = baseMap[val];
      else
        bound = val;
      ourMap[key] = bound;
    }
    if (custom)
      for (var key in custom) if (custom.hasOwnProperty(key))
        addBinding(key, custom[key]);
    var extra = completion.options.extraKeys;
    if (extra)
      for (var key in extra) if (extra.hasOwnProperty(key))
        addBinding(key, extra[key]);
    return ourMap;
  }

  function getHintElement(hintsElement, el) {
    while (el && el != hintsElement) {
      if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement) return el;
      el = el.parentNode;
    }
  }

  function Widget(completion, data) {
    this.completion = completion;
    this.data = data;
    this.picked = false;
    var widget = this, cm = completion.cm;

    var hints = this.hints = document.createElement("ul");
    hints.className = "CodeMirror-hints";
    this.selectedHint = data.selectedHint || 0;

    var completions = data.list;
    for (var i = 0; i < completions.length; ++i) {
      var elt = hints.appendChild(document.createElement("li")), cur = completions[i];
      var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
      if (cur.className != null) className = cur.className + " " + className;
      elt.className = className;
      if (cur.render) cur.render(elt, data, cur);
      else elt.appendChild(document.createTextNode(cur.displayText || getText(cur)));
      elt.hintId = i;
    }

    var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
    var left = pos.left, top = pos.bottom, below = true;
    hints.style.left = left + "px";
    hints.style.top = top + "px";
    // If we're at the edge of the screen, then we want the menu to appear on the left of the cursor.
    var winW = window.innerWidth || Math.max(document.body.offsetWidth, document.documentElement.offsetWidth);
    var winH = window.innerHeight || Math.max(document.body.offsetHeight, document.documentElement.offsetHeight);
    (completion.options.container || document.body).appendChild(hints);
    var box = hints.getBoundingClientRect(), overlapY = box.bottom - winH;
    var scrolls = hints.scrollHeight > hints.clientHeight + 1
    var startScroll = cm.getScrollInfo();

    if (overlapY > 0) {
      var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
      if (curTop - height > 0) { // Fits above cursor
        hints.style.top = (top = pos.top - height) + "px";
        below = false;
      } else if (height > winH) {
        hints.style.height = (winH - 5) + "px";
        hints.style.top = (top = pos.bottom - box.top) + "px";
        var cursor = cm.getCursor();
        if (data.from.ch != cursor.ch) {
          pos = cm.cursorCoords(cursor);
          hints.style.left = (left = pos.left) + "px";
          box = hints.getBoundingClientRect();
        }
      }
    }
    var overlapX = box.right - winW;
    if (overlapX > 0) {
      if (box.right - box.left > winW) {
        hints.style.width = (winW - 5) + "px";
        overlapX -= (box.right - box.left) - winW;
      }
      hints.style.left = (left = pos.left - overlapX) + "px";
    }
    if (scrolls) for (var node = hints.firstChild; node; node = node.nextSibling)
      node.style.paddingRight = cm.display.nativeBarWidth + "px"

    cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
      moveFocus: function(n, avoidWrap) { widget.changeActive(widget.selectedHint + n, avoidWrap); },
      setFocus: function(n) { widget.changeActive(n); },
      menuSize: function() { return widget.screenAmount(); },
      length: completions.length,
      close: function() { completion.close(); },
      pick: function() { widget.pick(); },
      data: data
    }));

    if (completion.options.closeOnUnfocus) {
      var closingOnBlur;
      cm.on("blur", this.onBlur = function() { closingOnBlur = setTimeout(function() { completion.close(); }, 100); });
      cm.on("focus", this.onFocus = function() { clearTimeout(closingOnBlur); });
    }

    cm.on("scroll", this.onScroll = function() {
      var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
      var newTop = top + startScroll.top - curScroll.top;
      var point = newTop - (window.pageYOffset || (document.documentElement || document.body).scrollTop);
      if (!below) point += hints.offsetHeight;
      if (point <= editor.top || point >= editor.bottom) return completion.close();
      hints.style.top = newTop + "px";
      hints.style.left = (left + startScroll.left - curScroll.left) + "px";
    });

    CodeMirror.on(hints, "dblclick", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {widget.changeActive(t.hintId); widget.pick();}
    });

    CodeMirror.on(hints, "click", function(e) {
      var t = getHintElement(hints, e.target || e.srcElement);
      if (t && t.hintId != null) {
        widget.changeActive(t.hintId);
        if (completion.options.completeOnSingleClick) widget.pick();
      }
    });

    CodeMirror.on(hints, "mousedown", function() {
      setTimeout(function(){cm.focus();}, 20);
    });

    CodeMirror.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
    return true;
  }

  Widget.prototype = {
    close: function() {
      if (this.completion.widget != this) return;
      this.completion.widget = null;
      this.hints.parentNode.removeChild(this.hints);
      this.completion.cm.removeKeyMap(this.keyMap);

      var cm = this.completion.cm;
      if (this.completion.options.closeOnUnfocus) {
        cm.off("blur", this.onBlur);
        cm.off("focus", this.onFocus);
      }
      cm.off("scroll", this.onScroll);
    },

    disable: function() {
      this.completion.cm.removeKeyMap(this.keyMap);
      var widget = this;
      this.keyMap = {Enter: function() { widget.picked = true; }};
      this.completion.cm.addKeyMap(this.keyMap);
    },

    pick: function() {
      this.completion.pick(this.data, this.selectedHint);
    },

    changeActive: function(i, avoidWrap) {
      if (i >= this.data.list.length)
        i = avoidWrap ? this.data.list.length - 1 : 0;
      else if (i < 0)
        i = avoidWrap ? 0  : this.data.list.length - 1;
      if (this.selectedHint == i) return;
      var node = this.hints.childNodes[this.selectedHint];
      node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
      node = this.hints.childNodes[this.selectedHint = i];
      node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
      if (node.offsetTop < this.hints.scrollTop)
        this.hints.scrollTop = node.offsetTop - 3;
      else if (node.offsetTop + node.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
        this.hints.scrollTop = node.offsetTop + node.offsetHeight - this.hints.clientHeight + 3;
      CodeMirror.signal(this.data, "select", this.data.list[this.selectedHint], node);
    },

    screenAmount: function() {
      return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
    }
  };

  function applicableHelpers(cm, helpers) {
    if (!cm.somethingSelected()) return helpers
    var result = []
    for (var i = 0; i < helpers.length; i++)
      if (helpers[i].supportsSelection) result.push(helpers[i])
    return result
  }

  function fetchHints(hint, cm, options, callback) {
    if (hint.async) {
      hint(cm, callback, options)
    } else {
      var result = hint(cm, options)
      if (result && result.then) result.then(callback)
      else callback(result)
    }
  }

  function resolveAutoHints(cm, pos) {
    var helpers = cm.getHelpers(pos, "hint"), words
    if (helpers.length) {
      var resolved = function(cm, callback, options) {
        var app = applicableHelpers(cm, helpers);
        function run(i) {
          if (i == app.length) return callback(null)
          fetchHints(app[i], cm, options, function(result) {
            if (result && result.list.length > 0) callback(result)
            else run(i + 1)
          })
        }
        run(0)
      }
      resolved.async = true
      resolved.supportsSelection = true
      return resolved
    } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
      return function(cm) { return CodeMirror.hint.fromList(cm, {words: words}) }
    } else if (CodeMirror.hint.anyword) {
      return function(cm, options) { return CodeMirror.hint.anyword(cm, options) }
    } else {
      return function() {}
    }
  }

  CodeMirror.registerHelper("hint", "auto", {
    resolve: resolveAutoHints
  });

  CodeMirror.registerHelper("hint", "fromList", function(cm, options) {
    var cur = cm.getCursor(), token = cm.getTokenAt(cur);
    var to = CodeMirror.Pos(cur.line, token.end);
    if (token.string && /\w/.test(token.string[token.string.length - 1])) {
      var term = token.string, from = CodeMirror.Pos(cur.line, token.start);
    } else {
      var term = "", from = to;
    }
    var found = [];
    for (var i = 0; i < options.words.length; i++) {
      var word = options.words[i];
      if (word.slice(0, term.length) == term)
        found.push(word);
    }

    if (found.length) return {list: found, from: from, to: to};
  });

  CodeMirror.commands.autocomplete = CodeMirror.showHint;

  var defaultOptions = {
    hint: CodeMirror.hint.auto,
    completeSingle: true,
    alignWithWord: true,
    closeCharacters: /[\s()\[\]{};:>,]/,
    closeOnUnfocus: true,
    completeOnSingleClick: true,
    container: null,
    customKeys: null,
    extraKeys: null
  };

  CodeMirror.defineOption("hintOptions", null);
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var Pos = CodeMirror.Pos;

  function getHints(cm, options) {
    var tags = options && options.schemaInfo;
    var quote = (options && options.quoteChar) || '"';
    if (!tags) return;
    var cur = cm.getCursor(), token = cm.getTokenAt(cur);
    if (token.end > cur.ch) {
      token.end = cur.ch;
      token.string = token.string.slice(0, cur.ch - token.start);
    }
    var inner = CodeMirror.innerMode(cm.getMode(), token.state);
    if (inner.mode.name != "xml") return;
    var result = [], replaceToken = false, prefix;
    var tag = /\btag\b/.test(token.type) && !/>$/.test(token.string);
    var tagName = tag && /^\w/.test(token.string), tagStart;

    if (tagName) {
      var before = cm.getLine(cur.line).slice(Math.max(0, token.start - 2), token.start);
      var tagType = /<\/$/.test(before) ? "close" : /<$/.test(before) ? "open" : null;
      if (tagType) tagStart = token.start - (tagType == "close" ? 2 : 1);
    } else if (tag && token.string == "<") {
      tagType = "open";
    } else if (tag && token.string == "</") {
      tagType = "close";
    }

    if (!tag && !inner.state.tagName || tagType) {
      if (tagName)
        prefix = token.string;
      replaceToken = tagType;
      var cx = inner.state.context, curTag = cx && tags[cx.tagName];
      var childList = cx ? curTag && curTag.children : tags["!top"];
      if (childList && tagType != "close") {
        for (var i = 0; i < childList.length; ++i) if (!prefix || childList[i].lastIndexOf(prefix, 0) == 0)
          result.push("<" + childList[i]);
      } else if (tagType != "close") {
        for (var name in tags)
          if (tags.hasOwnProperty(name) && name != "!top" && name != "!attrs" && (!prefix || name.lastIndexOf(prefix, 0) == 0))
            result.push("<" + name);
      }
      if (cx && (!prefix || tagType == "close" && cx.tagName.lastIndexOf(prefix, 0) == 0))
        result.push("</" + cx.tagName + ">");
    } else {
      // Attribute completion
      var curTag = tags[inner.state.tagName], attrs = curTag && curTag.attrs;
      var globalAttrs = tags["!attrs"];
      if (!attrs && !globalAttrs) return;
      if (!attrs) {
        attrs = globalAttrs;
      } else if (globalAttrs) { // Combine tag-local and global attributes
        var set = {};
        for (var nm in globalAttrs) if (globalAttrs.hasOwnProperty(nm)) set[nm] = globalAttrs[nm];
        for (var nm in attrs) if (attrs.hasOwnProperty(nm)) set[nm] = attrs[nm];
        attrs = set;
      }
      if (token.type == "string" || token.string == "=") { // A value
        var before = cm.getRange(Pos(cur.line, Math.max(0, cur.ch - 60)),
                                 Pos(cur.line, token.type == "string" ? token.start : token.end));
        var atName = before.match(/([^\s\u00a0=<>\"\']+)=$/), atValues;
        if (!atName || !attrs.hasOwnProperty(atName[1]) || !(atValues = attrs[atName[1]])) return;
        if (typeof atValues == 'function') atValues = atValues.call(this, cm); // Functions can be used to supply values for autocomplete widget
        if (token.type == "string") {
          prefix = token.string;
          var n = 0;
          if (/['"]/.test(token.string.charAt(0))) {
            quote = token.string.charAt(0);
            prefix = token.string.slice(1);
            n++;
          }
          var len = token.string.length;
          if (/['"]/.test(token.string.charAt(len - 1))) {
            quote = token.string.charAt(len - 1);
            prefix = token.string.substr(n, len - 2);
          }
          replaceToken = true;
        }
        for (var i = 0; i < atValues.length; ++i) if (!prefix || atValues[i].lastIndexOf(prefix, 0) == 0)
          result.push(quote + atValues[i] + quote);
      } else { // An attribute name
        if (token.type == "attribute") {
          prefix = token.string;
          replaceToken = true;
        }
        for (var attr in attrs) if (attrs.hasOwnProperty(attr) && (!prefix || attr.lastIndexOf(prefix, 0) == 0))
          result.push(attr);
      }
    }
    return {
      list: result,
      from: replaceToken ? Pos(cur.line, tagStart == null ? token.start : tagStart) : cur,
      to: replaceToken ? Pos(cur.line, token.end) : cur
    };
  }

  CodeMirror.registerHelper("hint", "xml", getHints);
});

// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: http://codemirror.net/LICENSE

(function(mod) {
  if (typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("./xml-hint"));
  else if (typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "./xml-hint"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  var langs = "ab aa af ak sq am ar an hy as av ae ay az bm ba eu be bn bh bi bs br bg my ca ch ce ny zh cv kw co cr hr cs da dv nl dz en eo et ee fo fj fi fr ff gl ka de el gn gu ht ha he hz hi ho hu ia id ie ga ig ik io is it iu ja jv kl kn kr ks kk km ki rw ky kv kg ko ku kj la lb lg li ln lo lt lu lv gv mk mg ms ml mt mi mr mh mn na nv nb nd ne ng nn no ii nr oc oj cu om or os pa pi fa pl ps pt qu rm rn ro ru sa sc sd se sm sg sr gd sn si sk sl so st es su sw ss sv ta te tg th ti bo tk tl tn to tr ts tt tw ty ug uk ur uz ve vi vo wa cy wo fy xh yi yo za zu".split(" ");
  var targets = ["_blank", "_self", "_top", "_parent"];
  var charsets = ["ascii", "utf-8", "utf-16", "latin1", "latin1"];
  var methods = ["get", "post", "put", "delete"];
  var encs = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"];
  var media = ["all", "screen", "print", "embossed", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "speech",
               "3d-glasses", "resolution [>][<][=] [X]", "device-aspect-ratio: X/Y", "orientation:portrait",
               "orientation:landscape", "device-height: [X]", "device-width: [X]"];
  var s = { attrs: {} }; // Simple tag, reused for a whole lot of tags

  var data = {
    a: {
      attrs: {
        href: null, ping: null, type: null,
        media: media,
        target: targets,
        hreflang: langs
      }
    },
    abbr: s,
    acronym: s,
    address: s,
    applet: s,
    area: {
      attrs: {
        alt: null, coords: null, href: null, target: null, ping: null,
        media: media, hreflang: langs, type: null,
        shape: ["default", "rect", "circle", "poly"]
      }
    },
    article: s,
    aside: s,
    audio: {
      attrs: {
        src: null, mediagroup: null,
        crossorigin: ["anonymous", "use-credentials"],
        preload: ["none", "metadata", "auto"],
        autoplay: ["", "autoplay"],
        loop: ["", "loop"],
        controls: ["", "controls"]
      }
    },
    b: s,
    base: { attrs: { href: null, target: targets } },
    basefont: s,
    bdi: s,
    bdo: s,
    big: s,
    blockquote: { attrs: { cite: null } },
    body: s,
    br: s,
    button: {
      attrs: {
        form: null, formaction: null, name: null, value: null,
        autofocus: ["", "autofocus"],
        disabled: ["", "autofocus"],
        formenctype: encs,
        formmethod: methods,
        formnovalidate: ["", "novalidate"],
        formtarget: targets,
        type: ["submit", "reset", "button"]
      }
    },
    canvas: { attrs: { width: null, height: null } },
    caption: s,
    center: s,
    cite: s,
    code: s,
    col: { attrs: { span: null } },
    colgroup: { attrs: { span: null } },
    command: {
      attrs: {
        type: ["command", "checkbox", "radio"],
        label: null, icon: null, radiogroup: null, command: null, title: null,
        disabled: ["", "disabled"],
        checked: ["", "checked"]
      }
    },
    data: { attrs: { value: null } },
    datagrid: { attrs: { disabled: ["", "disabled"], multiple: ["", "multiple"] } },
    datalist: { attrs: { data: null } },
    dd: s,
    del: { attrs: { cite: null, datetime: null } },
    details: { attrs: { open: ["", "open"] } },
    dfn: s,
    dir: s,
    div: s,
    dl: s,
    dt: s,
    em: s,
    embed: { attrs: { src: null, type: null, width: null, height: null } },
    eventsource: { attrs: { src: null } },
    fieldset: { attrs: { disabled: ["", "disabled"], form: null, name: null } },
    figcaption: s,
    figure: s,
    font: s,
    footer: s,
    form: {
      attrs: {
        action: null, name: null,
        "accept-charset": charsets,
        autocomplete: ["on", "off"],
        enctype: encs,
        method: methods,
        novalidate: ["", "novalidate"],
        target: targets
      }
    },
    frame: s,
    frameset: s,
    h1: s, h2: s, h3: s, h4: s, h5: s, h6: s,
    head: {
      attrs: {},
      children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
    },
    header: s,
    hgroup: s,
    hr: s,
    html: {
      attrs: { manifest: null },
      children: ["head", "body"]
    },
    i: s,
    iframe: {
      attrs: {
        src: null, srcdoc: null, name: null, width: null, height: null,
        sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
        seamless: ["", "seamless"]
      }
    },
    img: {
      attrs: {
        alt: null, src: null, ismap: null, usemap: null, width: null, height: null,
        crossorigin: ["anonymous", "use-credentials"]
      }
    },
    input: {
      attrs: {
        alt: null, dirname: null, form: null, formaction: null,
        height: null, list: null, max: null, maxlength: null, min: null,
        name: null, pattern: null, placeholder: null, size: null, src: null,
        step: null, value: null, width: null,
        accept: ["audio/*", "video/*", "image/*"],
        autocomplete: ["on", "off"],
        autofocus: ["", "autofocus"],
        checked: ["", "checked"],
        disabled: ["", "disabled"],
        formenctype: encs,
        formmethod: methods,
        formnovalidate: ["", "novalidate"],
        formtarget: targets,
        multiple: ["", "multiple"],
        readonly: ["", "readonly"],
        required: ["", "required"],
        type: ["hidden", "text", "search", "tel", "url", "email", "password", "datetime", "date", "month",
               "week", "time", "datetime-local", "number", "range", "color", "checkbox", "radio",
               "file", "submit", "image", "reset", "button"]
      }
    },
    ins: { attrs: { cite: null, datetime: null } },
    kbd: s,
    keygen: {
      attrs: {
        challenge: null, form: null, name: null,
        autofocus: ["", "autofocus"],
        disabled: ["", "disabled"],
        keytype: ["RSA"]
      }
    },
    label: { attrs: { "for": null, form: null } },
    legend: s,
    li: { attrs: { value: null } },
    link: {
      attrs: {
        href: null, type: null,
        hreflang: langs,
        media: media,
        sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
      }
    },
    map: { attrs: { name: null } },
    mark: s,
    menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
    meta: {
      attrs: {
        content: null,
        charset: charsets,
        name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
        "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
      }
    },
    meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
    nav: s,
    noframes: s,
    noscript: s,
    object: {
      attrs: {
        data: null, type: null, name: null, usemap: null, form: null, width: null, height: null,
        typemustmatch: ["", "typemustmatch"]
      }
    },
    ol: { attrs: { reversed: ["", "reversed"], start: null, type: ["1", "a", "A", "i", "I"] } },
    optgroup: { attrs: { disabled: ["", "disabled"], label: null } },
    option: { attrs: { disabled: ["", "disabled"], label: null, selected: ["", "selected"], value: null } },
    output: { attrs: { "for": null, form: null, name: null } },
    p: s,
    param: { attrs: { name: null, value: null } },
    pre: s,
    progress: { attrs: { value: null, max: null } },
    q: { attrs: { cite: null } },
    rp: s,
    rt: s,
    ruby: s,
    s: s,
    samp: s,
    script: {
      attrs: {
        type: ["text/javascript"],
        src: null,
        async: ["", "async"],
        defer: ["", "defer"],
        charset: charsets
      }
    },
    section: s,
    select: {
      attrs: {
        form: null, name: null, size: null,
        autofocus: ["", "autofocus"],
        disabled: ["", "disabled"],
        multiple: ["", "multiple"]
      }
    },
    small: s,
    source: { attrs: { src: null, type: null, media: null } },
    span: s,
    strike: s,
    strong: s,
    style: {
      attrs: {
        type: ["text/css"],
        media: media,
        scoped: null
      }
    },
    sub: s,
    summary: s,
    sup: s,
    table: s,
    tbody: s,
    td: { attrs: { colspan: null, rowspan: null, headers: null } },
    textarea: {
      attrs: {
        dirname: null, form: null, maxlength: null, name: null, placeholder: null,
        rows: null, cols: null,
        autofocus: ["", "autofocus"],
        disabled: ["", "disabled"],
        readonly: ["", "readonly"],
        required: ["", "required"],
        wrap: ["soft", "hard"]
      }
    },
    tfoot: s,
    th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
    thead: s,
    time: { attrs: { datetime: null } },
    title: s,
    tr: s,
    track: {
      attrs: {
        src: null, label: null, "default": null,
        kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
        srclang: langs
      }
    },
    tt: s,
    u: s,
    ul: s,
    "var": s,
    video: {
      attrs: {
        src: null, poster: null, width: null, height: null,
        crossorigin: ["anonymous", "use-credentials"],
        preload: ["auto", "metadata", "none"],
        autoplay: ["", "autoplay"],
        mediagroup: ["movie"],
        muted: ["", "muted"],
        controls: ["", "controls"]
      }
    },
    wbr: s
  };

  var globalAttrs = {
    accesskey: ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"],
    "class": null,
    contenteditable: ["true", "false"],
    contextmenu: null,
    dir: ["ltr", "rtl", "auto"],
    draggable: ["true", "false", "auto"],
    dropzone: ["copy", "move", "link", "string:", "file:"],
    hidden: ["hidden"],
    id: null,
    inert: ["inert"],
    itemid: null,
    itemprop: null,
    itemref: null,
    itemscope: ["itemscope"],
    itemtype: null,
    lang: ["en", "es"],
    spellcheck: ["true", "false"],
    style: null,
    tabindex: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
    title: null,
    translate: ["yes", "no"],
    onclick: null,
    rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"]
  };
  function populate(obj) {
    for (var attr in globalAttrs) if (globalAttrs.hasOwnProperty(attr))
      obj.attrs[attr] = globalAttrs[attr];
  }

  populate(s);
  for (var tag in data) if (data.hasOwnProperty(tag) && data[tag] != s)
    populate(data[tag]);

  CodeMirror.htmlSchema = data;
  function htmlHint(cm, options) {
    var local = {schemaInfo: data};
    if (options) for (var opt in options) local[opt] = options[opt];
    return CodeMirror.hint.xml(cm, local);
  }
  CodeMirror.registerHelper("hint", "html", htmlHint);
});
